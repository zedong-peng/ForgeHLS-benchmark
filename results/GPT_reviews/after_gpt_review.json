[
  {
    "File Path": "../data/kernels/PolyBench/2mm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6624000029,
    "Worst-caseLatency": 6624000029.0,
    "BRAM_18K": 0,
    "LUT": 2227,
    "DSP": 17,
    "FF": 2247,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_2mm",
    "ResourceMetric": 0.0011134744,
    "design_id": "project",
    "algo_name": "2mm",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "2mm.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* 2mm.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"2mm.h\"\n\n\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_2mm(int ni, int nj, int nk, int nl,\n\t\tDATA_TYPE alpha,\n\t\tDATA_TYPE beta,\n\t\tDATA_TYPE POLYBENCH_2D(tmp,NI,NJ,ni,nj),\n\t\tDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\n\t\tDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),\n\t\tDATA_TYPE POLYBENCH_2D(C,NJ,NL,nj,nl),\n\t\tDATA_TYPE POLYBENCH_2D(D,NI,NL,ni,nl))\n{\n  int i, j, k;\n\n#pragma scop\n  /* D := alpha*A*B*C + beta*D */\n  for (i = 0; i < _PB_NI; i++)\n    for (j = 0; j < _PB_NJ; j++)\n      {\n\ttmp[i][j] = SCALAR_VAL(0.0);\n\tfor (k = 0; k < _PB_NK; ++k)\n\t  tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n  for (i = 0; i < _PB_NI; i++)\n    for (j = 0; j < _PB_NL; j++)\n      {\n\tD[i][j] *= beta;\n\tfor (k = 0; k < _PB_NJ; ++k)\n\t  D[i][j] += tmp[i][k] * C[k][j];\n      }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "2mm.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _2MM_H\n# define _2MM_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(NI) && !defined(NJ) && !defined(NK) && !defined(NL)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define NI 16\n#   define NJ 18\n#   define NK 22\n#   define NL 24\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define NI 40\n#   define NJ 50\n#   define NK 70\n#   define NL 80\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define NI 180\n#   define NJ 190\n#   define NK 210\n#   define NL 220\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define NI 800\n#   define NJ 900\n#   define NK 1100\n#   define NL 1200\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define NI 1600\n#   define NJ 1800\n#   define NK 2200\n#   define NL 2400\n#  endif\n\n\n#endif /* !(NI NJ NK NL) */\n\n# define _PB_NI POLYBENCH_LOOP_BOUND(NI,ni)\n# define _PB_NJ POLYBENCH_LOOP_BOUND(NJ,nj)\n# define _PB_NK POLYBENCH_LOOP_BOUND(NK,nk)\n# define _PB_NL POLYBENCH_LOOP_BOUND(NL,nl)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_2MM_H */\n"
      }
    ],
    "code_length": 1279,
    "token_count": 483,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/AES_Encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 191489,
    "Worst-caseLatency": 191489.0,
    "BRAM_18K": 0,
    "LUT": 1369,
    "DSP": 0,
    "FF": 200,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "AES_Encrypt",
    "ResourceMetric": 0.0002817026,
    "design_id": "project",
    "algo_name": "AES_Encrypt",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "AES_Encrypt.cpp",
        "file_content": "#include <stdint.h>\n\n#define AES_BLOCK_SIZE 16\n#define LARGE_SCALE 1024\n\nvoid SubBytes(uint8_t state[AES_BLOCK_SIZE]) {\n    static const uint8_t sbox[256] = {\n        // S-box values here\n    };\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = sbox[state[i]];\n    }\n}\n\nvoid ShiftRows(uint8_t state[AES_BLOCK_SIZE]) {\n    uint8_t temp;\n    // Rotate first row 1 columns to left  \n    temp = state[1];\n    state[1] = state[5];\n    state[5] = state[9];\n    state[9] = state[13];\n    state[13] = temp;\n\n    // Rotate second row 2 columns to left  \n    temp = state[2];\n    state[2] = state[10];\n    state[10] = temp;\n    temp = state[6];\n    state[6] = state[14];\n    state[14] = temp;\n\n    // Rotate third row 3 columns to left\n    temp = state[3];\n    state[3] = state[15];\n    state[15] = state[11];\n    state[11] = state[7];\n    state[7] = temp;\n}\n\nvoid MixColumns(uint8_t state[AES_BLOCK_SIZE]) {\n    uint8_t temp[AES_BLOCK_SIZE];\n    for (int i = 0; i < 4; i++) {\n        temp[4*i] = (uint8_t)(0x02 * state[4*i] ^ 0x03 * state[4*i+1] ^ state[4*i+2] ^ state[4*i+3]);\n        temp[4*i+1] = (uint8_t)(state[4*i] ^ 0x02 * state[4*i+1] ^ 0x03 * state[4*i+2] ^ state[4*i+3]);\n        temp[4*i+2] = (uint8_t)(state[4*i] ^ state[4*i+1] ^ 0x02 * state[4*i+2] ^ 0x03 * state[4*i+3]);\n        temp[4*i+3] = (uint8_t)(0x03 * state[4*i] ^ state[4*i+1] ^ state[4*i+2] ^ 0x02 * state[4*i+3]);\n    }\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = temp[i];\n    }\n}\n\nvoid AddRoundKey(uint8_t state[AES_BLOCK_SIZE], const uint8_t roundKey[AES_BLOCK_SIZE]) {\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] ^= roundKey[i];\n    }\n}\n\nvoid AES_Encrypt(uint8_t input[LARGE_SCALE][AES_BLOCK_SIZE], uint8_t output[LARGE_SCALE][AES_BLOCK_SIZE], const uint8_t roundKeys[11][AES_BLOCK_SIZE]) {\n    for (int block = 0; block < LARGE_SCALE; block++) {\n        uint8_t state[AES_BLOCK_SIZE];\n        for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n            state[i] = input[block][i];\n        }\n\n        AddRoundKey(state, roundKeys[0]);\n\n        for (int round = 1; round < 10; round++) {\n            SubBytes(state);\n            ShiftRows(state);\n            MixColumns(state);\n            AddRoundKey(state, roundKeys[round]);\n        }\n\n        SubBytes(state);\n        ShiftRows(state);\n        AddRoundKey(state, roundKeys[10]);\n\n        for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n            output[block][i] = state[i];\n        }\n    }\n}\n\n// Top function name: AES_Encrypt\n"
      }
    ],
    "code_length": 2501,
    "token_count": 830,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/BNN/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4691,
    "Worst-caseLatency": 166859646537.0,
    "BRAM_18K": 59,
    "LUT": 29744,
    "DSP": 3,
    "FF": 6098,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "top",
    "ResourceMetric": 0.0100298906,
    "design_id": "project",
    "algo_name": "BNN",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "xf_video_mem.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * HLS Video Memory Partition Header File\n */\n\n#ifndef ___XF__VIDEO_MEM__\n#define ___XF__VIDEO_MEM__\n\n//#define __DEBUG__\n\n#ifdef AESL_SYN\n#undef __DEBUG__\n#endif\n\n#include \"string.h\"\n#include \"xf_params.hpp\"\n\ntypedef ap_uint<32> XF_SIZE_T;\n\nnamespace xf {\nnamespace cv {\n\n//--------------------------------------------------------------------------------------\n// Template class of Window\n//--------------------------------------------------------------------------------------\ntemplate <int ROWS, int COLS, typename T>\nclass Window {\n   public:\n    Window(){\n// clang-format off\n\t#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=2\n        // clang-format on\n    };\n\n    /* Window main APIs */\n    void shift_pixels_left();\n    void shift_pixels_right();\n    void shift_pixels_up();\n    void shift_pixels_down();\n    void insert_pixel(T value, int row, int col);\n    void insert_row(T value[COLS], int row);\n    void insert_top_row(T value[COLS]);\n    void insert_bottom_row(T value[COLS]);\n    void insert_col(T value[ROWS], int col);\n    void insert_left_col(T value[ROWS]);\n    void insert_right_col(T value[ROWS]);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_left();\n    void shift_right();\n    void shift_up();\n    void shift_down();\n    void insert(T value, int row, int col);\n    void insert_top(T value[COLS]);\n    void insert_bottom(T value[COLS]);\n    void insert_left(T value[ROWS]);\n    void insert_right(T value[ROWS]);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void window_print();\n    T val_t[ROWS][COLS];\n#endif\n};\n\n/* Member functions of Window class */\n/* Origin in upper-left point */\n/*       0   1        C-2 C-1\n *     +---+---+-...-+---+---+\n *  0  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *  1  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *       ...     ...    ...\n *     +---+---+-...-+---+---+\n * R-2 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n * R-1 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *\n */\n\n/*\n * Window content shift left\n * Assumes new values will be placed in right column = COLS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_left() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS - 1; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j + 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n            else\n                assert(val_t[i][j + 1] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift right\n * Assumes new values will be placed in left column = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_right() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = COLS - 1; j > 0; j--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j - 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n            else\n                assert(val_t[i][j - 1] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift up\n * Assumes new values will be placed in bottom row = ROWS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_up() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i + 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift down\n * Assumes new values will be placed in top row = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_down() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i - 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert pixel\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    val[row][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row && j != col) assert(val_t[i][j] == val[i][j] && \"*** window insert_pixel mismatch! ***\");\n        }\n    }\n    val_t[row][col] = value;\n    assert(val_t[row][col] == val[row][col] && \"*** window insert_pixel mismatch! ***\");\n#endif\n}\n\n/* Window insert row\n * Inserts a set of values in any row of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T j;\n    for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[row][j] = value[j];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert top row\n * Inserts a set of values in top row = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert bottom row\n * Inserts a set of values in bottom row = ROWS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, ROWS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert column\n * Inserts a set of values in any column of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = value[i];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != col)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert left column\n * Inserts a set of values in left column = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_left_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_left_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert right column\n * Inserts a set of values in right column = COLS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, COLS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_right_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_right_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n#ifdef __DEBUG__\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::window_print() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            std::cout << std::setw(20) << val[i][j];\n        }\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift left, while contents shift right\n * Assumes new values will be placed in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_left() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_left(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift right, while contents shift left\n * Assumes new values will be placed in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_right() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_right(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_up() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_down() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_pixel(value, row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert top\n * Inserts a set of values in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert bottom\n * Inserts a set of values in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert left\n * Inserts a set of values in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_right_col(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert right\n * Inserts a set of values in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_left_col(value);\n}\n\n//--------------------------------------------------------------------------------------\n// Template class of Line Buffer\n//--------------------------------------------------------------------------------------\n#define _LB_TPLT_DEC \\\n    template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE = RAM_S2P_BRAM, int RESHAPE_FACTOR = 1>\n#define _LB_TPLT template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR>\n#define _LB_ LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>\n\n_LB_TPLT_DEC class LineBuffer {\n   public:\n    LineBuffer() {\n// clang-format off\n\t#pragma HLS INLINE\n        #pragma HLS dependence variable=val inter false\n        #pragma HLS dependence variable=val intra false\n        // clang-format on\n\n        // #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n        //#pragma HLS array_reshape variable=val factor=RESHAPE_FACTOR  dim=1\n\n        switch (MEM_TYPE) {\n            case RAM_1P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_1P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=URAM\n                // clang-format on\n                break;\n            case RAM_2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_S2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_S2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_T2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_T2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=URAM\n                // clang-format on\n                break;\n            default:\n                assert(\"MEM_TYPE should be one of RAM_*_BRAM or RAM_*_URAM (*: 1P, 2P, S2P, T2P)\");\n        }\n\n        if (RESHAPE_FACTOR == 1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n            // clang-format on\n        } else {\n// clang-format off\n            #pragma HLS ARRAY_RESHAPE variable=val factor=RESHAPE_FACTOR  dim=1\n            // clang-format on\n        }\n    };\n\n    /* LineBuffer main APIs */\n    void shift_pixels_up(int col);\n    void shift_pixels_down(int col);\n    void insert_bottom_row(T value, int col);\n    void insert_top_row(T value, int col);\n    void get_col(T value[ROWS], int col);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_up(int col);\n    void shift_down(int col);\n    void insert_bottom(T value, int col);\n    void insert_top(T value, int col);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void linebuffer_print(int col);\n    T val_t[ROWS][COLS];\n#endif\n};\n/* Member functions of LineBuffer class */\n/* Origin in upper-left point */\n/*       0   1            C-2 C-1\n *     +---+---+-... ...-+---+---+\n *  0  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *  1  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *       ...     ... ...    ...\n *     +---+---+-... ...-+---+---+\n * R-2 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n * R-1 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *\n */\n\n/* Member functions of LineBuffer class */\n\n/*\n * LineBuffer content shift down\n * Assumes new values will be placed in top row = 0\n */\n_LB_TPLT void _LB_::shift_pixels_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i - 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == 0)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n                else\n                    assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * LineBuffer content shift up\n * Assumes new values will be placed in top row = ROWS-1\n */\n_LB_TPLT void _LB_::shift_pixels_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i + 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == ROWS - 1)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n                else\n                    assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert bottom row\n * Inserts a new value in bottom row= ROWS-1 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_bottom_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[ROWS - 1][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == ROWS - 1)\n                assert(val[i][j] == value && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert top row\n * Inserts a new value in top row=0 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_top_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[0][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == 0)\n                assert(val[i][j] == value && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer get a column\n * Get a column value of the linebuffer\n */\n_LB_TPLT void _LB_::get_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        value[i] = val[i][col];\n    }\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\n_LB_TPLT void _LB_::shift_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::shift_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in bottom row(=0)\n */\n_LB_TPLT void _LB_::insert_bottom(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::insert_top(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value, col);\n}\n\n#ifdef __DEBUG__\n_LB_TPLT void _LB_::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\n_LB_TPLT void _LB_::linebuffer_print(int col) {\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        std::cout << std::setw(20) << val[i][col];\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n#undef _LB_TPLT_DEC\n#undef _LB_TPLT\n#undef _LB_\n\n} // namespace cv\n} // namespace xf\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "Debug.h",
        "file_content": "#ifndef DEBUG_H\n#define DEBUG_H\n\n#ifndef DEBUG_LEVEL\n#define DEBUG_LEVEL 0\n#endif\n\n#ifdef HLS_COMPILE\n#undef DEBUG_LEVEL\n#endif\n\n#ifdef DEBUG_LEVEL\n\n  #define DB(lvl, x) if (lvl <= DEBUG_LEVEL) {x;}\n  #define DB_PRINT(lvl, ...) \\\n    if (lvl <= DEBUG_LEVEL) \\\n      printf (__VA_ARGS__)\n\n#else\n  \n  #define DB(lvl, x)   \n  #define DB_PRINT(lvl, ...)\n\n#endif\n\n#endif\n"
      },
      {
        "file_name": "Common.h",
        "file_content": "#ifndef COMMON_H\n#define COMMON_H\n\n#include <string>\n#include <cstdlib>\n#include <assert.h>\n#include <ap_int.h>\n\n#include \"Typedefs.h\"\n\n// Returns the repo's root dir or exits\nstd::string get_root_dir();\n\n// We encode negative to -1, positive to 0\ntemplate<typename T>\nBit sgn(const T x) {\n  #pragma HLS INLINE\n  return (x < 0) ? -1 : 0;\n}\n\n#endif\n"
      },
      {
        "file_name": "Accel.cpp",
        "file_content": "#include <iostream>\n#include <iomanip>\n#include <hls_stream.h>\n#include \"Accel.h\"\n#include \"AccelPrint.h\"\n\nconst static Word m1(\"0x5555555555555555\", 16);\nconst static Word m2(\"0x3333333333333333\", 16);\nconst static Word m4(\"0x0f0f0f0f0f0f0f0f\", 16);\nconst static Word h01(\"0x0101010101010101\", 16);\n\n// -----------------------------------------------------------------------\n// Hardware-specific print helpers\n// -----------------------------------------------------------------------\ntemplate<typename T>\nvoid print_ap_bits(const T& in, const unsigned W) {\n  printf (\"   \");\n  for (unsigned i = 0; i < W; ++i)\n    printf (\"%3d\", in[i] ? -1 : 0);\n  printf (\"\\n\");\n}\n\ntemplate<typename T>\nvoid print_params(T params[CONVOLVERS][K][K]) {\n  for (unsigned m = 0; m < CONVOLVERS; ++m) {\n    for (unsigned wr = 0; wr < K; ++wr) {\n      for (unsigned wc = 0; wc < K; ++wc) {\n        printf (\"%3d\", (params[m][wr][wc]==0) ? 0 : 1);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"--\\n\");\n  }\n}\n\ntemplate<typename T>\nvoid print_line_buffer_m(T lbuf[CONV_BANKS]) {\n  for (unsigned wr = 0; wr < CONV_ROWS; ++wr) {\n  for (unsigned bank = 0; bank < CONV_BANKS; ++bank) {\n    for (unsigned wc = 0; wc < CONV_COLS; ++wc) {\n      printf (\"%3d\", lbuf[bank][wr][wc].to_int());\n    }\n    printf (\" |\");\n  }\n  printf (\"\\n\");\n  }\n}\n\nTwoBit encode_bit(const Bit& b) {\n  return (b == 0) ? TwoBit(1) : TwoBit(-1);\n}\n\n// -----------------------------------------------------------------------\n// Conv\n// -----------------------------------------------------------------------\nConvOut conv3x3b(\n    const TwoBit line_buffer_m[CONV_BANKS][CONV_ROWS][CONV_COLS],\n    const Bit conv_params_m[K][K],\n    const ap_uint<4> bank,\n    const IdxType cc\n) {\n  ConvOut sum = 0;\n  for (ap_uint<2> kr = 0; kr < K; ++kr) {\n    for (ap_uint<2> kc = 0; kc < K; ++kc) {\n      TwoBit data = line_buffer_m[bank][kr][cc+kc];\n      const Bit& wt = conv_params_m[2-kr][2-kc];\n      data[1] = (wt & data[0]) ^ data[1];\n      sum += data;\n    }\n  }\n  return sum;\n}\n\n// -----------------------------------------------------------------------\n// Produce 32 elements of conv results\n// -----------------------------------------------------------------------\nvoid conv_word(\n    const TwoBit line_buffer_m[CONV_BANKS][CONV_ROWS][CONV_COLS],\n    const Bit conv_params_m[K][K],\n    ConvOut conv_out_buffer_m[WORD_SIZE]\n) {\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    for (ap_uint<4> cc = 0; cc < BANK_WIDTH; ++cc) {\n      conv_out_buffer_m[bank*BANK_WIDTH+cc] = conv3x3b( line_buffer_m, conv_params_m, bank, cc );\n    }\n  }\n}\n\n// -----------------------------------------------------------------------\n// Process each line in a word, we need to outline this loop to\n// avoid false control dependencies in Vivado HLS\n// -----------------------------------------------------------------------\nvoid process_word(\n    const TwoBit  word_buffer_m[CONV_BANKS][CONV_COLS],\n    const TwoBit  old_word_buffer_m[CONV_BANKS][CONV_COLS],\n    const bool lb[CONV_BANKS],\n    const bool rb[CONV_BANKS],\n    TwoBit  line_buffer_m[CONV_BANKS][CONV_ROWS][CONV_COLS],\n    const   Bit conv_params_m[K][K],\n    ConvOut conv_out_buffer_m[WORD_SIZE],\n    const   ap_uint<3> log_width,\n    const   ap_uint<6> words_per_image,\n    const   IdxType wrd\n) {\n  // slices_per_line = width / BANK_WIDTH\n  const ap_uint<5> slices_per_line = 1 << (log_width - LOG_BANK_WIDTH);\n  const bool first_wrd = (wrd == 0);\n  const bool last_wrd = (wrd == words_per_image);\n  DB_PRINT(4, \"process word %d, spl=%d\\n\", wrd.to_int(), slices_per_line.to_int());\n\n  // Prologue\n  // Update bottom row, slices are shifted left. Some slices copied from previous word (middle row)\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    ap_int<6> s_idx = bank + slices_per_line - CONV_BANKS;\n    if (s_idx < 0) {\n      // set to zero or copy from old word (middle row)\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][CONV_ROWS-1][cc] = old_word_buffer_m[CONV_BANKS+s_idx][cc];\n      }\n      line_buffer_m[bank][CONV_ROWS-1][0          ] = lb[bank] ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx][0];\n      line_buffer_m[bank][CONV_ROWS-1][CONV_COLS-1] = rb[bank] ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx][CONV_COLS-1];\n    } else {\n      // fill from new word\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][CONV_ROWS-1][cc] = (last_wrd) ? TwoBit(0) : word_buffer_m[s_idx][cc];\n      }\n      line_buffer_m[bank][CONV_ROWS-1][0          ] = (last_wrd || lb[bank]) ? TwoBit(0) : word_buffer_m[s_idx][0];\n      line_buffer_m[bank][CONV_ROWS-1][CONV_COLS-1] = (last_wrd || rb[bank]) ? TwoBit(0) : word_buffer_m[s_idx][CONV_COLS-1];\n    }\n  }\n  \n  DB(4,\n    printf(\"Accel lbuf wrd%d before conv:\\n\", wrd.to_int());\n    print_line_buffer_m(line_buffer_m);\n  );\n\n  // Convolution\n  conv_word( line_buffer_m, conv_params_m, conv_out_buffer_m );\n  \n  // Update\n  // Fill line buffer with lines from the new word\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    // --------------------------------------------------------------\n    // Top row, slices are shifted right by slices_per_line\n    ap_int<6> s_idx0 = bank - slices_per_line;\n    if (s_idx0 >= 0) {\n      // slice from input word\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][0][cc] = word_buffer_m[s_idx0][cc];\n      }\n      line_buffer_m[bank][0][0          ] = lb[bank] ? TwoBit(0) : word_buffer_m[s_idx0][0];\n      line_buffer_m[bank][0][CONV_COLS-1] = rb[bank] ? TwoBit(0) : word_buffer_m[s_idx0][CONV_COLS-1];\n    } else {\n      // set to zero or copy from old word (middle row)\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][0][cc] = (first_wrd) ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx0][cc];\n      }\n      line_buffer_m[bank][0][0          ] = (first_wrd || lb[bank]) ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx0][0];\n      line_buffer_m[bank][0][CONV_COLS-1] = (first_wrd || rb[bank]) ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx0][CONV_COLS-1];\n    }\n\n    // --------------------------------------------------------------\n    // Middle row, simply copy the word into the line buffer\n    for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n      line_buffer_m[bank][1][cc] = word_buffer_m[bank][cc];\n    }\n    // Fill end buffer bits\n    line_buffer_m[bank][1][0          ] = lb[bank] ? TwoBit(0) : word_buffer_m[bank][0];\n    line_buffer_m[bank][1][CONV_COLS-1] = rb[bank] ? TwoBit(0) : word_buffer_m[bank][CONV_COLS-1];\n  }\n\n  DB(4,\n    printf(\"Accel lbuf wrd%d after conv:\\n\", wrd.to_int());\n    print_line_buffer_m(line_buffer_m);\n  );\n}\n\n// -----------------------------------------------------------------------\n// A single PE reads from all inputs and weights to generate a single\n// output feature map.\n// * Make sure this function gets inlined by VHLS, or cosim may fail!\n// -----------------------------------------------------------------------\nvoid bin_conv(\n    Word wt_mem[CONVOLVERS][C_WT_WORDS],\n    NormComp nc,\n    Word dmem[2][CONVOLVERS][C_DMEM_WORDS],\n    ap_uint<1> d_i_idx,\n    ap_uint<1> d_o_idx,\n    const unsigned   n_inputs,\n    const Address    o_index,\n    const ap_uint<1> new_batch,\n    const ap_uint<2> width_mode,  // 0=8'b, 1=16'b, 2=32'b\n    const ap_uint<2> norm_mode    // 0='do nothing', 1='do norm', 2='do pool'\n) {\n  const ap_uint<3> log_width = width_mode + LOG_BANK_WIDTH; // width_mode + 3 = 3,4,5\n  const ap_uint<5> words_per_image = 1 << (2*width_mode); // 1, 4, 16\n  const unsigned n_phases = n_inputs / CONVOLVERS;\n  const unsigned images_per_phase = PIX_PER_PHASE >> (2*log_width); // 2*32*32 / 2^3, 2^4, 2^5 = 2^8, 2^7, 2^6\n  const unsigned WORDS_PER_PHASE = PIX_PER_PHASE / WORD_SIZE; // 2*32*32 / 64 = 512\n\n  assert(n_phases % images_per_phase == 0);\n  assert(n_inputs % images_per_phase == 0);\n  assert(images_per_phase*words_per_image == WORDS_PER_PHASE);\n\n  // ---------------------------------------------------------------------\n  // buffers\n  // ---------------------------------------------------------------------\n  TwoBit  line_buffer[CONVOLVERS][CONV_BANKS][CONV_ROWS][CONV_COLS];\n  Bit     conv_params[CONVOLVERS][K][K];\n  ConvSum fixed_buffer[WORDS_PER_PHASE][WORD_SIZE];\n  ConvSum fixed_temp[WORD_SIZE];\n  // per-convolver buffers\n  TwoBit  word_buffer[CONVOLVERS][CONV_BANKS][CONV_COLS];\n  TwoBit  old_word_buffer[CONVOLVERS][CONV_BANKS][CONV_COLS];\n  ConvOut conv_out_buffer[CONVOLVERS][WORD_SIZE];\n  // edge padding flag bits\n  bool lb[CONV_BANKS];\n  bool rb[CONV_BANKS];\n\n  static Address wt_addr = 0;           // address of weight word\n  static ap_uint<3> wt_offset = 0;      // offset 0..6 of param\n  if (new_batch != 0) { wt_addr = 0; wt_offset = 0; }\n\n  // ---------------------------------------------------------------------\n  // Calculate edge padding flag bits\n  const ap_uint<4> log_slice = log_width - LOG_BANK_WIDTH;\n  const ap_uint<4> w_div_8 = (1 << log_width) >> 3;\n  assert (w_div_8 > 0);\n  ap_uint<4> mask = ~ap_uint<4>(0);   // set mask to all 1s\n  mask = mask >> (4-log_slice);\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    \n    const ap_uint<4> x = bank & mask;\n    lb[bank] = (x == 0);          // (bank % w_div_8) == 0\n    rb[bank] = (x+1 == w_div_8);  // (bank % w_div_8) == w_div_8-1\n  }\n\n  // ---------------------------------------------------------------------\n  // Reset conv buffer\n  for (IdxType i = 0; i < WORDS_PER_PHASE; ++i) {\n    for (IdxType j = 0; j < WORD_SIZE; ++j) {\n      \n      fixed_buffer[i][j] = 0;\n    }\n  }\n\n  // ---------------------------------------------------------------------\n  // Compute in phases\n  // Each phase processes CONVOLVERS * WORDS_PER_PHASE input words\n  // ---------------------------------------------------------------------\n  LOOP_PHASES:\n  for (ap_uint<10> p = 0; p < n_phases; p += images_per_phase) {\n  #pragma HLS loop_tripcount min=8 max=64\n    DB(3, printf (\"=== PHASE %d ===\\n\", p.to_int()) );\n\n    // wrd = which word in the current image\n    // wrd_phase = which wrd in the current phase\n    ap_uint<8> wrd = 0;\n    ap_uint<8> wrd_phase = 0;\n\n    // Load a word each iteration, and then process it\n    // We load WORDS_PER_PHASE words per phase, however we also need 1 extra \"empty\"\n    // iteration per image in the phase to do the loop epilogue, so the loop bound\n    // is WORDS_PER_PHASE + images_per_phase\n    LOOP_WORDS_IN_PHASE:\n    for (ap_uint<8> count = 0; count < WORDS_PER_PHASE+images_per_phase; ++count) {\n    #pragma HLS loop_tripcount min=576 max=768\n      if (wrd == 0) {\n        Word wt_word_buffer[CONVOLVERS];\n\n        // -------------------------------------------------------------------\n        // Load param word\n        // Each word contains CONV_W_PER_WORD weight filters, after we use\n        // them all we should load the next word\n        // -------------------------------------------------------------------\n        LOOP_WT_WORDS:\n        for (IdxType m = 0; m < CONVOLVERS; ++m) {\n          /*if (wt_offset == 0)\n            wt_word_buffer[m] = wt_mem[m][wt_addr];\n          else\n            wt_word_buffer[m] = wt_word_buffer[m] >> WT_SIZE;\n          */\n          wt_word_buffer[m] = wt_mem[m][wt_addr] >> ap_uint<6>(WT_SIZE*wt_offset);\n        }\n        if (wt_offset == CONV_W_PER_WORD-1) {\n          ++wt_addr;\n          wt_offset = 0;\n        } else {\n          ++wt_offset;\n        }\n        //print_wt_word(wt_word_buffer[0]);\n\n        // -------------------------------------------------------------------\n        // Load params\n        // Each word contains CONV_W_PER_WORD weight filters packed into the first\n        // 63 bits, the last bit is unused. Wts are stored in output-major order.\n        // -------------------------------------------------------------------\n        LOOP_LOAD_WTS:\n        for (IdxType m = 0; m < CONVOLVERS; ++m) {\n          for (ap_uint<2> kr = 0; kr < K; ++kr) {\n            for (ap_uint<2> kc = 0; kc < K; ++kc)\n              conv_params[m][kr][kc] = wt_word_buffer[m][kr*K+kc];\n          }\n        }\n\n        DB(3, print_params(conv_params) );\n      }\n\n      // -------------------------------------------------------------------\n      // Every word in an image\n      // -------------------------------------------------------------------\n      // Load word\n      // (wrd_phase-wrd) is which wrd in the current phase, aligned to img boundary\n      if (wrd != words_per_image) {\n        LOOP_CONVOLVER_LOAD:\n        for (IdxType m = 0; m < CONVOLVERS; ++m) {\n          Word word = dmem[d_i_idx][m][p*words_per_image + wrd_phase];\n          for (IdxType bank = 0; bank < CONV_BANKS; ++bank) {\n            for (IdxType cc = 0; cc < CONV_COLS-2; ++cc) {\n              word_buffer[m][bank][cc+1] = encode_bit(word[ap_uint<6>(bank*BANK_WIDTH+cc)]);\n            }\n            word_buffer[m][bank][0          ] = (bank==0)            ?\n              TwoBit(0) : encode_bit(word[ap_uint<6>(bank*BANK_WIDTH-1)]);\n            word_buffer[m][bank][CONV_COLS-1] = (bank==CONV_BANKS-1) ?\n              TwoBit(0) : encode_bit(word[ap_uint<6>(bank*BANK_WIDTH+BANK_WIDTH)]);\n          }\n        }\n      }\n\n      // Compute\n      LOOP_CONVOLVERS:\n      for (IdxType m = 0; m < CONVOLVERS; ++m) {\n        // Do the following for each word in an image\n        process_word( word_buffer[m], old_word_buffer[m], lb, rb, line_buffer[m], conv_params[m],\n            conv_out_buffer[m], log_width, words_per_image, wrd );\n      } // CONVOLVERS\n\n      for (IdxType m = 0; m < CONVOLVERS; ++m) {\n        for (IdxType bank = 0; bank < CONV_BANKS; ++bank) {\n          for (IdxType cc = 0; cc < CONV_COLS; ++cc) {\n            old_word_buffer[m][bank][cc] = word_buffer[m][bank][cc];\n        } }\n      }\n\n      // -------------------------------------------------------------------\n      // Sum results across convolvers\n      // -------------------------------------------------------------------\n      for (IdxType i = 0; i < WORD_SIZE; ++i) {\n        // Ignore conv results after processing the first word\n        if (wrd > 0) {\n          ConvSum s = 0;\n          for (IdxType m = 0; m < CONVOLVERS; ++m)\n            s += conv_out_buffer[m][i];\n          fixed_buffer[wrd_phase-1][i] += s;\n        }\n      }\n\n      // -------------------------------------------------------------------\n      // Increment counters\n      // -------------------------------------------------------------------\n      if (wrd != words_per_image) {\n        wrd++;\n        wrd_phase++;\n      } else {\n        wrd = 0;\n      }\n    } // wrd_phase = 0 .. WORDS_PER_PHASE\n\n  } // n_phases\n\n  LOOP_ACC_PHASES:\n  for (ap_uint<5> w = 0; w < words_per_image; ++w) {\n    for (IdxType b = 0; b < WORD_SIZE; ++b) {\n      \n      fixed_temp[b] = fixed_buffer[w][b];\n    }\n\n    LOOP_ACC_PHASES_I:\n    for (ap_uint<8> i = words_per_image; i < WORDS_PER_PHASE; i += words_per_image) {\n    # pragma HLS loop_tripcount min= 32 max= 512\n      for (IdxType b = 0; b < WORD_SIZE; ++b) {\n        fixed_temp[b] += fixed_buffer[w+i][b];\n    } }\n\n    for (IdxType b = 0; b < WORD_SIZE; ++b) {\n      \n      fixed_buffer[w][b] = fixed_temp[b];\n    }\n  }\n\n  const Address bank_idx = o_index % CONVOLVERS;\n  const Address bank_off = o_index / CONVOLVERS;\n  const ap_uint<5> pool_width = 1 << (log_width-1);\n  DB(4,\n    unsigned width = 1 << log_width;\n    printf (\"=== conv result ===\\n\");\n    print_mat(fixed_buffer[0], width, 8, width);\n  );\n  DB_PRINT(2, \"  o_idx=%3d: nc=%6d\\n\", o_index.to_int(), nc.to_int());\n\n  static Word outword;\n  Word poolword;\n  LOOP_BATCH_NORM:\n  for (ap_uint<6> w = 0; w < words_per_image; ++w) {\n  # pragma HLS loop_tripcount min=1 max=16\n    Word binword;\n    Address o_bank_idx = bank_idx;\n    Address o_bank_offset = bank_off*words_per_image + w;\n    const ap_uint<6> out_offset = (w % 4) << 4;\n\n    for (ap_uint<7> i = 0; i < WORD_SIZE; ++i) {\n      binword[i] = (fixed_buffer[w][i] >= nc) ? 0 : 1;\n    }\n\n    if (norm_mode == 1) {\n      outword = binword;\n    }\n    else if (norm_mode == 2) {\n      // horizontal pooling first\n      ap_int<WORD_SIZE/2> poolword_h;\n      for (ap_uint<6> i = 0; i < WORD_SIZE/2; ++i) {\n        poolword_h[i] = binword[2*i] & binword[2*i+1];\n      }\n\n      // vertical pooling\n      for (ap_uint<6> i = 0; i < WORD_SIZE/4; ++i) {\n        // source indices\n        ap_uint<5> i0 = i >> (log_width-1);\n        i0 = (i0 << log_width) + i(log_width-2,0);\n        ap_uint<5> i1 = i0 + pool_width;\n        // dest index\n        ap_uint<6> d0 = out_offset + i;\n        poolword[d0] = poolword_h[i0] & poolword_h[i1];\n      }\n\n      // For log_width > 3 we can just assign the word, but log_width = 3 means width = 8,\n      // which means pooled width = 4, which is only 16 bits, which is less than 1 Word.\n      // So each time we get here we only have 16 bits, meaning we have to accumulate four\n      // of these 16-bit batches before writing a word out.\n      if (log_width != LOG_BANK_WIDTH) {\n        o_bank_offset /= 4;\n        outword = poolword;\n      } else {\n        outword = outword >> WORD_SIZE/4;\n        outword(63,48) = poolword(15,0);\n        o_bank_idx = (o_index/4)%CONVOLVERS;\n        o_bank_offset = (o_index/4)/CONVOLVERS;\n      }\n    }\n\n    dmem[d_o_idx][o_bank_idx][o_bank_offset] = outword;\n  }\n}\n\n// -----------------------------------------------------------------------\n// Module to do the first conv layer\n// -----------------------------------------------------------------------\nvoid fp_conv(\n    Word wt_mem[CONVOLVERS][C_WT_WORDS],\n    Word kh_mem[KH_WORDS],\n    Word dmem[2][CONVOLVERS][C_DMEM_WORDS],\n    ap_uint<1> d_i_idx,\n    ap_uint<1> d_o_idx,\n    const Address kh_index,\n    const Address o_index,\n    const unsigned N\n) {\n  const unsigned M = 3;\n  const unsigned S = 32;\n  const unsigned OUTWORDS = 16; // words per output image\n\n  C1InputType win[M][K][K];\n  C1InputType lbuf[M][K-1][S];\n  Word outwords[OUTWORDS];\n  WtType wtbuf[M];\n\n  Address wt_offset = 0;\n  ap_uint<3> wt_addr = 0;\n\n  // Parallelized across m, better for HLS\n  LOOP_FP_CONV_O:\n  for (IdxType n = 0; n < N; ++n) {\n  #pragma HLS loop_tripcount min=8 max=32\n    // clear linebuffers for each new output map\n    LOOP_RESET_LINEBUFFERS:\n    for (IdxType m = 0; m < M; ++m) {\n      PROLOG_COLS: for (IdxType c = 0; c < S; ++c) {\n        PROLOG_ROWS: for (IdxType r = 0; r < K/2; ++r) {\n          for (IdxType lr = 0; lr < K-2; ++lr) {\n            lbuf[m][lr][c] = lbuf[m][lr+1][c];\n          }\n          lbuf[m][K-2][c] = 0;\n      } }\n    }\n\n    // The weights for the 1st conv layer are just laid out\n    // linearly across wt_mem, 3 weights per 64-bit word\n    DB_PRINT(3, \"n = %u\\n\", n.to_int());\n    Word wt_word = wt_mem[n % CONVOLVERS][n / CONVOLVERS];\n    LOOP_LOAD_WTS:\n    for (ap_uint<2> m = 0; m < M; ++m) {\n      wtbuf[m] = wt_word((m+1)*WT_SIZE-1, m*WT_SIZE);\n      DB(3, print_wt(wtbuf[m]));\n      DB(3, printf(\"--\\n\"));\n    }\n\n    // load batch norm params\n    C1Comp nc;\n    load_kh(nc, kh_mem, (kh_index+n));\n    //printf (\"  n=%3d, nc=%6.3f\\n\", n.to_int(), nc.to_float());\n\n    // begin convolution\n    LOOP_CONV_ROWS: for (IdxType r = 0; r < S+1; ++r) {\n      LOOP_CONV_COLS: for (IdxType c = 0; c < S+1; ++c) {\n        // load input word\n        Word inword = 0;\n        if (r < S && c < S) {\n          const Address addr = r*S + c;\n          inword = dmem[d_i_idx][addr/C_DMEM_WORDS][addr%C_DMEM_WORDS];\n        }\n\n        for (ap_uint<2> m = 0; m < M; ++m) {\n          // load data: the value of pix is either the pixel at [r,c]\n          // 0 -> +1, -1 -> -1\n          // or -> 0 for padding around the boundaries\n          C1InputType pix;\n          const unsigned W = pix.length();\n          pix(W-1,0) = inword(W-1+m*W, m*W);\n\n          // window: shift left, leaving rightmost col for new data\n          for (IdxType wr = 0; wr < K; ++wr) {\n            for (IdxType wc = 0; wc < K-1; ++wc) {\n              win[m][wr][wc] = win[m][wr][wc+1];\n          } }\n\n          // window: fill top K-1 pixels of rightmost column from lbuf\n          for (IdxType wr = 0; wr < K-1; ++wr) {\n            C1InputType val = (c != S) ? lbuf[m][wr][c] : C1InputType(0);\n            win[m][wr][K-1] = val;\n          }\n\n          // window: fill bottom right with new input pixel\n          win[m][K-1][K-1] = pix;\n\n          // lbuf: shift up column c\n          if (c != S) {\n            for (IdxType lr = 0; lr < K-2; ++lr) {\n              lbuf[m][lr][c] = lbuf[m][lr+1][c];\n            }\n            lbuf[m][K-2][c] = pix;\n          }\n        } // m\n\n        // only perform the conv and store if legal position\n        if (r > 0 && c > 0) {\n          C1ConvType res = 0;\n          for (ap_uint<2> m = 0; m < M; ++m) {\n            for (ap_uint<2> wr = 0; wr < K; ++wr) {\n              for (ap_uint<2> wc = 0; wc < K; ++wc) {\n                const C1InputType& pix = win[m][wr][wc];\n                const Bit& b = wtbuf[m][8-(wr*K+wc)];\n                res += (b==0) ? pix : (C1InputType)(-pix);\n            } }\n          }\n\n          // perform normalization right here\n          outwords[(r-1)/2][((r-1)%2)*S + (c-1)] =\n            (res >= nc) ? Bit(0) : Bit(-1);\n        }\n\n      } // CONV_COLS\n    } // CONV_ROWS\n\n    // Here i is the word offset within the outwords buffer\n    LOOP_OUTPUT:\n    for (IdxType i = 0; i < OUTWORDS; ++i) {\n      Address img_idx = o_index+n;\n      Address bank_idx = img_idx % CONVOLVERS;\n      Address bank_off = img_idx / CONVOLVERS;\n      dmem[d_o_idx][bank_idx][bank_off*OUTWORDS + i] = outwords[i];\n    }\n  } // n\n}\n\nvoid bin_dense(\n    const Word wt_mem[CONVOLVERS][C_WT_WORDS],\n    const Word kh_mem[KH_WORDS],\n    Word dmem[2][CONVOLVERS][C_DMEM_WORDS],\n    ap_uint<2> layer_type,\n    ap_uint<1> d_i_idx,\n    ap_uint<1> d_o_idx,\n    const Address o_index,\n    const unsigned n_inputs,\n    const unsigned n_outputs\n) {\n  //assert(n_outputs % WORD_SIZE == 0);\n  assert(layer_type == LAYER_DENSE || n_outputs == 10);\n  assert(n_inputs/WORD_SIZE % CONVOLVERS == 0);\n\n  DenseSum sum_m[CONVOLVERS];\n  // for last layer\n  DenseNorm best_out = -1024;\n  ap_int<8> prediction = -1;\n\n  // read words from dmem and the wt store, dot them\n  // o is the output bit, i is the input bit\n  LOOP_DENSE_O:\n  for (Address o = 0; o < n_outputs; ++o) {\n  #pragma HLS loop_tripcount min=8 max=64\n    const Address o_addr = (o_index+o)/WORD_SIZE;\n    const ap_uint<6> o_offset = (o_index+o) % WORD_SIZE;\n    Word o_word = dmem[d_o_idx][o_addr%CONVOLVERS][o_addr/CONVOLVERS];\n\n    DenseSum sum = 0;\n\n    LOOP_DENSE_I:\n    for (Address i = 0; i < n_inputs; i+=CONVOLVERS*WORD_SIZE) {\n    #pragma HLS loop_tripcount min=8 max=64\n      const Address wt_addr = (o*n_inputs+i) / WORD_SIZE;\n\n      for (IdxType j = 0; j < CONVOLVERS; ++j) {\n        // in_wrd addr = [(i/WORD_SIZE+j) % CONVOLVERS][(i/WORD_SIZE+j) / CONVOLVERS]\n        // wt_wrd addr = [wt_addr % CONVOLVERS][wt_addr / CONVOLVERS]\n        const Word in_wrd = dmem[d_i_idx][j][i/WORD_SIZE/CONVOLVERS];\n        const Word wt_wrd = wt_mem[j][wt_addr / CONVOLVERS];\n\n        Word x = wt_wrd ^ in_wrd;\n\n        // count_set bit for 64 bits, returns 2*cnt\n        x -= (x >> 1) & m1;\n        x = (x & m2) + ((x >> 2) & m2);\n        x = (x + (x >> 4)) & m4;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        x = x & 0x7f;\n\n        sum_m[j] = WORD_SIZE - (DenseSum)(x<<1);\n      }\n\n      for (IdxType j = 0; j < CONVOLVERS; ++j)\n        sum += sum_m[j];\n    } // n_inputs\n\n    // not last layer -> biniarize,\n    // otherwise just store the value as a 64bit word\n    if (layer_type == LAYER_DENSE) {\n      Address kh_addr = o / KH_PER_WORD;\n      Word kh_word = kh_mem[kh_addr];\n\n      NormComp nc;\n      IdxType kh_off = o % KH_PER_WORD;\n      if (kh_off == 0)\n        nc(15,0) = kh_word(15, 0);\n      else if (kh_off == 1)\n        nc(15,0) = kh_word(31,16);\n      else if (kh_off == 2)\n        nc(15,0) = kh_word(47,32);\n      else\n        nc(15,0) = kh_word(63,48);\n\n      o_word[o_offset] = (sum >= nc) ? 0 : 1;\n    } else {\n      Address kh_addr = o / (const unsigned)2;\n      Word kh_word = kh_mem[kh_addr];\n\n      KType ki;  HType hi;\n      IdxType kh_off = o % 2;\n      if (kh_off == 0) {\n        ki(15,0) = kh_word(15, 0);\n        hi(15,0) = kh_word(31,16);\n      } else {\n        ki(15,0) = kh_word(47,32);\n        hi(15,0) = kh_word(63,48);\n      }\n\n      //printf (\" >> %d * %f + %f\\n\", sum.to_int(), ki.to_float(), hi.to_float());\n      ap_fixed<20,10> out = ap_fixed<20,10>(sum)*ki + hi;\n\n      if (o == 0 || out > best_out) {\n        prediction = o;\n        best_out = out;\n      }\n    }\n\n    dmem[d_o_idx][o_addr%CONVOLVERS][o_addr/CONVOLVERS] = o_word;\n  } // n_outputs\n\n  // Here we are using o_index as a bit index, not a word index!\n  if (layer_type == LAYER_LAST) {\n    Word o_word;\n    o_word(7,0) = prediction(7,0);\n    o_word(WORD_SIZE-1, 8) = 0;\n    dmem[d_o_idx][0][0] = o_word;\n  }\n}\n\n// -----------------------------------------------------------------------\n// Accelerator top module\n// -----------------------------------------------------------------------\nvoid top(\n    Word wt_i[WT_WORDS],\n    Word kh_i[KH_WORDS],\n    Word dmem_i[DMEM_WORDS],\n    Word dmem_o[DMEM_O_WORDS],\n    const Address    n_inputs,\n    const Address    n_outputs,\n    const Address    input_words,\n    const Address    output_words,\n    const ap_uint<3> layer_mode,  // [0]='new layer', [2:1]='conv1,conv,dense,last'\n    const ap_uint<1> dmem_mode,   // 0 means dmem[0] is input\n    const ap_uint<2> width_mode,  // 0=8'b, 1=16'b, 2=32'b\n    const ap_uint<2> norm_mode    // 0='do nothing', 1='do norm', 2='do pool'\n) {\n  DB_PRINT(2, \"==== Entering Accel ====\\n\");\n  const ap_uint<2> layer_type = layer_mode(2,1);\n  const unsigned width = 8 << width_mode;\n  DB_PRINT(1, \"  Inputs  = %d\\n\", n_inputs.to_int());\n  DB_PRINT(1, \"  Outputs = %d\\n\", n_outputs.to_int());\n  DB_PRINT(1, \"  i_words = %d\\n\", input_words.to_int());\n  DB_PRINT(1, \"  o_words = %d\\n\", output_words.to_int());\n  DB_PRINT(1, \"  Width = %d\\n\", width);\n  DB_PRINT(1, \"  layer_mode = %d %d\\n\", layer_mode[0]==0 ? 0 : 1, layer_type.to_int());\n  DB_PRINT(1, \"  dmem_mode = %d\\n\", dmem_mode.to_int());\n\n  assert(width <= MAX_WIDTH);\n  assert(n_inputs != 0);\n  if (layer_type <= LAYER_CONV) {\n    assert(input_words % CONVOLVERS == 0);\n    assert(n_inputs*width*width <= DMEM_WORDS*WORD_SIZE);\n    assert(n_inputs*WT_SIZE <= WT_WORDS*WORD_SIZE);\n  }\n\n  static Word dmem[2][CONVOLVERS][C_DMEM_WORDS];\n  static Word kh_mem[KH_WORDS];\n  static Word wt_mem[CONVOLVERS][C_WT_WORDS];\n  static Address kh_index = 0;\n  static Address o_index = 0;\n\n  if (layer_mode[0]) {\n    kh_index = 0;\n    o_index = 0;\n  } else {\n    kh_index = kh_index[0];\n  }\n\n  ap_uint<1> d_i_idx = dmem_mode;\n  ap_uint<1> d_o_idx = ~dmem_mode;\n\n  // Data input\n  const ap_uint<5> words_per_image = 1 << (2*width_mode);\n  Address img_idx = 0;  // i / words_per_image;\n  IdxType img_off = 0;  // i % words_per_image;\n  LOOP_DMEM_I: for (Address i = 0; i < input_words; ++i) {\n    if (layer_type == LAYER_CONV) {\n      Address bank_idx = img_idx % CONVOLVERS;\n      Address bank_off = img_idx / CONVOLVERS;\n      dmem[d_i_idx][bank_idx][(bank_off<<(2*width_mode)) + img_off] = dmem_i[i];\n    }\n    else if (layer_type == LAYER_CONV1)\n      dmem[d_i_idx][i/C_DMEM_WORDS][i%C_DMEM_WORDS] = dmem_i[i];\n    else\n      dmem[d_i_idx][i%CONVOLVERS][i/CONVOLVERS] = dmem_i[i];\n\n    if (++img_off == words_per_image) {\n      img_off = 0;\n      ++img_idx;\n    }\n  }\n\n  // Weight input, we must copy every 64-bit Word from the interface\n  // into the accelerator\n  LOOP_WT_I: for (Address i = 0; i < C_WT_WORDS*CONVOLVERS; ++i) {\n    wt_mem[i%CONVOLVERS][i/CONVOLVERS] = wt_i[i];\n  }\n  //printf (\"\\nAccel Weights:\\n\");\n  //print_params3d(wt_mem[0], 0, n_inputs*n_outputs);\n\n  LOOP_KH_I: for (ap_uint<16> i = 0; i < KH_WORDS; ++i)\n    kh_mem[i] = kh_i[i];\n\n  if (layer_type == LAYER_CONV1) {\n    assert(n_inputs == 3);\n\n    fp_conv(\n        wt_mem,\n        kh_mem,\n        dmem,\n        d_i_idx,\n        d_o_idx,\n        kh_index,\n        o_index,\n        n_outputs\n    );\n\n    kh_index += n_outputs;\n    o_index += n_outputs;\n  }\n  else if (layer_type == LAYER_CONV) {\n    assert(norm_mode != 2 || n_outputs % 4 == 0); // needed for pooling of 8x8 image\n    assert(n_inputs % CONVOLVERS == 0);\n\n    LOOP_IMG_BATCH:\n    for (IdxType i = 0; i < n_outputs; ++i) {\n      // Load the batch-norm parameters for this output\n      NormComp nc;\n      load_kh(nc, kh_mem, kh_index);\n\n      bin_conv(\n          wt_mem,\n          nc,\n          dmem,\n          d_i_idx, d_o_idx,\n          n_inputs,\n          o_index,\n          i == 0 ? 1 : 0,         // new_batch\n          width_mode,\n          norm_mode\n      );\n\n      kh_index++;\n      o_index++;\n    }\n  }\n  else {\n    bin_dense(\n        wt_mem,\n        kh_mem,\n        dmem,\n        layer_type,\n        d_i_idx, d_o_idx,\n        o_index,\n        n_inputs, n_outputs\n    );\n\n    o_index += n_outputs;\n  } // layer_type\n\n  // Data output\n  ap_uint<5> words_per_out = words_per_image / ((norm_mode!=2) ? 1 : 4);\n  img_idx = 0;\n  img_off = 0;\n  LOOP_DMEM_O: for (Address i = 0; i < output_words; ++i) {\n    // exclude conv6 (width==8, norm_mode==2) here because it writes\n    // the output fmaps linearly\n    if (layer_type <= LAYER_CONV && !(width_mode == 0 && norm_mode == 2)) {\n      Address bank_idx = img_idx % CONVOLVERS;\n      Address bank_off = img_idx / CONVOLVERS;\n      dmem_o[i] = dmem[d_o_idx][bank_idx][bank_off*words_per_out + img_off];\n    }\n    else\n      dmem_o[i] = dmem[d_o_idx][i%CONVOLVERS][i/CONVOLVERS];\n\n    if (++img_off == words_per_out) {\n      img_off = 0;\n      ++img_idx;\n    }\n  }\n}\n"
      },
      {
        "file_name": "Accel.h",
        "file_content": "#ifndef ACCEL_ACCEL_H\n#define ACCEL_ACCEL_H\n\n#include <cstddef>\n#include \"xf_utility.hpp\"\n#include \"xf_common.hpp\"\n#include <hls_stream.h>\n#include <stdlib.h>   // include this before sds_lib.h for size_t\n\n#include \"Typedefs.h\"\n#include \"Debug.h\"\n#include \"Common.h\"\n\n#ifdef __SDSCC__\n  #include \"sds_lib.h\"\n  #define MEM_ALLOC(size) sds_alloc(size)\n  #define MEM_FREE(ptr) sds_free(ptr)\n#else\n  #define MEM_ALLOC(size) malloc(size)\n  #define MEM_FREE(ptr) free(ptr)\n#endif\n\n//-------------------------------------------------------------------\n// Constants\n//-------------------------------------------------------------------\nconst unsigned CONVOLVERS = 2;\n\nconst unsigned WORD_SIZE = 64;\nconst unsigned WT_SIZE = 9;\nconst unsigned CONV_W_PER_WORD = 7;\nconst unsigned CONV1_W_PER_WORD = 4;\nconst unsigned KH_PER_WORD = 4;\nconst unsigned BYTE_SIZE = 8;\nconst unsigned K = 3;\nconst unsigned WT_L         = 16*4*512; // parameter to control wt mem size\nconst unsigned C_WT_WORDS   = ((WT_L+CONV_W_PER_WORD-1)/CONV_W_PER_WORD + CONVOLVERS-1) / CONVOLVERS;  // wt words per convolver\nconst unsigned WT_WORDS     = C_WT_WORDS*CONVOLVERS;\nconst unsigned KH_WORDS     = WT_L/128*16 / WORD_SIZE;\n\nconst unsigned DMEM_WORDS   = 128*32*32 / WORD_SIZE;\nconst unsigned C_DMEM_WORDS = DMEM_WORDS / CONVOLVERS;\nconst unsigned DMEM_O_WORDS = 512*4*4 / WORD_SIZE;\nconst unsigned DB_MEM_WORDS = 32*32;\n\nconst unsigned PIX_PER_PHASE = 2*32*32;\n\nconst unsigned MAX_WIDTH = WORD_SIZE;\nconst unsigned BANK_WIDTH = 8;\nconst unsigned LOG_BANK_WIDTH = 3;\n\nconst unsigned CONV_ROWS = 3;\nconst unsigned CONV_COLS = BANK_WIDTH+2;\nconst unsigned CONV_BANKS = WORD_SIZE / BANK_WIDTH;\n\n//-------------------------------------------------------------------\n// Typedefs\n//-------------------------------------------------------------------\nenum LayerTypeEnum {LAYER_CONV1, LAYER_CONV, LAYER_DENSE, LAYER_LAST};\n\ntypedef ap_int<WORD_SIZE> Word;\ntypedef ap_int<WT_SIZE> WtType;\ntypedef ap_uint<16> Address;\ntypedef ap_int<12> ConvSum;\ntypedef ap_int<5> ConvOut;\ntypedef ap_uint<10> IdxType;\ntypedef ap_fixed<16,4> C1Comp;\ntypedef ap_int<16> NormComp;\ntypedef ap_int<16> DenseSum;\ntypedef ap_fixed<16,12> DenseNorm;\n\ntypedef ap_fixed<20,2, AP_RND> C1InputType;\ntypedef ap_fixed<24,6, AP_RND> C1ConvType;\n\n\n//-------------------------------------------------------------------\n// Template functions\n//-------------------------------------------------------------------\ntemplate<typename T>\nvoid load_kh(T& comp, const Word kh_mem[KH_WORDS], Address idx) {\n  Word kh_word = kh_mem[idx/KH_PER_WORD];\n  IdxType off = idx % KH_PER_WORD;\n  if (off == 0)\n    comp(15,0) = kh_word(15, 0);\n  else if (off == 1)\n    comp(15,0) = kh_word(31,16);\n  else if (off == 2)\n    comp(15,0) = kh_word(47,32);\n  else\n    comp(15,0) = kh_word(63,48);\n}\n\n//-------------------------------------------------------------------\n// Accelerator synthesizable top-level function\n//-------------------------------------------------------------------\n#pragma SDS data copy(dmem_i[0:input_words], dmem_o[0:output_words])\n#pragma SDS data access_pattern(dmem_i:SEQUENTIAL, dmem_o:SEQUENTIAL)\n#pragma SDS data access_pattern(wt_i:SEQUENTIAL, kh_i:SEQUENTIAL)\n#pragma SDS data mem_attribute(dmem_i:PHYSICAL_CONTIGUOUS, dmem_o:PHYSICAL_CONTIGUOUS)\n#pragma SDS data mem_attribute(wt_i:PHYSICAL_CONTIGUOUS, kh_i:PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(dmem_i:AXIDMA_SIMPLE, dmem_o:AXIDMA_SIMPLE)\n#pragma SDS data data_mover(wt_i:AXIDMA_SIMPLE, kh_i:AXIDMA_SIMPLE)\nvoid top(\n    Word wt_i[WT_WORDS],\n    Word kh_i[KH_WORDS],\n    Word dmem_i[DMEM_WORDS],\n    Word dmem_o[DMEM_O_WORDS],\n    const Address    n_inputs,\n    const Address    n_outputs,\n    const Address    input_words,\n    const Address    output_words,\n    const ap_uint<3> layer_mode,  // [0]='new layer', [2:1]='conv1,conv,dense'\n    const ap_uint<1> dmem_mode,   // 0 means dmem[0] is input\n    const ap_uint<2> width_mode,  // 0=8'b, 1=16'b, 2=32'b\n    const ap_uint<2> norm_mode    // 0='do nothing', 1='do norm', 2='do pool'\n);\n\n#endif\n"
      },
      {
        "file_name": "xf_types.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_TYPES_H_\n#define _XF_TYPES_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n#include \"xf_params.hpp\"\n#include <stdint.h>\n\ntemplate <int N>\nstruct floatn {\n    float f[N];\n    float& operator[](int idx) { return f[idx]; }\n    const float& operator[](int idx) const { return f[idx]; }\n};\ntypedef floatn<3> float3;\n\ntemplate <int T>\nstruct StreamType {};\ntemplate <>\nstruct StreamType<XF_2UW> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct StreamType<XF_8UW> {\n    typedef ap_uint<8> name;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct StreamType<XF_9UW> {\n    typedef ap_uint<9> name;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct StreamType<XF_10UW> {\n    typedef ap_uint<10> name;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct StreamType<XF_12UW> {\n    typedef ap_uint<12> name;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct StreamType<XF_14UW> {\n    typedef ap_uint<14> name;\n    static const int bitdepth = 14;\n};\ntemplate <>\nstruct StreamType<XF_16UW> {\n    typedef ap_uint<16> name;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct StreamType<XF_19SW> {\n    typedef ap_int<19> name;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct StreamType<XF_20UW> {\n    typedef ap_uint<20> name;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct StreamType<XF_22UW> {\n    typedef ap_uint<22> name;\n    static const int bitdepth = 22;\n};\ntemplate <>\nstruct StreamType<XF_24UW> {\n    typedef ap_uint<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_24SW> {\n    typedef ap_int<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_28UW> {\n    typedef ap_uint<28> name;\n    static const int bitdepth = 28;\n};\ntemplate <>\nstruct StreamType<XF_30UW> {\n    typedef ap_uint<30> name;\n    static const int bitdepth = 30;\n};\ntemplate <>\nstruct StreamType<XF_32UW> {\n    typedef ap_uint<32> name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_32FW> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_96FW> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_192FW> {\n    typedef floatn<6> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_384FW> {\n    typedef floatn<12> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_768FW> {\n    typedef floatn<24> name;\n    static const int bitdepth = 768;\n};\ntemplate <>\nstruct StreamType<XF_1536FW> {\n    typedef floatn<48> name;\n    static const int bitdepth = 1536;\n};\ntemplate <>\nstruct StreamType<XF_35SW> {\n    typedef ap_int<35> name;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct StreamType<XF_36UW> {\n    typedef ap_uint<36> name;\n    static const int bitdepth = 36;\n};\ntemplate <>\nstruct StreamType<XF_40UW> {\n    typedef ap_uint<40> name;\n    static const int bitdepth = 40;\n};\ntemplate <>\nstruct StreamType<XF_42UW> {\n    typedef ap_uint<42> name;\n    static const int bitdepth = 42;\n};\ntemplate <>\nstruct StreamType<XF_48UW> {\n    typedef ap_uint<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_48SW> {\n    typedef ap_int<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_56UW> {\n    typedef ap_uint<56> name;\n    static const int bitdepth = 56;\n};\ntemplate <>\nstruct StreamType<XF_60UW> {\n    typedef ap_uint<60> name;\n    static const int bitdepth = 60;\n};\ntemplate <>\nstruct StreamType<XF_64UW> {\n    typedef ap_uint<64> name;\n    static const int bitdepth = 64;\n};\ntemplate <>\nstruct StreamType<XF_72UW> {\n    typedef ap_uint<72> name;\n    static const int bitdepth = 72;\n};\ntemplate <>\nstruct StreamType<XF_80UW> {\n    typedef ap_uint<80> name;\n    static const int bitdepth = 80;\n};\ntemplate <>\nstruct StreamType<XF_84UW> {\n    typedef ap_uint<84> name;\n    static const int bitdepth = 84;\n};\ntemplate <>\nstruct StreamType<XF_96UW> {\n    typedef ap_uint<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_96SW> {\n    typedef ap_int<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_112UW> {\n    typedef ap_uint<112> name;\n    static const int bitdepth = 112;\n};\ntemplate <>\nstruct StreamType<XF_120UW> {\n    typedef ap_uint<120> name;\n    static const int bitdepth = 120;\n};\ntemplate <>\nstruct StreamType<XF_128UW> {\n    typedef ap_uint<128> name;\n    static const int bitdepth = 128;\n};\ntemplate <>\nstruct StreamType<XF_144UW> {\n    typedef ap_uint<144> name;\n    static const int bitdepth = 144;\n};\ntemplate <>\nstruct StreamType<XF_152SW> {\n    typedef ap_int<152> name;\n    static const int bitdepth = 152;\n};\ntemplate <>\nstruct StreamType<XF_160UW> {\n    typedef ap_uint<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_160SW> {\n    typedef ap_int<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_168UW> {\n    typedef ap_int<168> name;\n    static const int bitdepth = 168;\n};\ntemplate <>\nstruct StreamType<XF_176UW> {\n    typedef ap_uint<176> name;\n    static const int bitdepth = 176;\n};\ntemplate <>\nstruct StreamType<XF_192UW> {\n    typedef ap_uint<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_192SW> {\n    typedef ap_int<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_256UW> {\n    typedef ap_uint<256> name;\n    static const int bitdepth = 256;\n};\ntemplate <>\nstruct StreamType<XF_280SW> {\n    typedef ap_int<280> name;\n    static const int bitdepth = 280;\n};\ntemplate <>\nstruct StreamType<XF_288UW> {\n    typedef ap_uint<288> name;\n    static const int bitdepth = 288;\n};\ntemplate <>\nstruct StreamType<XF_304SW> {\n    typedef ap_int<304> name;\n    static const int bitdepth = 304;\n};\ntemplate <>\nstruct StreamType<XF_320UW> {\n    typedef ap_int<320> name;\n    static const int bitdepth = 320;\n};\ntemplate <>\nstruct StreamType<XF_336UW> {\n    typedef ap_int<336> name;\n    static const int bitdepth = 336;\n};\ntemplate <>\nstruct StreamType<XF_352UW> {\n    typedef ap_uint<352> name;\n    static const int bitdepth = 352;\n};\ntemplate <>\nstruct StreamType<XF_384UW> {\n    typedef ap_uint<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_384SW> {\n    typedef ap_int<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_512UW> {\n    typedef ap_uint<512> name;\n    static const int bitdepth = 512;\n};\ntemplate <>\nstruct StreamType<XF_560SW> {\n    typedef ap_int<560> name;\n    static const int bitdepth = 560;\n};\ntemplate <>\nstruct StreamType<XF_576UW> {\n    typedef ap_uint<576> name;\n    static const int bitdepth = 576;\n};\n\ntemplate <int T>\nstruct PixelType {};\ntemplate <>\nstruct PixelType<XF_8UP> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef unsigned char name2;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_8SP> {\n    typedef ap_int<8> name;\n    typedef ap_uint<8> uname;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_9UP> {\n    typedef ap_uint<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_9SP> {\n    typedef ap_int<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_16UP> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_16SP> {\n    typedef ap_int<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_32UP> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_32SP> {\n    typedef ap_int<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_19SP> {\n    typedef ap_int<19> name;\n    typedef ap_uint<19> uname;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct PixelType<XF_35SP> {\n    typedef ap_int<35> name;\n    typedef ap_uint<35> uname;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct PixelType<XF_32FP> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_96FP> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct PixelType<XF_24SP> {\n    typedef ap_int<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct PixelType<XF_20SP> {\n    typedef ap_int<20> name;\n    typedef ap_uint<20> uname;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct PixelType<XF_48SP> {\n    typedef ap_int<48> name;\n    typedef ap_uint<48> uname;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct PixelType<XF_2UP> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct PixelType<XF_24UP> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\n\ntemplate <>\nstruct PixelType<XF_10UP> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct PixelType<XF_12UP> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct PixelType<XF_14UP> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    static const int bitdepth = 14;\n};\n#define XF_NPIXPERCYCLE(flags) xfNPixelsPerCycle<flags>::nppc\n\n#define XF_BITSHIFT(flags) xfNPixelsPerCycle<flags>::datashift\n\ntemplate <int T>\nstruct xfNPixelsPerCycle {};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC1> {\n    static const int datashift = 0;\n    static const int nppc = 1;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC2> {\n    static const int datashift = 1;\n    static const int nppc = 2;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC4> {\n    static const int datashift = 2;\n    static const int nppc = 4;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC8> {\n    static const int datashift = 3;\n    static const int nppc = 8;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC16> {\n    static const int datashift = 4;\n    static const int nppc = 16;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC32> {\n    static const int datashift = 5;\n    static const int nppc = 32;\n};\n\ntemplate <int T, int M>\nstruct DataType {};\n\n// One channel data types\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC1> {\n    typedef ap_uint<2> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_2UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC32> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC4> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC8> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC1> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned char wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC2> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC4> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC8> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC16> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC32> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC64> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC1> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_10UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC2> {\n    typedef ap_uint<20> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_20UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC4> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC8> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC16> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC1> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_12UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC2> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC4> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC8> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC16> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC1> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_14UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC2> {\n    typedef ap_uint<28> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_28UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC4> {\n    typedef ap_uint<56> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_56UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC8> {\n    typedef ap_uint<112> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_112UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_64UC1, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<64> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 64;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_32FW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC1> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<3> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_96FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC2> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<6> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_192FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC4> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<12> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_384FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC8> {\n    typedef ap_uint<768> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<24> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_768FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC16> {\n    typedef ap_uint<1536> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<48> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_1536FW;\n    static const int channel = 3;\n};\n\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\n// Two channels data types\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 2;\n};\n\n// template<> struct DataType <XF_10UC2, XF_NPPC1>   { typedef ap_uint<40>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; typedef unsigned  short int sname; typedef unsigned long long int wname; static const int\n// bitdepth = 10; static const int pixeldepth = XF_40UP;static const int wordwidth = XF_40UW; static const int channel =\n// 4;}; template<> struct DataType <XF_10UC2, XF_NPPC2>   { typedef ap_uint<80>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; static const int bitdepth = 10; static const int pixeldepth = XF_40UP;static const int\n// wordwidth = XF_80UW; static const int channel = 4;};\n\n// Three channels data types (TODO: Pixeldepth of XF_16U3 needs correction)\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC16> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC1> {\n    typedef ap_uint<30> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_30UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC2> {\n    typedef ap_uint<60> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_60UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC4> {\n    typedef ap_uint<120> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_120UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC8> {\n    typedef ap_uint<240> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_240UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC1> {\n    typedef ap_uint<36> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_36UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC2> {\n    typedef ap_uint<72> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_72UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC4> {\n    typedef ap_uint<144> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_144UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC8> {\n    typedef ap_uint<288> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_288UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC1> {\n    typedef ap_uint<42> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_42UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC2> {\n    typedef ap_uint<84> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_84UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC4> {\n    typedef ap_uint<168> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_168UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC8> {\n    typedef ap_uint<336> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_336UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_48SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_96SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_192SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_384SW;\n    static const int channel = 3;\n};\n// Four channels data types\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC1> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC2> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC4> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC8> {\n    typedef ap_uint<320> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_320UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC2> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC4> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC8> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\n\n#define TC(TYPE) TC##TYPE\n\n#define XF_TNAME(flags, npc) typename DataType<flags, npc>::name\n\n#define XF_DTUNAME(flags, npc) typename DataType<flags, npc>::uname\n\n#define XF_CTUNAME(flags, npc) typename DataType<flags, npc>::cname\n\n#define XF_PTSNAME(flags, npc) typename DataType<flags, npc>::sname\n\n#define XF_WTNAME(flags, npc) typename DataType<flags, npc>::wname\n\n#define XF_DTPIXELDEPTH(flags, npc) DataType<flags, npc>::bitdepth\n\n#define XF_DEPTH(flags, npc) DataType<flags, npc>::pixeldepth\n\n#define XF_WORDWIDTH(flags, npc) DataType<flags, npc>::wordwidth\n\n#define XF_CHANNELS(flags, npc) DataType<flags, npc>::channel\n\n#define XF_PIXELWIDTH(flags, npc) DataType<flags, npc>::pixelwidth\n\n#define XF_PTNAME(flags) typename PixelType<flags>::name\n\n#define XF_PIXELDEPTH(flags) PixelType<flags>::bitdepth\n\n#define XF_PTUNAME(flags) typename PixelType<flags>::uname\n\n#define XF_PTNAME2(flags) typename PixelType<flags>::name2\n\n#define XF_SNAME(flags) typename StreamType<flags>::name\n#define XF_WORDDEPTH(flags) StreamType<flags>::bitdepth\n\n#define XF_NAME(flags, npc) ap_uint<(XF_DTPIXELDEPTH(flags, npc) / XF_CHANNELS(flags, npc)) * XF_NPIXPERCYCLE(npc)>\n\n// find image width in terms of the number of words used to represent the data\n//#define IM_WIDTH(W,S) ((W)>>(S))\n\n// Xilinx headers\n#include <ap_int.h>\n#include <ap_fixed.h>\n#include <stdint.h>\n// Native types\n// typedef unsigned long     uint64_t;\ntypedef unsigned int uint32_t;\ntypedef unsigned short uint16_t;\n// typedef long int        int64_t;\ntypedef int int32_t;\ntypedef short int int16_t;\ntypedef unsigned char uchar_t;\ntypedef unsigned char uint8_t;\ntypedef signed char int8_t;\n\n// Arbitrary Precision integer types\ntypedef ap_uint<1> ap_uint1_t;\ntypedef ap_uint<2> ap_uint2_t;\ntypedef ap_uint<4> ap_uint4_t;\ntypedef ap_uint<5> ap_uint5_t;\ntypedef ap_uint<8> ap_uint8_t;\ntypedef ap_uint<9> ap_uint9_t;\ntypedef ap_uint<16> ap_uint16_t;\ntypedef ap_uint<17> ap_uint17_t;\ntypedef ap_uint<18> ap_uint18_t;\ntypedef ap_uint<20> ap_uint20_t;\ntypedef ap_uint<22> ap_uint22_t;\ntypedef ap_uint<23> ap_uint23_t;\ntypedef ap_uint<24> ap_uint24_t;\ntypedef ap_uint<32> ap_uint32_t;\ntypedef ap_uint<33> ap_uint33_t;\ntypedef ap_uint<34> ap_uint34_t;\ntypedef ap_uint<35> ap_uint35_t;\ntypedef ap_uint<38> ap_uint38_t;\ntypedef ap_uint<45> ap_uint45_t;\ntypedef ap_uint<48> ap_uint48_t;\ntypedef ap_uint<51> ap_uint51_t;\ntypedef ap_uint<64> ap_uint64_t;\ntypedef ap_uint<66> ap_uint66_t;\ntypedef ap_uint<72> ap_uint72_t;\ntypedef ap_uint<97> ap_uint97_t;\ntypedef ap_uint<101> ap_uint101_t;\ntypedef ap_uint<128> ap_uint128_t;\ntypedef ap_uint<144> ap_uint144_t;\ntypedef ap_uint<176> ap_uint176_t;\ntypedef ap_uint<192> ap_uint192_t;\ntypedef ap_uint<256> ap_uint256_t;\ntypedef ap_uint<352> ap_uint352_t;\ntypedef ap_uint<384> ap_uint384_t;\ntypedef ap_uint<512> ap_uint512_t;\ntypedef ap_uint<576> ap_uint576_t;\n\ntypedef ap_int<8> ap_int8_t;\ntypedef ap_int<9> ap_int9_t;\ntypedef ap_int<12> ap_int12_t;\ntypedef ap_int<15> ap_int15_t;\ntypedef ap_int<16> ap_int16_t;\ntypedef ap_int<18> ap_int18_t;\ntypedef ap_int<19> ap_int19_t;\ntypedef ap_int<20> ap_int20_t;\ntypedef ap_int<24> ap_int24_t;\ntypedef ap_int<32> ap_int32_t;\ntypedef ap_int<35> ap_int35_t;\ntypedef ap_int<36> ap_int36_t;\ntypedef ap_int<42> ap_int42_t;\ntypedef ap_int<48> ap_int48_t;\ntypedef ap_int<64> ap_int64_t;\ntypedef ap_int<152> ap_int152_t;\ntypedef ap_int<304> ap_int304_t;\ntypedef ap_int<280> ap_int280_t;\ntypedef ap_int<560> ap_int560_t;\n\n// Arbitrary Precision fixed-point types\ntypedef ap_ufixed<12, 12> uint12_q0;\ntypedef ap_ufixed<16, 16> uint16_q0; // 16-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<32, 32> uint32_q0; // 32-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<8, 8> uint8_q0;    // 8-bit unsigned with 0 fractional bits\n\n#endif //_XF_TYPES_H_\n"
      },
      {
        "file_name": "Typedefs.h",
        "file_content": "#ifndef TYPEDEFS_H\n#define TYPEDEFS_H\n\n#include <ap_int.h>\n\n//#define USE_FLOAT\n\n#ifdef USE_FLOAT\n\n  typedef float InputFixed;\n\n  // Types for weights\n  typedef ap_int<1> Bit;\n  typedef ap_int<2> TwoBit;\n\n  typedef float KType;\n  typedef float HType;\n\n  typedef float NormOutput;\n  typedef ap_int<14> ConvOutput;\n\n#else\n\n  // Quantized 32-bit input images in the range [-1,1]\n  typedef ap_fixed<32,2, AP_RND> InputFixed;\n\n  // Types for weights\n  typedef ap_int<1> Bit;\n  typedef ap_int<2> TwoBit;\n\n  typedef ap_fixed<16,2> KType;\n  typedef ap_fixed<16,4> HType;\n\n  typedef ap_fixed<16,5> NormOutput;\n  typedef ap_int<14> ConvOutput;\n\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xf_utility.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_UTILITY_H_\n#define _XF_UTILITY_H_\n\n#include \"ap_axi_sdata.h\"\n#include \"xf_common.hpp\"\n#include \"xf_video_mem.hpp\"\n#include <assert.h>\n#include <string.h>\n\nnamespace xf {\nnamespace cv {\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid Ptr2xfMat(ap_uint<BUS_WIDTH>* in_ptr, xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_mat.write(i, (XF_TNAME(TYPE, NPPC))in_ptr[i]);\n    }\n\n} // End of Ptr2xfMat()\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xfMat2Ptr(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat, ap_uint<BUS_WIDTH>* out_ptr) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_ptr[i] = in_mat.read(i);\n    }\n\n} // End of xfMat2Ptr()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                           ap_uint<BUS_WIDTH>* out_ptr,\n                           xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat.write(i, tmp);\n    }\n\n} // End of xFDuplicateMat_PTRMAT()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR and 2 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_1 = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_2 = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT2(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_1>& out_mat1,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_2>& out_mat2) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat1.write(i, tmp);\n        out_mat2.write(i, tmp);\n        // out_mat2.write(i, (XF_TNAME(XF_16SC1, NPPC))tmp); // TODO: Remove me as I am for experiment\n    }\n\n} // End of xFDuplicateMat_PTRMAT2()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR, 1 for xf::cv::Mat and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_MAT_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                                ap_uint<BUS_WIDTH>* out_ptr,\n                                xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat,\n                                hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n        out_mat.write(i, tmp);\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_MAT_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to stream out xf::cv::Mat on AXI bus for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFMat2AXI_Strm(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                    hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n\n        v.data = in_mat.read(i);\n        out_axi.write(v);\n    }\n\n} // End of xFMat2AXI_Strm()\n// ======================================================================================\n\n// ======================================================================================\n// Function to read AXI stream into xf::cv::Mat for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid AXI_Strm2xFMat(hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& in_axi,\n                    xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v = in_axi.read();\n\n        out_mat.write(i, v.data);\n    }\n\n} // End of AXI_Strm2xFMat()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to set border in the extracted kernel sized block\n// ======================================================================================\ntemplate <int K_ROWS, int K_COLS, typename SRC_T, int BORDER_T>\nvoid xFSetBorder(xf::cv::Window<K_ROWS, K_COLS, SRC_T>& src_blk,\n                 uint16_t _row,\n                 uint16_t _col,\n                 uint16_t _src_rows,\n                 uint16_t _src_cols) {\n#pragma HLS INLINE OFF\n\n    uint16_t blk_t_idx, blk_b_idx;\n    uint16_t blk_l_idx, blk_r_idx;\n\n    blk_t_idx = (K_ROWS - _row - 1);\n    blk_b_idx = (K_ROWS - (_row - _src_rows + 1) - 1);\n\n    blk_l_idx = (K_COLS - _col - 1);\n    blk_r_idx = (K_COLS - (_col - _src_cols + 1) - 1);\n\n    for (uint16_t r = 0; r < K_ROWS; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n        for (uint16_t c = 0; c < K_COLS; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n\n            bool top_border = ((r < blk_t_idx) && (_row < K_ROWS - 1)) ? true : false;\n            bool bottom_border = ((r > blk_b_idx) && (_row >= _src_rows)) ? true : false;\n            bool left_border = ((c < blk_l_idx) && (_col < K_COLS - 1)) ? true : false;\n            bool right_border = ((c > blk_r_idx) && (_col >= _src_cols)) ? true : false;\n\n            uint16_t r_idx = r, c_idx = c;\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                r_idx = top_border ? blk_t_idx : bottom_border ? blk_b_idx : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                r_idx = top_border ? (2 * blk_t_idx - r) : bottom_border ? (2 * blk_b_idx - r) : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                r_idx = top_border ? (2 * blk_t_idx - r - 1) : bottom_border ? (2 * blk_b_idx - r + 1) : r;\n\n            } else { // TODO: Need to add other modes support\n                r_idx = r;\n            }\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                c_idx = left_border ? blk_l_idx : right_border ? blk_r_idx : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                c_idx = left_border ? (2 * blk_l_idx - c) : right_border ? (2 * blk_r_idx - c) : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                c_idx = left_border ? (2 * blk_l_idx - c - 1) : right_border ? (2 * blk_r_idx - c + 1) : c;\n\n            } else { // TODO: Need to add other modes support\n                c_idx = c;\n            }\n\n            if ((top_border | bottom_border | left_border | right_border) && (BORDER_T == XF_BORDER_CONSTANT)) {\n                src_blk.val[r][c] = 0;\n            } else {\n                src_blk.val[r][c] = src_blk.val[r_idx][c_idx];\n            }\n        }\n    }\n\n} // End of xFSetBorder()\n// ======================================================================================\n\n/**\n * Extract Pixels from a packed word into an array from the index pos.\n * The number of pixels to be extracted is determined by the NPC.\n */\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfPackPixels(\n    XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val, uint16_t pos, int16_t loopIter, uint16_t& shift) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<8> STEP = XF_PIXELDEPTH(PIXELDEPTH);\n\n    for (ap_int<9> i = 0; i < loopIter; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        XF_PTUNAME(PIXELDEPTH) tmp = tmp_buf[pos];\n        val = val | (((XF_SNAME(WORDWIDTH))tmp) << (shift * STEP));\n        pos++;\n        shift++;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfExtractPixels(XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val1, int pos) {\n// clang-format off\n    #pragma HLS inline off\n    // clang-format on\n    XF_SNAME(WORDWIDTH) v = val1;\n\n    int shift = 0;\n    int STEP = XF_PIXELDEPTH(PIXELDEPTH);\nExtract_pixels_loop:\n    for (int i = 0; i < (1 << (XF_BITSHIFT(NPC))); i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        tmp_buf[pos + i] = v.range(shift + STEP - 1, shift);\n        shift = shift + STEP;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH_SRC, int DEPTH_SRC>\nvoid xfExtractData(XF_PTNAME(DEPTH_SRC) * src_buf1,\n                   XF_PTNAME(DEPTH_SRC) * src_buf2,\n                   XF_PTNAME(DEPTH_SRC) * src_buf3,\n                   XF_PTNAME(DEPTH_SRC) * src_buf4,\n                   XF_PTNAME(DEPTH_SRC) * src_buf5,\n                   XF_PTNAME(DEPTH_SRC) * src_buf6,\n                   XF_PTNAME(DEPTH_SRC) * src_buf7,\n                   XF_SNAME(WORDWIDTH_SRC) buf0,\n                   XF_SNAME(WORDWIDTH_SRC) buf1,\n                   XF_SNAME(WORDWIDTH_SRC) buf2,\n                   XF_SNAME(WORDWIDTH_SRC) buf3,\n                   XF_SNAME(WORDWIDTH_SRC) buf4,\n                   XF_SNAME(WORDWIDTH_SRC) buf5,\n                   XF_SNAME(WORDWIDTH_SRC) buf6) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf1[6], buf0, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf2[6], buf1, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf3[6], buf2, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf4[6], buf3, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf5[6], buf4, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf6[6], buf5, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf7[6], buf6, 0);\n}\n\ntemplate <int NPC, int DEPTH_SRC>\nvoid xfCopyData(XF_PTNAME(DEPTH_SRC) src_buf1[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf2[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf3[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf4[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf5[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf6[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf7[XF_NPIXPERCYCLE(NPC) + 6]) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<5> buf_size = (XF_NPIXPERCYCLE(NPC) + 6);\n    ap_uint<4> i = 0;\n    ap_uint<4> ind = buf_size - 6;\n\n    for (i = 0; i < 6; i++, ind++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=6 max=6\n#pragma HLS unroll factor=1\n        // clang-format on\n        src_buf1[i] = src_buf1[ind];\n        src_buf2[i] = src_buf2[ind];\n        src_buf3[i] = src_buf3[ind];\n        src_buf4[i] = src_buf4[ind];\n        src_buf5[i] = src_buf5[ind];\n        src_buf6[i] = src_buf6[ind];\n        src_buf7[i] = src_buf7[ind];\n    }\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut1(XF_SNAME(WORDWIDTH) * _src, unsigned long long int* _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, SIZE);\n#else\n    if (nbytes) memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn1(unsigned long long int* _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((AU_TNAME(WORDWIDTH)*)_dst, (AU_TNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\ntemplate <int WORDWIDTH, int NPC, int IN_BH, int IN_BW>\nvoid xFDuplicateStream(hls::stream<XF_SNAME(WORDWIDTH)>& in_strm,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm1,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm2,\n                       int imwidth,\n                       int imheight) {\n    for (int i = 0; i < imheight; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=IN_BH max=IN_BH\n        #pragma HLS LOOP_FLATTEN off\n        // clang-format on\n        for (int j = 0; j < (imwidth >> NPC); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS pipeline\n            #pragma HLS LOOP_TRIPCOUNT min=IN_BW max=IN_BW\n            // clang-format on\n            XF_SNAME(WORDWIDTH) tmp = in_strm.read();\n            out_strm1.write(tmp);\n            out_strm2.write(tmp);\n        }\n    }\n}\n\n// ==============================================================================\n// Class contains funcitons requried for accel file (top wrapper file)\n// ==============================================================================\nclass accel_utils {\n   public:\n    // ==============================================================================\n    // Read module(s) to handle data transfer from AXI/HLS stream to xfMat\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void Array2hlsStrm(ap_uint<PTR_WIDTH>* srcPtr, hls::stream<ap_uint<PTR_WIDTH> >& dstStrm, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstStrm.write(srcPtr[i]);\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void hlsStrm2xfMat(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat,\n                       int dstMat_cols_align_npc) {\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int loop_count = (rows * dstMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = dstMat_cols_align_npc - cols;\n        int in_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * dstMat_cols_align_npc; // channels\n        int ddr_read_cycles = (((in_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_read_cnt = 0;\n\n        int valid_bits = 0;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        int K_size;\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) out;\n        int ncpr = dstMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n        int strm_cnt_disply = 0;\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            int valid_bits_update;\n            int valid_bits_tmp = valid_bits - K_size;\n            XF_TNAME(MAT_T, NPC) out = 0;\n\n            if (valid_bits < K_size) {\n                if (valid_bits != 0) {\n                    out.range(valid_bits - 1, 0) = r.range(PTR_WIDTH - 1, PTR_WIDTH - valid_bits);\n                }\n                if (ddr_read_cnt < ddr_read_cycles) {\n                    r = srcStrm.read();\n                    ddr_read_cnt++;\n                } else {\n                    r = 0;\n                }\n                out.range(K_size - 1, valid_bits) = r.range(K_size - valid_bits - 1, 0);\n                valid_bits = PTR_WIDTH_min_Ksize + valid_bits;\n            } else {\n                out = r.range(PTR_WIDTH_plus_Ksize - valid_bits - 1, PTR_WIDTH - valid_bits);\n                valid_bits = valid_bits - K_size;\n            }\n\n            dstMat.write(i, out);\n        }\n        int stop = 0;\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\n    void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                     xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        Array2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH>(strm, dstMat,\n                                                                                         dstMat_cols_align_npc);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void axiStrm2hlsStrm(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                         hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = srcPtr.read();\n            dstStrm.write(v.data);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        axiStrm2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH_OUT>(strm, dstMat,\n                                                                                             dstMat_cols_align_npc);\n    }\n\n    // ==============================================================================\n    // Write module(s) to handle data transfer from xfMat to AXI/HLS stream\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void xfMat2hlsStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& srcMat,\n                       hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                       int srcMat_cols_align_npc) {\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int loop_count = (rows * srcMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = srcMat_cols_align_npc - cols;\n        int out_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * srcMat_cols_align_npc; // channels\n        int ddr_write_cycles = (((out_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_write_cnt = 0;\n\n        int bits_to_add = PTR_WIDTH;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) in;\n        int ncpr = srcMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            int K_size;\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            in = srcMat.read(i);\n\n            if (bits_to_add <= K_size) {\n                r.range(PTR_WIDTH - 1, PTR_WIDTH - bits_to_add) = in.range(bits_to_add - 1, 0);\n                dstStrm.write(r);\n\n                if (bits_to_add != K_size) {\n                    r.range(K_size - bits_to_add - 1, 0) = in.range(K_size - 1, bits_to_add);\n                }\n                bits_to_add = PTR_WIDTH_min_Ksize + bits_to_add;\n            } else {\n                r.range(PTR_WIDTH_plus_Ksize - bits_to_add - 1, PTR_WIDTH - bits_to_add) = in;\n                bits_to_add -= K_size;\n            }\n        }\n\n        if (bits_to_add != PTR_WIDTH) {\n            dstStrm.write(r);\n        }\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2Array(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstPtr[i] = srcStrm.read();\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int XFCVDEPTH = _XFCVDEPTH_DEFAULT,\n              int FILLZERO = 1>\n    void xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                     ap_uint<PTR_WIDTH>* dstPtr,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2Array<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2axiStrm(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                         hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = srcStrm.read();\n            dstPtr.write(v);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\n    void xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_IN>& srcMat,\n                       hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH_IN>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2axiStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT, int FILLZERO = 1>\nvoid xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat, ap_uint<PTR_WIDTH>* dstPtr, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n    accel_utils au;\n    au.xfMat2Array<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcMat, dstPtr);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n    accel_utils au;\n    au.Array2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcPtr, dstMat);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                   hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n    accel_utils au;\n    au.xfMat2axiStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>(srcMat, dstPtr);\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                   xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n    accel_utils au;\n    au.axiStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>(srcPtr, dstMat);\n}\n\n} // namespace cv\n} // namespace xf\n\n#endif //_XF_UTILITY_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "AccelPrint.h",
        "file_content": "#ifndef ACCEL_PRINT_H\n#define ACCEL_PRINT_H\n\n#include \"Accel.h\"\n#include <stdio.h>\n\n//------------------------------------------------------------------------\n// For an array of ap_int's, sets/gets the bit at bit_idx\n// calculated from the start of the array to val\n//------------------------------------------------------------------------\ntemplate<typename T>\ninline void set_bit(T array[], unsigned bit_idx, Bit val) {\n  unsigned W = array[0].length();\n  Address idx = bit_idx / W;\n  Address offset = bit_idx % W;\n  array[idx][offset] = val;\n}\n\ntemplate<typename T>\ninline Bit get_bit(T array[], unsigned bit_idx) {\n  unsigned W = array[0].length();\n  Address idx = bit_idx / W;\n  Address offset = bit_idx % W;\n  Bit result = array[idx][offset];\n  return result;\n}\n\n//------------------------------------------------------------------------\n// Printing matrices and bit arrays\n//------------------------------------------------------------------------\ntemplate<typename T>\nvoid print_mat(T in[], unsigned S, unsigned R, unsigned C) {\n  R = (R >= S) ? S : R;\n  C = (C >= S) ? S : C;\n  for (unsigned r = 0; r < R; ++r) {\n    for (unsigned c = 0; c < C; ++c)\n      std::cout << std::setw(4) << in[r*S+c] << \" \";\n    printf (\"\\n\");\n  }\n}\n\ntemplate<typename T>\nvoid print_mat3d(T in[], unsigned M, unsigned num, unsigned S, unsigned R, unsigned C) {\n  for (unsigned m = M; m < M+num; ++m) {\n    print_mat(in+m*S*S, S, R, C);\n    printf (\"--%u--\\n\", m+1);\n  }\n}\n\ntemplate<typename T>\nvoid print_bits(T in[], unsigned bit_offset, unsigned S, unsigned R, unsigned C) {\n  R = (R >= S) ? S : R;\n  C = (C >= S) ? S : C;\n  for (unsigned r = 0; r < R; ++r) {\n    for (unsigned c = 0; c < C; ++c)\n      std::cout << std::setw(2) << get_bit(in, bit_offset+r*S+c) << \" \";\n    printf (\"\\n\");\n  }\n}\n\ntemplate<typename T>\nvoid print_bits3d(T in[], unsigned M, unsigned num, unsigned S, unsigned R, unsigned C) {\n  for (unsigned m = M; m < M+num; ++m) {\n    print_bits(in, m*S*S, S, R, C);\n    printf (\"--%u--\\n\", m+1);\n  }\n}\n\nvoid print_params3d(Word in[], unsigned M, unsigned num);\nvoid print_wt_word(const Word& in);\nvoid print_wt(const WtType& in);\n\n#endif\n"
      },
      {
        "file_name": "xf_structs.hpp",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_STRUCTS_H_\n#define _XF_STRUCTS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#ifndef __SYNTHESIS__\n#include <iostream>\n#endif\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include \"xf_types.hpp\"\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <type_traits>\n\nnamespace xf {\nnamespace cv {\n\ntemplate <int T>\nap_uint<T> xf_satcast(int in_val) {\n    if (in_val > ((1 << T) - 1)) {\n        return ((1 << T) - 1);\n    } else if (in_val < 0) {\n        return 0;\n    } else {\n        return in_val;\n    }\n}\n\ntemplate <typename T>\nT float2ap_uint(float val) {\n    T* val_out = (T*)(&val);\n    return *val_out;\n}\n\ntemplate <typename T>\nfloat ap_uint2float(T val) {\n    float* val_out = (float*)(&val);\n    return *val_out;\n}\n\n//----------------------------------------------------------------------------------------------------//\n//  LOCAL STEREO BLOCK MATCHING UTILITY\n//----------------------------------------------------------------------------------------------------//\ntemplate <int WSIZE, int NDISP, int NDISP_UNIT>\nclass xFSBMState {\n   public:\n    // pre-filtering (normalization of input images)\n    int preFilterType; // =HLS_STEREO_BM_XSOBEL_TEST\n    int preFilterSize; // averaging window size: ~5x5..21x21\n    int preFilterCap;  // the output of pre-filtering is clipped by\n                       // [-preFilterCap,preFilterCap]\n\n    // correspondence using Sum of Absolute Difference (SAD)\n    int SADWindowSize;       // ~5x5..21x21 // defined in macro\n    int minDisparity;        // minimum disparity (can be negative)\n    int numberOfDisparities; // maximum disparity - minimum disparity (> 0)\n\n    // post-filtering\n    int textureThreshold; // the disparity is only computed for pixels\n\n    // with textured enough neighborhood\n    int uniquenessRatio; // accept the computed disparity d* only if\n    // SAD(d) >= SAD(d*)*(1 + uniquenessRatio/100.)\n    // for any d != d*+/-1 within the search range.\n\n    // int speckleWindowSize; // disparity variation window\n    // int speckleRange;      // acceptable range of variation in window\n\n    int ndisp_unit;\n    int sweepFactor;\n    int remainder;\n\n    xFSBMState() {\n        preFilterType = XF_STEREO_PREFILTER_SOBEL_TYPE; // Default Sobel filter\n        preFilterSize = WSIZE;\n        preFilterCap = 31;\n        SADWindowSize = WSIZE;\n        minDisparity = 0;\n        numberOfDisparities = NDISP;\n        textureThreshold = 10;\n        uniquenessRatio = 15;\n        sweepFactor = (NDISP / NDISP_UNIT) + ((NDISP % NDISP_UNIT) != 0);\n        ndisp_unit = NDISP_UNIT;\n        remainder = NDISP_UNIT * sweepFactor - NDISP;\n    }\n};\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Point_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Point_ {\n   public:\n    Point_();\n    Point_(T _x, T _y);\n    Point_(const Point_& pt);\n    ~Point_();\n\n    T x, y;\n};\n\n/* Member functions of Point_ class */\ntemplate <typename T>\ninline Point_<T>::Point_() {}\ntemplate <typename T>\ninline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}\ntemplate <typename T>\ninline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}\ntemplate <typename T>\ninline Point_<T>::~Point_() {}\n\ntypedef Point_<int> Point;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Size_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Size_ {\n   public:\n    Size_();\n    Size_(T _width, T _height);\n    Size_(const Size_<T>& sz);\n    Size_(const Point_<T>& pt);\n    T area();\n    ~Size_();\n\n    T width, height;\n};\n\n/* Member functions of Size_ class */\ntemplate <typename T>\ninline Size_<T>::Size_() {}\ntemplate <typename T>\ninline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}\ntemplate <typename T>\ninline T Size_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T>::~Size_() {}\n\ntypedef Size_<int> Size;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Rect_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Rect_ {\n   public:\n    Rect_();\n    Rect_(T _x, T _y, T _width, T _height);\n    Rect_(const Rect_& rect);\n    Rect_(const Point_<T>& pt, const Size_<T>& sz);\n    T area();\n    Size_<T> size();\n    Point_<T> tl(); // top-left point(inside);\n    Point_<T> tr(); // top-right point(outside);\n    Point_<T> bl(); // bottom-left point(outside);\n    Point_<T> br(); // bottom-right point(outside);\n    bool bContains(const Point_<T>& pt);\n    ~Rect_();\n\n    T x, y, width, height;\n};\n\n/* Member functions of Rect_ class */\ntemplate <typename T>\ninline Rect_<T>::Rect_() {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz)\n    : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline T Rect_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T> Rect_<T>::size() {\n    return Size_<T>(width, height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tl() {\n    return Point_<T>(x, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tr() {\n    return Point_<T>(x + width, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::bl() {\n    return Point_<T>(x, y + height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::br() {\n    return Point_<T>(x + width, y + height);\n}\ntemplate <typename T>\ninline bool Rect_<T>::bContains(const Point_<T>& pt) {\n    return (pt.x >= x && pt.x < x + width && pt.y >= y && pt.y < y + height);\n}\ntemplate <typename T>\ninline Rect_<T>::~Rect_() {}\n\ntypedef Rect_<int> Rect;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Scalar\n//----------------------------------------------------------------------------------------------------//\ntemplate <int N, typename T>\nclass Scalar {\n   public:\n    Scalar() {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N > 0);\n    }\n    Scalar(T v0) {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N >= 1 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n    }\n    Scalar(T v0, T v1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 2 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n    }\n    Scalar(T v0, T v1, T v2) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 3 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n    }\n    Scalar(T v0, T v1, T v2, T v3) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 4 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n        val[3] = v3;\n    }\n\n    void operator=(T value);\n    Scalar<N, T> operator+(T value);\n    Scalar<N, T> operator+(Scalar<N, T> s);\n    Scalar<N, T> operator-(T value);\n    Scalar<N, T> operator-(Scalar<N, T> s);\n    Scalar<N, T> operator*(T value);\n    Scalar<N, T> operator*(Scalar<N, T> s);\n    Scalar<N, T> operator/(T value);\n    Scalar<N, T> operator/(Scalar<N, T> s);\n\n    T val[N];\n};\n\ntemplate <int N, typename T>\nvoid Scalar<N, T>::operator=(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[k] = value;\n    }\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / s.val[k];\n    }\n    return res;\n}\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Mat\n//----------------------------------------------------------------------------------------------------//\n#if defined(__SYNTHESIS__) && !defined(__SDA_MEM_MAP__)\nstatic constexpr int _XFCVDEPTH_DEFAULT = 2;\n#else\nstatic constexpr int _XFCVDEPTH_DEFAULT = -1;\n#endif\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass Mat {\n   public:\n    unsigned char allocatedFlag; // flag to mark memory allocation in this class\n    int rows, cols, size;        // actual image size\n    //\tint cols_align_npc;\t\t\t\t\t\t// cols\n    // multiple\n    // of\n    // NPC\n\n    typedef XF_TNAME(T, NPC) DATATYPE;\n    using _DATATTYPE = typename std::conditional<\n        (XFCVDEPTH < 0),\n        DATATYPE*,                 // Case of Memory Mapped pointer\n        typename std::conditional< // Case of Stream\n            (XFCVDEPTH == 0),\n            hls::stream<DATATYPE>,           // Case of default Dtream depth or user can override outside\n            hls::stream<DATATYPE, XFCVDEPTH> // Case of Stream depth specified\n            >::type>::type;\n    _DATATTYPE data;\n\n    Mat(); // default constructor\n    Mat(Size _sz);\n    Mat(int _rows, int _cols);\n    Mat(int _size, int _rows, int _cols);\n    Mat(int _rows, int _cols, void* _data);\n    Mat(const Mat&); // copy constructor\n\n    ~Mat();\n\n    Mat& operator=(const Mat&); // Assignment operator\n    //  XF_TNAME(T, XF_NPPC1) operator() (unsigned int r, unsigned int c);\n    //  XF_CTUNAME(T, NPC) operator() (unsigned int r, unsigned int c, unsigned\n    //  int ch);\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void alloc_data() {\n#ifndef __SYNTHESIS__\n        data = (DATATYPE*)malloc(size * sizeof(DATATYPE));\n\n        if (data == NULL) {\n            fprintf(stderr, \"\\nFailed to allocate memory\\n\");\n        } else {\n            allocatedFlag = 1;\n        }\n#endif\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void alloc_data() {\n        // This is a stream\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void free_data() {\n        if (data != NULL) {\n#ifndef __SYNTHESIS__\n            free(data);\n#endif\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void free_data() {}\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        for (int i = 0; i < (rows * ((cols + NPC - 1) >> XF_BITSHIFT(NPC))); ++i) {\n#pragma HLS loop_tripcount min=1 max=1024\n            data[i] = src.data[i];\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        data = (DATATYPE*)_data;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data[index];\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data.read();\n    }\n    float read_float(int index);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data[index] = val;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data.write(val);\n    }\n    void write_float(int index, float val);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols);\n        copyTo(_data);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols, false);\n        assignDataPtr(_data);\n    }\n\n    void init(int _rows, int _cols, bool allocate = true);\n    void copyTo(void* fromData);\n    unsigned char* copyFrom();\n\n    const int type() const;\n    const int depth() const;\n    const int channels() const;\n\n    template <int DST_T>\n    void convertTo(Mat<DST_T, ROWS, COLS, NPC, XFCVDEPTH>& dst, int otype, double alpha = 1, double beta = 0);\n};\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::type() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return (T);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::depth() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_DTPIXELDEPTH(T, NPC);\n}\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::channels() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_CHANNELS(T, NPC);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::init(int _rows, int _cols, bool allocate) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    assert((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) &&\n           \"The number of rows and columns must be less than the template \"\n           \"arguments.\");\n\n    rows = _rows;\n    cols = _cols;\n    allocatedFlag = 0;\n    size = _rows * ((_cols + NPPC - 1) >> XF_BITSHIFT(NPPC));\n\n    if (allocate) {\n        alloc_data();\n    }\n}\n\n/*Copy constructor definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::Mat(const Mat& src) {\n    init(src.rows, src.cols);\n\n#ifndef __SYNTHESIS__\n    copyData(src);\n#endif\n}\n\n/*Assignment operator definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::operator=(const Mat& src) {\n    if (this == &src) {\n        return *this; // For self-assignment cases\n    }\n\n    // Cleaning up old data memory if any\n    free_data();\n    allocatedFlag = 0;\n\n    init(src.rows, src.cols);\n    copyData(src);\n\n    return *this;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(ROWS, COLS);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols, void* _data) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols, _data);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(Size _sz) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_sz.height, _sz.width);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline float Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::read_float(int index) {\n    union int2float {\n        unsigned I;\n        float F;\n    };\n    int2float val;\n    val.I = read(index).to_uint();\n    return val.F;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::write_float(int index, float float_val) {\n    float val = float_val;\n    ap_uint<32>* val_out = (ap_uint<32>*)(&val);\n    write(index, *val_out);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyTo(void* _input) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    XF_PTSNAME(T, NPPC)* input = (XF_PTSNAME(T, NPPC)*)_input;\n    XF_CTUNAME(T, NPPC) in_val;\n\n    int packcols = cols >> XF_BITSHIFT(NPPC);       // Total columns after considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < packcols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            for (int p = 0; p < nppc; p++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                DATATYPE out_val;\n                for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    if (T == XF_32FC1) {\n                        in_val = float2ap_uint<ap_uint<32> >(\n                            input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch]);\n                    } else {\n                        in_val = input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch];\n                    }\n\n                    out_val.range((p * pixdepth) + (ch + 1) * bitdepth - 1, (p * pixdepth) + ch * bitdepth) = in_val;\n                }\n                write((r * packcols + c), out_val);\n            }\n        }\n    }\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline unsigned char* Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyFrom() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    //\tint packcols  = cols >> XF_BITSHIFT(NPPC); //Total columns after\n    // considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    int cv_nbytes = bitdepth / 8;\n\n    unsigned char* value =\n        (unsigned char*)malloc(rows * cols * (XF_CHANNELS(T, NPPC)) * (sizeof(unsigned char)) * cv_nbytes);\n\n    int xf_npc_idx = 0;\n    int diff_ptr = 0;\n    int xf_ptr = 0;\n    int cv_ptr = 0;\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < cols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            DATATYPE in_val = read(xf_ptr);\n            for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                for (int b = 0; b < cv_nbytes; ++b) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    value[cv_ptr++] = in_val.range((xf_npc_idx * pixdepth) + (ch * bitdepth) + (b + 1) * 8 - 1,\n                                                   (xf_npc_idx * pixdepth) + (ch * bitdepth) + b * 8);\n                }\n            }\n            if (xf_npc_idx == nppc - 1) {\n                xf_npc_idx = 0;\n                xf_ptr++;\n            } else {\n                xf_npc_idx++;\n            }\n        }\n    }\n\n    return (unsigned char*)value;\n}\n\n/* Member functions of Mat class */\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ntemplate <int DST_T>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::convertTo(Mat<DST_T, ROWS, COLS, NPPC, XFCVDEPTH>& dst,\n                                                           int otype,\n                                                           double alpha,\n                                                           double beta) {\n    assert((XF_CHANNELS(T, NPPC) == 1) && \"Multi-channel images not supported\");\n\n    XF_TNAME(T, NPPC) tmp_in_pix;\n    XF_TNAME(DST_T, NPPC) tmp_out_pix;\n\n    XF_CTUNAME(T, NPPC) in_pix;\n    XF_CTUNAME(DST_T, NPPC) out_pix;\n\n    int min, max;\n\n    if (DST_T == XF_8UC1) {\n        min = 0;\n        max = 255;\n    } else if (DST_T == XF_16UC1) {\n        min = 0;\n        max = 65535;\n    } else if (DST_T == XF_16SC1) {\n        min = -32768;\n        max = 32767;\n    } else if (DST_T == XF_32SC1) {\n        min = -2147483648;\n        max = 2147483647;\n    } else {\n        assert(1 &&\n               \"Output image type not supoorted. XF_8UC1, XF_16UC1, XF_16SC1 \"\n               \"and XF_32SC1 are valid\");\n    }\n\n#define __SATCAST(X) (X >= max ? max : (X < 0 ? 0 : lround(X)))\n\n    for (int i = 0; i < rows; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int j = 0; j<cols>> (XF_BITSHIFT(NPPC)); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            int IN_STEP = XF_PIXELDEPTH(XF_DEPTH(T, NPPC));\n            int OUT_STEP = XF_PIXELDEPTH(XF_DEPTH(DST_T, NPPC));\n            int in_shift = 0;\n            int out_shift = 0;\n            DATATYPE in_val = read((i * cols >> (XF_BITSHIFT(NPPC))) + j);\n            DATATYPE out_val;\n\n            for (int k = 0; k < (1 << (XF_BITSHIFT(NPPC))); k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                in_pix = in_val.range(in_shift + IN_STEP - 1, in_shift);\n\n                if (otype == XF_CONVERT_16U_TO_8U || otype == XF_CONVERT_16S_TO_8U || otype == XF_CONVERT_32S_TO_8U ||\n                    otype == XF_CONVERT_32S_TO_16U || otype == XF_CONVERT_32S_TO_16S) {\n                    float tmp = (float)(in_pix * alpha + beta);\n                    in_pix = __SATCAST(tmp);\n\n                    if (in_pix < min) in_pix = min;\n                    if (in_pix > max) in_pix = max;\n\n                    tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = in_pix;\n                } else {\n                    if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) > max) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = max;\n\n                    } else if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) < min) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = min;\n\n                    } else {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = __SATCAST(in_pix * alpha + beta);\n                    }\n                }\n\n                out_pix = tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift);\n\n                out_val.range(out_shift + OUT_STEP - 1, out_shift) = out_pix;\n\n                in_shift = in_shift + IN_STEP;\n                out_shift = out_shift + OUT_STEP;\n            }\n            dst.write(((i * cols >> (XF_BITSHIFT(NPPC))) + j), out_val);\n        }\n    }\n}\n\ntemplate <int SRC_T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nMat<SRC_T, ROWS, COLS, NPC, XFCVDEPTH>::~Mat() {\n#ifndef __SYNTHESIS__\n    if (allocatedFlag == 1) {\n        free_data();\n    }\n#endif\n}\n//----------------------------------------------------------------------------------------------------//\n\n// Template metaprogramming implementation of floor log2 [[\ntemplate <int N>\nstruct log2 {\n   public:\n    static constexpr int fvalue = 1 + (log2<N / 2>::fvalue);                   // floor value\n    static constexpr int cvalue = (N > (1 << fvalue)) ? (fvalue + 1) : fvalue; // ceiling value\n};\n\ntemplate <>\nstruct log2<1> {\n   public:\n    static constexpr int fvalue = 0;\n    static constexpr int cvalue = 0;\n};\n\nstruct bgr2y8_params {\n    int black_Vmax = 20;\n    int black_Smax = 70;\n    int brown_Hmax = 15;\n    int brown_Vmax = 40;\n    int Smin = 60;\n    int Smax = 90;\n    int darkgreen_Vmax = 35;\n    int darkgreen_Hmin = 30;\n    int darkgreen_Hmax = 45;\n    int green_Hmax = 90;\n    int green_Hmin = 50;\n    int green_Vmax = 45;\n};\n//]]\n\n/*\n * The purpose of this class is to provide an interator over ap_uint<PTR_WIDTH>\n * object array such\n * that at each iter step one can get data bits corresponding to data to be\n * processed per cycle.\n *\n */\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIter : public Mat<T, ROWS, COLS, NPC, XFCVDEPTH> {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    static constexpr int XF_BITS_PER_CLOCK = XF_PIXELWIDTH(T, NPC) * XF_NPIXPERCYCLE(NPC);\n    static constexpr int COLS_BOUND_PER_NPC = ((COLS + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC));\n    static constexpr int LOOPBOUND = ROWS * COLS_BOUND_PER_NPC;\n    static constexpr int ADDRBOUND = ((ROWS * COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                     (log2<PTR_WIDTH>::cvalue);\n    static constexpr int LAST_BLK_PXL_WIDTH =\n        ((COLS >> XF_BITSHIFT(NPC)) == COLS_BOUND_PER_NPC)\n            ? XF_BITS_PER_CLOCK\n            : XF_PIXELWIDTH(T, NPC) * (COLS - ((COLS >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    static constexpr int COLS_ADDRBOUND = ((COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                          (log2<PTR_WIDTH>::cvalue);\n    static int cols_npc_aligned(int cols) { return ((cols + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC)); }\n\n    static int last_blk_pxl_width(int cols, int cols_bound_per_npc) {\n        return ((cols >> XF_BITSHIFT(NPC)) == cols_bound_per_npc)\n                   ? XF_BITS_PER_CLOCK\n                   : XF_PIXELWIDTH(T, NPC) * (cols - ((cols >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    }\n\n    static int loopbound(int rows, int cols) { return rows * cols_npc_aligned(cols); }\n\n    int loopbound() { return rows * cols_npc_aligned(cols); }\n\n    static int addrbound(int rows, int cols) {\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> cols_int16 = cols;\n\n        ap_uint<32> mul_rows_cols;\n\n// clang-format off\n#pragma HLS BIND_OP variable=mul_rows_cols op=mul impl=dsp latency=2\n        // clang-format on\n\n        mul_rows_cols = rows_int16 * cols_int16;\n\n        return ((mul_rows_cols * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >> (log2<PTR_WIDTH>::cvalue);\n    }\n    MMIter() : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>() {}\n\n    MMIter(int _rows, int _cols) : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {}\n};\n\n#define _MMITER MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterIn : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n    using _MMITER::COLS_ADDRBOUND;\n\n   private:\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop1:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    static void Axi2AxiStream(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = din.read();\n            dout.write(v.data);\n        }\n    }\n\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows_burst,\n                              int rows,\n                              int cols,\n                              int stride = -1) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> cols_addrbound = _MMITER::addrbound(rows_burst, cols);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> stride_addrbound = _MMITER::addrbound(rows_burst, stride);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> addrbound = (stride == -1) ? cols_addrbound : stride_addrbound;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> c;\n    MMIterInLoop1:\n        for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n            // clang-format on\n            for (c = 0; c < cols_addrbound; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_ADDRBOUND\n#pragma HLS pipeline\n                // clang-format on\n                dout.write(din[c + r * addrbound]);\n            }\n        }\n    }\n    template <int DEPTH>\n    static void AxiStream2MatStream(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                                    hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        int stride_bound_per_npc, strideBased_last_blk_width;\n\n        // if (stride == -1) {\n        stride_bound_per_npc = cols_bound_per_npc;\n        strideBased_last_blk_width = last_blk_width;\n        //} else {\n        //  stride_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        //  strideBased_last_blk_width = _MMITER::last_blk_pxl_width(stride, stride_bound_per_npc);\n        //}\n        int rd_cnt = 0;\n\n        int rem = 0;\n        ap_uint<PTR_WIDTH> val = 0;\n        int i;\n        int j = 0;\n        int bound = rows * stride_bound_per_npc;\n    MMIterInLoopRow:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            bool bLast = (j == (stride_bound_per_npc - 1));\n            int xf_bits_per_clock = bLast ? strideBased_last_blk_width : XF_BITS_PER_CLOCK;\n            int ptr_width_minus = bLast ? (PTR_WIDTH - strideBased_last_blk_width) : (PTR_WIDTH - XF_BITS_PER_CLOCK);\n            int ptr_width_plus = bLast ? (PTR_WIDTH + strideBased_last_blk_width) : (PTR_WIDTH + XF_BITS_PER_CLOCK);\n\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer = 0;\n            if (rem < xf_bits_per_clock) {\n                if (rem != 0) {\n                    localbuffer.range(rem - 1, 0) = val.range(PTR_WIDTH - 1, (PTR_WIDTH - rem));\n                }\n                val = din.read();\n                rd_cnt++;\n                localbuffer.range((xf_bits_per_clock - 1), rem) = val.range(((xf_bits_per_clock - 1) - rem), 0);\n                rem = ptr_width_minus + rem;\n            } else {\n                localbuffer = val.range(((ptr_width_plus - 1) - rem), (PTR_WIDTH - rem));\n                rem = rem - xf_bits_per_clock;\n            }\n            bool bLast_width = (j == (cols_bound_per_npc - 1));\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer2 = 0;\n            if (bLast_width == 0)\n                localbuffer2 = localbuffer;\n            else\n                localbuffer2 = localbuffer.range(last_blk_width - 1, 0);\n\n            if (j < cols_bound_per_npc) dout.write(localbuffer2);\n\n            j = (bLast) ? 0 : (j + 1);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2Mat(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterInLoop2:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, ldata, rows, cols_bound_per_npc, last_blk_width, stride);\n        MatStream2Mat(ldata, dout, rows, cols_bound_per_npc);\n    }\n\n    static void Axi2Mat(ap_uint<PTR_WIDTH>* din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n    static void Axi2Mat(\n        ap_uint<PTR_WIDTH>* din, ap_uint<XF_BITS_PER_CLOCK>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        ap_uint<XF_BITS_PER_CLOCK>* dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n   public:\n    MMIterIn(ap_uint<PTR_WIDTH>* d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(ap_uint<PTR_WIDTH>* d, int _rows, int _cols) : _MMITER(_rows, _cols) { Axi2Mat(d, data, rows, cols); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        Axi2Mat(d, data, rows, cols);\n    }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d) : _MMITER() { AxiStream2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        AxiStream2Mat(d, data, rows, cols);\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& din, int index) {\n        return din.read();\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(ap_uint<XF_BITS_PER_CLOCK>* din, int index) { return din[index]; }\n\n    ap_uint<XF_BITS_PER_CLOCK> read(int index) { return read(data, index); }\n\n    static void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                            xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                            int stride = -1) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols, stride);\n    }\n\n    static void Array2xfMat(\n        ap_uint<PTR_WIDTH>* srcPtr, ap_uint<XF_BITS_PER_CLOCK>* dstPtr, int rows, int cols, int stride = -1) {\n        Axi2Mat(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                              xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int FILLZERO = 1, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterOut : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n\n   private:\n    template <int DEPTH>\n    static void Mat2MatStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterOutLoop1:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                                    hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        ap_uint<16> strideBased_cols_bound_per_npc;\n        if (stride == -1 || FILLZERO == 0) {\n            strideBased_cols_bound_per_npc = cols_bound_per_npc;\n        } else {\n            strideBased_cols_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        }\n\n        ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled = 0; // valid bits remaining in current buffer\n        ap_uint<PTR_WIDTH> localbuffer = 0;\n        ap_uint<16> i;\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> j;\n\n    MMIterOutRow:\n        for (i = 0; i < rows_int16; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n        // clang-format on\n        MMIterOutCol:\n            for (j = 0; j < strideBased_cols_bound_per_npc; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_BOUND_PER_NPC\n#pragma HLS pipeline\n                // clang-format on\n\n                bool bLast = (j == (cols_bound_per_npc - 1));\n                int xf_bits_per_clock = bLast ? last_blk_width : XF_BITS_PER_CLOCK;\n                ap_uint<PTR_WIDTH> val;\n                if (j < cols_bound_per_npc || FILLZERO == 0)\n                    val = din.read();\n                else\n                    val = 0;\n\n                ap_uint<PTR_WIDTH> tempval = (val << filled);\n                localbuffer = (localbuffer | tempval);\n                ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled_next;\n\n                if (filled < (PTR_WIDTH - xf_bits_per_clock)) {\n                    filled_next = filled + xf_bits_per_clock;\n                } else if (j == cols_bound_per_npc - 1 && FILLZERO == 0) {\n                    dout.write(localbuffer);\n                    localbuffer = 0;\n                    filled_next = 0;\n                } else {\n                    dout.write(localbuffer);\n                    localbuffer = (val >> (PTR_WIDTH - filled));\n                    filled_next = filled + (xf_bits_per_clock - PTR_WIDTH);\n                }\n\n                filled = filled_next;\n            }\n        }\n\n        if (filled != 0) {\n            dout.write(localbuffer);\n        }\n    }\n\n    static void Mat2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        MatStream2AxiStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void Mat2AxiStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        Mat2MatStream(din, ldata, rows, cols_bound_per_npc);\n        MatStream2AxiStream(ldata, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<PTR_WIDTH>* dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop2:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = din.read();\n            dout.write(v);\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        ap_uint<PTR_WIDTH>* dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(\n        ap_uint<XF_BITS_PER_CLOCK>* din, ap_uint<PTR_WIDTH>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(ap_uint<XF_BITS_PER_CLOCK>* din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n   public:\n    MMIterOut() : _MMITER() {}\n\n    MMIterOut(int _rows, int _cols) : _MMITER(_rows, _cols) {}\n\n    inline static void write(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& dout,\n                             ap_uint<XF_BITS_PER_CLOCK>& val,\n                             int index) {\n        dout.write(val);\n    }\n\n    inline static void write(ap_uint<XF_BITS_PER_CLOCK>* dout, ap_uint<XF_BITS_PER_CLOCK>& val, int index) {\n        dout[index] = val;\n    }\n\n    void write(ap_uint<XF_BITS_PER_CLOCK>& val, int index) { write(data, val, index); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout) { Mat2Axi(data, dout); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout, int rows, int cols) { Mat2Axi(data, dout, rows, cols); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout) { Mat2Axi(data, dout); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout, int rows, int cols) {\n        Mat2Axi(data, dout, rows, cols);\n    }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout) { Mat2AxiStream(data, dout); }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout, int rows, int cols) { Mat2AxiStream(data, dout, rows, cols); }\n\n    static void xfMat2Array(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                            ap_uint<PTR_WIDTH>* dstPtr,\n                            int stride = -1) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols, stride);\n    }\n\n    static void xfMat2Array(\n        ap_uint<XF_BITS_PER_CLOCK>* srcPtr, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols, int stride = -1) {\n        Mat2Axi(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void xfMat2axiStrm(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dstPtr) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols);\n    }\n};\n\n} // namespace cv\n} // namespace xf\n\n#endif // _XF_STRUCTS_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "xf_common.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_COMMON_H_\n#define _XF_COMMON_H_\n\n#include \"xf_structs.hpp\"\n#include \"xf_params.hpp\"\n#include \"xf_types.hpp\"\n\nusing namespace xf::cv;\n#endif\n"
      },
      {
        "file_name": "xf_params.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_PARAMS_H_\n#define _XF_PARAMS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n\n#define __ABS(X) ((X) < 0 ? (-(X)) : (X))\n\n// Channels of an image\nenum _channel_extract {\n    XF_EXTRACT_CH_0, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_1, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_2, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_3, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_R, // Used to extract the RED channel\n    XF_EXTRACT_CH_G, // Used to extract the GREEN channel\n    XF_EXTRACT_CH_B, // Used to extract the BLUE channel\n    XF_EXTRACT_CH_A, // Used to extract the ALPHA channel\n    XF_EXTRACT_CH_Y, // Used to extract the LUMA channel\n    XF_EXTRACT_CH_U, // Used to extract the Cb/U channel\n    XF_EXTRACT_CH_V  // Used to extract the Cr/V/Value channel\n};\ntypedef _channel_extract XF_channel_extract_e;\n\n// Conversion Policy for fixed point arithmetic\nenum _convert_policy { XF_CONVERT_POLICY_SATURATE, XF_CONVERT_POLICY_TRUNCATE };\ntypedef _convert_policy XF_convert_policy_e;\n\n// Bit-depth conversion types\nenum _convert_bit_depth {\n    // Down-convert\n    XF_CONVERT_16U_TO_8U,\n    XF_CONVERT_16S_TO_8U,\n    XF_CONVERT_32S_TO_8U,\n    XF_CONVERT_32S_TO_16U,\n    XF_CONVERT_32S_TO_16S,\n    // Up-convert\n    XF_CONVERT_8U_TO_16U,\n    XF_CONVERT_8U_TO_16S,\n    XF_CONVERT_8U_TO_32S,\n    XF_CONVERT_16U_TO_32S,\n    XF_CONVERT_16S_TO_32S\n};\ntypedef _convert_bit_depth XF_convert_bit_depth_e;\n\n// Thresholding types\nenum _threshold_type {\n    XF_THRESHOLD_TYPE_BINARY = 0,\n    XF_THRESHOLD_TYPE_BINARY_INV = 1,\n    XF_THRESHOLD_TYPE_TRUNC = 2,\n    XF_THRESHOLD_TYPE_TOZERO = 3,\n    XF_THRESHOLD_TYPE_TOZERO_INV = 4,\n};\ntypedef _threshold_type XF_threshold_type_e;\n\n// Thresholding types\nenum _ccm_type {\n    XF_CCM_bt2020_bt709 = 0,\n    XF_CCM_bt709_bt2020 = 1,\n    XF_CCM_rgb_yuv_601 = 2,\n    XF_CCM_rgb_yuv_709 = 3,\n    XF_CCM_rgb_yuv_2020 = 4,\n    XF_CCM_yuv_rgb_601 = 5,\n    XF_CCM_yuv_rgb_709 = 6,\n    XF_CCM_yuv_rgb_2020 = 7,\n    XF_CCM_full_from_16_235 = 8,\n    XF_CCM_full_to_16_235 = 9,\n\n};\ntypedef _ccm_type XF_ccm_type_e;\n\n// Comparision types\nenum _comparison_op { XF_CMP_EQ = 0, XF_CMP_GT = 1, XF_CMP_GE = 2, XF_CMP_LT = 3, XF_CMP_LE = 4, XF_CMP_NE = 5 };\ntypedef _comparison_op _comparison_op_e;\n\n// Comparision types\nenum _reduction_op { REDUCE_SUM = 0, REDUCE_AVG = 1, REDUCE_MAX = 2, REDUCE_MIN = 3 };\ntypedef _reduction_op _reduction_op_e;\n\n// Pixel Per Cycle\nenum _pixel_per_cycle {\n    XF_NPPC1 = 1,\n    XF_NPPC2 = 2,\n    XF_NPPC4 = 4,\n    XF_NPPC8 = 8,\n    XF_NPPC16 = 16,\n    XF_NPPC32 = 32,\n    XF_NPPC64 = 64\n};\ntypedef _pixel_per_cycle XF_nppc_e;\n\n// Pixel types\nenum _pixel_type {\n    XF_8UP = 0,\n    XF_8SP = 1,\n    XF_14UP = 2,\n    XF_16UP = 3,\n    XF_16SP = 4,\n    XF_32UP = 5,\n    XF_32SP = 6,\n    XF_19SP = 7,\n    XF_32FP = 8,\n    XF_35SP = 9,\n    XF_24SP = 10,\n    XF_20SP = 11,\n    XF_48SP = 12,\n    XF_2UP = 13,\n    XF_9SP = 14,\n    XF_9UP = 15,\n    XF_24UP = 16,\n    XF_64UP = 17,\n    XF_10UP = 18,\n    XF_12UP = 19,\n    XF_40UP = 20,\n    XF_42UP = 20,\n    XF_48UP = 21,\n    XF_30UP = 22,\n    XF_36UP = 23,\n    XF_96FP = 24\n};\ntypedef _pixel_type XF_pixel_type_e;\n\n// Word width\nenum _word_width {\n    XF_2UW = 0,\n    XF_8UW = 1,\n    XF_9UW = 2,\n    XF_10UW = 3,\n    XF_12UW = 4,\n    XF_14UW = 5,\n    XF_16UW = 6,\n    XF_19SW = 7,\n    XF_20UW = 8,\n    XF_22UW = 9,\n    XF_24UW = 10,\n    XF_24SW = 11,\n    XF_28UW = 12,\n    XF_30UW = 13,\n    XF_32UW = 14,\n    XF_32FW = 15,\n    XF_35SW = 16,\n    XF_36UW = 17,\n    XF_40UW = 18,\n    XF_42UW = 19,\n    XF_48UW = 20,\n    XF_48SW = 21,\n    XF_56UW = 22,\n    XF_60UW = 23,\n    XF_64UW = 24,\n    XF_72UW = 25,\n    XF_80UW = 26,\n    XF_84UW = 27,\n    XF_96UW = 28,\n    XF_96SW = 29,\n    XF_112UW = 30,\n    XF_120UW = 31,\n    XF_128UW = 32,\n    XF_144UW = 33,\n    XF_152SW = 34,\n    XF_160UW = 35,\n    XF_160SW = 36,\n    XF_168UW = 37,\n    XF_176UW = 38,\n    XF_192UW = 39,\n    XF_192SW = 40,\n    XF_240UW = 41,\n    XF_256UW = 42,\n    XF_280SW = 43,\n    XF_288UW = 44,\n    XF_304SW = 45,\n    XF_320UW = 46,\n    XF_336UW = 47,\n    XF_352UW = 48,\n    XF_384UW = 49,\n    XF_384SW = 50,\n    XF_512UW = 51,\n    XF_560SW = 52,\n    XF_576UW = 53,\n    XF_96FW = 54,\n    XF_192FW = 55,\n    XF_384FW = 56,\n    XF_768FW = 57,\n    XF_1536FW = 58\n};\ntypedef _word_width XF_word_width_e;\n\n// Filter size\nenum _filter_size { XF_FILTER_3X3 = 3, XF_FILTER_5X5 = 5, XF_FILTER_7X7 = 7 };\ntypedef _filter_size XF_filter_size_e;\n\n// Radius size for Non Maximum Suppression\nenum _nms_radius { XF_NMS_RADIUS_1 = 1, XF_NMS_RADIUS_2 = 2, XF_NMS_RADIUS_3 = 3 };\ntypedef _nms_radius XF_nms_radius_e;\n\n// Image Pyramid Parameters\nenum _image_pyramid_params {\n    XF_PYRAMID_TYPE_GXFSSIAN = 0,\n    XF_PYRAMID_TYPE_LAPLACIAN = 1,\n    XF_PYRAMID_SCALE_HALF = 2,\n    XF_PYRAMID_SCALE_ORB = 3,\n    XF_PYRAMID_SCALE_DOUBLE = 4\n};\ntypedef _image_pyramid_params XF_image_pyramid_params_e;\n\n// Magnitude computation\nenum _normalisation_params { XF_L1NORM = 0, XF_L2NORM = 1 };\ntypedef _normalisation_params XF_normalisation_params_e;\n\nenum _border_type {\n    XF_BORDER_CONSTANT = 0,\n    XF_BORDER_REPLICATE = 1,\n    XF_BORDER_REFLECT = 2,\n    XF_BORDER_WRAP = 3,\n    XF_BORDER_REFLECT_101 = 4,\n    XF_BORDER_TRANSPARENT = 5,\n    XF_BORDER_REFLECT101 = XF_BORDER_REFLECT_101,\n    XF_BORDER_DEFAULT = XF_BORDER_REFLECT_101,\n    XF_BORDER_ISOLATED = 16,\n};\ntypedef _border_type XF_border_type_e;\n\nenum _structuring_element_shape {\n    XF_SHAPE_RECT = 0,\n    XF_SHAPE_ELLIPSE = 1,\n    XF_SHAPE_CROSS = 2,\n\n};\nenum _wb_type {\n    XF_WB_GRAY = 0,\n    XF_WB_SIMPLE = 1,\n};\n\nenum multistream {\n    SLICES_DEFAULT = 1,\n};\n// Phase computation\nenum _phase_params { XF_RADIANS = 0, XF_DEGREES = 1 };\ntypedef _phase_params XF_phase_params_e;\n\n// Types of Interpolaton techniques used in resize, affine and perspective\nenum _interpolation_types { XF_INTERPOLATION_NN = 0, XF_INTERPOLATION_BILINEAR = 1, XF_INTERPOLATION_AREA = 2 };\ntypedef _interpolation_types _interpolation_types_e;\n\n// loop dependent variables used in image pyramid\nenum _loop_dependent_vars { XF_GXFSSIANLOOP = 8, XF_BUFSIZE = 12 };\ntypedef _loop_dependent_vars loop_dependent_vars_e;\n\n// loop dependent variables used in image pyramid\nenum _image_size { XF_SDIMAGE = 0, XF_HDIMAGE = 1 };\ntypedef _image_size image_size_e;\n\n// enumerations for HOG feature descriptor\nenum _input_image_type { XF_GRAY = 1, XF_RGB = 3 };\ntypedef _input_image_type input_image_type_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_output_type { XF_HOG_RB = 0, XF_HOG_NRB = 1 };\ntypedef _HOG_output_type HOG_output_type_e;\n\nenum use_model { XF_STANDALONE = 0, XF_PIPELINE = 1 };\ntypedef use_model use_model_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_type { XF_DHOG = 0, XF_SHOG = 1 };\ntypedef _HOG_type HOG_type_e;\n\n// enumerations for Stereo BM\nenum XF_stereo_prefilter_type { XF_STEREO_PREFILTER_SOBEL_TYPE, XF_STEREO_PREFILTER_NORM_TYPE };\n/****************************new************************/\n// enumerations for Demosaicing\nenum XF_demosaicing {\n    XF_BAYER_BG,\n    XF_BAYER_GB,\n    XF_BAYER_GR,\n    XF_BAYER_RG,\n};\n// typedef XF_stereo_prefilter_type XF_stereo_pre_filter_type_e;\n// enum _pixel_percycle\n//{\n//\tXF_NPPC1  = 0,\n//\tXF_NPPC8  = 3,\n//\tXF_NPPC16 = 4\n//};\n// typedef _pixel_percycle XF_nppc_e;\n\n// enumerations for Architecture\nenum _ARCH_type {\n    XF_STREAM = 0,\n    XF_MEMORYMAPPED = 1\n\n};\ntypedef _ARCH_type _ARCH_type_e;\n\nenum _pixeltype {\n    XF_8UC1 = 0,\n    XF_14UC1 = 1,\n    XF_16UC1 = 2,\n    XF_16SC1 = 3,\n    XF_24UC1 = 4,\n    XF_24SC1 = 5,\n    XF_32UC1 = 6,\n    XF_32FC1 = 7,\n    XF_32SC1 = 8,\n    XF_8UC2 = 9,\n    XF_8UC4 = 10,\n    XF_2UC1 = 11,\n    XF_8UC3 = 16,\n    XF_16UC3 = 13,\n    XF_16SC3 = 14,\n    XF_16UC4 = 15,\n    XF_10UC1 = 12,\n    XF_10UC4 = 17,\n    XF_12UC1 = 18,\n    XF_12UC4 = 19,\n    XF_10UC3 = 20,\n    XF_12UC3 = 21,\n    XF_14UC3 = 22,\n    XF_32FC3 = 23,\n    XF_64UC1 = 24\n};\ntypedef _pixeltype XF_npt_e;\n\nenum _ramtype {\n    RAM_1P_BRAM = 0,\n    RAM_1P_LUTRAM = 1,\n    RAM_1P_URAM = 2,\n    RAM_2P_BRAM = 3,\n    RAM_2P_LUTRAM = 4,\n    RAM_2P_URAM = 5,\n    RAM_S2P_BRAM = 6,\n    RAM_S2P_LUTRAM = 7,\n    RAM_S2P_URAM = 8,\n    RAM_T2P_BRAM = 9,\n    RAM_T2P_URAM = 10\n};\ntypedef _ramtype XF_ramtype_e;\n\n#endif //_XF_PARAMS_H_\n"
      }
    ],
    "code_length": 29660,
    "token_count": 9181,
    "pragma_number": 310,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adc_24bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adc_24bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "adc_24bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adc_24bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid adc_24bit(uint32_t input[ARRAY_SIZE], uint32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t sample = input[i];\n        uint32_t processed_sample = (sample & 0xFFFFFF); // Mask to 24 bits\n        output[i] = processed_sample;\n    }\n}\n\n// Top function name: adc_24bit\n"
      }
    ],
    "code_length": 354,
    "token_count": 102,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adc_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adc_8bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "adc_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adc_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid adc_8bit(uint8_t input[SIZE], uint8_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        uint8_t sample = input[i];\n        output[i] = sample;\n    }\n}\n\n// Top function name: adc_8bit\n"
      }
    ],
    "code_length": 239,
    "token_count": 76,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/aes/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 585,
    "Worst-caseLatency": 585.0,
    "BRAM_18K": 0,
    "LUT": 394696,
    "DSP": 0,
    "FF": 45309,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "aes256_encrypt_ecb",
    "ResourceMetric": 0.0800331561,
    "design_id": "project",
    "algo_name": "aes",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "aes.c",
        "file_content": "/*\n*   Byte-oriented AES-256 implementation.\n*   All lookup tables replaced with 'on the fly' calculations.\n*/\n#include \"aes.h\"\n\n#define F(x)   (((x)<<1) ^ ((((x)>>7) & 1) * 0x1b))\n#define FD(x)  (((x) >> 1) ^ (((x) & 1) ? 0x8d : 0))\n\n#define BACK_TO_TABLES\n#ifdef BACK_TO_TABLES\n\nconst uint8_t sbox[256] = {\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\n#define rj_sbox(x)     sbox[(x)]\n\n#else /* tableless subroutines */\n\n/* -------------------------------------------------------------------------- */\nuint8_t gf_alog(uint8_t x) // calculate anti-logarithm gen 3\n{\n    uint8_t atb = 1, z;\n\n    alog : while (x--) {z = atb; atb <<= 1; if (z & 0x80) atb^= 0x1b; atb ^= z;}\n\n    return atb;\n} /* gf_alog */\n\n/* -------------------------------------------------------------------------- */\nuint8_t gf_log(uint8_t x) // calculate logarithm gen 3\n{\n    uint8_t atb = 1, i = 0, z;\n\n    glog : do {\n        if (atb == x) break;\n        z = atb; atb <<= 1; if (z & 0x80) atb^= 0x1b; atb ^= z;\n    } while (++i > 0);\n\n    return i;\n} /* gf_log */\n\n\n/* -------------------------------------------------------------------------- */\nuint8_t gf_mulinv(uint8_t x) // calculate multiplicative inverse\n{\n    return (x) ? gf_alog(255 - gf_log(x)) : 0;\n} /* gf_mulinv */\n\n/* -------------------------------------------------------------------------- */\nuint8_t rj_sbox(uint8_t x)\n{\n    uint8_t y, sb;\n\n    sb = y = gf_mulinv(x);\n    y = (y<<1)|(y>>7); sb ^= y;  y = (y<<1)|(y>>7); sb ^= y;\n    y = (y<<1)|(y>>7); sb ^= y;  y = (y<<1)|(y>>7); sb ^= y;\n\n    return (sb ^ 0x63);\n} /* rj_sbox */\n#endif\n\n/* -------------------------------------------------------------------------- */\nuint8_t rj_xtime(uint8_t x)\n{\n    return (x & 0x80) ? ((x << 1) ^ 0x1b) : (x << 1);\n} /* rj_xtime */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_subBytes(uint8_t *buf)\n{\n    register uint8_t i = 16;\n\n    sub : while (i--) buf[i] = rj_sbox(buf[i]);\n} /* aes_subBytes */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_addRoundKey(uint8_t *buf, uint8_t *key)\n{\n    register uint8_t i = 16;\n\n    addkey : while (i--) buf[i] ^= key[i];\n} /* aes_addRoundKey */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_addRoundKey_cpy(uint8_t *buf, uint8_t *key, uint8_t *cpk)\n{\n    register uint8_t i = 16;\n\n    cpkey : while (i--)  buf[i] ^= (cpk[i] = key[i]), cpk[16+i] = key[16 + i];\n} /* aes_addRoundKey_cpy */\n\n\n/* -------------------------------------------------------------------------- */\nvoid aes_shiftRows(uint8_t *buf)\n{\n    register uint8_t i, j; /* to make it potentially parallelable :) */\n\n    i = buf[1]; buf[1] = buf[5]; buf[5] = buf[9]; buf[9] = buf[13]; buf[13] = i;\n    i = buf[10]; buf[10] = buf[2]; buf[2] = i;\n    j = buf[3]; buf[3] = buf[15]; buf[15] = buf[11]; buf[11] = buf[7]; buf[7] = j;\n    j = buf[14]; buf[14] = buf[6]; buf[6]  = j;\n\n} /* aes_shiftRows */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_mixColumns(uint8_t *buf)\n{\n    register uint8_t i, a, b, c, d, e;\n\n    mix : for (i = 0; i < 16; i += 4)\n    {\n        a = buf[i]; b = buf[i + 1]; c = buf[i + 2]; d = buf[i + 3];\n        e = a ^ b ^ c ^ d;\n        buf[i] ^= e ^ rj_xtime(a^b);   buf[i+1] ^= e ^ rj_xtime(b^c);\n        buf[i+2] ^= e ^ rj_xtime(c^d); buf[i+3] ^= e ^ rj_xtime(d^a);\n    }\n} /* aes_mixColumns */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_expandEncKey(uint8_t *k, uint8_t *rc)\n{\n    register uint8_t i;\n\n    k[0] ^= rj_sbox(k[29]) ^ (*rc);\n    k[1] ^= rj_sbox(k[30]);\n    k[2] ^= rj_sbox(k[31]);\n    k[3] ^= rj_sbox(k[28]);\n    *rc = F( *rc);\n\n    exp1 : for(i = 4; i < 16; i += 4)  k[i] ^= k[i-4],   k[i+1] ^= k[i-3],\n        k[i+2] ^= k[i-2], k[i+3] ^= k[i-1];\n    k[16] ^= rj_sbox(k[12]);\n    k[17] ^= rj_sbox(k[13]);\n    k[18] ^= rj_sbox(k[14]);\n    k[19] ^= rj_sbox(k[15]);\n\n    exp2 : for(i = 20; i < 32; i += 4) k[i] ^= k[i-4],   k[i+1] ^= k[i-3],\n        k[i+2] ^= k[i-2], k[i+3] ^= k[i-1];\n\n} /* aes_expandEncKey */\n\n/* -------------------------------------------------------------------------- */\nvoid aes256_encrypt_ecb(aes256_context *ctx, uint8_t k[32], uint8_t buf[16])\n{\n    //INIT\n    uint8_t rcon = 1;\n    uint8_t i;\n\n    ecb1 : for (i = 0; i < sizeof(ctx->key); i++){\n        ctx->enckey[i] = ctx->deckey[i] = k[i];\n    }\n    ecb2 : for (i = 8;--i;){\n        aes_expandEncKey(ctx->deckey, &rcon);\n    }\n\n    //DEC\n    aes_addRoundKey_cpy(buf, ctx->enckey, ctx->key);\n    ecb3 : for(i = 1, rcon = 1; i < 14; ++i)\n    {\n        aes_subBytes(buf);\n        aes_shiftRows(buf);\n        aes_mixColumns(buf);\n        if( i & 1 ) aes_addRoundKey( buf, &ctx->key[16]);\n        else aes_expandEncKey(ctx->key, &rcon), aes_addRoundKey(buf, ctx->key);\n    }\n    aes_subBytes(buf);\n    aes_shiftRows(buf);\n    aes_expandEncKey(ctx->key, &rcon);\n    aes_addRoundKey(buf, ctx->key);\n} /* aes256_encrypt */\n\n"
      },
      {
        "file_name": "aes.h",
        "file_content": "/*\n*   Byte-oriented AES-256 implementation.\n*   All lookup tables replaced with 'on the fly' calculations.\n*/\n#include \"support.h\"\n\ntypedef struct {\n  uint8_t key[32];\n  uint8_t enckey[32];\n  uint8_t deckey[32];\n} aes256_context;\n\nvoid aes256_encrypt_ecb(aes256_context *ctx, uint8_t k[32], uint8_t buf[16]);\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  aes256_context ctx;\n  uint8_t k[32];\n  uint8_t buf[16];\n};\n\n"
      }
    ],
    "code_length": 6621,
    "token_count": 2990,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/aggregation_of_struct/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 12,
    "Worst-caseLatency": 12.0,
    "BRAM_18K": 0,
    "LUT": 240,
    "DSP": 0,
    "FF": 39,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 4.9763e-05,
    "design_id": "project",
    "algo_name": "aggregation_of_struct",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_int.h\"\n#include <iostream>\n\n#define N 10\n\nstruct A {\n    int foo[3];\n    ap_int<23> bar;\n};\n\n// Top function\nint dut(A arr[N]);\n\nint dut(A arr[N]) {\n#pragma HLS interface ap_fifo port = arr\n#pragma HLS aggregate variable = arr\n    int sum = 0;\n    for (unsigned i = 0; i < N; i++) {\n        auto tmp = arr[i];\n        sum += tmp.foo[0] + tmp.foo[1] + tmp.foo[2] + tmp.bar;\n    }\n    return sum;\n}\n"
      }
    ],
    "code_length": 1798,
    "token_count": 441,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/and_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 79,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "and_gate",
    "ResourceMetric": 1.75465e-05,
    "design_id": "project",
    "algo_name": "and_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "and_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid and_gate(ap_uint<1> input1[SIZE], ap_uint<1> input2[SIZE], ap_uint<1> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] & input2[i];\n    }\n}\n\n// Top function name: and_gate\n"
      }
    ],
    "code_length": 251,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/array_partition_block_cyclic/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 530,
    "Worst-caseLatency": 1066.0,
    "BRAM_18K": 3,
    "LUT": 7718,
    "DSP": 63,
    "FF": 3691,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "matmul_partition",
    "ResourceMetric": 0.0037653008,
    "design_id": "project",
    "algo_name": "array_partition_block_cyclic",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n// Includes\n/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n#define MAX_DIM 16\n\nvoid matmul_partition(int* in1, int* in2, int* out_r, int dim, int rep_count);\n\n// TRIPCOUNT identifier\nconst unsigned int c_dim = MAX_DIM;\n\nvoid matmul_partition(int* in1, int* in2, int* out_r, int dim, int rep_count) { // Matrix Dimension. Assuming Square Matrix\n#pragma HLS INTERFACE m_axi port = in1 depth = 256\n#pragma HLS INTERFACE m_axi port = in2 depth = 256\n#pragma HLS INTERFACE m_axi port = out_r depth = 256\n\n    int A[MAX_DIM * MAX_DIM];\n    int B[MAX_DIM * MAX_DIM];\n    int C[MAX_DIM * MAX_DIM];\n// Cyclic Partition for A as matrix multiplication needs row-wise parallel\n// access\n#pragma HLS ARRAY_PARTITION variable = A dim = 1 cyclic factor = 16\n// Block Partition for B as matrix multiplication needs column-wise parallel\n// access\n#pragma HLS ARRAY_PARTITION variable = B dim = 1 block factor = 16\n\n// As A and B Matrix are partitioned with the factor of MAX_DIM, so to get\n// parallel row/column access, input square matrix[dimXdim] should be written\n// into local Array in MATRIX[MAX_DIM * MAX_DIM] format\n\n// Burst read for matrix A\n// Auto-pipeline is going to apply pipeline to these loops\nreadA:\n    for (int itr = 0, i = 0, j = 0; itr < dim * dim; itr++, j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim* c_dim max = c_dim * c_dim\n        if (j == dim) {\n            j = 0;\n            i++;\n        }\n        A[i * MAX_DIM + j] = in1[itr];\n    }\n\n// Burst read for matrix B\nreadB:\n    for (int itr = 0, i = 0, j = 0; itr < dim * dim; itr++, j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim* c_dim max = c_dim * c_dim\n        if (j == dim) {\n            j = 0;\n            i++;\n        }\n        B[i * MAX_DIM + j] = in2[itr];\n    }\n\nloop2:\n    for (int x = 0; x < rep_count; x++) {\n#pragma HLS LOOP_TRIPCOUNT min = 1 max = 1\n    lreorder1:\n        for (int i = 0; i < dim; i++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim\n        // As A and B are partition correctly so loop pipelining is applied\n        // at 2nd level loop and which will eventually unroll the lower loop\n        lreorder2:\n            for (int j = 0; j < dim; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim\n                int result = 0;\n            lreorder3:\n                for (int k = 0; k < MAX_DIM; k++) {\n                    //#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim\n                    result += A[i * MAX_DIM + k] * B[k * MAX_DIM + j];\n                }\n                C[i * MAX_DIM + j] = result;\n            }\n        }\n    }\n\n// Burst write from output matrices to global memory\n// Burst write from matrix C\nwriteC:\n    for (int itr = 0, i = 0, j = 0; itr < dim * dim; itr++, j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim* c_dim max = c_dim * c_dim\n        if (j == dim) {\n            j = 0;\n            i++;\n        }\n        out_r[itr] = C[i * MAX_DIM + j];\n    }\n}\n"
      },
      {
        "file_name": "xmatmul_partition.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xmatmul_partition.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XMatmul_partition_CfgInitialize(XMatmul_partition *InstancePtr, XMatmul_partition_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XMatmul_partition_Set_in1(XMatmul_partition *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA, (u32)(Data));\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XMatmul_partition_Get_in1(XMatmul_partition *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA);\n    Data += (u64)XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XMatmul_partition_Set_in2(XMatmul_partition *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA, (u32)(Data));\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XMatmul_partition_Get_in2(XMatmul_partition *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA);\n    Data += (u64)XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XMatmul_partition_Set_out_r(XMatmul_partition *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA, (u32)(Data));\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XMatmul_partition_Get_out_r(XMatmul_partition *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA);\n    Data += (u64)XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xmatmul_partition_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xmatmul_partition.h\"\n\nextern XMatmul_partition_Config XMatmul_partition_ConfigTable[];\n\n#ifdef SDT\nXMatmul_partition_Config *XMatmul_partition_LookupConfig(UINTPTR BaseAddress) {\n\tXMatmul_partition_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XMatmul_partition_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XMatmul_partition_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XMatmul_partition_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, UINTPTR BaseAddress) {\n\tXMatmul_partition_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XMatmul_partition_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XMatmul_partition_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXMatmul_partition_Config *XMatmul_partition_LookupConfig(u16 DeviceId) {\n\tXMatmul_partition_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XMATMUL_PARTITION_NUM_INSTANCES; Index++) {\n\t\tif (XMatmul_partition_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XMatmul_partition_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, u16 DeviceId) {\n\tXMatmul_partition_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XMatmul_partition_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XMatmul_partition_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xmatmul_partition_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xmatmul_partition.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XMatmul_partition_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XMatmul_partition_uio_map maps[ MAX_UIO_MAPS ];\n} XMatmul_partition_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XMatmul_partition_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XMatmul_partition_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XMatmul_partition_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XMatmul_partition_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XMatmul_partition_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, const char* InstanceName) {\n\tXMatmul_partition_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XMatmul_partition_Release(XMatmul_partition *InstancePtr) {\n\tXMatmul_partition_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xmatmul_partition_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of in1\n//        bit 31~0 - in1[31:0] (Read/Write)\n// 0x14 : Data signal of in1\n//        bit 31~0 - in1[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of in2\n//        bit 31~0 - in2[31:0] (Read/Write)\n// 0x20 : Data signal of in2\n//        bit 31~0 - in2[63:32] (Read/Write)\n// 0x24 : reserved\n// 0x28 : Data signal of out_r\n//        bit 31~0 - out_r[31:0] (Read/Write)\n// 0x2c : Data signal of out_r\n//        bit 31~0 - out_r[63:32] (Read/Write)\n// 0x30 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA   0x10\n#define XMATMUL_PARTITION_CONTROL_BITS_IN1_DATA   64\n#define XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA   0x1c\n#define XMATMUL_PARTITION_CONTROL_BITS_IN2_DATA   64\n#define XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA 0x28\n#define XMATMUL_PARTITION_CONTROL_BITS_OUT_R_DATA 64\n\n"
      },
      {
        "file_name": "xmatmul_partition.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XMATMUL_PARTITION_H\n#define XMATMUL_PARTITION_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xmatmul_partition_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XMatmul_partition_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XMatmul_partition;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XMatmul_partition_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XMatmul_partition_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XMatmul_partition_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XMatmul_partition_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, UINTPTR BaseAddress);\nXMatmul_partition_Config* XMatmul_partition_LookupConfig(UINTPTR BaseAddress);\n#else\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, u16 DeviceId);\nXMatmul_partition_Config* XMatmul_partition_LookupConfig(u16 DeviceId);\n#endif\nint XMatmul_partition_CfgInitialize(XMatmul_partition *InstancePtr, XMatmul_partition_Config *ConfigPtr);\n#else\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, const char* InstanceName);\nint XMatmul_partition_Release(XMatmul_partition *InstancePtr);\n#endif\n\n\nvoid XMatmul_partition_Set_in1(XMatmul_partition *InstancePtr, u64 Data);\nu64 XMatmul_partition_Get_in1(XMatmul_partition *InstancePtr);\nvoid XMatmul_partition_Set_in2(XMatmul_partition *InstancePtr, u64 Data);\nu64 XMatmul_partition_Get_in2(XMatmul_partition *InstancePtr);\nvoid XMatmul_partition_Set_out_r(XMatmul_partition *InstancePtr, u64 Data);\nu64 XMatmul_partition_Get_out_r(XMatmul_partition *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      }
    ],
    "code_length": 14547,
    "token_count": 3920,
    "pragma_number": 12,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/atax/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16003904,
    "Worst-caseLatency": 16003904.0,
    "BRAM_18K": 0,
    "LUT": 1526,
    "DSP": 11,
    "FF": 1490,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_atax",
    "ResourceMetric": 0.0007402409,
    "design_id": "project",
    "algo_name": "atax",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "atax.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _ATAX_H\n# define _ATAX_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(M) && !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define M 38\n#   define N 42\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define M 116\n#   define N 124\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define M 390\n#   define N 410\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define M 1900\n#   define N 2100\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define M 1800\n#   define N 2200\n#  endif\n\n\n#endif /* !(M N) */\n\n# define _PB_M POLYBENCH_LOOP_BOUND(M,m)\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_ATAX_H */\n"
      },
      {
        "file_name": "atax.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* atax.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"atax.h\"\n\n\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_atax(int m, int n,\n\t\t DATA_TYPE POLYBENCH_2D(A,M,N,m,n),\n\t\t DATA_TYPE POLYBENCH_1D(x,N,n),\n\t\t DATA_TYPE POLYBENCH_1D(y,N,n),\n\t\t DATA_TYPE POLYBENCH_1D(tmp,M,m))\n{\n  int i, j;\n\n#pragma scop\n  for (i = 0; i < _PB_N; i++)\n    y[i] = 0;\n  for (i = 0; i < _PB_M; i++)\n    {\n      tmp[i] = SCALAR_VAL(0.0);\n      for (j = 0; j < _PB_N; j++)\n\ttmp[i] = tmp[i] + A[i][j] * x[j];\n      for (j = 0; j < _PB_N; j++)\n\ty[j] = y[j] + A[i][j] * tmp[i];\n    }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 1033,
    "token_count": 356,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/attention_augmented_convolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 15738863,
    "Worst-caseLatency": 15738863.0,
    "BRAM_18K": 4096,
    "LUT": 2673,
    "DSP": 10,
    "FF": 2925,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "attention_augmented_convolution",
    "ResourceMetric": 0.2550383365,
    "design_id": "project",
    "algo_name": "attention_augmented_convolution",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "attention_augmented_convolution.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 1024\n#define KERNEL_SIZE 3\n#define ATTENTION_HEADS 8\n\nvoid attention_augmented_convolution(\n    float input[INPUT_SIZE][INPUT_SIZE],\n    float output[OUTPUT_SIZE][OUTPUT_SIZE],\n    float kernel[KERNEL_SIZE][KERNEL_SIZE],\n    float attention_weights[ATTENTION_HEADS][INPUT_SIZE][INPUT_SIZE])\n{\n    float conv_result[INPUT_SIZE][INPUT_SIZE] = {0};\n    float attention_result[INPUT_SIZE][INPUT_SIZE] = {0};\n\n    // Convolution\n    for (int i = 0; i < INPUT_SIZE - KERNEL_SIZE + 1; i++) {\n        for (int j = 0; j < INPUT_SIZE - KERNEL_SIZE + 1; j++) {\n            float sum = 0.0;\n            for (int ki = 0; ki < KERNEL_SIZE; ki++) {\n                for (int kj = 0; kj < KERNEL_SIZE; kj++) {\n                    sum += input[i + ki][j + kj] * kernel[ki][kj];\n                }\n            }\n            conv_result[i][j] = sum;\n        }\n    }\n\n    // Attention Mechanism\n    for (int h = 0; h < ATTENTION_HEADS; h++) {\n        for (int i = 0; i < INPUT_SIZE; i++) {\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                attention_result[i][j] += input[i][j] * attention_weights[h][i][j];\n            }\n        }\n    }\n\n    // Combining Convolution and Attention Results\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            output[i][j] = conv_result[i][j] + attention_result[i][j];\n        }\n    }\n}\n\n// Top function name: attention_augmented_convolution\n"
      }
    ],
    "code_length": 1502,
    "token_count": 418,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/backprop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4466201,
    "Worst-caseLatency": 4466201.0,
    "BRAM_18K": 6,
    "LUT": 29862,
    "DSP": 92,
    "FF": 55246,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "backprop",
    "ResourceMetric": 0.0139443851,
    "design_id": "project",
    "algo_name": "backprop",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "backprop.h",
        "file_content": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"support.h\"\n\n// Fixed parameters\n#define input_dimension  13\n#define possible_outputs  3\n#define training_sets   163\n#define nodes_per_layer  64\n#define layers            2\n#define learning_rate  0.01\n#define epochs            1\n#define test_sets        15\n#define norm_param    0.005\n\n#define max 1.0\n#define offset 0.5\n\n//Data Bounds\n#define TYPE double\n#define MAX 1000\n#define MIN 1\n\nvoid backprop(\n    TYPE weights1[input_dimension*nodes_per_layer],\n    TYPE weights2[nodes_per_layer*nodes_per_layer],\n    TYPE weights3[nodes_per_layer*possible_outputs],\n    TYPE biases1[nodes_per_layer],\n    TYPE biases2[nodes_per_layer],\n    TYPE biases3[possible_outputs],\n    TYPE training_data[training_sets*input_dimension],\n    TYPE training_targets[training_sets*possible_outputs]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n    TYPE weights1[input_dimension*nodes_per_layer];\n    TYPE weights2[nodes_per_layer*nodes_per_layer];\n    TYPE weights3[nodes_per_layer*possible_outputs];\n    TYPE biases1[nodes_per_layer];\n    TYPE biases2[nodes_per_layer];\n    TYPE biases3[possible_outputs];\n    TYPE training_data[training_sets*input_dimension];\n    TYPE training_targets[training_sets*possible_outputs];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "backprop.c",
        "file_content": "#include \"backprop.h\"\n\nvoid soft_max(TYPE net_outputs[possible_outputs], TYPE activations[possible_outputs]) {\n    int i;\n    TYPE sum;\n    sum = (TYPE) 0.0;\n\n    for(i=0; i < possible_outputs; i++) {\n        sum += exp(-activations[i]);\n    }\n    for(i=0; i < possible_outputs; i++) {\n        net_outputs[i] = exp(-activations[i])/sum;\n    }\n}\n\nvoid RELU(TYPE activations[nodes_per_layer], TYPE dactivations[nodes_per_layer], int size) {\n    int i;\n    for( i = 0; i < size; i++) {\n        dactivations[i] = activations[i]*(1.0-activations[i]);\n        activations[i] = 1.0/(1.0+exp(-activations[i]));\n    }\n}\n\nvoid add_bias_to_activations(TYPE biases[nodes_per_layer], \n                               TYPE activations[nodes_per_layer],\n                               int size) {\n    int i;\n    for( i = 0; i < size; i++){\n        activations[i] = activations[i] + biases[i];\n    }\n}\n\nvoid matrix_vector_product_with_bias_input_layer(TYPE biases[nodes_per_layer],\n                                                 TYPE weights[input_dimension*nodes_per_layer],\n                                                 TYPE activations[nodes_per_layer],\n                                                 TYPE input_sample[input_dimension]){\n    int i,j;\n    for(j = 0; j < nodes_per_layer; j++){\n        activations[j] = (TYPE)0.0;\n        for (i = 0; i < input_dimension; i++){\n            activations[j] += weights[j*input_dimension + i] * input_sample[i];\n        }\n    }\n    add_bias_to_activations(biases, activations, nodes_per_layer);\n}\n\nvoid matrix_vector_product_with_bias_second_layer(TYPE biases[nodes_per_layer],\n                                                 TYPE weights[nodes_per_layer*nodes_per_layer],\n                                                 TYPE activations[nodes_per_layer],\n                                                 TYPE input_activations[nodes_per_layer]){\n    int i,j;\n    for (i = 0; i < nodes_per_layer; i++){\n        activations[i] = (TYPE)0.0;\n        for(j = 0; j < nodes_per_layer; j++){\n            activations[i] += weights[i*nodes_per_layer + j] * input_activations[j];\n        }\n    }\n    add_bias_to_activations(biases, activations, nodes_per_layer);\n}\n\nvoid matrix_vector_product_with_bias_output_layer(TYPE biases[possible_outputs],\n                                                 TYPE weights[nodes_per_layer*possible_outputs],\n                                                 TYPE activations[possible_outputs],\n                                                 TYPE input_activations[nodes_per_layer]){\n    int i, j;\n    for(j = 0; j < possible_outputs; j++){\n        activations[j] = (TYPE)0.0;\n        for (i = 0; i < nodes_per_layer; i++){\n            activations[j] += weights[j*nodes_per_layer + i] * input_activations[i];\n        }\n    }\n    add_bias_to_activations(biases, activations, possible_outputs);\n}\n\nvoid take_difference(TYPE net_outputs[possible_outputs], \n                     TYPE solutions[possible_outputs], \n                     TYPE output_difference[possible_outputs],\n                     TYPE dactivations[possible_outputs]) {\n    int i;\n    for( i = 0; i < possible_outputs; i++){\n        output_difference[i] = (((net_outputs[i]) - solutions[i]) * -1.0) * dactivations[i];\n    }\n}\n\nvoid get_delta_matrix_weights3(TYPE delta_weights3[nodes_per_layer*possible_outputs],\n                               TYPE output_difference[possible_outputs],\n                               TYPE last_activations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        for( j = 0; j < possible_outputs; j++) {\n            delta_weights3[i*possible_outputs + j] = last_activations[i] * output_difference[j];\n        }\n    }\n}\n\nvoid get_oracle_activations2(TYPE weights3[nodes_per_layer*possible_outputs], \n                             TYPE output_differences[possible_outputs], \n                             TYPE oracle_activations[nodes_per_layer],\n                             TYPE dactivations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        oracle_activations[i] = (TYPE)0.0;\n        for( j = 0; j < possible_outputs; j++) {\n            oracle_activations[i] += output_differences[j] * weights3[i*possible_outputs + j];\n        }\n        oracle_activations[i] = oracle_activations[i] * dactivations[i];\n    }\n}\n\nvoid get_delta_matrix_weights2(TYPE delta_weights2[nodes_per_layer*nodes_per_layer],\n                               TYPE output_difference[nodes_per_layer],\n                               TYPE last_activations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        for( j = 0; j < nodes_per_layer; j++) {\n            delta_weights2[i*nodes_per_layer + j] = last_activations[i] * output_difference[j];\n        }\n    }\n}\n\nvoid get_oracle_activations1(TYPE weights2[nodes_per_layer*nodes_per_layer], \n                             TYPE output_differences[nodes_per_layer], \n                             TYPE oracle_activations[nodes_per_layer],\n                             TYPE dactivations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        oracle_activations[i] = (TYPE)0.0;\n        for( j = 0; j < nodes_per_layer; j++) {\n            oracle_activations[i] += output_differences[j] * weights2[i*nodes_per_layer + j];\n        }\n        oracle_activations[i] = oracle_activations[i] * dactivations[i];\n    }\n}\n\nvoid get_delta_matrix_weights1(TYPE delta_weights1[input_dimension*nodes_per_layer],\n                               TYPE output_difference[nodes_per_layer],\n                               TYPE last_activations[input_dimension]) {\n    int i, j;\n    for( i = 0; i < input_dimension; i++) {\n        for( j = 0; j < nodes_per_layer; j++) {\n            delta_weights1[i*nodes_per_layer + j] = last_activations[i] * output_difference[j];\n        }\n    }\n}\n\nvoid update_weights(TYPE weights1[input_dimension*nodes_per_layer],\n                    TYPE weights2[nodes_per_layer*nodes_per_layer],\n                    TYPE weights3[nodes_per_layer*possible_outputs],\n                    TYPE d_weights1[input_dimension*nodes_per_layer],\n                    TYPE d_weights2[nodes_per_layer*nodes_per_layer],\n                    TYPE d_weights3[nodes_per_layer*possible_outputs],\n                    TYPE biases1[nodes_per_layer],\n                    TYPE biases2[nodes_per_layer],\n                    TYPE biases3[possible_outputs],\n                    TYPE d_biases1[nodes_per_layer],\n                    TYPE d_biases2[nodes_per_layer],\n                    TYPE d_biases3[possible_outputs]) {\n    int i, j;\n    double norm, bias_norm;\n    norm = 0.0;\n    bias_norm = 0.0;\n\n    for(i=0; i < input_dimension; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights1[i*nodes_per_layer + j] -= (d_weights1[i*nodes_per_layer + j] * learning_rate);\n            norm += weights1[i*nodes_per_layer + j]*weights1[i*nodes_per_layer + j];\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases1[i] -= (d_biases1[i]*learning_rate);\n        bias_norm += biases1[i]*biases1[i];\n    }\n    \n    norm = sqrt(norm);\n    bias_norm = sqrt(bias_norm);\n\n    for(i=0; i < input_dimension; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights1[i*nodes_per_layer + j] = (weights1[i*nodes_per_layer + j]/norm);\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases1[i] = (biases1[i]/bias_norm);\n    }\n\n    norm = (double)0.0;\n    bias_norm = (double)0.0;\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights2[i*nodes_per_layer + j] -= (d_weights2[i*nodes_per_layer + j] * learning_rate);\n            norm += weights2[i*nodes_per_layer + j]*weights2[i*nodes_per_layer + j];\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases2[i] -= (d_biases2[i]*learning_rate);\n        bias_norm += biases2[i]*biases2[i];\n    }\n\n    norm = sqrt(norm);\n    bias_norm = sqrt(bias_norm);\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights2[i*nodes_per_layer + j] = (weights2[i*nodes_per_layer + j]/norm);\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases2[i] = (biases2[i]/bias_norm);\n    }\n\n    norm = (double)0.0;\n    bias_norm = (double)0.0;\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < possible_outputs; j++){\n            weights3[i*possible_outputs + j] -= (d_weights3[i*possible_outputs + j] * learning_rate);\n            norm += weights3[i*possible_outputs + j]*weights3[i*possible_outputs + j];\n        }\n    }\n    for(i=0; i<possible_outputs;i++){\n        biases3[i] -= d_biases3[i]*learning_rate;\n        bias_norm += biases3[i]*biases3[i];\n    }\n\n    norm = sqrt(norm);\n    bias_norm = sqrt(bias_norm);\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < possible_outputs; j++){\n            weights3[i*possible_outputs + j] = (weights3[i*possible_outputs + j]/norm);\n        }\n    }\n    for(i=0; i < possible_outputs; i++){\n        biases3[i] = (biases3[i]/bias_norm);\n    }\n}\n\nvoid backprop(TYPE weights1[input_dimension*nodes_per_layer], \n                TYPE weights2[nodes_per_layer*nodes_per_layer],\n                TYPE weights3[nodes_per_layer*possible_outputs],\n                TYPE biases1[nodes_per_layer], \n                TYPE biases2[nodes_per_layer],\n                TYPE biases3[possible_outputs],\n                TYPE training_data[training_sets*input_dimension],\n                TYPE training_targets[training_sets*possible_outputs]) {\n    int i,j;\n    //Forward and training structures\n    TYPE activations1[nodes_per_layer];\n    TYPE activations2[nodes_per_layer];\n    TYPE activations3[possible_outputs];\n    TYPE dactivations1[nodes_per_layer];\n    TYPE dactivations2[nodes_per_layer];\n    TYPE dactivations3[possible_outputs];\n    TYPE net_outputs[possible_outputs];\n    //Training structure\n    TYPE output_difference[possible_outputs];\n    TYPE delta_weights1[input_dimension*nodes_per_layer]; \n    TYPE delta_weights2[nodes_per_layer*nodes_per_layer];\n    TYPE delta_weights3[nodes_per_layer*possible_outputs];\n    TYPE oracle_activations1[nodes_per_layer];\n    TYPE oracle_activations2[nodes_per_layer];\n\n    for(i=0; i<training_sets; i++){\n        for(j=0;j<nodes_per_layer;j++){\n            activations1[j] = (TYPE)0.0;\n            activations2[j] = (TYPE)0.0;\n            if(j<possible_outputs){\n                activations3[j] = (TYPE)0.0;\n            }\n        }\n        matrix_vector_product_with_bias_input_layer(biases1, weights1, activations1, &training_data[i*input_dimension]);\n        RELU(activations1, dactivations1, nodes_per_layer);\n        matrix_vector_product_with_bias_second_layer(biases2, weights2, activations2, activations1);\n        RELU(activations2, dactivations2, nodes_per_layer);\n        matrix_vector_product_with_bias_output_layer(biases3, weights3, activations3, activations2);\n        RELU(activations3, dactivations3, possible_outputs);\n        soft_max(net_outputs, activations3);\n        take_difference(net_outputs, &training_targets[i*possible_outputs], output_difference, dactivations3);\n        get_delta_matrix_weights3(delta_weights3, output_difference, activations2);\n        get_oracle_activations2(weights3, output_difference, oracle_activations2, dactivations2);\n        get_delta_matrix_weights2(delta_weights2, oracle_activations2, activations1);\n        get_oracle_activations1(weights2, oracle_activations2, oracle_activations1, dactivations1);\n        get_delta_matrix_weights1(delta_weights1, oracle_activations1, &training_data[i*input_dimension]);\n        update_weights(weights1, weights2, weights3, delta_weights1, delta_weights2, delta_weights3, \n                       biases1, biases2, biases3, oracle_activations1, oracle_activations2, output_difference);\n    }\n}\n"
      }
    ],
    "code_length": 11867,
    "token_count": 2849,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/batch_renormalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1065,
    "Worst-caseLatency": 1065.0,
    "BRAM_18K": 0,
    "LUT": 895,
    "DSP": 10,
    "FF": 1167,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "batch_renormalization",
    "ResourceMetric": 0.0005605633,
    "design_id": "project",
    "algo_name": "batch_renormalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "batch_renormalization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid batch_renormalization(float input[N], float output[N], float mean, float variance, float r, float d) {\n    float epsilon = 1e-5;\n    float inv_std = 1.0 / sqrt(variance + epsilon);\n\n    for (int i = 0; i < N; i++) {\n        float normalized = (input[i] - mean) * inv_std;\n        output[i] = r * normalized + d;\n    }\n}\n\n// Top function name: batch_renormalization\n"
      }
    ],
    "code_length": 404,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/bfs_queue/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 198401.0,
    "BRAM_18K": 0,
    "LUT": 995,
    "DSP": 0,
    "FF": 339,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bfs",
    "ResourceMetric": 0.0002233102,
    "design_id": "project",
    "algo_name": "bfs_queue",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "bfs.h",
        "file_content": "/*\nImplementation based on:\nHong, Oguntebi, Olukotun. \"Efficient Parallel Graph Exploration on Multi-Core CPU and GPU.\" PACT, 2011.\n*/\n\n#include <stdlib.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include \"support.h\"\n\n// Terminology (but not values) from graph500 spec\n//   graph density = 2^-(2*SCALE - EDGE_FACTOR)\n#define SCALE 8\n#define EDGE_FACTOR 16\n\n#define N_NODES (1<<SCALE)\n#define N_EDGES (N_NODES*EDGE_FACTOR)\n\n// upper limit\n#define N_LEVELS 10\n\n// Larger than necessary for small graphs, but appropriate for large ones\ntypedef uint64_t edge_index_t;\ntypedef uint64_t node_index_t;\n\ntypedef struct edge_t_struct {\n  // These fields are common in practice, but we elect not to use them.\n  //weight_t weight;\n  //node_index_t src;\n  node_index_t dst;\n} edge_t;\n\ntypedef struct node_t_struct {\n  edge_index_t edge_begin;\n  edge_index_t edge_end;\n} node_t;\n\ntypedef int8_t level_t;\n#define MAX_LEVEL INT8_MAX\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  node_t nodes[N_NODES];\n  edge_t edges[N_EDGES];\n  node_index_t starting_node;\n  level_t level[N_NODES];\n  edge_index_t level_counts[N_LEVELS];\n};\n\nvoid bfs(node_t nodes[N_NODES], edge_t edges[N_EDGES], node_index_t starting_node, level_t level[N_NODES], edge_index_t level_counts[N_LEVELS]);\n"
      },
      {
        "file_name": "bfs.c",
        "file_content": "/*\nImplementation based on:\nHong, Oguntebi, Olukotun. \"Efficient Parallel Graph Exploration on Multi-Core CPU and GPU.\" PACT, 2011.\n*/\n\n#include \"bfs.h\"\n\n#define Q_PUSH(node) { queue[q_in==0?N_NODES-1:q_in-1]=node; q_in=(q_in+1)%N_NODES; }\n#define Q_PEEK() (queue[q_out])\n#define Q_POP() { q_out = (q_out+1)%N_NODES; }\n#define Q_EMPTY() (q_in>q_out ? q_in==q_out+1 : (q_in==0)&&(q_out==N_NODES-1))\n\nvoid bfs(node_t nodes[N_NODES], edge_t edges[N_EDGES],\n            node_index_t starting_node, level_t level[N_NODES],\n            edge_index_t level_counts[N_LEVELS])\n{\n  node_index_t queue[N_NODES];\n  node_index_t q_in, q_out;\n  node_index_t dummy;\n  node_index_t n;\n  edge_index_t e;\n\n  /*init_levels: for( n=0; n<N_NODES; n++ )*/\n  /*level[n] = MAX_LEVEL;*/\n  /*init_horizons: for( i=0; i<N_LEVELS; i++ )*/\n  /*level_counts[i] = 0;*/\n\n  q_in = 1;\n  q_out = 0;\n  level[starting_node] = 0;\n  level_counts[0] = 1;\n  Q_PUSH(starting_node);\n\n  loop_queue: for( dummy=0; dummy<N_NODES; dummy++ ) { // Typically while(not_empty(queue)){\n    if( Q_EMPTY() )\n      break;\n    n = Q_PEEK();\n    Q_POP();\n    edge_index_t tmp_begin = nodes[n].edge_begin;\n    edge_index_t tmp_end = nodes[n].edge_end;\n    loop_neighbors: for( e=tmp_begin; e<tmp_end; e++ ) {\n      #pragma HLS loop_tripcount min=1 max=N_NODES\n      node_index_t tmp_dst = edges[e].dst;\n      level_t tmp_level = level[tmp_dst];\n\n      if( tmp_level ==MAX_LEVEL ) { // Unmarked\n        level_t tmp_level = level[n]+1;\n        level[tmp_dst] = tmp_level;\n        ++level_counts[tmp_level];\n        Q_PUSH(tmp_dst);\n      }\n    }\n  }\n\n  /*\n  printf(\"Horizons:\");\n  for( i=0; i<N_LEVELS; i++ )\n    printf(\" %d\", level_counts[i]);\n  printf(\"\\n\");\n  */\n}\n"
      }
    ],
    "code_length": 1707,
    "token_count": 537,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/binary_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5,
    "Worst-caseLatency": 2054.0,
    "BRAM_18K": 0,
    "LUT": 557,
    "DSP": 0,
    "FF": 228,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_search",
    "ResourceMetric": 0.0001286742,
    "design_id": "project",
    "algo_name": "binary_search",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "binary_search.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid binary_search(ap_int<32> array[ARRAY_SIZE], ap_int<32> key, ap_int<32> &index) {\n    ap_int<32> low = 0;\n    ap_int<32> high = ARRAY_SIZE - 1;\n    ap_int<32> mid;\n\n    index = -1; // Default value if key is not found\n\n    for (ap_int<32> i = 0; i < ARRAY_SIZE; i++) {\n        if (low <= high) {\n            mid = (low + high) / 2;\n            if (array[mid] == key) {\n                index = mid;\n                break;\n            } else if (array[mid] < key) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n}\n\n// Top function name: binary_search\n"
      }
    ],
    "code_length": 667,
    "token_count": 196,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/burst_rw/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3,
    "Worst-caseLatency": 50689.0,
    "BRAM_18K": 3,
    "LUT": 1898,
    "DSP": 0,
    "FF": 1439,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vadd",
    "ResourceMetric": 0.0006879564,
    "design_id": "project",
    "algo_name": "burst_rw",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n/*******************************************************************************\nDescription:\n    HLS Example using AXI4-master interface for burst read and write\n*******************************************************************************/\n\n// Includes\n// Missing include: #include <stdio.h>\n// Missing include: #include <string.h>\n#define DATA_SIZE 2048\n#define INCR_VALUE 10\n// define internal buffer max size\n#define BURSTBUFFERSIZE 256\n\nvoid vadd(int* a, int size, int inc_value);\n// TRIPCOUNT identifiers\nconst unsigned int c_size_min = 1;\nconst unsigned int c_size_max = BURSTBUFFERSIZE;\nconst unsigned int c_chunk_sz = DATA_SIZE;\n\nvoid vadd(int* a, int size, int inc_value) {\n// Map pointer a to AXI4-master interface for global memory access\n#pragma HLS INTERFACE m_axi port = a offset = slave bundle = gmem max_read_burst_length = 256 max_write_burst_length = 256 depth = 2048\n// We also need to map a and return to a bundled axilite slave interface\n#pragma HLS INTERFACE s_axilite port = a\n#pragma HLS INTERFACE s_axilite port = size\n#pragma HLS INTERFACE s_axilite port = inc_value\n#pragma HLS INTERFACE s_axilite port = return\n\n    int burstbuffer[BURSTBUFFERSIZE];\n\nread_buf:\n    // Per iteration of this loop perform BURSTBUFFERSIZE vector addition\n    for (int i = 0; i < size; i += BURSTBUFFERSIZE) {\n#pragma HLS LOOP_TRIPCOUNT min = c_size_min* c_size_min max = c_chunk_sz * c_chunk_sz / (c_size_max * c_size_max)\n        int chunk_size = BURSTBUFFERSIZE;\n        // boundary checks\n        if ((i + BURSTBUFFERSIZE) > size) chunk_size = size - i;\n        // burst read\n        // Auto-pipeline is going to apply pipeline to these loops\n        for (int j = 0; j < chunk_size; j++) {\n// As the outer loop is not a perfect loop\n#pragma HLS loop_flatten off\n#pragma HLS LOOP_TRIPCOUNT min = c_size_min max = c_size_max\n            burstbuffer[j] = a[i + j];\n        }\n\n    // calculate and write results to global memory, the sequential write in a for\n    // loop can be inferred to a memory burst access\n    calc_write:\n        for (int j = 0; j < chunk_size; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_size_max max = c_chunk_sz\n            burstbuffer[j] = burstbuffer[j] + inc_value;\n            a[i + j] = burstbuffer[j];\n        }\n    }\n}\n"
      },
      {
        "file_name": "xvadd_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xvadd.h\"\n\nextern XVadd_Config XVadd_ConfigTable[];\n\n#ifdef SDT\nXVadd_Config *XVadd_LookupConfig(UINTPTR BaseAddress) {\n\tXVadd_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XVadd_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XVadd_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XVadd_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, UINTPTR BaseAddress) {\n\tXVadd_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XVadd_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XVadd_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXVadd_Config *XVadd_LookupConfig(u16 DeviceId) {\n\tXVadd_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XVADD_NUM_INSTANCES; Index++) {\n\t\tif (XVadd_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XVadd_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, u16 DeviceId) {\n\tXVadd_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XVadd_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XVadd_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xvadd_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : Control signals\n//        bit 0  - ap_start (Read/Write/COH)\n//        bit 1  - ap_done (Read/COR)\n//        bit 2  - ap_idle (Read)\n//        bit 3  - ap_ready (Read/COR)\n//        bit 7  - auto_restart (Read/Write)\n//        bit 9  - interrupt (Read)\n//        others - reserved\n// 0x04 : Global Interrupt Enable Register\n//        bit 0  - Global Interrupt Enable (Read/Write)\n//        others - reserved\n// 0x08 : IP Interrupt Enable Register (Read/Write)\n//        bit 0 - enable ap_done interrupt (Read/Write)\n//        bit 1 - enable ap_ready interrupt (Read/Write)\n//        others - reserved\n// 0x0c : IP Interrupt Status Register (Read/TOW)\n//        bit 0 - ap_done (Read/TOW)\n//        bit 1 - ap_ready (Read/TOW)\n//        others - reserved\n// 0x10 : Data signal of a\n//        bit 31~0 - a[31:0] (Read/Write)\n// 0x14 : Data signal of a\n//        bit 31~0 - a[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of size\n//        bit 31~0 - size[31:0] (Read/Write)\n// 0x20 : reserved\n// 0x24 : Data signal of inc_value\n//        bit 31~0 - inc_value[31:0] (Read/Write)\n// 0x28 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XVADD_CONTROL_ADDR_AP_CTRL        0x00\n#define XVADD_CONTROL_ADDR_GIE            0x04\n#define XVADD_CONTROL_ADDR_IER            0x08\n#define XVADD_CONTROL_ADDR_ISR            0x0c\n#define XVADD_CONTROL_ADDR_A_DATA         0x10\n#define XVADD_CONTROL_BITS_A_DATA         64\n#define XVADD_CONTROL_ADDR_SIZE_DATA      0x1c\n#define XVADD_CONTROL_BITS_SIZE_DATA      32\n#define XVADD_CONTROL_ADDR_INC_VALUE_DATA 0x24\n#define XVADD_CONTROL_BITS_INC_VALUE_DATA 32\n\n"
      },
      {
        "file_name": "xvadd.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xvadd.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XVadd_CfgInitialize(XVadd *InstancePtr, XVadd_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XVadd_Start(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL) & 0x80;\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL, Data | 0x01);\n}\n\nu32 XVadd_IsDone(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL);\n    return (Data >> 1) & 0x1;\n}\n\nu32 XVadd_IsIdle(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL);\n    return (Data >> 2) & 0x1;\n}\n\nu32 XVadd_IsReady(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL);\n    // check ap_start to see if the pcore is ready for next input\n    return !(Data & 0x1);\n}\n\nvoid XVadd_EnableAutoRestart(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL, 0x80);\n}\n\nvoid XVadd_DisableAutoRestart(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL, 0);\n}\n\nvoid XVadd_Set_a(XVadd *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA, (u32)(Data));\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XVadd_Get_a(XVadd *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA);\n    Data += (u64)XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XVadd_Set_size(XVadd *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_SIZE_DATA, Data);\n}\n\nu32 XVadd_Get_size(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_SIZE_DATA);\n    return Data;\n}\n\nvoid XVadd_Set_inc_value(XVadd *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_INC_VALUE_DATA, Data);\n}\n\nu32 XVadd_Get_inc_value(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_INC_VALUE_DATA);\n    return Data;\n}\n\nvoid XVadd_InterruptGlobalEnable(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_GIE, 1);\n}\n\nvoid XVadd_InterruptGlobalDisable(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_GIE, 0);\n}\n\nvoid XVadd_InterruptEnable(XVadd *InstancePtr, u32 Mask) {\n    u32 Register;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Register =  XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER);\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER, Register | Mask);\n}\n\nvoid XVadd_InterruptDisable(XVadd *InstancePtr, u32 Mask) {\n    u32 Register;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Register =  XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER);\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER, Register & (~Mask));\n}\n\nvoid XVadd_InterruptClear(XVadd *InstancePtr, u32 Mask) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_ISR, Mask);\n}\n\nu32 XVadd_InterruptGetEnabled(XVadd *InstancePtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    return XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER);\n}\n\nu32 XVadd_InterruptGetStatus(XVadd *InstancePtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    return XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_ISR);\n}\n\n"
      },
      {
        "file_name": "xvadd.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XVADD_H\n#define XVADD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xvadd_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XVadd_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XVadd;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XVadd_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XVadd_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XVadd_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XVadd_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XVadd_Initialize(XVadd *InstancePtr, UINTPTR BaseAddress);\nXVadd_Config* XVadd_LookupConfig(UINTPTR BaseAddress);\n#else\nint XVadd_Initialize(XVadd *InstancePtr, u16 DeviceId);\nXVadd_Config* XVadd_LookupConfig(u16 DeviceId);\n#endif\nint XVadd_CfgInitialize(XVadd *InstancePtr, XVadd_Config *ConfigPtr);\n#else\nint XVadd_Initialize(XVadd *InstancePtr, const char* InstanceName);\nint XVadd_Release(XVadd *InstancePtr);\n#endif\n\nvoid XVadd_Start(XVadd *InstancePtr);\nu32 XVadd_IsDone(XVadd *InstancePtr);\nu32 XVadd_IsIdle(XVadd *InstancePtr);\nu32 XVadd_IsReady(XVadd *InstancePtr);\nvoid XVadd_EnableAutoRestart(XVadd *InstancePtr);\nvoid XVadd_DisableAutoRestart(XVadd *InstancePtr);\n\nvoid XVadd_Set_a(XVadd *InstancePtr, u64 Data);\nu64 XVadd_Get_a(XVadd *InstancePtr);\nvoid XVadd_Set_size(XVadd *InstancePtr, u32 Data);\nu32 XVadd_Get_size(XVadd *InstancePtr);\nvoid XVadd_Set_inc_value(XVadd *InstancePtr, u32 Data);\nu32 XVadd_Get_inc_value(XVadd *InstancePtr);\n\nvoid XVadd_InterruptGlobalEnable(XVadd *InstancePtr);\nvoid XVadd_InterruptGlobalDisable(XVadd *InstancePtr);\nvoid XVadd_InterruptEnable(XVadd *InstancePtr, u32 Mask);\nvoid XVadd_InterruptDisable(XVadd *InstancePtr, u32 Mask);\nvoid XVadd_InterruptClear(XVadd *InstancePtr, u32 Mask);\nu32 XVadd_InterruptGetEnabled(XVadd *InstancePtr);\nu32 XVadd_InterruptGetStatus(XVadd *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xvadd_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xvadd.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XVadd_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XVadd_uio_map maps[ MAX_UIO_MAPS ];\n} XVadd_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XVadd_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XVadd_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XVadd_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XVadd_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XVadd_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, const char* InstanceName) {\n\tXVadd_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XVadd_Release(XVadd *InstancePtr) {\n\tXVadd_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      }
    ],
    "code_length": 15803,
    "token_count": 4315,
    "pragma_number": 9,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/correlation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 20212041,
    "Worst-caseLatency": 8064063241.0,
    "BRAM_18K": 0,
    "LUT": 3251,
    "DSP": 16,
    "FF": 3103,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_correlation",
    "ResourceMetric": 0.0013642131,
    "design_id": "project",
    "algo_name": "correlation",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "correlation.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* correlation.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"correlation.h\"\n\n\n\n\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_correlation(int m, int n,\n\t\t\tDATA_TYPE float_n,\n\t\t\tDATA_TYPE POLYBENCH_2D(data,N,M,n,m),\n\t\t\tDATA_TYPE POLYBENCH_2D(corr,M,M,m,m),\n\t\t\tDATA_TYPE POLYBENCH_1D(mean,M,m),\n\t\t\tDATA_TYPE POLYBENCH_1D(stddev,M,m))\n{\n  int i, j, k;\n\n  DATA_TYPE eps = SCALAR_VAL(0.1);\n\n\n#pragma scop\n  for (j = 0; j < _PB_M; j++)\n    {\n      mean[j] = SCALAR_VAL(0.0);\n      for (i = 0; i < _PB_N; i++)\n\tmean[j] += data[i][j];\n      mean[j] /= float_n;\n    }\n\n\n   for (j = 0; j < _PB_M; j++)\n    {\n      stddev[j] = SCALAR_VAL(0.0);\n      for (i = 0; i < _PB_N; i++)\n        stddev[j] += (data[i][j] - mean[j]) * (data[i][j] - mean[j]);\n      stddev[j] /= float_n;\n      stddev[j] = SQRT_FUN(stddev[j]);\n      /* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n      stddev[j] = stddev[j] <= eps ? SCALAR_VAL(1.0) : stddev[j];\n    }\n\n  /* Center and reduce the column vectors. */\n  for (i = 0; i < _PB_N; i++)\n    for (j = 0; j < _PB_M; j++)\n      {\n        data[i][j] -= mean[j];\n        data[i][j] /= SQRT_FUN(float_n) * stddev[j];\n      }\n\n  /* Calculate the m * m correlation matrix. */\n  for (i = 0; i < _PB_M-1; i++)\n    {\n      corr[i][i] = SCALAR_VAL(1.0);\n      for (j = i+1; j < _PB_M; j++)\n        {\n          corr[i][j] = SCALAR_VAL(0.0);\n          for (k = 0; k < _PB_N; k++)\n            corr[i][j] += (data[k][i] * data[k][j]);\n          corr[j][i] = corr[i][j];\n        }\n    }\n  corr[_PB_M-1][_PB_M-1] = SCALAR_VAL(1.0);\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "correlation.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _CORRELATION_H\n# define _CORRELATION_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(M) && !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define M 28\n#   define N 32\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define M 80\n#   define N 100\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define M 240\n#   define N 260\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define M 1200\n#   define N 1400\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define M 2600\n#   define N 3000\n#  endif\n\n\n#endif /* !(M N) */\n\n# define _PB_M POLYBENCH_LOOP_BOUND(M,m)\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_CORRELATION_H */\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 2224,
    "token_count": 733,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/cryptographic_rng/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 178,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cryptographic_rng",
    "ResourceMetric": 3.84489e-05,
    "design_id": "project",
    "algo_name": "cryptographic_rng",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "cryptographic_rng.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid cryptographic_rng(ap_uint<32> seed, ap_uint<32> output[ARRAY_SIZE]) {\n    ap_uint<32> state = seed;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        state = state ^ (state << 13);\n        state = state ^ (state >> 17);\n        state = state ^ (state << 5);\n        output[i] = state;\n    }\n}\n\n// Top function name: cryptographic_rng\n"
      }
    ],
    "code_length": 386,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cutmix/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048579,
    "Worst-caseLatency": 1048579.0,
    "BRAM_18K": 0,
    "LUT": 767,
    "DSP": 0,
    "FF": 200,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cutmix",
    "ResourceMetric": 0.0001662601,
    "design_id": "project",
    "algo_name": "cutmix",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cutmix.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define IMG_SIZE 1024\n#define BBOX_SIZE 256\n\nvoid cutmix(float img1[IMG_SIZE][IMG_SIZE], float img2[IMG_SIZE][IMG_SIZE], float output[IMG_SIZE][IMG_SIZE], int x, int y, int w, int h, float lambda) {\n    int i, j;\n\n    // Ensure the bounding box is within the image boundaries\n    int x1 = std::max(0, x);\n    int y1 = std::max(0, y);\n    int x2 = std::min(IMG_SIZE, x + w);\n    int y2 = std::min(IMG_SIZE, y + h);\n\n    // Apply CutMix\n    for (i = 0; i < IMG_SIZE; i++) {\n        for (j = 0; j < IMG_SIZE; j++) {\n            if (i >= y1 && i < y2 && j >= x1 && j < x2) {\n                output[i][j] = img2[i][j];\n            } else {\n                output[i][j] = img1[i][j];\n            }\n        }\n    }\n}\n// Top function name: cutmix\n"
      }
    ],
    "code_length": 778,
    "token_count": 253,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dac_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dac_16bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "dac_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dac_16bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dac_16bit(ap_uint<16> input[ARRAY_SIZE], ap_uint<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: dac_16bit\n"
      }
    ],
    "code_length": 240,
    "token_count": 77,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/data_augmentation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1041,
    "Worst-caseLatency": 1041.0,
    "BRAM_18K": 0,
    "LUT": 7240,
    "DSP": 97,
    "FF": 2977,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_augmentation",
    "ResourceMetric": 0.0043610979,
    "design_id": "project",
    "algo_name": "data_augmentation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "data_augmentation.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid data_augmentation(float input[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        // Example augmentation: scaling\n        output[i] = input[i] * 1.5f;\n        \n        // Example augmentation: adding noise\n        output[i] += sin(input[i]);\n        \n        // Example augmentation: clipping\n        if (output[i] > 1.0f) {\n            output[i] = 1.0f;\n        } else if (output[i] < -1.0f) {\n            output[i] = -1.0f;\n        }\n    }\n}\n\n// Top function name: data_augmentation\n"
      }
    ],
    "code_length": 550,
    "token_count": 155,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/data_bus_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_bus_32bit",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "data_bus_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "data_bus_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid data_bus_32bit(uint32_t input[SIZE], uint32_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] + 1;\n    }\n}\n\n// Top function name: data_bus_32bit\n"
      }
    ],
    "code_length": 224,
    "token_count": 74,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/decision_tree_inference/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6,
    "Worst-caseLatency": 4102.0,
    "BRAM_18K": 0,
    "LUT": 348,
    "DSP": 0,
    "FF": 469,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decision_tree_inference",
    "ResourceMetric": 0.000111703,
    "design_id": "project",
    "algo_name": "decision_tree_inference",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "decision_tree_inference.cpp",
        "file_content": "#include <stdint.h>\n\n#define N_FEATURES 10\n#define N_NODES 1024\n\nstruct Node {\n    int feature_index;\n    float threshold;\n    int left;\n    int right;\n    float value;\n};\n\nvoid decision_tree_inference(float features[N_FEATURES], Node nodes[N_NODES], float *result) {\n    int node_index = 0;\n    for (int i = 0; i < N_NODES; i++) {\n        Node node = nodes[node_index];\n        if (node.left == -1 && node.right == -1) {\n            *result = node.value;\n            return;\n        }\n        if (features[node.feature_index] <= node.threshold) {\n            node_index = node.left;\n        } else {\n            node_index = node.right;\n        }\n    }\n    *result = 0.0f; // Default value if no leaf node is reached\n}\n\n// Top function name: decision_tree_inference\n"
      }
    ],
    "code_length": 767,
    "token_count": 192,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/decoder_5to32/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 34,
    "Worst-caseLatency": 34.0,
    "BRAM_18K": 0,
    "LUT": 218,
    "DSP": 0,
    "FF": 40,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decoder_5to32",
    "ResourceMetric": 4.564e-05,
    "design_id": "project",
    "algo_name": "decoder_5to32",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "decoder_5to32.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_WIDTH 5\n#define OUTPUT_WIDTH 32\n#define NUM_INPUTS (1 << INPUT_WIDTH)\n\nvoid decoder_5to32(ap_uint<INPUT_WIDTH> input, ap_uint<OUTPUT_WIDTH> &output) {\n    output = 0;\n    for (int i = 0; i < NUM_INPUTS; i++) {\n        if (input == i) {\n            output = 1 << i;\n        }\n    }\n}\n\n// Top function name: decoder_5to32\n"
      }
    ],
    "code_length": 355,
    "token_count": 108,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/deriche/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 300810321,
    "Worst-caseLatency": 300810321.0,
    "BRAM_18K": 1,
    "LUT": 7418,
    "DSP": 29,
    "FF": 3994,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_deriche",
    "ResourceMetric": 0.0026708832,
    "design_id": "project",
    "algo_name": "deriche",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "deriche.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* deriche.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"deriche.h\"\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Original code provided by Gael Deest */\nvoid kernel_deriche(int w, int h, DATA_TYPE alpha,\n       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h),\n       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h),\n       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h),\n       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h)) {\n    int i,j;\n    DATA_TYPE xm1, tm1, ym1, ym2;\n    DATA_TYPE xp1, xp2;\n    DATA_TYPE tp1, tp2;\n    DATA_TYPE yp1, yp2;\n\n    DATA_TYPE k;\n    DATA_TYPE a1, a2, a3, a4, a5, a6, a7, a8;\n    DATA_TYPE b1, b2, c1, c2;\n\n#pragma scop\n   k = (SCALAR_VAL(1.0)-EXP_FUN(-alpha))*(SCALAR_VAL(1.0)-EXP_FUN(-alpha))/(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*alpha*EXP_FUN(-alpha)-EXP_FUN(SCALAR_VAL(2.0)*alpha));\n   a1 = a5 = k;\n   a2 = a6 = k*EXP_FUN(-alpha)*(alpha-SCALAR_VAL(1.0));\n   a3 = a7 = k*EXP_FUN(-alpha)*(alpha+SCALAR_VAL(1.0));\n   a4 = a8 = -k*EXP_FUN(SCALAR_VAL(-2.0)*alpha);\n   b1 =  POW_FUN(SCALAR_VAL(2.0),-alpha);\n   b2 = -EXP_FUN(SCALAR_VAL(-2.0)*alpha);\n   c1 = c2 = 1;\n\n   for (i=0; i<_PB_W; i++) {\n        ym1 = SCALAR_VAL(0.0);\n        ym2 = SCALAR_VAL(0.0);\n        xm1 = SCALAR_VAL(0.0);\n        for (j=0; j<_PB_H; j++) {\n            y1[i][j] = a1*imgIn[i][j] + a2*xm1 + b1*ym1 + b2*ym2;\n            xm1 = imgIn[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    for (i=0; i<_PB_W; i++) {\n        yp1 = SCALAR_VAL(0.0);\n        yp2 = SCALAR_VAL(0.0);\n        xp1 = SCALAR_VAL(0.0);\n        xp2 = SCALAR_VAL(0.0);\n        for (j=_PB_H-1; j>=0; j--) {\n            y2[i][j] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2;\n            xp2 = xp1;\n            xp1 = imgIn[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (i=0; i<_PB_W; i++)\n        for (j=0; j<_PB_H; j++) {\n            imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);\n        }\n\n    for (j=0; j<_PB_H; j++) {\n        tm1 = SCALAR_VAL(0.0);\n        ym1 = SCALAR_VAL(0.0);\n        ym2 = SCALAR_VAL(0.0);\n        for (i=0; i<_PB_W; i++) {\n            y1[i][j] = a5*imgOut[i][j] + a6*tm1 + b1*ym1 + b2*ym2;\n            tm1 = imgOut[i][j];\n            ym2 = ym1;\n            ym1 = y1 [i][j];\n        }\n    }\n\n\n    for (j=0; j<_PB_H; j++) {\n        tp1 = SCALAR_VAL(0.0);\n        tp2 = SCALAR_VAL(0.0);\n        yp1 = SCALAR_VAL(0.0);\n        yp2 = SCALAR_VAL(0.0);\n        for (i=_PB_W-1; i>=0; i--) {\n            y2[i][j] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2;\n            tp2 = tp1;\n            tp1 = imgOut[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (i=0; i<_PB_W; i++)\n        for (j=0; j<_PB_H; j++)\n            imgOut[i][j] = c2*(y1[i][j] + y2[i][j]);\n\n#pragma endscop\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "deriche.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _DERICHE_H\n# define _DERICHE_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(W) && !defined(H)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define W 64\n#   define H 64\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define W 192\n#   define H 128\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define W 720\n#   define H 480\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define W 4096\n#   define H 2160\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define W 7680\n#   define H 4320\n#  endif\n\n\n#endif /* !(W H) */\n\n# define _PB_W POLYBENCH_LOOP_BOUND(W,w)\n# define _PB_H POLYBENCH_LOOP_BOUND(H,h)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_FLOAT\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_DERICHE_H */\n"
      }
    ],
    "code_length": 3171,
    "token_count": 1235,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dice_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2075,
    "Worst-caseLatency": 2075.0,
    "BRAM_18K": 0,
    "LUT": 1694,
    "DSP": 18,
    "FF": 1624,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dice_loss",
    "ResourceMetric": 0.0009792329,
    "design_id": "project",
    "algo_name": "dice_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dice_loss.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid dice_loss(float pred[SIZE], float target[SIZE], float &loss) {\n    float intersection = 0.0;\n    float sum_pred = 0.0;\n    float sum_target = 0.0;\n\n    for (int i = 0; i < SIZE; i++) {\n        intersection += pred[i] * target[i];\n        sum_pred += pred[i];\n        sum_target += target[i];\n    }\n\n    loss = 1.0 - (2.0 * intersection) / (sum_pred + sum_target);\n}\n\n// Top function name: dice_loss\n"
      }
    ],
    "code_length": 441,
    "token_count": 131,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dma_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8194,
    "Worst-caseLatency": 8194.0,
    "BRAM_18K": 0,
    "LUT": 203,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dma_controller",
    "ResourceMetric": 4.3243e-05,
    "design_id": "project",
    "algo_name": "dma_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dma_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid dma_controller(uint32_t input[8][SIZE], uint32_t output[8][SIZE]) {\n    for (int channel = 0; channel < 8; channel++) {\n        for (int i = 0; i < SIZE; i++) {\n            output[channel][i] = input[channel][i];\n        }\n    }\n}\n\n// Top function name: dma_controller\n"
      }
    ],
    "code_length": 314,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dot_product/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 191,
    "DSP": 4,
    "FF": 78,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dot_product",
    "ResourceMetric": 0.0001549215,
    "design_id": "project",
    "algo_name": "dot_product",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dot_product.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dot_product(const int32_t A[ARRAY_SIZE], const int32_t B[ARRAY_SIZE], int64_t &result) {\n    result = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result += (int64_t)A[i] * (int64_t)B[i];\n    }\n}\n\n// Top function name: dot_product\n"
      }
    ],
    "code_length": 291,
    "token_count": 94,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/ethernet_mac_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2056,
    "Worst-caseLatency": 2056.0,
    "BRAM_18K": 0,
    "LUT": 457,
    "DSP": 0,
    "FF": 55,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ethernet_mac_controller",
    "ResourceMetric": 9.29101e-05,
    "design_id": "project",
    "algo_name": "ethernet_mac_controller",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "ethernet_mac_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define PACKET_SIZE 1024\n\nvoid ethernet_mac_controller(uint8_t input_packet[PACKET_SIZE], uint8_t output_packet[PACKET_SIZE]) {\n    uint16_t crc = 0xFFFF;\n    uint8_t polynomial = 0x07;\n\n    // Calculate CRC for input packet\n    for (int i = 0; i < PACKET_SIZE; i++) {\n        crc ^= input_packet[i];\n        for (int j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc = (crc >> 1) ^ polynomial;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n\n    // Append CRC to the output packet\n    for (int i = 0; i < PACKET_SIZE; i++) {\n        output_packet[i] = input_packet[i];\n    }\n    output_packet[PACKET_SIZE - 2] = crc & 0xFF;\n    output_packet[PACKET_SIZE - 1] = (crc >> 8) & 0xFF;\n}\n\n// Top function name: ethernet_mac_controller\n"
      }
    ],
    "code_length": 800,
    "token_count": 233,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_deep_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2627163,
    "Worst-caseLatency": 2627163.0,
    "BRAM_18K": 5,
    "LUT": 1046,
    "DSP": 1,
    "FF": 177,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_deep_learning",
    "ResourceMetric": 0.000555281,
    "design_id": "project",
    "algo_name": "federated_deep_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_deep_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n#define FEATURE_SIZE 256\n#define NUM_CLIENTS 10\n\ntypedef ap_int<16> data_t;\n\nvoid federated_deep_learning(data_t global_model[FEATURE_SIZE], data_t client_data[NUM_CLIENTS][DATA_SIZE][FEATURE_SIZE], data_t updated_model[FEATURE_SIZE]) {\n    data_t local_models[NUM_CLIENTS][FEATURE_SIZE];\n    data_t sum_model[FEATURE_SIZE];\n\n    // Initialize sum_model to zero\n    for (int i = 0; i < FEATURE_SIZE; i++) {\n        sum_model[i] = 0;\n    }\n\n    // Local training on each client\n    for (int client = 0; client < NUM_CLIENTS; client++) {\n        for (int i = 0; i < FEATURE_SIZE; i++) {\n            local_models[client][i] = global_model[i];\n        }\n\n        for (int data_idx = 0; data_idx < DATA_SIZE; data_idx++) {\n            for (int feature = 0; feature < FEATURE_SIZE; feature++) {\n                local_models[client][feature] += client_data[client][data_idx][feature];\n            }\n        }\n    }\n\n    // Aggregate local models to update the global model\n    for (int client = 0; client < NUM_CLIENTS; client++) {\n        for (int i = 0; i < FEATURE_SIZE; i++) {\n            sum_model[i] += local_models[client][i];\n        }\n    }\n\n    for (int i = 0; i < FEATURE_SIZE; i++) {\n        updated_model[i] = sum_model[i] / NUM_CLIENTS;\n    }\n}\n\n// Top function name: federated_deep_learning\n"
      }
    ],
    "code_length": 1343,
    "token_count": 356,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_differential_privacy/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1030,
    "Worst-caseLatency": 1030.0,
    "BRAM_18K": 0,
    "LUT": 817,
    "DSP": 3,
    "FF": 632,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_differential_privacy",
    "ResourceMetric": 0.0003003813,
    "design_id": "project",
    "algo_name": "federated_differential_privacy",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_differential_privacy.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n#define EPSILON 1.0\n#define DELTA 1e-5\n#define SENSITIVITY 1.0\n\nvoid federated_differential_privacy(\n    double input[ARRAY_SIZE],\n    double output[ARRAY_SIZE],\n    double noise[ARRAY_SIZE])\n{\n    double scale = SENSITIVITY / EPSILON;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] + noise[i] * scale;\n    }\n}\n\n// Top function name: federated_differential_privacy\n"
      }
    ],
    "code_length": 452,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_neural_architecture_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048579,
    "Worst-caseLatency": 1048579.0,
    "BRAM_18K": 0,
    "LUT": 361,
    "DSP": 3,
    "FF": 158,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_neural_architecture_search",
    "ResourceMetric": 0.0001674882,
    "design_id": "project",
    "algo_name": "federated_neural_architecture_search",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_neural_architecture_search.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nvoid federated_neural_architecture_search(\n    ap_uint<32> input_data[LARGE_SCALE],\n    ap_uint<32> output_data[LARGE_SCALE],\n    ap_uint<32> weights[LARGE_SCALE],\n    ap_uint<32> biases[LARGE_SCALE])\n{\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        ap_uint<32> sum = 0;\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            sum += input_data[j] * weights[j];\n        }\n        output_data[i] = sum + biases[i];\n    }\n}\n\n// Top function name: federated_neural_architecture_search\n"
      }
    ],
    "code_length": 538,
    "token_count": 154,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/free_running_kernel_remerge_ii4to1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 54,
    "Worst-caseLatency": 54.0,
    "BRAM_18K": 0,
    "LUT": 626,
    "DSP": 0,
    "FF": 167,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 0.0001360572,
    "design_id": "project",
    "algo_name": "free_running_kernel_remerge_ii4to1",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//                    +--proc-->[ II=4 ]--+\n//                   /                     \\               \n// in -->[demux II=1]                       [mux II=1]---> out\n//                   \\                     /\n//                    +--proc-->[ II=4 ]--+\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_int.h\"\n#include <hls_stream.h>\nusing namespace hls;\n\n#include <iostream>\nusing namespace std;\n\n//--------------------------------------------\ntemplate <int ID> void proc(stream<int, 16>& in, stream<int, 16>& out) {\n    for (int i = 0; i < 25; i++) {\n#pragma HLS LATENCY min = 2 max = 2\n        int var;\n        in.read(var);\n        out.write(var);\n    }\n}\n\n//--------------------------------------------\nvoid mux(stream<int, 16> (&inter)[2], stream<int>& mux_output) {\n    int mux_sel = 0;\n    for (int i = 0; i < 50; i++) {\n        int var;\n        inter[mux_sel].read(var);\n        mux_output.write(var);\n        mux_sel = (mux_sel == 0) ? (1) : (0);\n    }\n}\n\n//--------------------------------------------\nvoid demux(stream<int>& in, stream<int, 16> (&inter)[2]) {\n    int demux_sel = 0;\n    for (int i = 0; i < 50; i++) {\n\n        int var;\n        in.read(var);\n        inter[demux_sel].write(var);\n        demux_sel = (demux_sel == 0) ? 1 : 0;\n    }\n}\n\nvoid example(stream<int>& in, stream<int>& out) {\n#pragma HLS INTERFACE mode = ap_ctrl_none port = return\n#pragma HLS DATAFLOW\n\n    stream<int, 16> inter[2];\n    stream<int, 16> mux_in[2];\n\n    demux(in, inter);\n    proc<0>(inter[0], mux_in[0]);\n    proc<1>(inter[1], mux_in[1]);\n    mux(mux_in, out);\n}\n"
      }
    ],
    "code_length": 2921,
    "token_count": 746,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/fsm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 212,
    "DSP": 0,
    "FF": 18,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fsm",
    "ResourceMetric": 4.238e-05,
    "design_id": "project",
    "algo_name": "fsm",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "fsm.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nenum State { STATE_0, STATE_1, STATE_2, STATE_3 };\n\nvoid fsm(ap_uint<1> input[LARGE_SCALE], ap_uint<1> output[LARGE_SCALE]) {\n    State current_state = STATE_0;\n\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        switch (current_state) {\n            case STATE_0:\n                if (input[i] == 1) {\n                    current_state = STATE_1;\n                }\n                output[i] = 0;\n                break;\n            case STATE_1:\n                if (input[i] == 0) {\n                    current_state = STATE_2;\n                }\n                output[i] = 1;\n                break;\n            case STATE_2:\n                if (input[i] == 1) {\n                    current_state = STATE_3;\n                }\n                output[i] = 0;\n                break;\n            case STATE_3:\n                if (input[i] == 0) {\n                    current_state = STATE_0;\n                }\n                output[i] = 1;\n                break;\n        }\n    }\n}\n\n// Top function name: fsm\n"
      }
    ],
    "code_length": 1051,
    "token_count": 252,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/gaussian_blur/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13601700,
    "Worst-caseLatency": 13601700.0,
    "BRAM_18K": 0,
    "LUT": 2046,
    "DSP": 10,
    "FF": 3150,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gaussian_blur",
    "ResourceMetric": 0.0009714195,
    "design_id": "project",
    "algo_name": "gaussian_blur",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "gaussian_blur.cpp",
        "file_content": "#include <cmath>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid gaussian_blur(const float input[HEIGHT][WIDTH], float output[HEIGHT][WIDTH]) {\n    const float kernel[5][5] = {\n        {1, 4, 7, 4, 1},\n        {4, 16, 26, 16, 4},\n        {7, 26, 41, 26, 7},\n        {4, 16, 26, 16, 4},\n        {1, 4, 7, 4, 1}\n    };\n    const float kernel_sum = 273.0;\n\n    for (int y = 2; y < HEIGHT - 2; y++) {\n        for (int x = 2; x < WIDTH - 2; x++) {\n            float sum = 0.0;\n            for (int ky = 0; ky < 5; ky++) {\n                for (int kx = 0; kx < 5; kx++) {\n                    sum += input[y + ky - 2][x + kx - 2] * kernel[ky][kx];\n                }\n            }\n            output[y][x] = sum / kernel_sum;\n        }\n    }\n}\n\n// Top function name: gaussian_blur\n"
      }
    ],
    "code_length": 771,
    "token_count": 281,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/gemm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1321125001,
    "Worst-caseLatency": 1321125001.0,
    "BRAM_18K": 0,
    "LUT": 1672,
    "DSP": 20,
    "FF": 1942,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_gemm",
    "ResourceMetric": 0.0010609125,
    "design_id": "project",
    "algo_name": "gemm",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "gemm.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _GEMM_H\n# define _GEMM_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(NI) && !defined(NJ) && !defined(NK)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define NI 20\n#   define NJ 25\n#   define NK 30\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define NI 60\n#   define NJ 70\n#   define NK 80\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define NI 200\n#   define NJ 220\n#   define NK 240\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define NI 1000\n#   define NJ 1100\n#   define NK 1200\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define NI 2000\n#   define NJ 2300\n#   define NK 2600\n#  endif\n\n\n#endif /* !(NI NJ NK) */\n\n# define _PB_NI POLYBENCH_LOOP_BOUND(NI,ni)\n# define _PB_NJ POLYBENCH_LOOP_BOUND(NJ,nj)\n# define _PB_NK POLYBENCH_LOOP_BOUND(NK,nk)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_GEMM_H */\n"
      },
      {
        "file_name": "gemm.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* gemm.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"gemm.h\"\n\n\n\n\n/* DCE code. Must scan the entire live-out data.\n\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_gemm(int ni, int nj, int nk,\n\t\t DATA_TYPE alpha,\n\t\t DATA_TYPE beta,\n\t\t DATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),\n\t\t DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\n\t\t DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj))\n{\n  int i, j, k;\n\n//BLAS PARAMS\n//TRANSA = 'N'\n//TRANSB = 'N'\n// => Form C := alpha*A*B + beta*C,\n//A is NIxNK\n//B is NKxNJ\n//C is NIxNJ\n#pragma scop\n  lp1: for (i = 0; i < _PB_NI; i++) {\n    lp2: for (j = 0; j < _PB_NJ; j++)\n\tC[i][j] *= beta;\n    lp3: for (k = 0; k < _PB_NK; k++) {\n       lp4: for (j = 0; j < _PB_NJ; j++)\n\t  C[i][j] += alpha * A[i][k] * B[k][j];\n    }\n  }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 1212,
    "token_count": 429,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/gradient_clipping/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 226,
    "DSP": 0,
    "FF": 158,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gradient_clipping",
    "ResourceMetric": 5.84883e-05,
    "design_id": "project",
    "algo_name": "gradient_clipping",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "gradient_clipping.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n#define CLIP_THRESHOLD 1.0\n\nvoid gradient_clipping(float gradients[ARRAY_SIZE], float clipped_gradients[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (gradients[i] > CLIP_THRESHOLD) {\n            clipped_gradients[i] = CLIP_THRESHOLD;\n        } else if (gradients[i] < -CLIP_THRESHOLD) {\n            clipped_gradients[i] = -CLIP_THRESHOLD;\n        } else {\n            clipped_gradients[i] = gradients[i];\n        }\n    }\n}\n\n// Top function name: gradient_clipping\n"
      }
    ],
    "code_length": 530,
    "token_count": 132,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/i2c_master_slave_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 221,
    "DSP": 0,
    "FF": 48,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "i2c_master_slave_controller",
    "ResourceMetric": 4.69824e-05,
    "design_id": "project",
    "algo_name": "i2c_master_slave_controller",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "i2c_master_slave_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid i2c_master_slave_controller(\n    uint8_t master_tx[ARRAY_SIZE], \n    uint8_t master_rx[ARRAY_SIZE], \n    uint8_t slave_tx[ARRAY_SIZE], \n    uint8_t slave_rx[ARRAY_SIZE], \n    uint8_t master_tx_size, \n    uint8_t slave_tx_size)\n{\n    uint8_t master_tx_index = 0;\n    uint8_t slave_tx_index = 0;\n    uint8_t master_rx_index = 0;\n    uint8_t slave_rx_index = 0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (master_tx_index < master_tx_size) {\n            slave_rx[slave_rx_index++] = master_tx[master_tx_index++];\n        }\n        if (slave_tx_index < slave_tx_size) {\n            master_rx[master_rx_index++] = slave_tx[slave_tx_index++];\n        }\n    }\n}\n\n// Top function name: i2c_master_slave_controller\n"
      }
    ],
    "code_length": 769,
    "token_count": 218,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/iir_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9236,
    "Worst-caseLatency": 9236.0,
    "BRAM_18K": 2,
    "LUT": 1133,
    "DSP": 5,
    "FF": 1408,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "iir_filter",
    "ResourceMetric": 0.0006147995,
    "design_id": "project",
    "algo_name": "iir_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "iir_filter.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid iir_filter(float input[N], float output[N], float a[3], float b[3]) {\n    float w[N] = {0};\n\n    for (int n = 0; n < N; n++) {\n        float wn = input[n];\n        if (n >= 1) {\n            wn -= a[1] * w[n - 1];\n        }\n        if (n >= 2) {\n            wn -= a[2] * w[n - 2];\n        }\n        w[n] = wn;\n\n        output[n] = b[0] * w[n];\n        if (n >= 1) {\n            output[n] += b[1] * w[n - 1];\n        }\n        if (n >= 2) {\n            output[n] += b[2] * w[n - 2];\n        }\n    }\n}\n\n// Top function name: iir_filter\n"
      }
    ],
    "code_length": 572,
    "token_count": 201,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/inorder_traversal/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1032,
    "Worst-caseLatency": 5128.0,
    "BRAM_18K": 1,
    "LUT": 547,
    "DSP": 0,
    "FF": 167,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "inorder_traversal",
    "ResourceMetric": 0.0001829117,
    "design_id": "project",
    "algo_name": "inorder_traversal",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "inorder_traversal.cpp",
        "file_content": "#include <iostream>\n\n#define NODES 1024\n\nstruct TreeNode {\n    int val;\n    int left;\n    int right;\n};\n\nvoid inorder_traversal(TreeNode nodes[NODES], int root, int result[NODES], int &index) {\n    int stack[NODES];\n    int top = -1;\n    int current = root;\n\n    for (int i = 0; i < NODES; i++) {\n        result[i] = -1;\n    }\n\n    index = 0;\n\n    for (int i = 0; i < NODES * 2; i++) {\n        if (current != -1) {\n            stack[++top] = current;\n            current = nodes[current].left;\n        } else if (top != -1) {\n            current = stack[top--];\n            result[index++] = nodes[current].val;\n            current = nodes[current].right;\n        } else {\n            break;\n        }\n    }\n}\n\n// Top function name: inorder_traversal\n"
      }
    ],
    "code_length": 751,
    "token_count": 206,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/jaccard_similarity/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 501,
    "DSP": 0,
    "FF": 219,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jaccard_similarity",
    "ResourceMetric": 0.0001170724,
    "design_id": "project",
    "algo_name": "jaccard_similarity",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "jaccard_similarity.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid jaccard_similarity(int32_t A[SIZE], int32_t B[SIZE], float *similarity) {\n    int32_t intersection = 0;\n    int32_t union_set = 0;\n\n    for (int i = 0; i < SIZE; i++) {\n        if (A[i] == 1 && B[i] == 1) {\n            intersection++;\n        }\n        if (A[i] == 1 || B[i] == 1) {\n            union_set++;\n        }\n    }\n\n    if (union_set == 0) {\n        *similarity = 0.0f;\n    } else {\n        *similarity = (float)intersection / (float)union_set;\n    }\n}\n\n// Top function name: jaccard_similarity\n"
      }
    ],
    "code_length": 549,
    "token_count": 174,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/jensen_shannon_divergence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 7199,
    "Worst-caseLatency": 7199.0,
    "BRAM_18K": 2,
    "LUT": 1667,
    "DSP": 18,
    "FF": 1660,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jensen_shannon_divergence",
    "ResourceMetric": 0.001101515,
    "design_id": "project",
    "algo_name": "jensen_shannon_divergence",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "jensen_shannon_divergence.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid jensen_shannon_divergence(float P[ARRAY_SIZE], float Q[ARRAY_SIZE], float& result) {\n    float M[ARRAY_SIZE];\n    float divergence = 0.0;\n\n    // Calculate M = 0.5 * (P + Q)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        M[i] = 0.5 * (P[i] + Q[i]);\n    }\n\n    // Calculate divergence = 0.5 * (sum(P * log(P / M)) + sum(Q * log(Q / M)))\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (P[i] > 0) {\n            divergence += P[i] * logf(P[i] / M[i]);\n        }\n        if (Q[i] > 0) {\n            divergence += Q[i] * logf(Q[i] / M[i]);\n        }\n    }\n\n    result = 0.5 * divergence;\n}\n\n// Top function name: jensen_shannon_divergence\n"
      }
    ],
    "code_length": 712,
    "token_count": 239,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/jk_flip_flop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 104,
    "DSP": 0,
    "FF": 28,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jk_flip_flop",
    "ResourceMetric": 2.26283e-05,
    "design_id": "project",
    "algo_name": "jk_flip_flop",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "jk_flip_flop.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid jk_flip_flop(ap_uint<1> J[SIZE], ap_uint<1> K[SIZE], ap_uint<1> clk[SIZE], ap_uint<1> Q[SIZE], ap_uint<1> Qn[SIZE]) {\n    ap_uint<1> state = 0; // Initial state of the flip-flop\n    for (int i = 0; i < SIZE; i++) {\n        if (clk[i] == 1) { // On the rising edge of the clock\n            if (J[i] == 0 && K[i] == 0) {\n                // No change\n            } else if (J[i] == 0 && K[i] == 1) {\n                state = 0; // Reset\n            } else if (J[i] == 1 && K[i] == 0) {\n                state = 1; // Set\n            } else if (J[i] == 1 && K[i] == 1) {\n                state = ~state; // Toggle\n            }\n        }\n        Q[i] = state;\n        Qn[i] = ~state;\n    }\n}\n\n// Top function name: jk_flip_flop\n"
      }
    ],
    "code_length": 766,
    "token_count": 265,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/kullback_leibler_divergence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2068,
    "Worst-caseLatency": 2068.0,
    "BRAM_18K": 0,
    "LUT": 1256,
    "DSP": 18,
    "FF": 1051,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kullback_leibler_divergence",
    "ResourceMetric": 0.0008402993,
    "design_id": "project",
    "algo_name": "kullback_leibler_divergence",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "kullback_leibler_divergence.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid kullback_leibler_divergence(const float P[ARRAY_SIZE], const float Q[ARRAY_SIZE], float &result) {\n    result = 0.0f;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (P[i] > 0 && Q[i] > 0) {\n            result += P[i] * logf(P[i] / Q[i]);\n        }\n    }\n}\n\n// Top function name: kullback_leibler_divergence\n"
      }
    ],
    "code_length": 362,
    "token_count": 120,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/laplace_approximation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5256146,
    "Worst-caseLatency": 5256146.0,
    "BRAM_18K": 0,
    "LUT": 2328,
    "DSP": 14,
    "FF": 2855,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "laplace_approximation",
    "ResourceMetric": 0.0011080275,
    "design_id": "project",
    "algo_name": "laplace_approximation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "laplace_approximation.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid laplace_approximation(double input[N][N], double output[N][N]) {\n    double laplace_kernel[3][3] = {\n        {0,  1, 0},\n        {1, -4, 1},\n        {0,  1, 0}\n    };\n\n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++) {\n                    sum += input[i + ki][j + kj] * laplace_kernel[ki + 1][kj + 1];\n                }\n            }\n            output[i][j] = sum;\n        }\n    }\n}\n\n// Top function name: laplace_approximation\n"
      }
    ],
    "code_length": 621,
    "token_count": 208,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/lu_decomposition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1068017,
    "Worst-caseLatency": 4284519398.0,
    "BRAM_18K": 0,
    "LUT": 2116,
    "DSP": 11,
    "FF": 1747,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lu_decomposition",
    "ResourceMetric": 0.0008780239,
    "design_id": "project",
    "algo_name": "lu_decomposition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "lu_decomposition.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    int i, j, k;\n\n    // Initialize L and U matrices\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            if (i == j) {\n                L[i][j] = 1.0;\n            } else {\n                L[i][j] = 0.0;\n            }\n            U[i][j] = 0.0;\n        }\n    }\n\n    // Perform LU Decomposition\n    for (k = 0; k < N; k++) {\n        U[k][k] = A[k][k];\n        for (i = k + 1; i < N; i++) {\n            L[i][k] = A[i][k] / U[k][k];\n            U[k][i] = A[k][i];\n        }\n        for (i = k + 1; i < N; i++) {\n            for (j = k + 1; j < N; j++) {\n                A[i][j] = A[i][j] - L[i][k] * U[k][j];\n            }\n        }\n    }\n}\n\n// Top function name: lu_decomposition\n"
      }
    ],
    "code_length": 806,
    "token_count": 290,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/md_grid/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4865,
    "Worst-caseLatency": 67895681.0,
    "BRAM_18K": 0,
    "LUT": 7371,
    "DSP": 109,
    "FF": 7927,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "md",
    "ResourceMetric": 0.0051932839,
    "design_id": "project",
    "algo_name": "md_grid",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "md.c",
        "file_content": "#include \"md.h\"\n\n#define MIN(x,y) ( (x)<(y) ? (x) : (y) )\n#define MAX(x,y) ( (x)>(y) ? (x) : (y) )\n\nvoid md( int n_points[blockSide][blockSide][blockSide],\n         dvector_t force[blockSide][blockSide][blockSide][densityFactor],\n         dvector_t position[blockSide][blockSide][blockSide][densityFactor] )\n{\n  ivector_t b0, b1; // b0 is the current block, b1 is b0 or a neighboring block\n  dvector_t p, q; // p is a point in b0, q is a point in either b0 or b1\n  int32_t p_idx, q_idx;\n  TYPE dx, dy, dz, r2inv, r6inv, potential, f;\n\n  // Iterate over the grid, block by block\n  loop_grid0_x: for( b0.x=0; b0.x<blockSide; b0.x++ ) {\n  loop_grid0_y: for( b0.y=0; b0.y<blockSide; b0.y++ ) {\n  loop_grid0_z: for( b0.z=0; b0.z<blockSide; b0.z++ ) {\n  // Iterate over the 3x3x3 (modulo boundary conditions) cube of blocks around b0\n  loop_grid1_x: for( b1.x=MAX(0,b0.x-1); b1.x<MIN(blockSide,b0.x+2); b1.x++ ) {\n    #pragma HLS loop_tripcount min=1 max=blockSide\n  loop_grid1_y: for( b1.y=MAX(0,b0.y-1); b1.y<MIN(blockSide,b0.y+2); b1.y++ ) {\n    #pragma HLS loop_tripcount min=1 max=blockSide\n  loop_grid1_z: for( b1.z=MAX(0,b0.z-1); b1.z<MIN(blockSide,b0.z+2); b1.z++ ) {\n    #pragma HLS loop_tripcount min=1 max=blockSide\n    // For all points in b0\n    dvector_t *base_q = position[b1.x][b1.y][b1.z];\n    int q_idx_range = n_points[b1.x][b1.y][b1.z];\n    loop_p: for( p_idx=0; p_idx<n_points[b0.x][b0.y][b0.z]; p_idx++ ) {\n      #pragma HLS loop_tripcount min=1 max=64 avg=1\n      p = position[b0.x][b0.y][b0.z][p_idx];\n      TYPE sum_x = force[b0.x][b0.y][b0.z][p_idx].x;\n      TYPE sum_y = force[b0.x][b0.y][b0.z][p_idx].y;\n      TYPE sum_z = force[b0.x][b0.y][b0.z][p_idx].z;\n      // For all points in b1\n      loop_q: for( q_idx=0; q_idx< q_idx_range ; q_idx++ ) {\n        #pragma HLS loop_tripcount min=1 max=64 avg=1\n        q = *(base_q + q_idx);\n\n        // Don't compute our own\n        if( q.x!=p.x || q.y!=p.y || q.z!=p.z ) {\n          // Compute the LJ-potential\n          dx = p.x - q.x;\n          dy = p.y - q.y;\n          dz = p.z - q.z;\n          r2inv = 1.0/( dx*dx + dy*dy + dz*dz );\n          r6inv = r2inv*r2inv*r2inv;\n          potential = r6inv*(lj1*r6inv - lj2);\n          // Update forces\n          f = r2inv*potential;\n          sum_x += f*dx;\n          sum_y += f*dy;\n          sum_z += f*dz;\n        }\n      } // loop_q\n      force[b0.x][b0.y][b0.z][p_idx].x = sum_x ;\n      force[b0.x][b0.y][b0.z][p_idx].y = sum_y ;\n      force[b0.x][b0.y][b0.z][p_idx].z = sum_z ;\n    } // loop_p\n  }}} // loop_grid1_*\n  }}} // loop_grid0_*\n}\n"
      },
      {
        "file_name": "md.h",
        "file_content": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"support.h\"\n\n#define TYPE double\n\n// Problem Constants\n#define nAtoms        256\n#define domainEdge    20.0\n#define blockSide     4\n//#define blockSide     1\n#define nBlocks       (blockSide*blockSide*blockSide)\n#define blockEdge     (domainEdge/((TYPE)blockSide))\n// Memory Bound\n// This is an artifact of using statically-allocated arrays. We'll pretend that\n// it doesn't exist and instead track the actual number of points.\n#define densityFactor 10\n// LJ coefficients\n#define lj1           1.5\n#define lj2           2.0\n\ntypedef struct {\n  TYPE x, y, z;\n} dvector_t;\ntypedef struct {\n  int32_t x, y, z;\n} ivector_t;\n\nvoid md( int32_t n_points[blockSide][blockSide][blockSide],\n         dvector_t force[blockSide][blockSide][blockSide][densityFactor],\n         dvector_t position[blockSide][blockSide][blockSide][densityFactor]\n       );\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  int32_t n_points[blockSide][blockSide][blockSide];\n  dvector_t force[blockSide][blockSide][blockSide][densityFactor];\n  dvector_t position[blockSide][blockSide][blockSide][densityFactor];\n};\n"
      }
    ],
    "code_length": 2557,
    "token_count": 963,
    "pragma_number": 5,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/mips/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 76,
    "Worst-caseLatency": 76.0,
    "BRAM_18K": 0,
    "LUT": 2308,
    "DSP": 8,
    "FF": 366,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "main",
    "ResourceMetric": 0.0006993174,
    "design_id": "project",
    "algo_name": "mips",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "mips.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*\n * Copyright (C) 2008\n * Y. Hara, H. Tomiyama, S. Honda, H. Takada and K. Ishii\n * Nagoya University, Japan\n * All rights reserved.\n *\n * Disclaimer of Warranty\n *\n * These software programs are available to the user without any license fee or\n * royalty on an \"as is\" basis. The authors disclaims any and all warranties, \n * whether express, implied, or statuary, including any implied warranties or \n * merchantability or of fitness for a particular purpose. In no event shall the\n * copyright-holder be liable for any incidental, punitive, or consequential damages\n * of any kind whatsoever arising from the use of these programs. This disclaimer\n * of warranty extends to the user of these programs and user's customers, employees,\n * agents, transferees, successors, and assigns.\n *\n */\n#include <stdio.h>\n#include \"imem.h\"\nint main_result;\n\n#define R 0\n\n#define ADDU 33\n#define SUBU 35\n\n#define MULT 24\n#define MULTU 25\n\n#define MFHI 16\n#define MFLO 18\n\n#define AND 36\n#define OR 37\n#define XOR 38\n#define SLL 0\n#define SRL 2\n#define SLLV 4\n#define SRLV 6\n\n#define SLT 42\n#define SLTU 43\n\n#define JR 8\n\n#define J 2\n#define JAL 3\n\n#define ADDIU 9\n#define ANDI 12\n#define ORI 13\n#define XORI 14\n\n#define LW 35\n#define SW 43\n#define LUI 15\n\n#define BEQ 4\n#define BNE 5\n#define BGEZ 1\n\n#define SLTI 10\n#define SLTIU 11\n\n/*\n+--------------------------------------------------------------------------+\n| * Test Vectors (added for CHStone)                                       |\n|     A : input data                                                       |\n|     outData : expected output data                                       |\n+--------------------------------------------------------------------------+\n*/\nconst int A[8] = { 22, 5, -9, 3, -17, 38, 0, 11 };\nconst int outData[8] = { -17, -9, 0, 3, 5, 11, 22, 38 };\n\n#define IADDR(x)\t(((x)&0x000000ff)>>2)\n#define DADDR(x)\t(((x)&0x000000ff)>>2)\n\nint\nmain ()\n{\n  long long hilo;\n  int reg[32];\n  int Hi = 0;\n  int Lo = 0;\n  int pc = 0;\n  int dmem[64];\n  int j;\n\n  unsigned int ins;\n  int op;\n  int rs;\n  int rt;\n  int rd;\n  int shamt;\n  int funct;\n  short address;\n  int tgtadr;\n\n    while (1)\n    {\n\t#pragma HLS loop_tripcount min=1 max=1\n      int i;\n      int n_inst;\n\n      n_inst = 0;\n      main_result = 0;\n\n      for (i = 0; i < 32; i++)\n\t{\n\t  reg[i] = 0;\n\t}\n      reg[29] = 0x7fffeffc;\n\n      for (i = 0; i < 64; i++)\n\t{\n\t  dmem[i] = A[i];\n\t}\n\n      pc = 0x00400000;\n\n      do\n\t{\n\t\t#pragma HLS loop_tripcount min=1 max=1\n\t  ins = imem[IADDR (pc)];\n\t  pc = pc + 4;\n\n\t  op = ins >> 26;\n\n\t  switch (op)\n\t    {\n\t    case R:\n\t      funct = ins & 0x3f;\n\t      shamt = (ins >> 6) & 0x1f;\n\t      rd = (ins >> 11) & 0x1f;\n\t      rt = (ins >> 16) & 0x1f;\n\t      rs = (ins >> 21) & 0x1f;\n\n\t      switch (funct)\n\t\t{\n\n\t\tcase ADDU:\n\t\t  reg[rd] = reg[rs] + reg[rt];\n\t\t  break;\n\t\tcase SUBU:\n\t\t  reg[rd] = reg[rs] - reg[rt];\n\t\t  break;\n\n\t\tcase MULT:\n\t\t  hilo = (long long) reg[rs] * (long long) reg[rt];\n\t\t  Lo = hilo & 0x00000000ffffffffULL;\n\t\t  Hi = ((int) (hilo >> 32)) & 0xffffffffUL;\n\t\t  break;\n\t\tcase MULTU:\n\t\t  hilo =\n\t\t    (unsigned long long) ((unsigned int) (reg[rs])) *\n\t\t    (unsigned long long) ((unsigned int) (reg[rt]));\n\t\t  Lo = hilo & 0x00000000ffffffffULL;\n\t\t  Hi = ((int) (hilo >> 32)) & 0xffffffffUL;\n\t\t  break;\n\n\t\tcase MFHI:\n\t\t  reg[rd] = Hi;\n\t\t  break;\n\t\tcase MFLO:\n\t\t  reg[rd] = Lo;\n\t\t  break;\n\n\t\tcase AND:\n\t\t  reg[rd] = reg[rs] & reg[rt];\n\t\t  break;\n\t\tcase OR:\n\t\t  reg[rd] = reg[rs] | reg[rt];\n\t\t  break;\n\t\tcase XOR:\n\t\t  reg[rd] = reg[rs] ^ reg[rt];\n\t\t  break;\n\t\tcase SLL:\n\t\t  reg[rd] = reg[rt] << shamt;\n\t\t  break;\n\t\tcase SRL:\n\t\t  reg[rd] = reg[rt] >> shamt;\n\t\t  break;\n\t\tcase SLLV:\n\t\t  reg[rd] = reg[rt] << reg[rs];\n\t\t  break;\n\t\tcase SRLV:\n\t\t  reg[rd] = reg[rt] >> reg[rs];\n\t\t  break;\n\n\t\tcase SLT:\n\t\t  reg[rd] = reg[rs] < reg[rt];\n\t\t  break;\n\t\tcase SLTU:\n\t\t  reg[rd] = (unsigned int) reg[rs] < (unsigned int) reg[rt];\n\t\t  break;\n\n\t\tcase JR:\n\t\t  pc = reg[rs];\n\t\t  break;\n\t\tdefault:\n\t\t  pc = 0;\t// error\n\t\t  break;\n\t\t}\n\t      break;\n\n\t    case J:\n\t      tgtadr = ins & 0x3ffffff;\n\t      pc = tgtadr << 2;\n\t      break;\n\t    case JAL:\n\t      tgtadr = ins & 0x3ffffff;\n\t      reg[31] = pc;\n\t      pc = tgtadr << 2;\n\t      break;\n\n\t    default:\n\n\t      address = ins & 0xffff;\n\t      rt = (ins >> 16) & 0x1f;\n\t      rs = (ins >> 21) & 0x1f;\n\t      switch (op)\n\t\t{\n\t\tcase ADDIU:\n\t\t  reg[rt] = reg[rs] + address;\n\t\t  break;\n\n\t\tcase ANDI:\n\t\t  reg[rt] = reg[rs] & (unsigned short) address;\n\t\t  break;\n\t\tcase ORI:\n\t\t  reg[rt] = reg[rs] | (unsigned short) address;\n\t\t  break;\n\t\tcase XORI:\n\t\t  reg[rt] = reg[rs] ^ (unsigned short) address;\n\t\t  break;\n\n\t\tcase LW:\n\t\t  reg[rt] = dmem[DADDR (reg[rs] + address)];\n\t\t  break;\n\t\tcase SW:\n\t\t  dmem[DADDR (reg[rs] + address)] = reg[rt];\n\t\t  break;\n\n\t\tcase LUI:\n\t\t  reg[rt] = address << 16;\n\t\t  break;\n\n\t\tcase BEQ:\n\t\t  if (reg[rs] == reg[rt])\n\t\t    pc = pc - 4 + (address << 2);\n\t\t  break;\n\t\tcase BNE:\n\t\t  if (reg[rs] != reg[rt])\n\t\t    pc = pc - 4 + (address << 2);\n\t\t  break;\n\t\tcase BGEZ:\n\t\t  if (reg[rs] >= 0)\n\t\t    pc = pc - 4 + (address << 2);\n\t\t  break;\n\n\t\tcase SLTI:\n\t\t  reg[rt] = reg[rs] < address;\n\t\t  break;\n\n\t\tcase SLTIU:\n\t\t  reg[rt] = (unsigned int) reg[rs] < (unsigned short) address;\n\t\t  break;\n\n\t\tdefault:\n\t\t  pc = 0;\t/* error */\n\t\t  break;\n\t\t}\n\t      break;\n\t    }\n\t  reg[0] = 0;\n\t  n_inst = n_inst + 1;\n\t}\n      while (pc != 0);\n\n      return main_result;\n    }\n}\n"
      },
      {
        "file_name": "imem.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*\n * Copyright (C) 2008\n * Y. Hara, H. Tomiyama, S. Honda, H. Takada and K. Ishii\n * Nagoya University, Japan\n * All rights reserved.\n *\n * Disclaimer of Warranty\n *\n * These software programs are available to the user without any license fee or\n * royalty on an \"as is\" basis. The authors disclaims any and all warranties, \n * whether express, implied, or statuary, including any implied warranties or \n * merchantability or of fitness for a particular purpose. In no event shall the\n * copyright-holder be liable for any incidental, punitive, or consequential damages\n * of any kind whatsoever arising from the use of these programs. This disclaimer\n * of warranty extends to the user of these programs and user's customers, employees,\n * agents, transferees, successors, and assigns.\n *\n */\nconst unsigned long imem[44] = {\n  0x8fa40000,\t\t\t// [0x00400000]  lw $4, 0($29)                   ; 175: lw $a0 0($sp)               # argc\n  0x27a50004,\t\t\t// [0x00400004]  addiu $5, $29, 4                ; 176: addiu $a1 $sp 4             # argv\n  0x24a60004,\t\t\t// [0x00400008]  addiu $6, $5, 4                 ; 177: addiu $a2 $a1 4             # envp\n  0x00041080,\t\t\t// [0x0040000c]  sll $2, $4, 2                   ; 178: sll $v0 $a0 2\n  0x00c23021,\t\t\t// [0x00400010]  addu $6, $6, $2                 ; 179: addu $a2 $a2 $v0\n  0x0c100016,\t\t\t// [0x00400014]  jal 0x00400058 [main]           ; 180: jal main\n  0x00000000,\t\t\t// [0x00400018]  nop                             ; 181: nop\n  0x3402000a,\t\t\t// [0x0040001c]  ori $2, $0, 10                  ; 183: li $v0 10\n  0x0000000c,\t\t\t// [0x00400020]  syscall                         ; 184: syscall                     # syscall 10 (exit)\n  0x3c011001,\t\t\t// [0x00400024]  lui $1, 4097 [A]                ; 4: la   $t0,A           ; C&S\n  0x34280000,\t\t\t// [0x00400028]  ori $8, $1, 0 [A]\n  0x00044880,\t\t\t// [0x0040002c]  sll $9, $4, 2                   ; 5: sll  $t1,$a0,2\n  0x01094821,\t\t\t// [0x00400030]  addu $9, $8, $9                 ; 6: addu $t1,$t0,$t1\n  0x8d2a0000,\t\t\t// [0x00400034]  lw $10, 0($9)                   ; 7: lw   $t2,($t1)\n  0x00055880,\t\t\t// [0x00400038]  sll $11, $5, 2                  ; 8: sll  $t3,$a1,2\n  0x010b5821,\t\t\t// [0x0040003c]  addu $11, $8, $11               ; 9: addu $t3,$t0,$t3\n  0x8d6c0000,\t\t\t// [0x00400040]  lw $12, 0($11)                  ; 10: lw   $t4,($t3)\n  0x018a682a,\t\t\t// [0x00400044]  slt $13, $12, $10               ; 11: slt  $t5,$t4,$t2\n  0x11a00003,\t\t\t// [0x00400048]  beq $13, $0, 12 [L1-0x00400048] ; 12: beq  $t5,$zero,L1\n  0xad2c0000,\t\t\t// [0x0040004c]  sw $12, 0($9)                   ; 13: sw   $t4,($t1)\n  0xad6a0000,\t\t\t// [0x00400050]  sw $10, 0($11)                  ; 14: sw   $t2,($t3)\n  0x03e00008,\t\t\t// [0x00400054]  jr $31                          ; 15: jr   $ra            ; L1\n  0x27bdfff4,\t\t\t// [0x00400058]  addiu $29, $29, -12             ; 17: addiu $sp,$sp,-12   ; main\n  0xafbf0008,\t\t\t// [0x0040005c]  sw $31, 8($29)                  ; 18: sw   $ra,8($sp)\n  0xafb10004,\t\t\t// [0x00400060]  sw $17, 4($29)                  ; 19: sw   $s1,4($sp)\n  0xafb00000,\t\t\t// [0x00400064]  sw $16, 0($29)                  ; 20: sw   $s0,0($sp)\n  0x24100000,\t\t\t// [0x00400068]  addiu $16, $0, 0                ; 21: addiu $s0,$zero,0\n  0x2a080008,\t\t\t// [0x0040006c]  slti $8, $16, 8                 ; 22: slti $t0,$s0,8      ; L5\n  0x1100000b,\t\t\t// [0x00400070]  beq $8, $0, 44 [L2-0x00400070]  ; 23: beq  $t0,$zero,L2\n  0x26110001,\t\t\t// [0x00400074]  addiu $17, $16, 1               ; 24: addiu $s1,$s0,1\n  0x2a280008,\t\t\t// [0x00400078]  slti $8, $17, 8                 ; 25: slti $t0,$s1,8      ; L4\n  0x11000006,\t\t\t// [0x0040007c]  beq $8, $0, 24 [L3-0x0040007c]  ; 26: beq  $t0,$zero,L3\n  0x26040000,\t\t\t// [0x00400080]  addiu $4, $16, 0                ; 27: addiu $a0,$s0,0\n  0x26250000,\t\t\t// [0x00400084]  addiu $5, $17, 0                ; 28: addiu $a1,$s1,0\n  0x0c100009,\t\t\t// [0x00400088]  jal 0x00400024 [compare_swap]   ; 29: jal  compare_swap\n  0x26310001,\t\t\t// [0x0040008c]  addiu $17, $17, 1               ; 30: addiu $s1,$s1,1\n  0x0810001e,\t\t\t// [0x00400090]  j 0x00400078 [L4]               ; 31: j    L4\n  0x26100001,\t\t\t// [0x00400094]  addiu $16, $16, 1               ; 32: addiu $s0,$s0,1     ; L3\n  0x0810001b,\t\t\t// [0x00400098]  j 0x0040006c [L5]               ; 33: j    L5\n  0x8fbf0008,\t\t\t// [0x0040009c]  lw $31, 8($29)                  ; 34: lw   $ra,8($sp)     ; L2\n  0x8fb10004,\t\t\t// [0x004000a0]  lw $17, 4($29)                  ; 35: lw   $s1,4($sp)\n  0x8fb00000,\t\t\t// [0x004000a4]  lw $16, 0($29)                  ; 36: lw   $s0,0($sp)\n  0x27bd000c,\t\t\t// [0x004000a8]  addiu $29, $29, 12              ; 37: addiu $sp,$sp,12\n  0x03e00008,\t\t\t// [0x004000ac]  jr $31                          ; 38: jr   $ra\n};\n"
      }
    ],
    "code_length": 6621,
    "token_count": 2012,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mlp/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1321474,
    "Worst-caseLatency": 1346818.0,
    "BRAM_18K": 6,
    "LUT": 5645,
    "DSP": 40,
    "FF": 3001,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mlp",
    "ResourceMetric": 0.0028504356,
    "design_id": "project",
    "algo_name": "mlp",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mlp.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 256\n\nvoid mlp(float input[INPUT_SIZE], float hidden_weights[HIDDEN_SIZE][INPUT_SIZE], float hidden_bias[HIDDEN_SIZE], float output_weights[OUTPUT_SIZE][HIDDEN_SIZE], float output_bias[OUTPUT_SIZE], float output[OUTPUT_SIZE]) {\n    float hidden_layer[HIDDEN_SIZE];\n    float sum;\n\n    // Compute hidden layer activations\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        sum = hidden_bias[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            sum += input[j] * hidden_weights[i][j];\n        }\n        hidden_layer[i] = tanh(sum); // Activation function\n    }\n\n    // Compute output layer activations\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        sum = output_bias[i];\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            sum += hidden_layer[j] * output_weights[i][j];\n        }\n        output[i] = tanh(sum); // Activation function\n    }\n}\n\n// Top function name: mlp\n"
      }
    ],
    "code_length": 976,
    "token_count": 256,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/modified/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 133,
    "Worst-caseLatency": 133.0,
    "BRAM_18K": 0,
    "LUT": 211,
    "DSP": 0,
    "FF": 67,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mem_bottleneck_resolved",
    "ResourceMetric": 4.68865e-05,
    "design_id": "project",
    "algo_name": "modified",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _ARRAY_MEM_PERFORM_H_\n#define _ARRAY_MEM_PERFORM_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 128\n\ntypedef ap_int<8> din_t;\ntypedef ap_int<16> dout_t;\n\ndout_t mem_bottleneck_resolved(din_t mem[N]);\n\n#endif\n\ndout_t mem_bottleneck_resolved(din_t mem[N]) {\n\n    din_t tmp0, tmp1, tmp2;\n    dout_t sum = 0;\n    int i;\n\n    tmp0 = mem[0];\n    tmp1 = mem[1];\nSUM_LOOP:\n    for (i = 2; i < N; i++) {\n        tmp2 = mem[i];\n        sum += tmp2 + tmp1 + tmp0;\n        tmp0 = tmp1;\n        tmp1 = tmp2;\n    }\n\n    return sum;\n}\n"
      }
    ],
    "code_length": 1964,
    "token_count": 502,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/nested_cross_validation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 0,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nested_cross_validation",
    "ResourceMetric": 0.0,
    "design_id": "project",
    "algo_name": "nested_cross_validation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "nested_cross_validation.cpp",
        "file_content": "#include <iostream>\n\n#define DATA_SIZE 1024\n\nvoid nested_cross_validation(float data[DATA_SIZE], float labels[DATA_SIZE], int k_folds, float results[DATA_SIZE]) {\n    int fold_size = DATA_SIZE / k_folds;\n    for (int i = 0; i < k_folds; i++) {\n        // Split data into training and validation sets\n        float train_data[DATA_SIZE - fold_size];\n        float train_labels[DATA_SIZE - fold_size];\n        float val_data[fold_size];\n        float val_labels[fold_size];\n\n        int train_idx = 0;\n        int val_idx = 0;\n        for (int j = 0; j < DATA_SIZE; j++) {\n            if (j >= i * fold_size && j < (i + 1) * fold_size) {\n                val_data[val_idx] = data[j];\n                val_labels[val_idx] = labels[j];\n                val_idx++;\n            } else {\n                train_data[train_idx] = data[j];\n                train_labels[train_idx] = labels[j];\n                train_idx++;\n            }\n        }\n\n        // Inner cross-validation\n        for (int m = 0; m < k_folds; m++) {\n            float inner_train_data[DATA_SIZE - 2 * fold_size];\n            float inner_train_labels[DATA_SIZE - 2 * fold_size];\n            float inner_val_data[fold_size];\n            float inner_val_labels[fold_size];\n\n            int inner_train_idx = 0;\n            int inner_val_idx = 0;\n            for (int n = 0; n < DATA_SIZE - fold_size; n++) {\n                if (n >= m * fold_size && n < (m + 1) * fold_size) {\n                    inner_val_data[inner_val_idx] = train_data[n];\n                    inner_val_labels[inner_val_idx] = train_labels[n];\n                    inner_val_idx++;\n                } else {\n                    inner_train_data[inner_train_idx] = train_data[n];\n                    inner_train_labels[inner_train_idx] = train_labels[n];\n                    inner_train_idx++;\n                }\n            }\n\n            // Train model on inner_train_data and inner_train_labels\n            // Validate model on inner_val_data and inner_val_labels\n            // Store the result\n        }\n\n        // Train final model on train_data and train_labels\n        // Validate final model on val_data and val_labels\n        // Store the result\n    }\n}\n\n// Top function name: nested_cross_validation\n"
      }
    ],
    "code_length": 2238,
    "token_count": 512,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/nussinov/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 37501,
    "Worst-caseLatency": 31312507501.0,
    "BRAM_18K": 0,
    "LUT": 1214,
    "DSP": 3,
    "FF": 495,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_nussinov",
    "ResourceMetric": 0.000363376,
    "design_id": "project",
    "algo_name": "nussinov",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "nussinov.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* nussinov.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"nussinov.h\"\n\n/* RNA bases represented as chars, range is [0,3] */\ntypedef char base;\n\n#define match(b1, b2) (((b1)+(b2)) == 3 ? 1 : 0)\n#define max_score(s1, s2) ((s1 >= s2) ? s1 : s2)\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/*\n  Original version by Dave Wonnacott at Haverford College <davew@cs.haverford.edu>,\n  with help from Allison Lake, Ting Zhou, and Tian Jin,\n  based on algorithm by Nussinov, described in Allison Lake's senior thesis.\n*/\nvoid kernel_nussinov(int n, base POLYBENCH_1D(seq,N,n),\n\t\t\t   DATA_TYPE POLYBENCH_2D(table,N,N,n,n))\n{\n  int i, j, k;\n\n#pragma scop\n for (i = _PB_N-1; i >= 0; i--) {\n  for (j=i+1; j<_PB_N; j++) {\n   #pragma HLS loop_tripcount min=1 max=_PB_N\n   if (j-1>=0)\n      table[i][j] = max_score(table[i][j], table[i][j-1]);\n   if (i+1<_PB_N)\n      table[i][j] = max_score(table[i][j], table[i+1][j]);\n\n   if (j-1>=0 && i+1<_PB_N) {\n     /* don't allow adjacent elements to bond */\n     if (i<j-1)\n        table[i][j] = max_score(table[i][j], table[i+1][j-1]+match(seq[i], seq[j]));\n     else\n        table[i][j] = max_score(table[i][j], table[i+1][j-1]);\n   }\n\n   for (k=i+1; k<j; k++) {\n      #pragma HLS loop_tripcount min=1 max=_PB_N\n      table[i][j] = max_score(table[i][j], table[i][k] + table[k+1][j]);\n   }\n  }\n }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "nussinov.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _NUSSINOV_H\n# define _NUSSINOV_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define N 60\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define N 180\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define N 500\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define N 2500\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define N 5500\n#  endif\n\n\n#endif /* !(N) */\n\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_INT\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_NUSSINOV_H */\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 1792,
    "token_count": 596,
    "pragma_number": 4,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/optical-flow/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 30429237,
    "Worst-caseLatency": 30429237.0,
    "BRAM_18K": 132,
    "LUT": 27479,
    "DSP": 64,
    "FF": 34472,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "optical_flow",
    "ResourceMetric": 0.0185323387,
    "design_id": "project",
    "algo_name": "optical-flow",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "xf_video_mem.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * HLS Video Memory Partition Header File\n */\n\n#ifndef ___XF__VIDEO_MEM__\n#define ___XF__VIDEO_MEM__\n\n//#define __DEBUG__\n\n#ifdef AESL_SYN\n#undef __DEBUG__\n#endif\n\n#include \"string.h\"\n#include \"xf_params.hpp\"\n\ntypedef ap_uint<32> XF_SIZE_T;\n\nnamespace xf {\nnamespace cv {\n\n//--------------------------------------------------------------------------------------\n// Template class of Window\n//--------------------------------------------------------------------------------------\ntemplate <int ROWS, int COLS, typename T>\nclass Window {\n   public:\n    Window(){\n// clang-format off\n\t#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=2\n        // clang-format on\n    };\n\n    /* Window main APIs */\n    void shift_pixels_left();\n    void shift_pixels_right();\n    void shift_pixels_up();\n    void shift_pixels_down();\n    void insert_pixel(T value, int row, int col);\n    void insert_row(T value[COLS], int row);\n    void insert_top_row(T value[COLS]);\n    void insert_bottom_row(T value[COLS]);\n    void insert_col(T value[ROWS], int col);\n    void insert_left_col(T value[ROWS]);\n    void insert_right_col(T value[ROWS]);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_left();\n    void shift_right();\n    void shift_up();\n    void shift_down();\n    void insert(T value, int row, int col);\n    void insert_top(T value[COLS]);\n    void insert_bottom(T value[COLS]);\n    void insert_left(T value[ROWS]);\n    void insert_right(T value[ROWS]);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void window_print();\n    T val_t[ROWS][COLS];\n#endif\n};\n\n/* Member functions of Window class */\n/* Origin in upper-left point */\n/*       0   1        C-2 C-1\n *     +---+---+-...-+---+---+\n *  0  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *  1  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *       ...     ...    ...\n *     +---+---+-...-+---+---+\n * R-2 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n * R-1 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *\n */\n\n/*\n * Window content shift left\n * Assumes new values will be placed in right column = COLS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_left() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS - 1; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j + 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n            else\n                assert(val_t[i][j + 1] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift right\n * Assumes new values will be placed in left column = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_right() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = COLS - 1; j > 0; j--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j - 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n            else\n                assert(val_t[i][j - 1] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift up\n * Assumes new values will be placed in bottom row = ROWS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_up() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i + 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift down\n * Assumes new values will be placed in top row = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_down() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i - 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert pixel\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    val[row][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row && j != col) assert(val_t[i][j] == val[i][j] && \"*** window insert_pixel mismatch! ***\");\n        }\n    }\n    val_t[row][col] = value;\n    assert(val_t[row][col] == val[row][col] && \"*** window insert_pixel mismatch! ***\");\n#endif\n}\n\n/* Window insert row\n * Inserts a set of values in any row of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T j;\n    for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[row][j] = value[j];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert top row\n * Inserts a set of values in top row = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert bottom row\n * Inserts a set of values in bottom row = ROWS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, ROWS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert column\n * Inserts a set of values in any column of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = value[i];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != col)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert left column\n * Inserts a set of values in left column = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_left_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_left_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert right column\n * Inserts a set of values in right column = COLS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, COLS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_right_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_right_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n#ifdef __DEBUG__\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::window_print() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            std::cout << std::setw(20) << val[i][j];\n        }\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift left, while contents shift right\n * Assumes new values will be placed in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_left() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_left(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift right, while contents shift left\n * Assumes new values will be placed in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_right() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_right(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_up() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_down() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_pixel(value, row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert top\n * Inserts a set of values in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert bottom\n * Inserts a set of values in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert left\n * Inserts a set of values in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_right_col(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert right\n * Inserts a set of values in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_left_col(value);\n}\n\n//--------------------------------------------------------------------------------------\n// Template class of Line Buffer\n//--------------------------------------------------------------------------------------\n#define _LB_TPLT_DEC \\\n    template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE = RAM_S2P_BRAM, int RESHAPE_FACTOR = 1>\n#define _LB_TPLT template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR>\n#define _LB_ LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>\n\n_LB_TPLT_DEC class LineBuffer {\n   public:\n    LineBuffer() {\n// clang-format off\n\t#pragma HLS INLINE\n        #pragma HLS dependence variable=val inter false\n        #pragma HLS dependence variable=val intra false\n        // clang-format on\n\n        // #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n        //#pragma HLS array_reshape variable=val factor=RESHAPE_FACTOR  dim=1\n\n        switch (MEM_TYPE) {\n            case RAM_1P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_1P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=URAM\n                // clang-format on\n                break;\n            case RAM_2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_S2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_S2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_T2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_T2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=URAM\n                // clang-format on\n                break;\n            default:\n                assert(\"MEM_TYPE should be one of RAM_*_BRAM or RAM_*_URAM (*: 1P, 2P, S2P, T2P)\");\n        }\n\n        if (RESHAPE_FACTOR == 1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n            // clang-format on\n        } else {\n// clang-format off\n            #pragma HLS ARRAY_RESHAPE variable=val factor=RESHAPE_FACTOR  dim=1\n            // clang-format on\n        }\n    };\n\n    /* LineBuffer main APIs */\n    void shift_pixels_up(int col);\n    void shift_pixels_down(int col);\n    void insert_bottom_row(T value, int col);\n    void insert_top_row(T value, int col);\n    void get_col(T value[ROWS], int col);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_up(int col);\n    void shift_down(int col);\n    void insert_bottom(T value, int col);\n    void insert_top(T value, int col);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void linebuffer_print(int col);\n    T val_t[ROWS][COLS];\n#endif\n};\n/* Member functions of LineBuffer class */\n/* Origin in upper-left point */\n/*       0   1            C-2 C-1\n *     +---+---+-... ...-+---+---+\n *  0  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *  1  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *       ...     ... ...    ...\n *     +---+---+-... ...-+---+---+\n * R-2 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n * R-1 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *\n */\n\n/* Member functions of LineBuffer class */\n\n/*\n * LineBuffer content shift down\n * Assumes new values will be placed in top row = 0\n */\n_LB_TPLT void _LB_::shift_pixels_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i - 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == 0)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n                else\n                    assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * LineBuffer content shift up\n * Assumes new values will be placed in top row = ROWS-1\n */\n_LB_TPLT void _LB_::shift_pixels_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i + 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == ROWS - 1)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n                else\n                    assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert bottom row\n * Inserts a new value in bottom row= ROWS-1 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_bottom_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[ROWS - 1][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == ROWS - 1)\n                assert(val[i][j] == value && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert top row\n * Inserts a new value in top row=0 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_top_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[0][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == 0)\n                assert(val[i][j] == value && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer get a column\n * Get a column value of the linebuffer\n */\n_LB_TPLT void _LB_::get_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        value[i] = val[i][col];\n    }\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\n_LB_TPLT void _LB_::shift_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::shift_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in bottom row(=0)\n */\n_LB_TPLT void _LB_::insert_bottom(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::insert_top(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value, col);\n}\n\n#ifdef __DEBUG__\n_LB_TPLT void _LB_::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\n_LB_TPLT void _LB_::linebuffer_print(int col) {\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        std::cout << std::setw(20) << val[i][col];\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n#undef _LB_TPLT_DEC\n#undef _LB_TPLT\n#undef _LB_\n\n} // namespace cv\n} // namespace xf\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "optical_flow.cpp",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                      optical_flow.cpp                         */\n/*                                                               */\n/*             Hardware function for optical flow                */\n/*                                                               */\n/*===============================================================*/\n\n#include \"optical_flow.h\"\n// use HLS video library\n// #include <hls_video.h>\n\n// use HLS fixed point\n#include \"ap_fixed.h\"\n\n#include \"xf_utility.hpp\"\n#include \"xf_common.hpp\"\n\n// define these constants so they can be used in pragma\nconst int max_width = MAX_WIDTH; \nconst int default_depth = MAX_WIDTH;\n// calculate gradient in x and y directions\nvoid gradient_xy_calc(input_t frame[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  // our own line buffer\n  static pixel_t buf[5][MAX_WIDTH];\n  #pragma HLS array_partition variable=buf complete dim=1\n\n  // small buffer\n  pixel_t smallbuf[5];\n  #pragma HLS array_partition variable=smallbuf complete dim=0\n  \n  // window buffer\n  xf::cv::Window<5,5,input_t> window;\n\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n\n  GRAD_XY_OUTER: for(int r=0; r<MAX_HEIGHT+2; r++)\n  {\n    GRAD_XY_INNER: for(int c=0; c<MAX_WIDTH+2; c++)\n    {\n      \n      // read out values from current line buffer\n      for (int i = 0; i < 4; i ++ )\n        smallbuf[i] = buf[i+1][c];\n      // the new value is either 0 or read from frame\n      if (r<MAX_HEIGHT && c<MAX_WIDTH)\n        smallbuf[4] = (pixel_t)(frame[r][c]);\n      else if (c < MAX_WIDTH)\n        smallbuf[4] = 0;\n      // update line buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n      else if(c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n\n      // manage window buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        window.shift_pixels_left();\n        \n        for (int i = 0; i < 5; i ++ )\n          window.insert_pixel(smallbuf[i],i,4);\n      }\n      else\n      {\n        window.shift_pixels_left();\n        window.insert_pixel(0,0,4);\n        window.insert_pixel(0,1,4);\n        window.insert_pixel(0,2,4);\n        window.insert_pixel(0,3,4);\n        window.insert_pixel(0,4,4);\n      }\n\n      // compute gradient\n      pixel_t x_grad = 0;\n      pixel_t y_grad = 0;\n      if(r>=4 && r<MAX_HEIGHT && c>=4 && c<MAX_WIDTH)\n      {\n        GRAD_XY_XYGRAD: for(int i=0; i<5; i++)\n        {\n          x_grad += window.getval(2,i)*GRAD_WEIGHTS[i];\n          y_grad += window.getval(i,2)*GRAD_WEIGHTS[i];\n        }\n        gradient_x[r-2][c-2] = x_grad/12;\n        gradient_y[r-2][c-2] = y_grad/12;\n      }\n      else if(r>=2 && c>=2)\n      {\n        gradient_x[r-2][c-2] = 0;\n        gradient_y[r-2][c-2] = 0;\n      }\n    }\n  }\n}\n\n// calculate gradient in the z direction\nvoid gradient_z_calc(input_t frame1[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame2[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame3[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame4[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame5[MAX_HEIGHT][MAX_WIDTH], \n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])\n{\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n  GRAD_Z_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_Z_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      gradient_z[r][c] =((pixel_t)(frame1[r][c]*GRAD_WEIGHTS[0] \n                        + frame2[r][c]*GRAD_WEIGHTS[1]\n                        + frame3[r][c]*GRAD_WEIGHTS[2]\n                        + frame4[r][c]*GRAD_WEIGHTS[3]\n                        + frame5[r][c]*GRAD_WEIGHTS[4]))/12;\n    }\n  }\n}\n\n// average the gradient in y direction\nvoid gradient_weight_y(pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH],\n    gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::LineBuffer<7,MAX_WIDTH,gradient_t> buf;\n\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+3; r++)\n  {\n    GRAD_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      #pragma HLS dependence variable=buf inter false\n\n      if(r<MAX_HEIGHT)\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = gradient_x[r][c];\n        tmp.y = gradient_y[r][c];\n        tmp.z = gradient_z[r][c];\n        buf.insert_bottom_row(tmp,c);\n      }\n      else\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;\n        buf.insert_bottom_row(tmp,c);\n      }     \n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(r >= 6 && r<MAX_HEIGHT)\n      { \n        GRAD_WEIGHT_Y_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(i,c).x*GRAD_FILTER[i];\n          acc.y += buf.getval(i,c).y*GRAD_FILTER[i];\n          acc.z += buf.getval(i,c).z*GRAD_FILTER[i];\n        }\n        filt_grad[r-3][c] = acc;\n      }\n      else if(r>=3)\n      {\n        filt_grad[r-3][c] = acc;\n      }\n    }\n  }\n}\n\n// average gradient in the x direction\nvoid gradient_weight_x(gradient_t y_filt[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::Window<1,7,gradient_t> buf;\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+3; c++)\n    {\n      \n      buf.shift_pixels_left();\n      gradient_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = y_filt[r][c];\n      }\n      else\n      {\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;  \n      }\n      buf.insert_pixel(tmp,0,6);\n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(c >= 6 && c<MAX_WIDTH) \n      {\n        GRAD_WEIGHT_X_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(0,i).x*GRAD_FILTER[i];\n          acc.y += buf.getval(0,i).y*GRAD_FILTER[i];\n          acc.z += buf.getval(0,i).z*GRAD_FILTER[i];\n        }\n        filt_grad[r][c-3] = acc;\n      }\n      else if(c>=3)\n      {\n        filt_grad[r][c-3] = acc;\n      }\n    }\n  }\n}\n\n// outer product \nvoid outer_product(gradient_t gradient[MAX_HEIGHT][MAX_WIDTH],\n     outer_t outer_product[MAX_HEIGHT][MAX_WIDTH])\n{\n  OUTER_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    OUTER_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      gradient_t grad = gradient[r][c];\n      outer_pixel_t x = (outer_pixel_t) grad.x;\n      outer_pixel_t y = (outer_pixel_t) grad.y;\n      outer_pixel_t z = (outer_pixel_t) grad.z;\n      outer_t out;\n      out.val[0] = (x*x);\n      out.val[1] = (y*y);\n      out.val[2] = (z*z);\n      out.val[3] = (x*y);\n      out.val[4] = (x*z);\n      out.val[5] = (y*z);\n      outer_product[r][c] = out;\n    }\n  }\n}\n\n// tensor weight\nvoid tensor_weight_y(outer_t outer[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::LineBuffer<3,MAX_WIDTH,outer_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+1; r++)\n  {\n    TENSOR_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      \n      outer_t tmp;\n      #pragma HLS data_pack variable=tmp\n      #pragma HLS data_pack variable=buf.val[0]\n      buf.shift_pixels_up(c);\n      if(r<MAX_HEIGHT)\n      {\n        tmp = outer[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_Y_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }   \n      buf.insert_bottom_row(tmp,c);\n\n      tensor_t acc;\n       v: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n     \n      if (r >= 2 && r < MAX_HEIGHT) \n      {\n        TENSOR_WEIGHT_Y_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(i,c);\n          pixel_t k = TENSOR_FILTER[i];\n          TENSOR_WEIGHT_Y_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*k;\n          }\n        }\n      }\n      if(r >= 1)\n      { \n        tensor_y[r-1][c] = acc;      \n      }\n    }\n  }\n}\n\nvoid tensor_weight_x(tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::Window<1,3,tensor_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  //const float TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    TENSOR_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+1; c++)\n    {\n      \n      buf.shift_pixels_left();\n      tensor_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = tensor_y[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_X_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }\n      buf.insert_pixel(tmp,0,2);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_X_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n      if (c >= 2 && c < MAX_WIDTH) \n      {\n        TENSOR_WEIGHT_X_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(0,i);\n          TENSOR_WEIGHT_X_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*TENSOR_FILTER[i];\n          }\n        }\n      }\n      if(c>=1)\n      {\n        tensor[r][c-1] = acc;\n      }\n    }\n  }\n}\n\n// compute output flow\nvoid flow_calc(tensor_t tensors[MAX_HEIGHT][MAX_WIDTH],\n               velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  static outer_pixel_t buf[2];\n  FLOW_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    FLOW_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      tensor_t tmp_tensor = tensors[r][c];\n      if(r>=2 && r<MAX_HEIGHT-2 && c>=2 && c<MAX_WIDTH-2)\n      {\n\t      calc_pixel_t t1 = (calc_pixel_t) tmp_tensor.val[0];\n\t      calc_pixel_t t2 = (calc_pixel_t) tmp_tensor.val[1];\n\t      calc_pixel_t t3 = (calc_pixel_t) tmp_tensor.val[2];\n\t      calc_pixel_t t4 = (calc_pixel_t) tmp_tensor.val[3];\n\t      calc_pixel_t t5 = (calc_pixel_t) tmp_tensor.val[4];\n\t      calc_pixel_t t6 = (calc_pixel_t) tmp_tensor.val[5];\n\n        calc_pixel_t denom = t1*t2-t4*t4;\n\t      calc_pixel_t numer0 = t6*t4-t5*t2;\n\t      calc_pixel_t numer1 = t5*t4-t6*t1;\n\n\t      if(denom != 0)\n        {\n          buf[0] = numer0 / denom;\n          buf[1] = numer1 / denom;\n\t      } \n\t      else\n\t      {\n\t\t      buf[0] = 0;\n\t\t      buf[1] = 0;\n\t      }\n      }\n      else\n      {\n        buf[0] = buf[1] = 0;\n      }\n\n      outputs[r][c].x = (vel_pixel_t)buf[0];\n      outputs[r][c].y = (vel_pixel_t)buf[1];\n\n    }\n  }\n}\n\n// top-level kernel function\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  #pragma HLS data_pack variable=outputs\n\n  #pragma HLS DATAFLOW\n\n  // FIFOs connecting the stages\n  static pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_x depth=default_depth\n  static pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_y depth=default_depth\n  static pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_z depth=max_width*4\n  static gradient_t y_filtered[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=y_filtered depth=default_depth\n  static gradient_t filtered_gradient[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=filtered_gradient depth=default_depth\n  static outer_t out_product[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=out_product depth=default_depth\n  #pragma HLS data_pack variable=out_product\n  static tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=tensor_y depth=default_depth\n  #pragma HLS data_pack variable=tensor_y\n  static tensor_t tensor[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=tensor depth=default_depth\n  #pragma HLS data_pack variable=tensor\n\n  // FIFOs for streaming in, just for clarity\n  static input_t frame1_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame1_a depth=default_depth\n  static input_t frame2_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame2_a depth=default_depth\n  static input_t frame4_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame4_a depth=default_depth\n  static input_t frame5_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame5_a depth=default_depth\n\n  //Need to duplicate frame3 for the two calculations\n  static input_t frame3_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame3_a depth=default_depth\n  static input_t frame3_b[MAX_HEIGHT][MAX_WIDTH];\n  // #pragma HLS STREAM variable=frame3_b depth=default_depth\n  // Cannot stream  'frame3_b.V': the stream channel does not have data consumer function.\n\n  // stream in and organize the inputs\n  static frames_t buf;\n  FRAMES_CP_OUTER: for (int r=0; r<MAX_HEIGHT; r++) \n  {\n    FRAMES_CP_INNER: for (int c=0; c<MAX_WIDTH; c++) \n    {\n      \n\n      // one wide read\n      buf = frames[r][c];\n      // assign values to the FIFOs\n      frame1_a[r][c] = ((input_t)(buf(7 ,  0)) >> 8);\n      frame2_a[r][c] = ((input_t)(buf(15,  8)) >> 8);\n      frame3_a[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame3_b[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame4_a[r][c] = ((input_t)(buf(31, 24)) >> 8);\n      frame5_a[r][c] = ((input_t)(buf(39, 32)) >> 8);\n    }\n  }\n  //\n  // compute\n  gradient_xy_calc(frame3_a, gradient_x, gradient_y);\n  gradient_z_calc(frame1_a, frame2_a, frame3_b, frame4_a, frame5_a, gradient_z);\n  gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);\n  gradient_weight_x(y_filtered, filtered_gradient);\n  outer_product(filtered_gradient, out_product);\n  tensor_weight_y(out_product, tensor_y);\n  tensor_weight_x(tensor_y, tensor);\n  flow_calc(tensor, outputs);\n\n}\n"
      },
      {
        "file_name": "optical_flow.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                       optical_flow.h                          */\n/*                                                               */\n/*             Hardware function for optical flow                */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __OPTICAL_FLOW_H__\n#define __OPTICAL_FLOW_H__\n\n#include \"typedefs.h\"\n\n// convolution filters\nconst int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\nconst pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\nconst pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n\n// top-level function \n#pragma SDS data access_pattern(frames:SEQUENTIAL, outputs:SEQUENTIAL)\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH]);\n\n#endif\n"
      },
      {
        "file_name": "typedefs.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                        typedefs.h                             */\n/*                                                               */\n/*        Defines types and constants for host function          */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\nconst int MAX_HEIGHT = 436;\nconst int MAX_WIDTH = 1024;\n\n// basic typedefs\n#ifndef SW\n\t#include \"ap_fixed.h\"\n\ttypedef ap_fixed<17,9> input_t;\n\ttypedef ap_fixed<32,13> pixel_t;\n\ttypedef ap_fixed<32,27> outer_pixel_t;\n\ttypedef ap_fixed<64,56> calc_pixel_t;\n\ttypedef ap_fixed<32,13> vel_pixel_t;\n#else\n\ttypedef float pixel_t;\n  typedef float outer_pixel_t;\n  typedef float vel_pixel_t;\n#endif\ntypedef struct{\n\tpixel_t x;\n\tpixel_t y;\n\tpixel_t z;\n}gradient_t;\n\ntypedef struct{\n    outer_pixel_t val[6];\n}outer_t; \n\ntypedef struct{\n    outer_pixel_t val[6];\n}tensor_t;\n\ntypedef struct{\n    vel_pixel_t x;\n    vel_pixel_t y;\n}velocity_t;\n\n#ifndef SW\n  #include \"ap_int.h\"\n  // for data packing\n  typedef ap_uint<64> frames_t;\n#endif\n\n#ifdef OCL\n  #include <string>\n  // change the target device here\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xf_types.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_TYPES_H_\n#define _XF_TYPES_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n#include \"xf_params.hpp\"\n#include <stdint.h>\n\ntemplate <int N>\nstruct floatn {\n    float f[N];\n    float& operator[](int idx) { return f[idx]; }\n    const float& operator[](int idx) const { return f[idx]; }\n};\ntypedef floatn<3> float3;\n\ntemplate <int T>\nstruct StreamType {};\ntemplate <>\nstruct StreamType<XF_2UW> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct StreamType<XF_8UW> {\n    typedef ap_uint<8> name;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct StreamType<XF_9UW> {\n    typedef ap_uint<9> name;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct StreamType<XF_10UW> {\n    typedef ap_uint<10> name;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct StreamType<XF_12UW> {\n    typedef ap_uint<12> name;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct StreamType<XF_14UW> {\n    typedef ap_uint<14> name;\n    static const int bitdepth = 14;\n};\ntemplate <>\nstruct StreamType<XF_16UW> {\n    typedef ap_uint<16> name;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct StreamType<XF_19SW> {\n    typedef ap_int<19> name;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct StreamType<XF_20UW> {\n    typedef ap_uint<20> name;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct StreamType<XF_22UW> {\n    typedef ap_uint<22> name;\n    static const int bitdepth = 22;\n};\ntemplate <>\nstruct StreamType<XF_24UW> {\n    typedef ap_uint<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_24SW> {\n    typedef ap_int<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_28UW> {\n    typedef ap_uint<28> name;\n    static const int bitdepth = 28;\n};\ntemplate <>\nstruct StreamType<XF_30UW> {\n    typedef ap_uint<30> name;\n    static const int bitdepth = 30;\n};\ntemplate <>\nstruct StreamType<XF_32UW> {\n    typedef ap_uint<32> name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_32FW> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_96FW> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_192FW> {\n    typedef floatn<6> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_384FW> {\n    typedef floatn<12> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_768FW> {\n    typedef floatn<24> name;\n    static const int bitdepth = 768;\n};\ntemplate <>\nstruct StreamType<XF_1536FW> {\n    typedef floatn<48> name;\n    static const int bitdepth = 1536;\n};\ntemplate <>\nstruct StreamType<XF_35SW> {\n    typedef ap_int<35> name;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct StreamType<XF_36UW> {\n    typedef ap_uint<36> name;\n    static const int bitdepth = 36;\n};\ntemplate <>\nstruct StreamType<XF_40UW> {\n    typedef ap_uint<40> name;\n    static const int bitdepth = 40;\n};\ntemplate <>\nstruct StreamType<XF_42UW> {\n    typedef ap_uint<42> name;\n    static const int bitdepth = 42;\n};\ntemplate <>\nstruct StreamType<XF_48UW> {\n    typedef ap_uint<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_48SW> {\n    typedef ap_int<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_56UW> {\n    typedef ap_uint<56> name;\n    static const int bitdepth = 56;\n};\ntemplate <>\nstruct StreamType<XF_60UW> {\n    typedef ap_uint<60> name;\n    static const int bitdepth = 60;\n};\ntemplate <>\nstruct StreamType<XF_64UW> {\n    typedef ap_uint<64> name;\n    static const int bitdepth = 64;\n};\ntemplate <>\nstruct StreamType<XF_72UW> {\n    typedef ap_uint<72> name;\n    static const int bitdepth = 72;\n};\ntemplate <>\nstruct StreamType<XF_80UW> {\n    typedef ap_uint<80> name;\n    static const int bitdepth = 80;\n};\ntemplate <>\nstruct StreamType<XF_84UW> {\n    typedef ap_uint<84> name;\n    static const int bitdepth = 84;\n};\ntemplate <>\nstruct StreamType<XF_96UW> {\n    typedef ap_uint<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_96SW> {\n    typedef ap_int<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_112UW> {\n    typedef ap_uint<112> name;\n    static const int bitdepth = 112;\n};\ntemplate <>\nstruct StreamType<XF_120UW> {\n    typedef ap_uint<120> name;\n    static const int bitdepth = 120;\n};\ntemplate <>\nstruct StreamType<XF_128UW> {\n    typedef ap_uint<128> name;\n    static const int bitdepth = 128;\n};\ntemplate <>\nstruct StreamType<XF_144UW> {\n    typedef ap_uint<144> name;\n    static const int bitdepth = 144;\n};\ntemplate <>\nstruct StreamType<XF_152SW> {\n    typedef ap_int<152> name;\n    static const int bitdepth = 152;\n};\ntemplate <>\nstruct StreamType<XF_160UW> {\n    typedef ap_uint<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_160SW> {\n    typedef ap_int<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_168UW> {\n    typedef ap_int<168> name;\n    static const int bitdepth = 168;\n};\ntemplate <>\nstruct StreamType<XF_176UW> {\n    typedef ap_uint<176> name;\n    static const int bitdepth = 176;\n};\ntemplate <>\nstruct StreamType<XF_192UW> {\n    typedef ap_uint<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_192SW> {\n    typedef ap_int<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_256UW> {\n    typedef ap_uint<256> name;\n    static const int bitdepth = 256;\n};\ntemplate <>\nstruct StreamType<XF_280SW> {\n    typedef ap_int<280> name;\n    static const int bitdepth = 280;\n};\ntemplate <>\nstruct StreamType<XF_288UW> {\n    typedef ap_uint<288> name;\n    static const int bitdepth = 288;\n};\ntemplate <>\nstruct StreamType<XF_304SW> {\n    typedef ap_int<304> name;\n    static const int bitdepth = 304;\n};\ntemplate <>\nstruct StreamType<XF_320UW> {\n    typedef ap_int<320> name;\n    static const int bitdepth = 320;\n};\ntemplate <>\nstruct StreamType<XF_336UW> {\n    typedef ap_int<336> name;\n    static const int bitdepth = 336;\n};\ntemplate <>\nstruct StreamType<XF_352UW> {\n    typedef ap_uint<352> name;\n    static const int bitdepth = 352;\n};\ntemplate <>\nstruct StreamType<XF_384UW> {\n    typedef ap_uint<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_384SW> {\n    typedef ap_int<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_512UW> {\n    typedef ap_uint<512> name;\n    static const int bitdepth = 512;\n};\ntemplate <>\nstruct StreamType<XF_560SW> {\n    typedef ap_int<560> name;\n    static const int bitdepth = 560;\n};\ntemplate <>\nstruct StreamType<XF_576UW> {\n    typedef ap_uint<576> name;\n    static const int bitdepth = 576;\n};\n\ntemplate <int T>\nstruct PixelType {};\ntemplate <>\nstruct PixelType<XF_8UP> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef unsigned char name2;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_8SP> {\n    typedef ap_int<8> name;\n    typedef ap_uint<8> uname;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_9UP> {\n    typedef ap_uint<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_9SP> {\n    typedef ap_int<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_16UP> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_16SP> {\n    typedef ap_int<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_32UP> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_32SP> {\n    typedef ap_int<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_19SP> {\n    typedef ap_int<19> name;\n    typedef ap_uint<19> uname;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct PixelType<XF_35SP> {\n    typedef ap_int<35> name;\n    typedef ap_uint<35> uname;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct PixelType<XF_32FP> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_96FP> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct PixelType<XF_24SP> {\n    typedef ap_int<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct PixelType<XF_20SP> {\n    typedef ap_int<20> name;\n    typedef ap_uint<20> uname;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct PixelType<XF_48SP> {\n    typedef ap_int<48> name;\n    typedef ap_uint<48> uname;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct PixelType<XF_2UP> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct PixelType<XF_24UP> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\n\ntemplate <>\nstruct PixelType<XF_10UP> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct PixelType<XF_12UP> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct PixelType<XF_14UP> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    static const int bitdepth = 14;\n};\n#define XF_NPIXPERCYCLE(flags) xfNPixelsPerCycle<flags>::nppc\n\n#define XF_BITSHIFT(flags) xfNPixelsPerCycle<flags>::datashift\n\ntemplate <int T>\nstruct xfNPixelsPerCycle {};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC1> {\n    static const int datashift = 0;\n    static const int nppc = 1;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC2> {\n    static const int datashift = 1;\n    static const int nppc = 2;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC4> {\n    static const int datashift = 2;\n    static const int nppc = 4;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC8> {\n    static const int datashift = 3;\n    static const int nppc = 8;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC16> {\n    static const int datashift = 4;\n    static const int nppc = 16;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC32> {\n    static const int datashift = 5;\n    static const int nppc = 32;\n};\n\ntemplate <int T, int M>\nstruct DataType {};\n\n// One channel data types\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC1> {\n    typedef ap_uint<2> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_2UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC32> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC4> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC8> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC1> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned char wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC2> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC4> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC8> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC16> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC32> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC64> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC1> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_10UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC2> {\n    typedef ap_uint<20> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_20UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC4> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC8> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC16> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC1> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_12UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC2> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC4> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC8> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC16> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC1> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_14UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC2> {\n    typedef ap_uint<28> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_28UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC4> {\n    typedef ap_uint<56> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_56UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC8> {\n    typedef ap_uint<112> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_112UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_64UC1, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<64> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 64;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_32FW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC1> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<3> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_96FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC2> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<6> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_192FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC4> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<12> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_384FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC8> {\n    typedef ap_uint<768> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<24> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_768FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC16> {\n    typedef ap_uint<1536> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<48> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_1536FW;\n    static const int channel = 3;\n};\n\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\n// Two channels data types\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 2;\n};\n\n// template<> struct DataType <XF_10UC2, XF_NPPC1>   { typedef ap_uint<40>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; typedef unsigned  short int sname; typedef unsigned long long int wname; static const int\n// bitdepth = 10; static const int pixeldepth = XF_40UP;static const int wordwidth = XF_40UW; static const int channel =\n// 4;}; template<> struct DataType <XF_10UC2, XF_NPPC2>   { typedef ap_uint<80>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; static const int bitdepth = 10; static const int pixeldepth = XF_40UP;static const int\n// wordwidth = XF_80UW; static const int channel = 4;};\n\n// Three channels data types (TODO: Pixeldepth of XF_16U3 needs correction)\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC16> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC1> {\n    typedef ap_uint<30> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_30UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC2> {\n    typedef ap_uint<60> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_60UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC4> {\n    typedef ap_uint<120> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_120UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC8> {\n    typedef ap_uint<240> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_240UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC1> {\n    typedef ap_uint<36> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_36UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC2> {\n    typedef ap_uint<72> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_72UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC4> {\n    typedef ap_uint<144> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_144UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC8> {\n    typedef ap_uint<288> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_288UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC1> {\n    typedef ap_uint<42> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_42UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC2> {\n    typedef ap_uint<84> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_84UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC4> {\n    typedef ap_uint<168> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_168UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC8> {\n    typedef ap_uint<336> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_336UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_48SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_96SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_192SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_384SW;\n    static const int channel = 3;\n};\n// Four channels data types\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC1> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC2> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC4> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC8> {\n    typedef ap_uint<320> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_320UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC2> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC4> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC8> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\n\n#define TC(TYPE) TC##TYPE\n\n#define XF_TNAME(flags, npc) typename DataType<flags, npc>::name\n\n#define XF_DTUNAME(flags, npc) typename DataType<flags, npc>::uname\n\n#define XF_CTUNAME(flags, npc) typename DataType<flags, npc>::cname\n\n#define XF_PTSNAME(flags, npc) typename DataType<flags, npc>::sname\n\n#define XF_WTNAME(flags, npc) typename DataType<flags, npc>::wname\n\n#define XF_DTPIXELDEPTH(flags, npc) DataType<flags, npc>::bitdepth\n\n#define XF_DEPTH(flags, npc) DataType<flags, npc>::pixeldepth\n\n#define XF_WORDWIDTH(flags, npc) DataType<flags, npc>::wordwidth\n\n#define XF_CHANNELS(flags, npc) DataType<flags, npc>::channel\n\n#define XF_PIXELWIDTH(flags, npc) DataType<flags, npc>::pixelwidth\n\n#define XF_PTNAME(flags) typename PixelType<flags>::name\n\n#define XF_PIXELDEPTH(flags) PixelType<flags>::bitdepth\n\n#define XF_PTUNAME(flags) typename PixelType<flags>::uname\n\n#define XF_PTNAME2(flags) typename PixelType<flags>::name2\n\n#define XF_SNAME(flags) typename StreamType<flags>::name\n#define XF_WORDDEPTH(flags) StreamType<flags>::bitdepth\n\n#define XF_NAME(flags, npc) ap_uint<(XF_DTPIXELDEPTH(flags, npc) / XF_CHANNELS(flags, npc)) * XF_NPIXPERCYCLE(npc)>\n\n// find image width in terms of the number of words used to represent the data\n//#define IM_WIDTH(W,S) ((W)>>(S))\n\n// Xilinx headers\n#include <ap_int.h>\n#include <ap_fixed.h>\n#include <stdint.h>\n// Native types\n// typedef unsigned long     uint64_t;\ntypedef unsigned int uint32_t;\ntypedef unsigned short uint16_t;\n// typedef long int        int64_t;\ntypedef int int32_t;\ntypedef short int int16_t;\ntypedef unsigned char uchar_t;\ntypedef unsigned char uint8_t;\ntypedef signed char int8_t;\n\n// Arbitrary Precision integer types\ntypedef ap_uint<1> ap_uint1_t;\ntypedef ap_uint<2> ap_uint2_t;\ntypedef ap_uint<4> ap_uint4_t;\ntypedef ap_uint<5> ap_uint5_t;\ntypedef ap_uint<8> ap_uint8_t;\ntypedef ap_uint<9> ap_uint9_t;\ntypedef ap_uint<16> ap_uint16_t;\ntypedef ap_uint<17> ap_uint17_t;\ntypedef ap_uint<18> ap_uint18_t;\ntypedef ap_uint<20> ap_uint20_t;\ntypedef ap_uint<22> ap_uint22_t;\ntypedef ap_uint<23> ap_uint23_t;\ntypedef ap_uint<24> ap_uint24_t;\ntypedef ap_uint<32> ap_uint32_t;\ntypedef ap_uint<33> ap_uint33_t;\ntypedef ap_uint<34> ap_uint34_t;\ntypedef ap_uint<35> ap_uint35_t;\ntypedef ap_uint<38> ap_uint38_t;\ntypedef ap_uint<45> ap_uint45_t;\ntypedef ap_uint<48> ap_uint48_t;\ntypedef ap_uint<51> ap_uint51_t;\ntypedef ap_uint<64> ap_uint64_t;\ntypedef ap_uint<66> ap_uint66_t;\ntypedef ap_uint<72> ap_uint72_t;\ntypedef ap_uint<97> ap_uint97_t;\ntypedef ap_uint<101> ap_uint101_t;\ntypedef ap_uint<128> ap_uint128_t;\ntypedef ap_uint<144> ap_uint144_t;\ntypedef ap_uint<176> ap_uint176_t;\ntypedef ap_uint<192> ap_uint192_t;\ntypedef ap_uint<256> ap_uint256_t;\ntypedef ap_uint<352> ap_uint352_t;\ntypedef ap_uint<384> ap_uint384_t;\ntypedef ap_uint<512> ap_uint512_t;\ntypedef ap_uint<576> ap_uint576_t;\n\ntypedef ap_int<8> ap_int8_t;\ntypedef ap_int<9> ap_int9_t;\ntypedef ap_int<12> ap_int12_t;\ntypedef ap_int<15> ap_int15_t;\ntypedef ap_int<16> ap_int16_t;\ntypedef ap_int<18> ap_int18_t;\ntypedef ap_int<19> ap_int19_t;\ntypedef ap_int<20> ap_int20_t;\ntypedef ap_int<24> ap_int24_t;\ntypedef ap_int<32> ap_int32_t;\ntypedef ap_int<35> ap_int35_t;\ntypedef ap_int<36> ap_int36_t;\ntypedef ap_int<42> ap_int42_t;\ntypedef ap_int<48> ap_int48_t;\ntypedef ap_int<64> ap_int64_t;\ntypedef ap_int<152> ap_int152_t;\ntypedef ap_int<304> ap_int304_t;\ntypedef ap_int<280> ap_int280_t;\ntypedef ap_int<560> ap_int560_t;\n\n// Arbitrary Precision fixed-point types\ntypedef ap_ufixed<12, 12> uint12_q0;\ntypedef ap_ufixed<16, 16> uint16_q0; // 16-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<32, 32> uint32_q0; // 32-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<8, 8> uint8_q0;    // 8-bit unsigned with 0 fractional bits\n\n#endif //_XF_TYPES_H_\n"
      },
      {
        "file_name": "xf_utility.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_UTILITY_H_\n#define _XF_UTILITY_H_\n\n#include \"ap_axi_sdata.h\"\n#include \"xf_common.hpp\"\n#include \"xf_video_mem.hpp\"\n#include <assert.h>\n#include <string.h>\n\nnamespace xf {\nnamespace cv {\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid Ptr2xfMat(ap_uint<BUS_WIDTH>* in_ptr, xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_mat.write(i, (XF_TNAME(TYPE, NPPC))in_ptr[i]);\n    }\n\n} // End of Ptr2xfMat()\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xfMat2Ptr(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat, ap_uint<BUS_WIDTH>* out_ptr) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_ptr[i] = in_mat.read(i);\n    }\n\n} // End of xfMat2Ptr()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                           ap_uint<BUS_WIDTH>* out_ptr,\n                           xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat.write(i, tmp);\n    }\n\n} // End of xFDuplicateMat_PTRMAT()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR and 2 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_1 = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_2 = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT2(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_1>& out_mat1,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_2>& out_mat2) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat1.write(i, tmp);\n        out_mat2.write(i, tmp);\n        // out_mat2.write(i, (XF_TNAME(XF_16SC1, NPPC))tmp); // TODO: Remove me as I am for experiment\n    }\n\n} // End of xFDuplicateMat_PTRMAT2()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR, 1 for xf::cv::Mat and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_MAT_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                                ap_uint<BUS_WIDTH>* out_ptr,\n                                xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat,\n                                hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n        out_mat.write(i, tmp);\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_MAT_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to stream out xf::cv::Mat on AXI bus for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFMat2AXI_Strm(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                    hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n\n        v.data = in_mat.read(i);\n        out_axi.write(v);\n    }\n\n} // End of xFMat2AXI_Strm()\n// ======================================================================================\n\n// ======================================================================================\n// Function to read AXI stream into xf::cv::Mat for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid AXI_Strm2xFMat(hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& in_axi,\n                    xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v = in_axi.read();\n\n        out_mat.write(i, v.data);\n    }\n\n} // End of AXI_Strm2xFMat()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to set border in the extracted kernel sized block\n// ======================================================================================\ntemplate <int K_ROWS, int K_COLS, typename SRC_T, int BORDER_T>\nvoid xFSetBorder(xf::cv::Window<K_ROWS, K_COLS, SRC_T>& src_blk,\n                 uint16_t _row,\n                 uint16_t _col,\n                 uint16_t _src_rows,\n                 uint16_t _src_cols) {\n#pragma HLS INLINE OFF\n\n    uint16_t blk_t_idx, blk_b_idx;\n    uint16_t blk_l_idx, blk_r_idx;\n\n    blk_t_idx = (K_ROWS - _row - 1);\n    blk_b_idx = (K_ROWS - (_row - _src_rows + 1) - 1);\n\n    blk_l_idx = (K_COLS - _col - 1);\n    blk_r_idx = (K_COLS - (_col - _src_cols + 1) - 1);\n\n    for (uint16_t r = 0; r < K_ROWS; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n        for (uint16_t c = 0; c < K_COLS; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n\n            bool top_border = ((r < blk_t_idx) && (_row < K_ROWS - 1)) ? true : false;\n            bool bottom_border = ((r > blk_b_idx) && (_row >= _src_rows)) ? true : false;\n            bool left_border = ((c < blk_l_idx) && (_col < K_COLS - 1)) ? true : false;\n            bool right_border = ((c > blk_r_idx) && (_col >= _src_cols)) ? true : false;\n\n            uint16_t r_idx = r, c_idx = c;\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                r_idx = top_border ? blk_t_idx : bottom_border ? blk_b_idx : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                r_idx = top_border ? (2 * blk_t_idx - r) : bottom_border ? (2 * blk_b_idx - r) : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                r_idx = top_border ? (2 * blk_t_idx - r - 1) : bottom_border ? (2 * blk_b_idx - r + 1) : r;\n\n            } else { // TODO: Need to add other modes support\n                r_idx = r;\n            }\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                c_idx = left_border ? blk_l_idx : right_border ? blk_r_idx : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                c_idx = left_border ? (2 * blk_l_idx - c) : right_border ? (2 * blk_r_idx - c) : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                c_idx = left_border ? (2 * blk_l_idx - c - 1) : right_border ? (2 * blk_r_idx - c + 1) : c;\n\n            } else { // TODO: Need to add other modes support\n                c_idx = c;\n            }\n\n            if ((top_border | bottom_border | left_border | right_border) && (BORDER_T == XF_BORDER_CONSTANT)) {\n                src_blk.val[r][c] = 0;\n            } else {\n                src_blk.val[r][c] = src_blk.val[r_idx][c_idx];\n            }\n        }\n    }\n\n} // End of xFSetBorder()\n// ======================================================================================\n\n/**\n * Extract Pixels from a packed word into an array from the index pos.\n * The number of pixels to be extracted is determined by the NPC.\n */\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfPackPixels(\n    XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val, uint16_t pos, int16_t loopIter, uint16_t& shift) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<8> STEP = XF_PIXELDEPTH(PIXELDEPTH);\n\n    for (ap_int<9> i = 0; i < loopIter; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        XF_PTUNAME(PIXELDEPTH) tmp = tmp_buf[pos];\n        val = val | (((XF_SNAME(WORDWIDTH))tmp) << (shift * STEP));\n        pos++;\n        shift++;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfExtractPixels(XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val1, int pos) {\n// clang-format off\n    #pragma HLS inline off\n    // clang-format on\n    XF_SNAME(WORDWIDTH) v = val1;\n\n    int shift = 0;\n    int STEP = XF_PIXELDEPTH(PIXELDEPTH);\nExtract_pixels_loop:\n    for (int i = 0; i < (1 << (XF_BITSHIFT(NPC))); i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        tmp_buf[pos + i] = v.range(shift + STEP - 1, shift);\n        shift = shift + STEP;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH_SRC, int DEPTH_SRC>\nvoid xfExtractData(XF_PTNAME(DEPTH_SRC) * src_buf1,\n                   XF_PTNAME(DEPTH_SRC) * src_buf2,\n                   XF_PTNAME(DEPTH_SRC) * src_buf3,\n                   XF_PTNAME(DEPTH_SRC) * src_buf4,\n                   XF_PTNAME(DEPTH_SRC) * src_buf5,\n                   XF_PTNAME(DEPTH_SRC) * src_buf6,\n                   XF_PTNAME(DEPTH_SRC) * src_buf7,\n                   XF_SNAME(WORDWIDTH_SRC) buf0,\n                   XF_SNAME(WORDWIDTH_SRC) buf1,\n                   XF_SNAME(WORDWIDTH_SRC) buf2,\n                   XF_SNAME(WORDWIDTH_SRC) buf3,\n                   XF_SNAME(WORDWIDTH_SRC) buf4,\n                   XF_SNAME(WORDWIDTH_SRC) buf5,\n                   XF_SNAME(WORDWIDTH_SRC) buf6) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf1[6], buf0, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf2[6], buf1, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf3[6], buf2, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf4[6], buf3, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf5[6], buf4, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf6[6], buf5, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf7[6], buf6, 0);\n}\n\ntemplate <int NPC, int DEPTH_SRC>\nvoid xfCopyData(XF_PTNAME(DEPTH_SRC) src_buf1[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf2[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf3[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf4[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf5[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf6[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf7[XF_NPIXPERCYCLE(NPC) + 6]) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<5> buf_size = (XF_NPIXPERCYCLE(NPC) + 6);\n    ap_uint<4> i = 0;\n    ap_uint<4> ind = buf_size - 6;\n\n    for (i = 0; i < 6; i++, ind++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=6 max=6\n#pragma HLS unroll factor=1\n        // clang-format on\n        src_buf1[i] = src_buf1[ind];\n        src_buf2[i] = src_buf2[ind];\n        src_buf3[i] = src_buf3[ind];\n        src_buf4[i] = src_buf4[ind];\n        src_buf5[i] = src_buf5[ind];\n        src_buf6[i] = src_buf6[ind];\n        src_buf7[i] = src_buf7[ind];\n    }\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut1(XF_SNAME(WORDWIDTH) * _src, unsigned long long int* _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, SIZE);\n#else\n    if (nbytes) memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn1(unsigned long long int* _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((AU_TNAME(WORDWIDTH)*)_dst, (AU_TNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\ntemplate <int WORDWIDTH, int NPC, int IN_BH, int IN_BW>\nvoid xFDuplicateStream(hls::stream<XF_SNAME(WORDWIDTH)>& in_strm,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm1,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm2,\n                       int imwidth,\n                       int imheight) {\n    for (int i = 0; i < imheight; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=IN_BH max=IN_BH\n        #pragma HLS LOOP_FLATTEN off\n        // clang-format on\n        for (int j = 0; j < (imwidth >> NPC); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS pipeline\n            #pragma HLS LOOP_TRIPCOUNT min=IN_BW max=IN_BW\n            // clang-format on\n            XF_SNAME(WORDWIDTH) tmp = in_strm.read();\n            out_strm1.write(tmp);\n            out_strm2.write(tmp);\n        }\n    }\n}\n\n// ==============================================================================\n// Class contains funcitons requried for accel file (top wrapper file)\n// ==============================================================================\nclass accel_utils {\n   public:\n    // ==============================================================================\n    // Read module(s) to handle data transfer from AXI/HLS stream to xfMat\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void Array2hlsStrm(ap_uint<PTR_WIDTH>* srcPtr, hls::stream<ap_uint<PTR_WIDTH> >& dstStrm, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstStrm.write(srcPtr[i]);\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void hlsStrm2xfMat(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat,\n                       int dstMat_cols_align_npc) {\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int loop_count = (rows * dstMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = dstMat_cols_align_npc - cols;\n        int in_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * dstMat_cols_align_npc; // channels\n        int ddr_read_cycles = (((in_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_read_cnt = 0;\n\n        int valid_bits = 0;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        int K_size;\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) out;\n        int ncpr = dstMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n        int strm_cnt_disply = 0;\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            int valid_bits_update;\n            int valid_bits_tmp = valid_bits - K_size;\n            XF_TNAME(MAT_T, NPC) out = 0;\n\n            if (valid_bits < K_size) {\n                if (valid_bits != 0) {\n                    out.range(valid_bits - 1, 0) = r.range(PTR_WIDTH - 1, PTR_WIDTH - valid_bits);\n                }\n                if (ddr_read_cnt < ddr_read_cycles) {\n                    r = srcStrm.read();\n                    ddr_read_cnt++;\n                } else {\n                    r = 0;\n                }\n                out.range(K_size - 1, valid_bits) = r.range(K_size - valid_bits - 1, 0);\n                valid_bits = PTR_WIDTH_min_Ksize + valid_bits;\n            } else {\n                out = r.range(PTR_WIDTH_plus_Ksize - valid_bits - 1, PTR_WIDTH - valid_bits);\n                valid_bits = valid_bits - K_size;\n            }\n\n            dstMat.write(i, out);\n        }\n        int stop = 0;\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\n    void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                     xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        Array2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH>(strm, dstMat,\n                                                                                         dstMat_cols_align_npc);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void axiStrm2hlsStrm(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                         hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = srcPtr.read();\n            dstStrm.write(v.data);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        axiStrm2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH_OUT>(strm, dstMat,\n                                                                                             dstMat_cols_align_npc);\n    }\n\n    // ==============================================================================\n    // Write module(s) to handle data transfer from xfMat to AXI/HLS stream\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void xfMat2hlsStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& srcMat,\n                       hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                       int srcMat_cols_align_npc) {\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int loop_count = (rows * srcMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = srcMat_cols_align_npc - cols;\n        int out_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * srcMat_cols_align_npc; // channels\n        int ddr_write_cycles = (((out_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_write_cnt = 0;\n\n        int bits_to_add = PTR_WIDTH;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) in;\n        int ncpr = srcMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            int K_size;\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            in = srcMat.read(i);\n\n            if (bits_to_add <= K_size) {\n                r.range(PTR_WIDTH - 1, PTR_WIDTH - bits_to_add) = in.range(bits_to_add - 1, 0);\n                dstStrm.write(r);\n\n                if (bits_to_add != K_size) {\n                    r.range(K_size - bits_to_add - 1, 0) = in.range(K_size - 1, bits_to_add);\n                }\n                bits_to_add = PTR_WIDTH_min_Ksize + bits_to_add;\n            } else {\n                r.range(PTR_WIDTH_plus_Ksize - bits_to_add - 1, PTR_WIDTH - bits_to_add) = in;\n                bits_to_add -= K_size;\n            }\n        }\n\n        if (bits_to_add != PTR_WIDTH) {\n            dstStrm.write(r);\n        }\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2Array(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstPtr[i] = srcStrm.read();\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int XFCVDEPTH = _XFCVDEPTH_DEFAULT,\n              int FILLZERO = 1>\n    void xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                     ap_uint<PTR_WIDTH>* dstPtr,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2Array<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2axiStrm(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                         hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = srcStrm.read();\n            dstPtr.write(v);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\n    void xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_IN>& srcMat,\n                       hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH_IN>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2axiStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT, int FILLZERO = 1>\nvoid xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat, ap_uint<PTR_WIDTH>* dstPtr, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n    accel_utils au;\n    au.xfMat2Array<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcMat, dstPtr);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n    accel_utils au;\n    au.Array2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcPtr, dstMat);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                   hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n    accel_utils au;\n    au.xfMat2axiStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>(srcMat, dstPtr);\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                   xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n    accel_utils au;\n    au.axiStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>(srcPtr, dstMat);\n}\n\n} // namespace cv\n} // namespace xf\n\n#endif //_XF_UTILITY_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "xf_structs.hpp",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_STRUCTS_H_\n#define _XF_STRUCTS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#ifndef __SYNTHESIS__\n#include <iostream>\n#endif\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include \"xf_types.hpp\"\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <type_traits>\n\nnamespace xf {\nnamespace cv {\n\ntemplate <int T>\nap_uint<T> xf_satcast(int in_val) {\n    if (in_val > ((1 << T) - 1)) {\n        return ((1 << T) - 1);\n    } else if (in_val < 0) {\n        return 0;\n    } else {\n        return in_val;\n    }\n}\n\ntemplate <typename T>\nT float2ap_uint(float val) {\n    T* val_out = (T*)(&val);\n    return *val_out;\n}\n\ntemplate <typename T>\nfloat ap_uint2float(T val) {\n    float* val_out = (float*)(&val);\n    return *val_out;\n}\n\n//----------------------------------------------------------------------------------------------------//\n//  LOCAL STEREO BLOCK MATCHING UTILITY\n//----------------------------------------------------------------------------------------------------//\ntemplate <int WSIZE, int NDISP, int NDISP_UNIT>\nclass xFSBMState {\n   public:\n    // pre-filtering (normalization of input images)\n    int preFilterType; // =HLS_STEREO_BM_XSOBEL_TEST\n    int preFilterSize; // averaging window size: ~5x5..21x21\n    int preFilterCap;  // the output of pre-filtering is clipped by\n                       // [-preFilterCap,preFilterCap]\n\n    // correspondence using Sum of Absolute Difference (SAD)\n    int SADWindowSize;       // ~5x5..21x21 // defined in macro\n    int minDisparity;        // minimum disparity (can be negative)\n    int numberOfDisparities; // maximum disparity - minimum disparity (> 0)\n\n    // post-filtering\n    int textureThreshold; // the disparity is only computed for pixels\n\n    // with textured enough neighborhood\n    int uniquenessRatio; // accept the computed disparity d* only if\n    // SAD(d) >= SAD(d*)*(1 + uniquenessRatio/100.)\n    // for any d != d*+/-1 within the search range.\n\n    // int speckleWindowSize; // disparity variation window\n    // int speckleRange;      // acceptable range of variation in window\n\n    int ndisp_unit;\n    int sweepFactor;\n    int remainder;\n\n    xFSBMState() {\n        preFilterType = XF_STEREO_PREFILTER_SOBEL_TYPE; // Default Sobel filter\n        preFilterSize = WSIZE;\n        preFilterCap = 31;\n        SADWindowSize = WSIZE;\n        minDisparity = 0;\n        numberOfDisparities = NDISP;\n        textureThreshold = 10;\n        uniquenessRatio = 15;\n        sweepFactor = (NDISP / NDISP_UNIT) + ((NDISP % NDISP_UNIT) != 0);\n        ndisp_unit = NDISP_UNIT;\n        remainder = NDISP_UNIT * sweepFactor - NDISP;\n    }\n};\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Point_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Point_ {\n   public:\n    Point_();\n    Point_(T _x, T _y);\n    Point_(const Point_& pt);\n    ~Point_();\n\n    T x, y;\n};\n\n/* Member functions of Point_ class */\ntemplate <typename T>\ninline Point_<T>::Point_() {}\ntemplate <typename T>\ninline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}\ntemplate <typename T>\ninline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}\ntemplate <typename T>\ninline Point_<T>::~Point_() {}\n\ntypedef Point_<int> Point;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Size_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Size_ {\n   public:\n    Size_();\n    Size_(T _width, T _height);\n    Size_(const Size_<T>& sz);\n    Size_(const Point_<T>& pt);\n    T area();\n    ~Size_();\n\n    T width, height;\n};\n\n/* Member functions of Size_ class */\ntemplate <typename T>\ninline Size_<T>::Size_() {}\ntemplate <typename T>\ninline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}\ntemplate <typename T>\ninline T Size_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T>::~Size_() {}\n\ntypedef Size_<int> Size;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Rect_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Rect_ {\n   public:\n    Rect_();\n    Rect_(T _x, T _y, T _width, T _height);\n    Rect_(const Rect_& rect);\n    Rect_(const Point_<T>& pt, const Size_<T>& sz);\n    T area();\n    Size_<T> size();\n    Point_<T> tl(); // top-left point(inside);\n    Point_<T> tr(); // top-right point(outside);\n    Point_<T> bl(); // bottom-left point(outside);\n    Point_<T> br(); // bottom-right point(outside);\n    bool bContains(const Point_<T>& pt);\n    ~Rect_();\n\n    T x, y, width, height;\n};\n\n/* Member functions of Rect_ class */\ntemplate <typename T>\ninline Rect_<T>::Rect_() {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz)\n    : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline T Rect_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T> Rect_<T>::size() {\n    return Size_<T>(width, height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tl() {\n    return Point_<T>(x, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tr() {\n    return Point_<T>(x + width, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::bl() {\n    return Point_<T>(x, y + height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::br() {\n    return Point_<T>(x + width, y + height);\n}\ntemplate <typename T>\ninline bool Rect_<T>::bContains(const Point_<T>& pt) {\n    return (pt.x >= x && pt.x < x + width && pt.y >= y && pt.y < y + height);\n}\ntemplate <typename T>\ninline Rect_<T>::~Rect_() {}\n\ntypedef Rect_<int> Rect;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Scalar\n//----------------------------------------------------------------------------------------------------//\ntemplate <int N, typename T>\nclass Scalar {\n   public:\n    Scalar() {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N > 0);\n    }\n    Scalar(T v0) {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N >= 1 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n    }\n    Scalar(T v0, T v1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 2 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n    }\n    Scalar(T v0, T v1, T v2) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 3 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n    }\n    Scalar(T v0, T v1, T v2, T v3) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 4 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n        val[3] = v3;\n    }\n\n    void operator=(T value);\n    Scalar<N, T> operator+(T value);\n    Scalar<N, T> operator+(Scalar<N, T> s);\n    Scalar<N, T> operator-(T value);\n    Scalar<N, T> operator-(Scalar<N, T> s);\n    Scalar<N, T> operator*(T value);\n    Scalar<N, T> operator*(Scalar<N, T> s);\n    Scalar<N, T> operator/(T value);\n    Scalar<N, T> operator/(Scalar<N, T> s);\n\n    T val[N];\n};\n\ntemplate <int N, typename T>\nvoid Scalar<N, T>::operator=(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[k] = value;\n    }\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / s.val[k];\n    }\n    return res;\n}\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Mat\n//----------------------------------------------------------------------------------------------------//\n#if defined(__SYNTHESIS__) && !defined(__SDA_MEM_MAP__)\nstatic constexpr int _XFCVDEPTH_DEFAULT = 2;\n#else\nstatic constexpr int _XFCVDEPTH_DEFAULT = -1;\n#endif\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass Mat {\n   public:\n    unsigned char allocatedFlag; // flag to mark memory allocation in this class\n    int rows, cols, size;        // actual image size\n    //\tint cols_align_npc;\t\t\t\t\t\t// cols\n    // multiple\n    // of\n    // NPC\n\n    typedef XF_TNAME(T, NPC) DATATYPE;\n    using _DATATTYPE = typename std::conditional<\n        (XFCVDEPTH < 0),\n        DATATYPE*,                 // Case of Memory Mapped pointer\n        typename std::conditional< // Case of Stream\n            (XFCVDEPTH == 0),\n            hls::stream<DATATYPE>,           // Case of default Dtream depth or user can override outside\n            hls::stream<DATATYPE, XFCVDEPTH> // Case of Stream depth specified\n            >::type>::type;\n    _DATATTYPE data;\n\n    Mat(); // default constructor\n    Mat(Size _sz);\n    Mat(int _rows, int _cols);\n    Mat(int _size, int _rows, int _cols);\n    Mat(int _rows, int _cols, void* _data);\n    Mat(const Mat&); // copy constructor\n\n    ~Mat();\n\n    Mat& operator=(const Mat&); // Assignment operator\n    //  XF_TNAME(T, XF_NPPC1) operator() (unsigned int r, unsigned int c);\n    //  XF_CTUNAME(T, NPC) operator() (unsigned int r, unsigned int c, unsigned\n    //  int ch);\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void alloc_data() {\n#ifndef __SYNTHESIS__\n        data = (DATATYPE*)malloc(size * sizeof(DATATYPE));\n\n        if (data == NULL) {\n            fprintf(stderr, \"\\nFailed to allocate memory\\n\");\n        } else {\n            allocatedFlag = 1;\n        }\n#endif\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void alloc_data() {\n        // This is a stream\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void free_data() {\n        if (data != NULL) {\n#ifndef __SYNTHESIS__\n            free(data);\n#endif\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void free_data() {}\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        for (int i = 0; i < (rows * ((cols + NPC - 1) >> XF_BITSHIFT(NPC))); ++i) {\n#pragma HLS loop_tripcount min=1 max=1024\n            data[i] = src.data[i];\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        data = (DATATYPE*)_data;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data[index];\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data.read();\n    }\n    float read_float(int index);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data[index] = val;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data.write(val);\n    }\n    void write_float(int index, float val);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols);\n        copyTo(_data);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols, false);\n        assignDataPtr(_data);\n    }\n\n    void init(int _rows, int _cols, bool allocate = true);\n    void copyTo(void* fromData);\n    unsigned char* copyFrom();\n\n    const int type() const;\n    const int depth() const;\n    const int channels() const;\n\n    template <int DST_T>\n    void convertTo(Mat<DST_T, ROWS, COLS, NPC, XFCVDEPTH>& dst, int otype, double alpha = 1, double beta = 0);\n};\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::type() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return (T);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::depth() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_DTPIXELDEPTH(T, NPC);\n}\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::channels() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_CHANNELS(T, NPC);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::init(int _rows, int _cols, bool allocate) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    assert((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) &&\n           \"The number of rows and columns must be less than the template \"\n           \"arguments.\");\n\n    rows = _rows;\n    cols = _cols;\n    allocatedFlag = 0;\n    size = _rows * ((_cols + NPPC - 1) >> XF_BITSHIFT(NPPC));\n\n    if (allocate) {\n        alloc_data();\n    }\n}\n\n/*Copy constructor definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::Mat(const Mat& src) {\n    init(src.rows, src.cols);\n\n#ifndef __SYNTHESIS__\n    copyData(src);\n#endif\n}\n\n/*Assignment operator definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::operator=(const Mat& src) {\n    if (this == &src) {\n        return *this; // For self-assignment cases\n    }\n\n    // Cleaning up old data memory if any\n    free_data();\n    allocatedFlag = 0;\n\n    init(src.rows, src.cols);\n    copyData(src);\n\n    return *this;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(ROWS, COLS);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols, void* _data) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols, _data);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(Size _sz) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_sz.height, _sz.width);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline float Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::read_float(int index) {\n    union int2float {\n        unsigned I;\n        float F;\n    };\n    int2float val;\n    val.I = read(index).to_uint();\n    return val.F;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::write_float(int index, float float_val) {\n    float val = float_val;\n    ap_uint<32>* val_out = (ap_uint<32>*)(&val);\n    write(index, *val_out);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyTo(void* _input) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    XF_PTSNAME(T, NPPC)* input = (XF_PTSNAME(T, NPPC)*)_input;\n    XF_CTUNAME(T, NPPC) in_val;\n\n    int packcols = cols >> XF_BITSHIFT(NPPC);       // Total columns after considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < packcols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            for (int p = 0; p < nppc; p++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                DATATYPE out_val;\n                for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    if (T == XF_32FC1) {\n                        in_val = float2ap_uint<ap_uint<32> >(\n                            input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch]);\n                    } else {\n                        in_val = input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch];\n                    }\n\n                    out_val.range((p * pixdepth) + (ch + 1) * bitdepth - 1, (p * pixdepth) + ch * bitdepth) = in_val;\n                }\n                write((r * packcols + c), out_val);\n            }\n        }\n    }\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline unsigned char* Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyFrom() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    //\tint packcols  = cols >> XF_BITSHIFT(NPPC); //Total columns after\n    // considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    int cv_nbytes = bitdepth / 8;\n\n    unsigned char* value =\n        (unsigned char*)malloc(rows * cols * (XF_CHANNELS(T, NPPC)) * (sizeof(unsigned char)) * cv_nbytes);\n\n    int xf_npc_idx = 0;\n    int diff_ptr = 0;\n    int xf_ptr = 0;\n    int cv_ptr = 0;\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < cols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            DATATYPE in_val = read(xf_ptr);\n            for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                for (int b = 0; b < cv_nbytes; ++b) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    value[cv_ptr++] = in_val.range((xf_npc_idx * pixdepth) + (ch * bitdepth) + (b + 1) * 8 - 1,\n                                                   (xf_npc_idx * pixdepth) + (ch * bitdepth) + b * 8);\n                }\n            }\n            if (xf_npc_idx == nppc - 1) {\n                xf_npc_idx = 0;\n                xf_ptr++;\n            } else {\n                xf_npc_idx++;\n            }\n        }\n    }\n\n    return (unsigned char*)value;\n}\n\n/* Member functions of Mat class */\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ntemplate <int DST_T>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::convertTo(Mat<DST_T, ROWS, COLS, NPPC, XFCVDEPTH>& dst,\n                                                           int otype,\n                                                           double alpha,\n                                                           double beta) {\n    assert((XF_CHANNELS(T, NPPC) == 1) && \"Multi-channel images not supported\");\n\n    XF_TNAME(T, NPPC) tmp_in_pix;\n    XF_TNAME(DST_T, NPPC) tmp_out_pix;\n\n    XF_CTUNAME(T, NPPC) in_pix;\n    XF_CTUNAME(DST_T, NPPC) out_pix;\n\n    int min, max;\n\n    if (DST_T == XF_8UC1) {\n        min = 0;\n        max = 255;\n    } else if (DST_T == XF_16UC1) {\n        min = 0;\n        max = 65535;\n    } else if (DST_T == XF_16SC1) {\n        min = -32768;\n        max = 32767;\n    } else if (DST_T == XF_32SC1) {\n        min = -2147483648;\n        max = 2147483647;\n    } else {\n        assert(1 &&\n               \"Output image type not supoorted. XF_8UC1, XF_16UC1, XF_16SC1 \"\n               \"and XF_32SC1 are valid\");\n    }\n\n#define __SATCAST(X) (X >= max ? max : (X < 0 ? 0 : lround(X)))\n\n    for (int i = 0; i < rows; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int j = 0; j<cols>> (XF_BITSHIFT(NPPC)); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            int IN_STEP = XF_PIXELDEPTH(XF_DEPTH(T, NPPC));\n            int OUT_STEP = XF_PIXELDEPTH(XF_DEPTH(DST_T, NPPC));\n            int in_shift = 0;\n            int out_shift = 0;\n            DATATYPE in_val = read((i * cols >> (XF_BITSHIFT(NPPC))) + j);\n            DATATYPE out_val;\n\n            for (int k = 0; k < (1 << (XF_BITSHIFT(NPPC))); k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                in_pix = in_val.range(in_shift + IN_STEP - 1, in_shift);\n\n                if (otype == XF_CONVERT_16U_TO_8U || otype == XF_CONVERT_16S_TO_8U || otype == XF_CONVERT_32S_TO_8U ||\n                    otype == XF_CONVERT_32S_TO_16U || otype == XF_CONVERT_32S_TO_16S) {\n                    float tmp = (float)(in_pix * alpha + beta);\n                    in_pix = __SATCAST(tmp);\n\n                    if (in_pix < min) in_pix = min;\n                    if (in_pix > max) in_pix = max;\n\n                    tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = in_pix;\n                } else {\n                    if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) > max) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = max;\n\n                    } else if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) < min) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = min;\n\n                    } else {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = __SATCAST(in_pix * alpha + beta);\n                    }\n                }\n\n                out_pix = tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift);\n\n                out_val.range(out_shift + OUT_STEP - 1, out_shift) = out_pix;\n\n                in_shift = in_shift + IN_STEP;\n                out_shift = out_shift + OUT_STEP;\n            }\n            dst.write(((i * cols >> (XF_BITSHIFT(NPPC))) + j), out_val);\n        }\n    }\n}\n\ntemplate <int SRC_T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nMat<SRC_T, ROWS, COLS, NPC, XFCVDEPTH>::~Mat() {\n#ifndef __SYNTHESIS__\n    if (allocatedFlag == 1) {\n        free_data();\n    }\n#endif\n}\n//----------------------------------------------------------------------------------------------------//\n\n// Template metaprogramming implementation of floor log2 [[\ntemplate <int N>\nstruct log2 {\n   public:\n    static constexpr int fvalue = 1 + (log2<N / 2>::fvalue);                   // floor value\n    static constexpr int cvalue = (N > (1 << fvalue)) ? (fvalue + 1) : fvalue; // ceiling value\n};\n\ntemplate <>\nstruct log2<1> {\n   public:\n    static constexpr int fvalue = 0;\n    static constexpr int cvalue = 0;\n};\n\nstruct bgr2y8_params {\n    int black_Vmax = 20;\n    int black_Smax = 70;\n    int brown_Hmax = 15;\n    int brown_Vmax = 40;\n    int Smin = 60;\n    int Smax = 90;\n    int darkgreen_Vmax = 35;\n    int darkgreen_Hmin = 30;\n    int darkgreen_Hmax = 45;\n    int green_Hmax = 90;\n    int green_Hmin = 50;\n    int green_Vmax = 45;\n};\n//]]\n\n/*\n * The purpose of this class is to provide an interator over ap_uint<PTR_WIDTH>\n * object array such\n * that at each iter step one can get data bits corresponding to data to be\n * processed per cycle.\n *\n */\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIter : public Mat<T, ROWS, COLS, NPC, XFCVDEPTH> {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    static constexpr int XF_BITS_PER_CLOCK = XF_PIXELWIDTH(T, NPC) * XF_NPIXPERCYCLE(NPC);\n    static constexpr int COLS_BOUND_PER_NPC = ((COLS + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC));\n    static constexpr int LOOPBOUND = ROWS * COLS_BOUND_PER_NPC;\n    static constexpr int ADDRBOUND = ((ROWS * COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                     (log2<PTR_WIDTH>::cvalue);\n    static constexpr int LAST_BLK_PXL_WIDTH =\n        ((COLS >> XF_BITSHIFT(NPC)) == COLS_BOUND_PER_NPC)\n            ? XF_BITS_PER_CLOCK\n            : XF_PIXELWIDTH(T, NPC) * (COLS - ((COLS >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    static constexpr int COLS_ADDRBOUND = ((COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                          (log2<PTR_WIDTH>::cvalue);\n    static int cols_npc_aligned(int cols) { return ((cols + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC)); }\n\n    static int last_blk_pxl_width(int cols, int cols_bound_per_npc) {\n        return ((cols >> XF_BITSHIFT(NPC)) == cols_bound_per_npc)\n                   ? XF_BITS_PER_CLOCK\n                   : XF_PIXELWIDTH(T, NPC) * (cols - ((cols >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    }\n\n    static int loopbound(int rows, int cols) { return rows * cols_npc_aligned(cols); }\n\n    int loopbound() { return rows * cols_npc_aligned(cols); }\n\n    static int addrbound(int rows, int cols) {\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> cols_int16 = cols;\n\n        ap_uint<32> mul_rows_cols;\n\n// clang-format off\n#pragma HLS BIND_OP variable=mul_rows_cols op=mul impl=dsp latency=2\n        // clang-format on\n\n        mul_rows_cols = rows_int16 * cols_int16;\n\n        return ((mul_rows_cols * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >> (log2<PTR_WIDTH>::cvalue);\n    }\n    MMIter() : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>() {}\n\n    MMIter(int _rows, int _cols) : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {}\n};\n\n#define _MMITER MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterIn : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n    using _MMITER::COLS_ADDRBOUND;\n\n   private:\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop1:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    static void Axi2AxiStream(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = din.read();\n            dout.write(v.data);\n        }\n    }\n\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows_burst,\n                              int rows,\n                              int cols,\n                              int stride = -1) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> cols_addrbound = _MMITER::addrbound(rows_burst, cols);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> stride_addrbound = _MMITER::addrbound(rows_burst, stride);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> addrbound = (stride == -1) ? cols_addrbound : stride_addrbound;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> c;\n    MMIterInLoop1:\n        for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n            // clang-format on\n            for (c = 0; c < cols_addrbound; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_ADDRBOUND\n#pragma HLS pipeline\n                // clang-format on\n                dout.write(din[c + r * addrbound]);\n            }\n        }\n    }\n    template <int DEPTH>\n    static void AxiStream2MatStream(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                                    hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        int stride_bound_per_npc, strideBased_last_blk_width;\n\n        // if (stride == -1) {\n        stride_bound_per_npc = cols_bound_per_npc;\n        strideBased_last_blk_width = last_blk_width;\n        //} else {\n        //  stride_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        //  strideBased_last_blk_width = _MMITER::last_blk_pxl_width(stride, stride_bound_per_npc);\n        //}\n        int rd_cnt = 0;\n\n        int rem = 0;\n        ap_uint<PTR_WIDTH> val = 0;\n        int i;\n        int j = 0;\n        int bound = rows * stride_bound_per_npc;\n    MMIterInLoopRow:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            bool bLast = (j == (stride_bound_per_npc - 1));\n            int xf_bits_per_clock = bLast ? strideBased_last_blk_width : XF_BITS_PER_CLOCK;\n            int ptr_width_minus = bLast ? (PTR_WIDTH - strideBased_last_blk_width) : (PTR_WIDTH - XF_BITS_PER_CLOCK);\n            int ptr_width_plus = bLast ? (PTR_WIDTH + strideBased_last_blk_width) : (PTR_WIDTH + XF_BITS_PER_CLOCK);\n\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer = 0;\n            if (rem < xf_bits_per_clock) {\n                if (rem != 0) {\n                    localbuffer.range(rem - 1, 0) = val.range(PTR_WIDTH - 1, (PTR_WIDTH - rem));\n                }\n                val = din.read();\n                rd_cnt++;\n                localbuffer.range((xf_bits_per_clock - 1), rem) = val.range(((xf_bits_per_clock - 1) - rem), 0);\n                rem = ptr_width_minus + rem;\n            } else {\n                localbuffer = val.range(((ptr_width_plus - 1) - rem), (PTR_WIDTH - rem));\n                rem = rem - xf_bits_per_clock;\n            }\n            bool bLast_width = (j == (cols_bound_per_npc - 1));\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer2 = 0;\n            if (bLast_width == 0)\n                localbuffer2 = localbuffer;\n            else\n                localbuffer2 = localbuffer.range(last_blk_width - 1, 0);\n\n            if (j < cols_bound_per_npc) dout.write(localbuffer2);\n\n            j = (bLast) ? 0 : (j + 1);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2Mat(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterInLoop2:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, ldata, rows, cols_bound_per_npc, last_blk_width, stride);\n        MatStream2Mat(ldata, dout, rows, cols_bound_per_npc);\n    }\n\n    static void Axi2Mat(ap_uint<PTR_WIDTH>* din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n    static void Axi2Mat(\n        ap_uint<PTR_WIDTH>* din, ap_uint<XF_BITS_PER_CLOCK>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        ap_uint<XF_BITS_PER_CLOCK>* dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n   public:\n    MMIterIn(ap_uint<PTR_WIDTH>* d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(ap_uint<PTR_WIDTH>* d, int _rows, int _cols) : _MMITER(_rows, _cols) { Axi2Mat(d, data, rows, cols); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        Axi2Mat(d, data, rows, cols);\n    }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d) : _MMITER() { AxiStream2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        AxiStream2Mat(d, data, rows, cols);\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& din, int index) {\n        return din.read();\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(ap_uint<XF_BITS_PER_CLOCK>* din, int index) { return din[index]; }\n\n    ap_uint<XF_BITS_PER_CLOCK> read(int index) { return read(data, index); }\n\n    static void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                            xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                            int stride = -1) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols, stride);\n    }\n\n    static void Array2xfMat(\n        ap_uint<PTR_WIDTH>* srcPtr, ap_uint<XF_BITS_PER_CLOCK>* dstPtr, int rows, int cols, int stride = -1) {\n        Axi2Mat(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                              xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int FILLZERO = 1, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterOut : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n\n   private:\n    template <int DEPTH>\n    static void Mat2MatStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterOutLoop1:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                                    hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        ap_uint<16> strideBased_cols_bound_per_npc;\n        if (stride == -1 || FILLZERO == 0) {\n            strideBased_cols_bound_per_npc = cols_bound_per_npc;\n        } else {\n            strideBased_cols_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        }\n\n        ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled = 0; // valid bits remaining in current buffer\n        ap_uint<PTR_WIDTH> localbuffer = 0;\n        ap_uint<16> i;\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> j;\n\n    MMIterOutRow:\n        for (i = 0; i < rows_int16; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n        // clang-format on\n        MMIterOutCol:\n            for (j = 0; j < strideBased_cols_bound_per_npc; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_BOUND_PER_NPC\n#pragma HLS pipeline\n                // clang-format on\n\n                bool bLast = (j == (cols_bound_per_npc - 1));\n                int xf_bits_per_clock = bLast ? last_blk_width : XF_BITS_PER_CLOCK;\n                ap_uint<PTR_WIDTH> val;\n                if (j < cols_bound_per_npc || FILLZERO == 0)\n                    val = din.read();\n                else\n                    val = 0;\n\n                ap_uint<PTR_WIDTH> tempval = (val << filled);\n                localbuffer = (localbuffer | tempval);\n                ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled_next;\n\n                if (filled < (PTR_WIDTH - xf_bits_per_clock)) {\n                    filled_next = filled + xf_bits_per_clock;\n                } else if (j == cols_bound_per_npc - 1 && FILLZERO == 0) {\n                    dout.write(localbuffer);\n                    localbuffer = 0;\n                    filled_next = 0;\n                } else {\n                    dout.write(localbuffer);\n                    localbuffer = (val >> (PTR_WIDTH - filled));\n                    filled_next = filled + (xf_bits_per_clock - PTR_WIDTH);\n                }\n\n                filled = filled_next;\n            }\n        }\n\n        if (filled != 0) {\n            dout.write(localbuffer);\n        }\n    }\n\n    static void Mat2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        MatStream2AxiStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void Mat2AxiStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        Mat2MatStream(din, ldata, rows, cols_bound_per_npc);\n        MatStream2AxiStream(ldata, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<PTR_WIDTH>* dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop2:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = din.read();\n            dout.write(v);\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        ap_uint<PTR_WIDTH>* dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(\n        ap_uint<XF_BITS_PER_CLOCK>* din, ap_uint<PTR_WIDTH>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(ap_uint<XF_BITS_PER_CLOCK>* din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n   public:\n    MMIterOut() : _MMITER() {}\n\n    MMIterOut(int _rows, int _cols) : _MMITER(_rows, _cols) {}\n\n    inline static void write(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& dout,\n                             ap_uint<XF_BITS_PER_CLOCK>& val,\n                             int index) {\n        dout.write(val);\n    }\n\n    inline static void write(ap_uint<XF_BITS_PER_CLOCK>* dout, ap_uint<XF_BITS_PER_CLOCK>& val, int index) {\n        dout[index] = val;\n    }\n\n    void write(ap_uint<XF_BITS_PER_CLOCK>& val, int index) { write(data, val, index); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout) { Mat2Axi(data, dout); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout, int rows, int cols) { Mat2Axi(data, dout, rows, cols); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout) { Mat2Axi(data, dout); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout, int rows, int cols) {\n        Mat2Axi(data, dout, rows, cols);\n    }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout) { Mat2AxiStream(data, dout); }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout, int rows, int cols) { Mat2AxiStream(data, dout, rows, cols); }\n\n    static void xfMat2Array(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                            ap_uint<PTR_WIDTH>* dstPtr,\n                            int stride = -1) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols, stride);\n    }\n\n    static void xfMat2Array(\n        ap_uint<XF_BITS_PER_CLOCK>* srcPtr, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols, int stride = -1) {\n        Mat2Axi(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void xfMat2axiStrm(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dstPtr) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols);\n    }\n};\n\n} // namespace cv\n} // namespace xf\n\n#endif // _XF_STRUCTS_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "xf_common.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_COMMON_H_\n#define _XF_COMMON_H_\n\n#include \"xf_structs.hpp\"\n#include \"xf_params.hpp\"\n#include \"xf_types.hpp\"\n\nusing namespace xf::cv;\n#endif\n"
      },
      {
        "file_name": "xf_params.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_PARAMS_H_\n#define _XF_PARAMS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n\n#define __ABS(X) ((X) < 0 ? (-(X)) : (X))\n\n// Channels of an image\nenum _channel_extract {\n    XF_EXTRACT_CH_0, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_1, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_2, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_3, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_R, // Used to extract the RED channel\n    XF_EXTRACT_CH_G, // Used to extract the GREEN channel\n    XF_EXTRACT_CH_B, // Used to extract the BLUE channel\n    XF_EXTRACT_CH_A, // Used to extract the ALPHA channel\n    XF_EXTRACT_CH_Y, // Used to extract the LUMA channel\n    XF_EXTRACT_CH_U, // Used to extract the Cb/U channel\n    XF_EXTRACT_CH_V  // Used to extract the Cr/V/Value channel\n};\ntypedef _channel_extract XF_channel_extract_e;\n\n// Conversion Policy for fixed point arithmetic\nenum _convert_policy { XF_CONVERT_POLICY_SATURATE, XF_CONVERT_POLICY_TRUNCATE };\ntypedef _convert_policy XF_convert_policy_e;\n\n// Bit-depth conversion types\nenum _convert_bit_depth {\n    // Down-convert\n    XF_CONVERT_16U_TO_8U,\n    XF_CONVERT_16S_TO_8U,\n    XF_CONVERT_32S_TO_8U,\n    XF_CONVERT_32S_TO_16U,\n    XF_CONVERT_32S_TO_16S,\n    // Up-convert\n    XF_CONVERT_8U_TO_16U,\n    XF_CONVERT_8U_TO_16S,\n    XF_CONVERT_8U_TO_32S,\n    XF_CONVERT_16U_TO_32S,\n    XF_CONVERT_16S_TO_32S\n};\ntypedef _convert_bit_depth XF_convert_bit_depth_e;\n\n// Thresholding types\nenum _threshold_type {\n    XF_THRESHOLD_TYPE_BINARY = 0,\n    XF_THRESHOLD_TYPE_BINARY_INV = 1,\n    XF_THRESHOLD_TYPE_TRUNC = 2,\n    XF_THRESHOLD_TYPE_TOZERO = 3,\n    XF_THRESHOLD_TYPE_TOZERO_INV = 4,\n};\ntypedef _threshold_type XF_threshold_type_e;\n\n// Thresholding types\nenum _ccm_type {\n    XF_CCM_bt2020_bt709 = 0,\n    XF_CCM_bt709_bt2020 = 1,\n    XF_CCM_rgb_yuv_601 = 2,\n    XF_CCM_rgb_yuv_709 = 3,\n    XF_CCM_rgb_yuv_2020 = 4,\n    XF_CCM_yuv_rgb_601 = 5,\n    XF_CCM_yuv_rgb_709 = 6,\n    XF_CCM_yuv_rgb_2020 = 7,\n    XF_CCM_full_from_16_235 = 8,\n    XF_CCM_full_to_16_235 = 9,\n\n};\ntypedef _ccm_type XF_ccm_type_e;\n\n// Comparision types\nenum _comparison_op { XF_CMP_EQ = 0, XF_CMP_GT = 1, XF_CMP_GE = 2, XF_CMP_LT = 3, XF_CMP_LE = 4, XF_CMP_NE = 5 };\ntypedef _comparison_op _comparison_op_e;\n\n// Comparision types\nenum _reduction_op { REDUCE_SUM = 0, REDUCE_AVG = 1, REDUCE_MAX = 2, REDUCE_MIN = 3 };\ntypedef _reduction_op _reduction_op_e;\n\n// Pixel Per Cycle\nenum _pixel_per_cycle {\n    XF_NPPC1 = 1,\n    XF_NPPC2 = 2,\n    XF_NPPC4 = 4,\n    XF_NPPC8 = 8,\n    XF_NPPC16 = 16,\n    XF_NPPC32 = 32,\n    XF_NPPC64 = 64\n};\ntypedef _pixel_per_cycle XF_nppc_e;\n\n// Pixel types\nenum _pixel_type {\n    XF_8UP = 0,\n    XF_8SP = 1,\n    XF_14UP = 2,\n    XF_16UP = 3,\n    XF_16SP = 4,\n    XF_32UP = 5,\n    XF_32SP = 6,\n    XF_19SP = 7,\n    XF_32FP = 8,\n    XF_35SP = 9,\n    XF_24SP = 10,\n    XF_20SP = 11,\n    XF_48SP = 12,\n    XF_2UP = 13,\n    XF_9SP = 14,\n    XF_9UP = 15,\n    XF_24UP = 16,\n    XF_64UP = 17,\n    XF_10UP = 18,\n    XF_12UP = 19,\n    XF_40UP = 20,\n    XF_42UP = 20,\n    XF_48UP = 21,\n    XF_30UP = 22,\n    XF_36UP = 23,\n    XF_96FP = 24\n};\ntypedef _pixel_type XF_pixel_type_e;\n\n// Word width\nenum _word_width {\n    XF_2UW = 0,\n    XF_8UW = 1,\n    XF_9UW = 2,\n    XF_10UW = 3,\n    XF_12UW = 4,\n    XF_14UW = 5,\n    XF_16UW = 6,\n    XF_19SW = 7,\n    XF_20UW = 8,\n    XF_22UW = 9,\n    XF_24UW = 10,\n    XF_24SW = 11,\n    XF_28UW = 12,\n    XF_30UW = 13,\n    XF_32UW = 14,\n    XF_32FW = 15,\n    XF_35SW = 16,\n    XF_36UW = 17,\n    XF_40UW = 18,\n    XF_42UW = 19,\n    XF_48UW = 20,\n    XF_48SW = 21,\n    XF_56UW = 22,\n    XF_60UW = 23,\n    XF_64UW = 24,\n    XF_72UW = 25,\n    XF_80UW = 26,\n    XF_84UW = 27,\n    XF_96UW = 28,\n    XF_96SW = 29,\n    XF_112UW = 30,\n    XF_120UW = 31,\n    XF_128UW = 32,\n    XF_144UW = 33,\n    XF_152SW = 34,\n    XF_160UW = 35,\n    XF_160SW = 36,\n    XF_168UW = 37,\n    XF_176UW = 38,\n    XF_192UW = 39,\n    XF_192SW = 40,\n    XF_240UW = 41,\n    XF_256UW = 42,\n    XF_280SW = 43,\n    XF_288UW = 44,\n    XF_304SW = 45,\n    XF_320UW = 46,\n    XF_336UW = 47,\n    XF_352UW = 48,\n    XF_384UW = 49,\n    XF_384SW = 50,\n    XF_512UW = 51,\n    XF_560SW = 52,\n    XF_576UW = 53,\n    XF_96FW = 54,\n    XF_192FW = 55,\n    XF_384FW = 56,\n    XF_768FW = 57,\n    XF_1536FW = 58\n};\ntypedef _word_width XF_word_width_e;\n\n// Filter size\nenum _filter_size { XF_FILTER_3X3 = 3, XF_FILTER_5X5 = 5, XF_FILTER_7X7 = 7 };\ntypedef _filter_size XF_filter_size_e;\n\n// Radius size for Non Maximum Suppression\nenum _nms_radius { XF_NMS_RADIUS_1 = 1, XF_NMS_RADIUS_2 = 2, XF_NMS_RADIUS_3 = 3 };\ntypedef _nms_radius XF_nms_radius_e;\n\n// Image Pyramid Parameters\nenum _image_pyramid_params {\n    XF_PYRAMID_TYPE_GXFSSIAN = 0,\n    XF_PYRAMID_TYPE_LAPLACIAN = 1,\n    XF_PYRAMID_SCALE_HALF = 2,\n    XF_PYRAMID_SCALE_ORB = 3,\n    XF_PYRAMID_SCALE_DOUBLE = 4\n};\ntypedef _image_pyramid_params XF_image_pyramid_params_e;\n\n// Magnitude computation\nenum _normalisation_params { XF_L1NORM = 0, XF_L2NORM = 1 };\ntypedef _normalisation_params XF_normalisation_params_e;\n\nenum _border_type {\n    XF_BORDER_CONSTANT = 0,\n    XF_BORDER_REPLICATE = 1,\n    XF_BORDER_REFLECT = 2,\n    XF_BORDER_WRAP = 3,\n    XF_BORDER_REFLECT_101 = 4,\n    XF_BORDER_TRANSPARENT = 5,\n    XF_BORDER_REFLECT101 = XF_BORDER_REFLECT_101,\n    XF_BORDER_DEFAULT = XF_BORDER_REFLECT_101,\n    XF_BORDER_ISOLATED = 16,\n};\ntypedef _border_type XF_border_type_e;\n\nenum _structuring_element_shape {\n    XF_SHAPE_RECT = 0,\n    XF_SHAPE_ELLIPSE = 1,\n    XF_SHAPE_CROSS = 2,\n\n};\nenum _wb_type {\n    XF_WB_GRAY = 0,\n    XF_WB_SIMPLE = 1,\n};\n\nenum multistream {\n    SLICES_DEFAULT = 1,\n};\n// Phase computation\nenum _phase_params { XF_RADIANS = 0, XF_DEGREES = 1 };\ntypedef _phase_params XF_phase_params_e;\n\n// Types of Interpolaton techniques used in resize, affine and perspective\nenum _interpolation_types { XF_INTERPOLATION_NN = 0, XF_INTERPOLATION_BILINEAR = 1, XF_INTERPOLATION_AREA = 2 };\ntypedef _interpolation_types _interpolation_types_e;\n\n// loop dependent variables used in image pyramid\nenum _loop_dependent_vars { XF_GXFSSIANLOOP = 8, XF_BUFSIZE = 12 };\ntypedef _loop_dependent_vars loop_dependent_vars_e;\n\n// loop dependent variables used in image pyramid\nenum _image_size { XF_SDIMAGE = 0, XF_HDIMAGE = 1 };\ntypedef _image_size image_size_e;\n\n// enumerations for HOG feature descriptor\nenum _input_image_type { XF_GRAY = 1, XF_RGB = 3 };\ntypedef _input_image_type input_image_type_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_output_type { XF_HOG_RB = 0, XF_HOG_NRB = 1 };\ntypedef _HOG_output_type HOG_output_type_e;\n\nenum use_model { XF_STANDALONE = 0, XF_PIPELINE = 1 };\ntypedef use_model use_model_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_type { XF_DHOG = 0, XF_SHOG = 1 };\ntypedef _HOG_type HOG_type_e;\n\n// enumerations for Stereo BM\nenum XF_stereo_prefilter_type { XF_STEREO_PREFILTER_SOBEL_TYPE, XF_STEREO_PREFILTER_NORM_TYPE };\n/****************************new************************/\n// enumerations for Demosaicing\nenum XF_demosaicing {\n    XF_BAYER_BG,\n    XF_BAYER_GB,\n    XF_BAYER_GR,\n    XF_BAYER_RG,\n};\n// typedef XF_stereo_prefilter_type XF_stereo_pre_filter_type_e;\n// enum _pixel_percycle\n//{\n//\tXF_NPPC1  = 0,\n//\tXF_NPPC8  = 3,\n//\tXF_NPPC16 = 4\n//};\n// typedef _pixel_percycle XF_nppc_e;\n\n// enumerations for Architecture\nenum _ARCH_type {\n    XF_STREAM = 0,\n    XF_MEMORYMAPPED = 1\n\n};\ntypedef _ARCH_type _ARCH_type_e;\n\nenum _pixeltype {\n    XF_8UC1 = 0,\n    XF_14UC1 = 1,\n    XF_16UC1 = 2,\n    XF_16SC1 = 3,\n    XF_24UC1 = 4,\n    XF_24SC1 = 5,\n    XF_32UC1 = 6,\n    XF_32FC1 = 7,\n    XF_32SC1 = 8,\n    XF_8UC2 = 9,\n    XF_8UC4 = 10,\n    XF_2UC1 = 11,\n    XF_8UC3 = 16,\n    XF_16UC3 = 13,\n    XF_16SC3 = 14,\n    XF_16UC4 = 15,\n    XF_10UC1 = 12,\n    XF_10UC4 = 17,\n    XF_12UC1 = 18,\n    XF_12UC4 = 19,\n    XF_10UC3 = 20,\n    XF_12UC3 = 21,\n    XF_14UC3 = 22,\n    XF_32FC3 = 23,\n    XF_64UC1 = 24\n};\ntypedef _pixeltype XF_npt_e;\n\nenum _ramtype {\n    RAM_1P_BRAM = 0,\n    RAM_1P_LUTRAM = 1,\n    RAM_1P_URAM = 2,\n    RAM_2P_BRAM = 3,\n    RAM_2P_LUTRAM = 4,\n    RAM_2P_URAM = 5,\n    RAM_S2P_BRAM = 6,\n    RAM_S2P_LUTRAM = 7,\n    RAM_S2P_URAM = 8,\n    RAM_T2P_BRAM = 9,\n    RAM_T2P_URAM = 10\n};\ntypedef _ramtype XF_ramtype_e;\n\n#endif //_XF_PARAMS_H_\n"
      }
    ],
    "code_length": 13996,
    "token_count": 4115,
    "pragma_number": 322,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/ordinal_feature_scaling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2091,
    "Worst-caseLatency": 2091.0,
    "BRAM_18K": 0,
    "LUT": 2255,
    "DSP": 2,
    "FF": 2592,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ordinal_feature_scaling",
    "ResourceMetric": 0.0007363648,
    "design_id": "project",
    "algo_name": "ordinal_feature_scaling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "ordinal_feature_scaling.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid ordinal_feature_scaling(int input[ARRAY_SIZE], int output[ARRAY_SIZE]) {\n    int min_val = input[0];\n    int max_val = input[0];\n\n    // Find the minimum and maximum values in the input array\n    for (int i = 1; i < ARRAY_SIZE; i++) {\n        if (input[i] < min_val) {\n            min_val = input[i];\n        }\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n    }\n\n    // Scale the input array to ordinal values\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] - min_val) * 100 / (max_val - min_val);\n    }\n}\n\n// Top function name: ordinal_feature_scaling\n"
      }
    ],
    "code_length": 660,
    "token_count": 183,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/osd_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 574,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "osd_processor",
    "ResourceMetric": 0.0001124701,
    "design_id": "project",
    "algo_name": "osd_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "osd_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid osd_processor(ap_int<16> input[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<16> temp = input[i];\n        ap_int<16> result = 0;\n\n        // Example processing: simple bitwise operations\n        for (int j = 0; j < 16; j++) {\n            if (temp[j] == 1) {\n                result |= (1 << (15 - j));\n            }\n        }\n\n        output[i] = result;\n    }\n}\n\n// Top function name: osd_processor\n"
      }
    ],
    "code_length": 484,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/purity_score/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2064,
    "Worst-caseLatency": null,
    "BRAM_18K": 6,
    "LUT": 1338,
    "DSP": 0,
    "FF": 499,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "purity_score",
    "ResourceMetric": 0.0006764505,
    "design_id": "project",
    "algo_name": "purity_score",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "purity_score.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid purity_score(int n, int labels[ARRAY_SIZE], int clusters[ARRAY_SIZE], float &purity) {\n    int cluster_count[ARRAY_SIZE] = {0};\n    int label_count[ARRAY_SIZE] = {0};\n    int max_label_in_cluster[ARRAY_SIZE] = {0};\n\n    for (int i = 0; i < n; i++) {\n        cluster_count[clusters[i]]++;\n        label_count[labels[i]]++;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int cluster_id = clusters[i];\n        int label_id = labels[i];\n        if (label_count[label_id] > max_label_in_cluster[cluster_id]) {\n            max_label_in_cluster[cluster_id] = label_count[label_id];\n        }\n    }\n\n    int sum_max_labels = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum_max_labels += max_label_in_cluster[i];\n    }\n\n    purity = static_cast<float>(sum_max_labels) / n;\n}\n\n// Top function name: purity_score\n"
      }
    ],
    "code_length": 881,
    "token_count": 242,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/rc_oscillator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3075,
    "Worst-caseLatency": 3075.0,
    "BRAM_18K": 0,
    "LUT": 138,
    "DSP": 2,
    "FF": 104,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rc_oscillator",
    "ResourceMetric": 9.18431e-05,
    "design_id": "project",
    "algo_name": "rc_oscillator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "rc_oscillator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid rc_oscillator(ap_int<16> input_signal[N], ap_int<16> output_signal[N], ap_int<16> R, ap_int<16> C) {\n    ap_int<16> Vout = 0;\n    for (int i = 0; i < N; i++) {\n        ap_int<16> Vin = input_signal[i];\n        Vout = (Vin - Vout) * R * C + Vout;\n        output_signal[i] = Vout;\n    }\n}\n\n// Top function name: rc_oscillator\n"
      }
    ],
    "code_length": 366,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/robust_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 432,
    "DSP": 0,
    "FF": 171,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "robust_optimization",
    "ResourceMetric": 9.92383e-05,
    "design_id": "project",
    "algo_name": "robust_optimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "robust_optimization.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid robust_optimization(double input[N], double output[N], double threshold) {\n    for (int i = 0; i < N; i++) {\n        double value = input[i];\n        if (value < threshold) {\n            output[i] = std::max(0.0, value);\n        } else {\n            output[i] = std::min(1.0, value);\n        }\n    }\n}\n\n// Top function name: robust_optimization\n"
      }
    ],
    "code_length": 405,
    "token_count": 109,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/robust_scaling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1036,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 399,
    "DSP": 2,
    "FF": 574,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "robust_scaling",
    "ResourceMetric": 0.0001869585,
    "design_id": "project",
    "algo_name": "robust_scaling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "robust_scaling.cpp",
        "file_content": "#include <hls_stream.h>\n#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid robust_scaling(float input[SIZE], float output[SIZE], float median, float mad) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (input[i] - median) / mad;\n    }\n}\n\n// Top function name: robust_scaling\n"
      }
    ],
    "code_length": 280,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/roc_curve/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048580,
    "Worst-caseLatency": 1048580.0,
    "BRAM_18K": 0,
    "LUT": 1136,
    "DSP": 0,
    "FF": 695,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "roc_curve",
    "ResourceMetric": 0.0002844832,
    "design_id": "project",
    "algo_name": "roc_curve",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "roc_curve.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid roc_curve(float predictions[N], int labels[N], float thresholds[N], int tp[N], int fp[N], int tn[N], int fn[N]) {\n    for (int t = 0; t < N; t++) {\n        tp[t] = 0;\n        fp[t] = 0;\n        tn[t] = 0;\n        fn[t] = 0;\n        for (int i = 0; i < N; i++) {\n            if (predictions[i] >= thresholds[t]) {\n                if (labels[i] == 1) {\n                    tp[t]++;\n                } else {\n                    fp[t]++;\n                }\n            } else {\n                if (labels[i] == 1) {\n                    fn[t]++;\n                } else {\n                    tn[t]++;\n                }\n            }\n        }\n    }\n}\n\n// Top function name: roc_curve\n"
      }
    ],
    "code_length": 716,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/rotate_array/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 94,
    "DSP": 0,
    "FF": 24,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rotate_array",
    "ResourceMetric": 2.03271e-05,
    "design_id": "project",
    "algo_name": "rotate_array",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "rotate_array.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid rotate_array(int input_array[ARRAY_SIZE], int output_array[ARRAY_SIZE], int rotate_by) {\n    int i;\n    for (i = 0; i < ARRAY_SIZE; i++) {\n        int new_index = (i + rotate_by) % ARRAY_SIZE;\n        output_array[new_index] = input_array[i];\n    }\n}\n\n// Top function name: rotate_array\n"
      }
    ],
    "code_length": 338,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/sample_rate_conversion/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 522,
    "Worst-caseLatency": 522.0,
    "BRAM_18K": 0,
    "LUT": 678,
    "DSP": 7,
    "FF": 786,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sample_rate_conversion",
    "ResourceMetric": 0.0003993075,
    "design_id": "project",
    "algo_name": "sample_rate_conversion",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "sample_rate_conversion.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 512\n\nvoid sample_rate_conversion(const float input[INPUT_SIZE], float output[OUTPUT_SIZE]) {\n    int i, j;\n    const int factor = INPUT_SIZE / OUTPUT_SIZE;\n    \n    for (i = 0; i < OUTPUT_SIZE; i++) {\n        float sum = 0;\n        for (j = 0; j < factor; j++) {\n            sum += input[i * factor + j];\n        }\n        output[i] = sum / factor;\n    }\n}\n\n// Top function name: sample_rate_conversion\n"
      }
    ],
    "code_length": 468,
    "token_count": 124,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/sha/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8260,
    "Worst-caseLatency": 8260.0,
    "BRAM_18K": 128,
    "LUT": 50619,
    "DSP": 0,
    "FF": 15531,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sha_stream",
    "ResourceMetric": 0.0191326028,
    "design_id": "project",
    "algo_name": "sha",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "sha.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/* NIST Secure Hash Algorithm */\n/* heavily modified by Uwe Hollerbach uh@alumni.caltech edu */\n/* from Peter C. Gutmann's implementation as found in */\n/* Applied Cryptography by Bruce Schneier */\n\n/* NIST's proposed modification to SHA of 7/11/94 may be */\n/* activated by defining USE_MODIFIED_SHA */\n\n\n#include \"sha.h\"\n/* SHA f()-functions */\n\n#define f1(x,y,z)\t((x & y) | (~x & z))\n#define f2(x,y,z)\t(x ^ y ^ z)\n#define f3(x,y,z)\t((x & y) | (x & z) | (y & z))\n#define f4(x,y,z)\t(x ^ y ^ z)\n\n/* SHA constants */\n\n#define CONST1\t\t0x5a827999L\n#define CONST2\t\t0x6ed9eba1L\n#define CONST3\t\t0x8f1bbcdcL\n#define CONST4\t\t0xca62c1d6L\n\n/* 32-bit rotate */\n\n#define ROT32(x,n)\t((x << n) | (x >> (32 - n)))\n\n#define FUNC(n,i)\t\t\t\t\t\t\\\n    temp = ROT32(A,5) + f##n(B,C,D) + E + W[i] + CONST##n;\t\\\n    E = D; D = C; C = ROT32(B,30); B = A; A = temp\n\nvoid\nlocal_memset (INT32 * s, int c, int n, int e)\n{\n  INT32 uc;\n  INT32 *p;\n  int m;\n\n  m = n / 4;\n  uc = c;\n  p = (INT32 *) s;\n  while (e-- > 0)\n    {\n      p++;\n    }\n  while (m-- > 0)\n    {\n      *p++ = uc;\n    }\n}\n\nvoid\nlocal_memcpy (INT32 * s1, const BYTE * s2, int n)\n{\n  INT32 *p1;\n  BYTE *p2;\n  INT32 tmp;\n  int m;\n  m = n / 4;\n  p1 = (INT32 *) s1;\n  p2 = (BYTE *) s2;\n\n  while (m-- > 0)\n    {\n      tmp = 0;\n      tmp |= 0xFF & *p2++;\n      tmp |= (0xFF & *p2++) << 8;\n      tmp |= (0xFF & *p2++) << 16;\n      tmp |= (0xFF & *p2++) << 24;\n      *p1 = tmp;\n      p1++;\n    }\n}\n\n/* do SHA transformation */\n\nstatic void\nsha_transform ()\n{\n  int i;\n  INT32 temp, A, B, C, D, E, W[80];\n\n  for (i = 0; i < 16; ++i)\n    {\n      W[i] = sha_info_data[i];\n    }\n  for (i = 16; i < 80; ++i)\n    {\n      W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n    }\n  A = sha_info_digest[0];\n  B = sha_info_digest[1];\n  C = sha_info_digest[2];\n  D = sha_info_digest[3];\n  E = sha_info_digest[4];\n\n  for (i = 0; i < 20; ++i)\n    {\n      FUNC (1, i);\n    }\n  for (i = 20; i < 40; ++i)\n    {\n      FUNC (2, i);\n    }\n  for (i = 40; i < 60; ++i)\n    {\n      FUNC (3, i);\n    }\n  for (i = 60; i < 80; ++i)\n    {\n      FUNC (4, i);\n    }\n\n  sha_info_digest[0] += A;\n  sha_info_digest[1] += B;\n  sha_info_digest[2] += C;\n  sha_info_digest[3] += D;\n  sha_info_digest[4] += E;\n}\n\n/* initialize the SHA digest */\n\nvoid\nsha_init ()\n{\n  sha_info_digest[0] = 0x67452301L;\n  sha_info_digest[1] = 0xefcdab89L;\n  sha_info_digest[2] = 0x98badcfeL;\n  sha_info_digest[3] = 0x10325476L;\n  sha_info_digest[4] = 0xc3d2e1f0L;\n  sha_info_count_lo = 0L;\n  sha_info_count_hi = 0L;\n}\n\n/* update the SHA digest */\n\nvoid\nsha_update (const BYTE * buffer, int count)\n{\n  if ((sha_info_count_lo + ((INT32) count << 3)) < sha_info_count_lo)\n    {\n      ++sha_info_count_hi;\n    }\n  sha_info_count_lo += (INT32) count << 3;\n  sha_info_count_hi += (INT32) count >> 29;\n  while (count >= SHA_BLOCKSIZE)\n    {\n      local_memcpy (sha_info_data, buffer, SHA_BLOCKSIZE);\n      sha_transform ();\n      buffer += SHA_BLOCKSIZE;\n      count -= SHA_BLOCKSIZE;\n    }\n  local_memcpy (sha_info_data, buffer, count);\n}\n\n/* finish computing the SHA digest */\n\nvoid\nsha_final ()\n{\n  int count;\n  INT32 lo_bit_count;\n  INT32 hi_bit_count;\n\n  lo_bit_count = sha_info_count_lo;\n  hi_bit_count = sha_info_count_hi;\n  count = (int) ((lo_bit_count >> 3) & 0x3f);\n  sha_info_data[count++] = 0x80;\n  if (count > 56)\n    {\n      local_memset (sha_info_data, 0, 64 - count, count);\n      sha_transform ();\n      local_memset (sha_info_data, 0, 56, 0);\n    }\n  else\n    {\n      local_memset (sha_info_data, 0, 56 - count, count);\n    }\n  sha_info_data[14] = hi_bit_count;\n  sha_info_data[15] = lo_bit_count;\n  sha_transform ();\n}\n\n/* compute the SHA digest of a FILE stream */\nvoid\nsha_stream ()\n{\n  int i, j;\n  const BYTE *p;\n\n  sha_init ();\n  for (j = 0; j < VSIZE; j++)\n    {\n      i = in_i[j];\n      p = &indata[j][0];\n      sha_update (p, i);\n    }\n  sha_final ();\n}\n"
      },
      {
        "file_name": "sha.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n#ifndef SHA_H\n#define SHA_H\n\n/* NIST Secure Hash Algorithm */\n/* heavily modified from Peter C. Gutmann's implementation */\n\n/* Useful defines & typedefs */\n\ntypedef unsigned char BYTE;\ntypedef unsigned int INT32;\n\n#define SHA_BLOCKSIZE\t\t64\n\nINT32 sha_info_digest[5];\t/* message digest */\nINT32 sha_info_count_lo, sha_info_count_hi;\t/* 64-bit bit count */\nINT32 sha_info_data[16];\n\nvoid sha_init ();\nvoid sha_update (const BYTE *, int);\nvoid sha_final ();\n\nvoid sha_stream ();\nvoid sha_print ();\n\n#define BLOCK_SIZE 8192\n#define VSIZE 2\n\n/*\n+--------------------------------------------------------------------------+\n| * Test Vectors (added for CHStone)                                       |\n|     indata, in_i : input data                                            |\n+--------------------------------------------------------------------------+\n*/\nconst BYTE indata[VSIZE][BLOCK_SIZE] = {\n  {75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111,\n   109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101,\n   115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100,\n   103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99,\n   108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102,\n   101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112,\n   102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116,\n   84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101,\n   102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110,\n   104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98,\n   121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114,\n   101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97,\n   100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109,\n   111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110,\n   109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103,\n   101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108,\n   100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118,\n   105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101,\n   114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116,\n   117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104,\n   101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117,\n   115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111,\n   117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111,\n   116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110,\n   100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117,\n   99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119,\n   109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121,\n   108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100,\n   104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114,\n   101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97,\n   114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116,\n   111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100,\n   114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99,\n   97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109,\n   117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108,\n   97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104,\n   111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101,\n   97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114,\n   101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105,\n   109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121,\n   97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79,\n   114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104,\n   97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116,\n   115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100,\n   100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115,\n   97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116,\n   104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115,\n   117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100,\n   111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101,\n   116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98,\n   101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98,\n   101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118,\n   101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119,\n   104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102,\n   109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115,\n   105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116,\n   104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114,\n   105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119,\n   105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115,\n   97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110,\n   101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108,\n   110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104,\n   101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121,\n   111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105,\n   108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116,\n   116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114,\n   115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116,\n   112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108,\n   102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121,\n   121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119,\n   104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108,\n   105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117,\n   97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121,\n   111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89,\n   111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121,\n   111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111,\n   114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117,\n   114, 101, 79, 114, 119, 111, 114, 114, 121, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116,\n   111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100,\n   114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99,\n   97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109,\n   117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108,\n   97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104,\n   111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101,\n   97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114,\n   101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105,\n   109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121,\n   97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79,\n   114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104,\n   97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117,\n   116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65,\n   100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101,\n   115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102,\n   116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108,\n   100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110,\n   101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114,\n   101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100,\n   98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109,\n   98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111,\n   118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115,\n   119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111,\n   102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97,\n   115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101,\n   116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101,\n   114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73,\n   119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105,\n   115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121,\n   116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117,\n   116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104,\n   110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108,\n   108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116,\n   105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117,\n   116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97,\n   114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97,\n   116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101,\n   108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97,\n   121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111,\n   119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105,\n   108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111,\n   117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115,\n   121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100,\n   89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115,\n   121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119,\n   111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110,\n   111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101,\n   103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110,\n   116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100,\n   105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110,\n   111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101,\n   97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111,\n   117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121,\n   111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117,\n   108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101,\n   114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112,\n   114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115,\n   116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115,\n   116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110,\n   111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98,\n   108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110,\n   100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99,\n   101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116,\n   104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106,\n   111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101,\n   97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104,\n   79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119,\n   105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110,\n   100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97,\n   117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117,\n   110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100,\n   66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121,\n   101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99,\n   107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114,\n   115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97,\n   119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110,\n   111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98,\n   105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121,\n   111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117,\n   115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101,\n   100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97,\n   115, 121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116,\n   119, 111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107,\n   110, 111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110,\n   101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111,\n   117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116,\n   101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110,\n   112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105,\n   115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101,\n   115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115,\n   110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105,\n   97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97,\n   110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110,\n   99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101,\n   116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110,\n   106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98,\n   101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116,\n   104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117,\n   119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97,\n   110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 75, 117, 114, 116,\n   86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110,\n   99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77,\n   73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108,\n   101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111,\n   102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110,\n   73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111,\n   117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116,\n   104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101,\n   101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108,\n   111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115,\n   111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101,\n   98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105,\n   101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116,\n   104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99,\n   101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101,\n   114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111,\n   119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112,\n   101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115,\n   112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101,\n   110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101,\n   114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117,\n   114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105,\n   110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100,\n   101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118,\n   101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109,\n   101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108,\n   108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115,\n   111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101,\n   99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110,\n   116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99,\n   104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121,\n   98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119,\n   102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108,\n   108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110,\n   111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103,\n   105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111,\n   117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111,\n   114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75,\n   117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117, 114, 116, 86,\n   111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99,\n   101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73,\n   84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117},\n  {116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97,\n   100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110,\n   50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111,\n   107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121,\n   111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108,\n   108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114,\n   97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111,\n   115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102,\n   111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98,\n   117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108,\n   111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97,\n   115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105, 110,\n   101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117, 116,\n   116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114, 114,\n   121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117, 114,\n   116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101,\n   110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97,\n   116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110,\n   116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115,\n   115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101,\n   101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114,\n   121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111,\n   114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104,\n   101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105,\n   116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97,\n   118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115,\n   99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97,\n   115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118,\n   105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114,\n   101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121,\n   111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120,\n   112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105,\n   115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99,\n   101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109,\n   105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110,\n   100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101,\n   114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117,\n   114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121,\n   118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116,\n   109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108,\n   108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111,\n   115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114,\n   101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97,\n   110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117,\n   99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97,\n   121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111,\n   119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97,\n   108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101,\n   110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97,\n   103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98,\n   111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119,\n   111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116,\n   116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65,\n   100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101,\n   115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102,\n   116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108,\n   100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110,\n   101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114,\n   101, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116,\n   115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100,\n   100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115,\n   97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116,\n   104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115,\n   117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100,\n   111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101,\n   116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98,\n   101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98,\n   101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118,\n   101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119,\n   104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102,\n   109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115,\n   105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116,\n   104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114,\n   105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119,\n   105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115,\n   97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110,\n   101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108,\n   110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104,\n   101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121,\n   111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105,\n   108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116,\n   116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114,\n   115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116,\n   112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108,\n   102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121,\n   121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119,\n   104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108,\n   105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117,\n   97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121,\n   111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89,\n   111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121,\n   111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111,\n   114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117,\n   114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111,\n   119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103,\n   117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116,\n   65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105,\n   101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111,\n   102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97,\n   114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117,\n   108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111,\n   110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117,\n   114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108,\n   100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114,\n   109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114,\n   111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116,\n   115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116,\n   111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98,\n   97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108,\n   101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100,\n   101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101,\n   73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104,\n   105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111,\n   121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97,\n   117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79,\n   104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105,\n   108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100,\n   116, 104, 101, 112, 111, 119, 101, 114, 97, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116,\n   111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100,\n   114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99,\n   97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109,\n   117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108,\n   97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104,\n   111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101,\n   97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114,\n   101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105,\n   109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121,\n   97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79,\n   114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104,\n   97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117,\n   116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65,\n   100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101,\n   115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102,\n   116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108,\n   100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110,\n   101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114,\n   101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100,\n   98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109,\n   98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111,\n   118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115,\n   119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111,\n   102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97,\n   115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101,\n   116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101,\n   114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73,\n   119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105,\n   115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121,\n   116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117,\n   116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104,\n   110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108,\n   108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116,\n   105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117,\n   116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97,\n   114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97,\n   116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101,\n   108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97,\n   121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111,\n   119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105,\n   108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111,\n   117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115,\n   121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100,\n   89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115,\n   121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119,\n   111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110,\n   111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101,\n   103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110,\n   116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100,\n   105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110,\n   111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101,\n   97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111,\n   117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121,\n   111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117,\n   108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101,\n   114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112,\n   114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115,\n   116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115,\n   116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110,\n   111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98,\n   108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110,\n   100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99,\n   101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116,\n   104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106,\n   111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101,\n   97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104,\n   79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119,\n   105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110,\n   100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97,\n   117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117,\n   110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100,\n   66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121,\n   101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99,\n   107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114,\n   115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97,\n   119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110,\n   111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98,\n   105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121,\n   111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117,\n   115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101,\n   100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97,\n   115, 121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116,\n   119, 111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107,\n   110, 111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110,\n   101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111,\n   117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116,\n   101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110,\n   112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105,\n   115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101,\n   115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115,\n   110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105,\n   97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97,\n   110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110,\n   99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101,\n   116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110,\n   106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98,\n   101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116,\n   104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117,\n   119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97,\n   110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101,\n   97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104,\n   117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101,\n   100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48,\n   121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98,\n   97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111,\n   117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108,\n   105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97,\n   115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115,\n   115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111,\n   114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117,\n   108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111,\n   111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115,\n   102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68,\n   111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98,\n   117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104,\n   101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105,\n   116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97,\n   118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115,\n   99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97,\n   115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118,\n   105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114,\n   101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121,\n   111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120,\n   112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105,\n   115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99,\n   101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109,\n   105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110,\n   100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101,\n   114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117,\n   114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121,\n   118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116,\n   109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108,\n   108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111,\n   115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114,\n   101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97,\n   110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117,\n   99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97,\n   121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111,\n   119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97,\n   108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101,\n   110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97,\n   103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98,\n   111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119,\n   111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111}\n};\nconst int in_i[VSIZE] = { 8192, 8192 };\n#endif /* SHA_H */\n"
      }
    ],
    "code_length": 5083,
    "token_count": 1592,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/sha256/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1077,
    "Worst-caseLatency": 1077.0,
    "BRAM_18K": 0,
    "LUT": 55635,
    "DSP": 0,
    "FF": 10984,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sha256",
    "ResourceMetric": 0.01172201,
    "design_id": "project",
    "algo_name": "sha256",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "sha256.cpp",
        "file_content": "#include <stdint.h>\n\n#define INPUT_SIZE 1024\n\nvoid sha256_transform(uint32_t state[8], const uint8_t data[64]) {\n    uint32_t a, b, c, d, e, f, g, h, t1, t2, m[64];\n    const uint32_t k[64] = {\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n    };\n\n    for (int i = 0, j = 0; i < 16; ++i, j += 4)\n        m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);\n    for (int i = 16; i < 64; ++i)\n        m[i] = m[i - 16] + ((m[i - 15] >> 7 | m[i - 15] << (32 - 7)) ^ (m[i - 15] >> 18 | m[i - 15] << (32 - 18)) ^ (m[i - 15] >> 3)) + m[i - 7] + ((m[i - 2] >> 17 | m[i - 2] << (32 - 17)) ^ (m[i - 2] >> 19 | m[i - 2] << (32 - 19)) ^ (m[i - 2] >> 10));\n\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    f = state[5];\n    g = state[6];\n    h = state[7];\n\n    for (int i = 0; i < 64; ++i) {\n        t1 = h + ((e >> 6 | e << (32 - 6)) ^ (e >> 11 | e << (32 - 11)) ^ (e >> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g)) + k[i] + m[i];\n        t2 = ((a >> 2 | a << (32 - 2)) ^ (a >> 13 | a << (32 - 13)) ^ (a >> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c));\n        h = g;\n        g = f;\n        f = e;\n        e = d + t1;\n        d = c;\n        c = b;\n        b = a;\n        a = t1 + t2;\n    }\n\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    state[5] += f;\n    state[6] += g;\n    state[7] += h;\n}\n\nvoid sha256(uint8_t hash[32], const uint8_t input[INPUT_SIZE]) {\n    uint32_t state[8] = {\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    };\n    uint8_t data[64];\n    uint32_t bitlen = INPUT_SIZE * 8;\n    int i;\n\n    for (i = 0; i < INPUT_SIZE / 64; ++i)\n        sha256_transform(state, input + i * 64);\n\n    int rem = INPUT_SIZE % 64;\n    for (i = 0; i < rem; ++i)\n        data[i] = input[INPUT_SIZE / 64 * 64 + i];\n    data[rem++] = 0x80;\n    if (rem > 56) {\n        for (i = rem; i < 64; ++i)\n            data[i] = 0;\n        sha256_transform(state, data);\n        rem = 0;\n    }\n    for (i = rem; i < 56; ++i)\n        data[i] = 0;\n    for (i = 0; i < 8; ++i)\n        data[63 - i] = bitlen >> (i * 8);\n    sha256_transform(state, data);\n\n    for (i = 0; i < 8; ++i) {\n        hash[i * 4] = (state[i] >> 24) & 0xff;\n        hash[i * 4 + 1] = (state[i] >> 16) & 0xff;\n        hash[i * 4 + 2] = (state[i] >> 8) & 0xff;\n        hash[i * 4 + 3] = state[i] & 0xff;\n    }\n}\n\n// Top function name: sha256\n"
      }
    ],
    "code_length": 3272,
    "token_count": 1626,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/spam-filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 18491531,
    "Worst-caseLatency": 18492726.0,
    "BRAM_18K": 10,
    "LUT": 5574,
    "DSP": 8,
    "FF": 880,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "SgdLR",
    "ResourceMetric": 0.0019949447,
    "design_id": "project",
    "algo_name": "spam-filter",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "sgd.cpp",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          typedefs.h                           */\n/*                                                               */\n/*              Constant definitions and typedefs.               */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\n\n\n\n// dataset information\nconst int NUM_FEATURES  = 1024;\nconst int NUM_SAMPLES   = 5000;\nconst int NUM_TRAINING  = 4500;\nconst int NUM_TESTING   = 500;\nconst int STEP_SIZE     = 60000; \nconst int NUM_EPOCHS    = 5;\nconst int DATA_SET_SIZE = NUM_FEATURES * NUM_SAMPLES;\n\n#ifdef OCL\n  #include <string>\n  // target device\n  // change here to map to a different device\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n// datatypes for accelerator\n\n#ifndef SW\n  #ifdef SDSOC\n    // embedded platforms have less off-chip bandwidth\n    #define VFTYPE_WIDTH  64\n    #define VDTYPE_WIDTH  64\n  #else\n    // take advantage of the off-chip bandwidth of ocl platforms\n    #define VFTYPE_WIDTH  512\n    #define VDTYPE_WIDTH  512\n  #endif\n\n  #include \"ap_int.h\"\n  #include \"ap_fixed.h\"\n  // features / parameters\n  #define FTYPE_TWIDTH 32\n  #define FTYPE_IWIDTH 13\n  typedef ap_fixed<FTYPE_TWIDTH,FTYPE_IWIDTH> FeatureType;\n  typedef ap_uint<VFTYPE_WIDTH>               VectorFeatureType;\n  const unsigned int F_VECTOR_SIZE = VFTYPE_WIDTH / FTYPE_TWIDTH;\n  // training data\n  #define DTYPE_TWIDTH 16\n  #define DTYPE_IWIDTH 4\n  typedef ap_fixed<DTYPE_TWIDTH,DTYPE_IWIDTH>  DataType;\n  typedef ap_uint<VDTYPE_WIDTH>                VectorDataType;\n  const unsigned int D_VECTOR_SIZE = VDTYPE_WIDTH / DTYPE_TWIDTH;\n  // label\n  #define LTYPE_WIDTH   8\n  #define VLTYPE_WIDTH  32\n  typedef ap_uint<LTYPE_WIDTH>                 LabelType;\n  typedef ap_uint<VLTYPE_WIDTH>                VectorLabelType;\n  const unsigned int L_VECTOR_SIZE = VLTYPE_WIDTH / LTYPE_WIDTH;\n  \n  // datatypes for the LUT\n  #define LUTOUT_TWIDTH     12\n  #define LUTOUT_IWIDTH     2\n  #define LUTIN_TWIDTH      12\n  #define LUTIN_IWIDTH      4\n  typedef ap_ufixed<32, 20> TmpFixed; \n  typedef ap_uint<LUTIN_TWIDTH> IdxFixed; \n  typedef ap_fixed<LUTIN_TWIDTH, LUTIN_IWIDTH> LutInFixed;\n  typedef ap_fixed<LUTOUT_TWIDTH, LUTOUT_IWIDTH> LutOutFixed;\n#else\n  // software version uses C++ built-in datatypes\n  typedef float FeatureType;\n  typedef float DataType;\n  typedef unsigned char LabelType;\n  // and uses math functions to compute sigmoid values\n  // no need to declare special datatype for sigmoid\n#endif\n\n#define PAR_FACTOR 32\n\n#endif\n\n/*===============================================================*/\n/*                                                               */\n/*                          sgd.cpp                              */\n/*                                                               */\n/*             Hardware function for spam filtering.             */\n/*                                                               */\n/*===============================================================*/\n\n#include \"sgd.h\"\n#include \"lut.h\"\n\n// wrapper for the streamin part\n// prevent incorrect flattening\nvoid read_data(VectorDataType  data[NUM_FEATURES / D_VECTOR_SIZE], \n               DataType        training_instance[NUM_FEATURES])\n{\n  #pragma HLS INLINE\n\n  READ_TRAINING_DATA: for (int i = 0; i < NUM_FEATURES / D_VECTOR_SIZE; i ++ )\n  {\n\n    VectorFeatureType tmp_data = data[i];\n    READ_TRAINING_DATA_INNER: for (int j = 0; j < D_VECTOR_SIZE; j ++ )\n      training_instance[i * D_VECTOR_SIZE + j].range(DTYPE_TWIDTH-1, 0) = tmp_data.range((j+1)*DTYPE_TWIDTH-1, j*DTYPE_TWIDTH);\n  }\n}\n\n// Function to compute the dot product of data (feature) vector and parameter vector\nFeatureType dotProduct(FeatureType param[NUM_FEATURES],\n                       DataType    feature[NUM_FEATURES])\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n  \n\n\n\n  FeatureType result = 0;\n  DOT: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n\n    DOT_INNER: for(int j = 0; j < PAR_FACTOR; j++) \n    {\n      FeatureType term = param[i*PAR_FACTOR+j] * feature[i*PAR_FACTOR+j];\n      result += term;\n    }\n  }\n  return result;\n}\n\n// values of sigmoid function stored in a look-up table\nFeatureType useLUT(FeatureType in) \n{ \n  #pragma HLS INLINE\n  IdxFixed index;\n  if (in < 0)\n  {\n    in = -in;\n    index = (IdxFixed)LUT_SIZE - (IdxFixed)(((TmpFixed)in) << (LUTIN_TWIDTH - LUTIN_IWIDTH));  \n  } \n  else \n    index = ((TmpFixed)in) << (LUTIN_TWIDTH - LUTIN_IWIDTH);  \n  return lut[index];\n}\n\n// Function to compute the probability. The Sigmoid function is implemented using BRAMS \n// to store the value of Sigmoid function for values relevant to this application\nFeatureType Sigmoid(FeatureType exponent) \n{\n  #pragma HLS INLINE\n  if (exponent > 4) \n    return 1.0;\n  else if (exponent < -4) \n    return 0.0;\n  else \n  {\n    LutInFixed inLut = (LutInFixed)exponent;\n    return useLUT(inLut);\n  } \n}\n\n// Compute the gradient of the cost function\nvoid computeGradient(\n    FeatureType grad[NUM_FEATURES],\n    DataType    feature[NUM_FEATURES],\n    FeatureType scale)\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n\n\n  GRAD: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n\n    GRAD_INNER: for (int j = 0; j < PAR_FACTOR; j++)\n      grad[i*PAR_FACTOR+j] = (scale * feature[i*PAR_FACTOR+j]);\n  }\n}\n\n// Update the parameter vector\nvoid updateParameter(\n    FeatureType param[NUM_FEATURES],\n    FeatureType grad[NUM_FEATURES],\n    FeatureType scale)\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n\n\n\n  UPDATE: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n\n    UPDATE_INNER: for (int j = 0; j < PAR_FACTOR; j++)\n      param[i*PAR_FACTOR+j] += scale * grad[i*PAR_FACTOR+j];\n  }\n}\n\n// stream out the data\nvoid streamOut(FeatureType theta_local[NUM_FEATURES], VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE])\n{\n  #pragma HLS INLINE\n  // stream out the result\n  STREAM_OUT: for (int i = 0; i < NUM_FEATURES / F_VECTOR_SIZE; i ++ )\n  {\n\n    VectorFeatureType tmp_theta = 0;\n    STREAM_OUT_INNER: for (int j = 0; j < F_VECTOR_SIZE; j ++ )\n      tmp_theta.range((j+1)*FTYPE_TWIDTH-1, j*FTYPE_TWIDTH) = theta_local[i * F_VECTOR_SIZE + j].range(FTYPE_TWIDTH-1, 0);\n    theta[i] = tmp_theta;\n  }\n\n}\n\n// wrapper, wraps the compute part for dataflow\nvoid compute(FeatureType theta_local[NUM_FEATURES], \n             LabelType training_label,\n             DataType training_instance[NUM_FEATURES])\n{\n  // array for storing gradient\n  FeatureType gradient[NUM_FEATURES];\n\n  // step size\n  FeatureType step = STEP_SIZE;\n\n  // do dot product with the parameter vector\n  FeatureType dot = dotProduct(theta_local, training_instance);\n  // do sigmoid function\n  FeatureType prob = Sigmoid(dot);\n  // compute gradient\n  computeGradient(gradient, training_instance, (prob-training_label));\n  // update the param vector\n  updateParameter(theta_local, gradient, -step);\n}\n\n\n\n// top-level function \nvoid SgdLR( VectorDataType    data[NUM_FEATURES * NUM_TRAINING / D_VECTOR_SIZE],\n            VectorLabelType   label[NUM_TRAINING / L_VECTOR_SIZE],\n            VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE],\n            bool readLabels,\n            bool writeOutput)\n{\n  // intermediate variables \n\n  // local version of the parameters\n  static FeatureType theta_local[NUM_FEATURES];\n  // local buffer of labels\n  static LabelType   label_local[NUM_TRAINING];\n\n  // array for storing one training instance\n  static DataType training_instance[NUM_FEATURES];\n\n  if (readLabels)\n  {\n    // copy in labels\n    LABEL_CP: for (int i = 0; i < NUM_TRAINING / L_VECTOR_SIZE; i ++ )\n    {\n\n      VectorLabelType tmp_label = label[i];\n      LABEL_CP_INNER: for (int j = 0; j < L_VECTOR_SIZE; j ++ )\n        label_local[i * L_VECTOR_SIZE + j].range(LTYPE_WIDTH-1, 0) = tmp_label.range((j+1)*LTYPE_WIDTH-1, j*LTYPE_WIDTH);\n    }\n  }\n\n  // main loop\n  // in each epoch, go through each training instance in sequence\n  TRAINING_INST: for( int training_id = 0; training_id < NUM_TRAINING; training_id ++ )\n  {  \n    #pragma HLS dataflow\n    // get the label\n    LabelType training_label = label_local[training_id];\n    // first reads in the training instance\n    read_data(data + training_id * NUM_FEATURES / D_VECTOR_SIZE, training_instance);\n    // compute part\n    compute(theta_local, training_label, training_instance);\n  }\n\n  if (writeOutput)\n    streamOut(theta_local, theta);\n}\n"
      },
      {
        "file_name": "sgd.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                            sgd.h                              */\n/*                                                               */\n/*          Top-level hardware function declaration              */\n/*                                                               */\n/*===============================================================*/\n\n#include \"typedefs.h\"\n\n// top-level function declaration\n#pragma SDS data mem_attribute(data:NON_CACHEABLE|PHYSICAL_CONTIGUOUS, label:CACHEABLE|PHYSICAL_CONTIGUOUS, theta:CACHEABLE|PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(data:AXIDMA_SG, label:AXIFIFO, theta:AXIDMA_SG)\n#pragma SDS data sys_port(data:AFI, label:AFI, theta:AFI)\n#pragma SDS data zero_copy(theta[0:NUM_FEATURES / F_VECTOR_SIZE])\n#pragma SDS data copy(data[0:NUM_FEATURES * NUM_TRAINING/D_VECTOR_SIZE])\n#pragma SDS data zero_copy(label[0:NUM_TRAINING/L_VECTOR_SIZE])\n#pragma SDS data access_pattern(data:SEQUENTIAL, label:SEQUENTIAL, theta:SEQUENTIAL) \nvoid SgdLR( VectorDataType    data[NUM_FEATURES * NUM_TRAINING / D_VECTOR_SIZE],\n            VectorLabelType   label[NUM_TRAINING / L_VECTOR_SIZE],\n            VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE],\n            bool readLabels,\n            bool writeOutput);\n\n"
      },
      {
        "file_name": "typedefs.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          typedefs.h                           */\n/*                                                               */\n/*              Constant definitions and typedefs.               */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\n\n\n\n// dataset information\nconst int NUM_FEATURES  = 1024;\nconst int NUM_SAMPLES   = 5000;\nconst int NUM_TRAINING  = 4500;\nconst int NUM_TESTING   = 500;\nconst int STEP_SIZE     = 60000; \nconst int NUM_EPOCHS    = 5;\nconst int DATA_SET_SIZE = NUM_FEATURES * NUM_SAMPLES;\n\n#ifdef OCL\n  #include <string>\n  // target device\n  // change here to map to a different device\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n// datatypes for accelerator\n\n#ifndef SW\n  #ifdef SDSOC\n    // embedded platforms have less off-chip bandwidth\n    #define VFTYPE_WIDTH  64\n    #define VDTYPE_WIDTH  64\n  #else\n    // take advantage of the off-chip bandwidth of ocl platforms\n    #define VFTYPE_WIDTH  512\n    #define VDTYPE_WIDTH  512\n  #endif\n\n  #include \"ap_int.h\"\n  #include \"ap_fixed.h\"\n  // features / parameters\n  #define FTYPE_TWIDTH 32\n  #define FTYPE_IWIDTH 13\n  typedef ap_fixed<FTYPE_TWIDTH,FTYPE_IWIDTH> FeatureType;\n  typedef ap_uint<VFTYPE_WIDTH>               VectorFeatureType;\n  const unsigned int F_VECTOR_SIZE = VFTYPE_WIDTH / FTYPE_TWIDTH;\n  // training data\n  #define DTYPE_TWIDTH 16\n  #define DTYPE_IWIDTH 4\n  typedef ap_fixed<DTYPE_TWIDTH,DTYPE_IWIDTH>  DataType;\n  typedef ap_uint<VDTYPE_WIDTH>                VectorDataType;\n  const unsigned int D_VECTOR_SIZE = VDTYPE_WIDTH / DTYPE_TWIDTH;\n  // label\n  #define LTYPE_WIDTH   8\n  #define VLTYPE_WIDTH  32\n  typedef ap_uint<LTYPE_WIDTH>                 LabelType;\n  typedef ap_uint<VLTYPE_WIDTH>                VectorLabelType;\n  const unsigned int L_VECTOR_SIZE = VLTYPE_WIDTH / LTYPE_WIDTH;\n  \n  // datatypes for the LUT\n  #define LUTOUT_TWIDTH     12\n  #define LUTOUT_IWIDTH     2\n  #define LUTIN_TWIDTH      12\n  #define LUTIN_IWIDTH      4\n  typedef ap_ufixed<32, 20> TmpFixed; \n  typedef ap_uint<LUTIN_TWIDTH> IdxFixed; \n  typedef ap_fixed<LUTIN_TWIDTH, LUTIN_IWIDTH> LutInFixed;\n  typedef ap_fixed<LUTOUT_TWIDTH, LUTOUT_IWIDTH> LutOutFixed;\n#else\n  // software version uses C++ built-in datatypes\n  typedef float FeatureType;\n  typedef float DataType;\n  typedef unsigned char LabelType;\n  // and uses math functions to compute sigmoid values\n  // no need to declare special datatype for sigmoid\n#endif\n\n#define PAR_FACTOR 32\n\n#endif\n"
      },
      {
        "file_name": "lut.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                            lut.h                              */\n/*                                                               */\n/*          Stores the look-up table for sigmoid function.       */\n/*                                                               */\n/*===============================================================*/\n\n\nconst int LUT_SIZE = 2048;\nstatic const LutOutFixed lut[LUT_SIZE] = {\n\t0.500000,\n\t0.500977,\n\t0.501953,\n\t0.502930,\n\t0.503906,\n\t0.504883,\n\t0.505859,\n\t0.506836,\n\t0.507812,\n\t0.508789,\n\t0.509766,\n\t0.510742,\n\t0.511719,\n\t0.512695,\n\t0.513672,\n\t0.514648,\n\t0.515625,\n\t0.516602,\n\t0.517578,\n\t0.518555,\n\t0.519531,\n\t0.520508,\n\t0.521484,\n\t0.522461,\n\t0.523438,\n\t0.524414,\n\t0.525391,\n\t0.526367,\n\t0.527344,\n\t0.528320,\n\t0.529297,\n\t0.530273,\n\t0.531250,\n\t0.532227,\n\t0.533203,\n\t0.534180,\n\t0.535156,\n\t0.536133,\n\t0.537109,\n\t0.538086,\n\t0.539062,\n\t0.540039,\n\t0.541016,\n\t0.541992,\n\t0.542969,\n\t0.543945,\n\t0.544922,\n\t0.545898,\n\t0.546875,\n\t0.547852,\n\t0.548828,\n\t0.549805,\n\t0.550781,\n\t0.551758,\n\t0.552734,\n\t0.553711,\n\t0.554688,\n\t0.555664,\n\t0.556641,\n\t0.557617,\n\t0.558594,\n\t0.559570,\n\t0.560547,\n\t0.561523,\n\t0.562500,\n\t0.563477,\n\t0.564453,\n\t0.565430,\n\t0.566406,\n\t0.567383,\n\t0.568359,\n\t0.569336,\n\t0.570312,\n\t0.571289,\n\t0.572266,\n\t0.573242,\n\t0.574219,\n\t0.575195,\n\t0.576172,\n\t0.577148,\n\t0.578125,\n\t0.579102,\n\t0.580078,\n\t0.581055,\n\t0.582031,\n\t0.583008,\n\t0.583984,\n\t0.584961,\n\t0.585938,\n\t0.586914,\n\t0.587891,\n\t0.588867,\n\t0.588867,\n\t0.589844,\n\t0.590820,\n\t0.591797,\n\t0.592773,\n\t0.593750,\n\t0.594727,\n\t0.595703,\n\t0.596680,\n\t0.597656,\n\t0.598633,\n\t0.599609,\n\t0.600586,\n\t0.601562,\n\t0.602539,\n\t0.603516,\n\t0.604492,\n\t0.605469,\n\t0.606445,\n\t0.607422,\n\t0.608398,\n\t0.609375,\n\t0.610352,\n\t0.611328,\n\t0.612305,\n\t0.612305,\n\t0.613281,\n\t0.614258,\n\t0.615234,\n\t0.616211,\n\t0.617188,\n\t0.618164,\n\t0.619141,\n\t0.620117,\n\t0.621094,\n\t0.622070,\n\t0.623047,\n\t0.624023,\n\t0.625000,\n\t0.625977,\n\t0.626953,\n\t0.627930,\n\t0.627930,\n\t0.628906,\n\t0.629883,\n\t0.630859,\n\t0.631836,\n\t0.632812,\n\t0.633789,\n\t0.634766,\n\t0.635742,\n\t0.636719,\n\t0.637695,\n\t0.638672,\n\t0.639648,\n\t0.640625,\n\t0.640625,\n\t0.641602,\n\t0.642578,\n\t0.643555,\n\t0.644531,\n\t0.645508,\n\t0.646484,\n\t0.647461,\n\t0.648438,\n\t0.649414,\n\t0.650391,\n\t0.650391,\n\t0.651367,\n\t0.652344,\n\t0.653320,\n\t0.654297,\n\t0.655273,\n\t0.656250,\n\t0.657227,\n\t0.658203,\n\t0.659180,\n\t0.660156,\n\t0.660156,\n\t0.661133,\n\t0.662109,\n\t0.663086,\n\t0.664062,\n\t0.665039,\n\t0.666016,\n\t0.666992,\n\t0.667969,\n\t0.667969,\n\t0.668945,\n\t0.669922,\n\t0.670898,\n\t0.671875,\n\t0.672852,\n\t0.673828,\n\t0.674805,\n\t0.674805,\n\t0.675781,\n\t0.676758,\n\t0.677734,\n\t0.678711,\n\t0.679688,\n\t0.680664,\n\t0.681641,\n\t0.681641,\n\t0.682617,\n\t0.683594,\n\t0.684570,\n\t0.685547,\n\t0.686523,\n\t0.687500,\n\t0.687500,\n\t0.688477,\n\t0.689453,\n\t0.690430,\n\t0.691406,\n\t0.692383,\n\t0.693359,\n\t0.693359,\n\t0.694336,\n\t0.695312,\n\t0.696289,\n\t0.697266,\n\t0.698242,\n\t0.699219,\n\t0.699219,\n\t0.700195,\n\t0.701172,\n\t0.702148,\n\t0.703125,\n\t0.704102,\n\t0.704102,\n\t0.705078,\n\t0.706055,\n\t0.707031,\n\t0.708008,\n\t0.708984,\n\t0.708984,\n\t0.709961,\n\t0.710938,\n\t0.711914,\n\t0.712891,\n\t0.712891,\n\t0.713867,\n\t0.714844,\n\t0.715820,\n\t0.716797,\n\t0.717773,\n\t0.717773,\n\t0.718750,\n\t0.719727,\n\t0.720703,\n\t0.721680,\n\t0.721680,\n\t0.722656,\n\t0.723633,\n\t0.724609,\n\t0.725586,\n\t0.725586,\n\t0.726562,\n\t0.727539,\n\t0.728516,\n\t0.729492,\n\t0.729492,\n\t0.730469,\n\t0.731445,\n\t0.732422,\n\t0.732422,\n\t0.733398,\n\t0.734375,\n\t0.735352,\n\t0.736328,\n\t0.736328,\n\t0.737305,\n\t0.738281,\n\t0.739258,\n\t0.739258,\n\t0.740234,\n\t0.741211,\n\t0.742188,\n\t0.743164,\n\t0.743164,\n\t0.744141,\n\t0.745117,\n\t0.746094,\n\t0.746094,\n\t0.747070,\n\t0.748047,\n\t0.749023,\n\t0.749023,\n\t0.750000,\n\t0.750977,\n\t0.751953,\n\t0.751953,\n\t0.752930,\n\t0.753906,\n\t0.754883,\n\t0.754883,\n\t0.755859,\n\t0.756836,\n\t0.756836,\n\t0.757812,\n\t0.758789,\n\t0.759766,\n\t0.759766,\n\t0.760742,\n\t0.761719,\n\t0.762695,\n\t0.762695,\n\t0.763672,\n\t0.764648,\n\t0.764648,\n\t0.765625,\n\t0.766602,\n\t0.767578,\n\t0.767578,\n\t0.768555,\n\t0.769531,\n\t0.769531,\n\t0.770508,\n\t0.771484,\n\t0.772461,\n\t0.772461,\n\t0.773438,\n\t0.774414,\n\t0.774414,\n\t0.775391,\n\t0.776367,\n\t0.776367,\n\t0.777344,\n\t0.778320,\n\t0.779297,\n\t0.779297,\n\t0.780273,\n\t0.781250,\n\t0.781250,\n\t0.782227,\n\t0.783203,\n\t0.783203,\n\t0.784180,\n\t0.785156,\n\t0.785156,\n\t0.786133,\n\t0.787109,\n\t0.787109,\n\t0.788086,\n\t0.789062,\n\t0.789062,\n\t0.790039,\n\t0.791016,\n\t0.791016,\n\t0.791992,\n\t0.792969,\n\t0.792969,\n\t0.793945,\n\t0.794922,\n\t0.794922,\n\t0.795898,\n\t0.796875,\n\t0.796875,\n\t0.797852,\n\t0.797852,\n\t0.798828,\n\t0.799805,\n\t0.799805,\n\t0.800781,\n\t0.801758,\n\t0.801758,\n\t0.802734,\n\t0.803711,\n\t0.803711,\n\t0.804688,\n\t0.804688,\n\t0.805664,\n\t0.806641,\n\t0.806641,\n\t0.807617,\n\t0.808594,\n\t0.808594,\n\t0.809570,\n\t0.809570,\n\t0.810547,\n\t0.811523,\n\t0.811523,\n\t0.812500,\n\t0.812500,\n\t0.813477,\n\t0.814453,\n\t0.814453,\n\t0.815430,\n\t0.816406,\n\t0.816406,\n\t0.817383,\n\t0.817383,\n\t0.818359,\n\t0.818359,\n\t0.819336,\n\t0.820312,\n\t0.820312,\n\t0.821289,\n\t0.821289,\n\t0.822266,\n\t0.823242,\n\t0.823242,\n\t0.824219,\n\t0.824219,\n\t0.825195,\n\t0.825195,\n\t0.826172,\n\t0.827148,\n\t0.827148,\n\t0.828125,\n\t0.828125,\n\t0.829102,\n\t0.829102,\n\t0.830078,\n\t0.831055,\n\t0.831055,\n\t0.832031,\n\t0.832031,\n\t0.833008,\n\t0.833008,\n\t0.833984,\n\t0.833984,\n\t0.834961,\n\t0.835938,\n\t0.835938,\n\t0.836914,\n\t0.836914,\n\t0.837891,\n\t0.837891,\n\t0.838867,\n\t0.838867,\n\t0.839844,\n\t0.839844,\n\t0.840820,\n\t0.841797,\n\t0.841797,\n\t0.842773,\n\t0.842773,\n\t0.843750,\n\t0.843750,\n\t0.844727,\n\t0.844727,\n\t0.845703,\n\t0.845703,\n\t0.846680,\n\t0.846680,\n\t0.847656,\n\t0.847656,\n\t0.848633,\n\t0.848633,\n\t0.849609,\n\t0.849609,\n\t0.850586,\n\t0.850586,\n\t0.851562,\n\t0.851562,\n\t0.852539,\n\t0.852539,\n\t0.853516,\n\t0.853516,\n\t0.854492,\n\t0.854492,\n\t0.855469,\n\t0.855469,\n\t0.856445,\n\t0.856445,\n\t0.857422,\n\t0.857422,\n\t0.858398,\n\t0.858398,\n\t0.859375,\n\t0.859375,\n\t0.860352,\n\t0.860352,\n\t0.861328,\n\t0.861328,\n\t0.862305,\n\t0.862305,\n\t0.863281,\n\t0.863281,\n\t0.864258,\n\t0.864258,\n\t0.864258,\n\t0.865234,\n\t0.865234,\n\t0.866211,\n\t0.866211,\n\t0.867188,\n\t0.867188,\n\t0.868164,\n\t0.868164,\n\t0.869141,\n\t0.869141,\n\t0.870117,\n\t0.870117,\n\t0.870117,\n\t0.871094,\n\t0.871094,\n\t0.872070,\n\t0.872070,\n\t0.873047,\n\t0.873047,\n\t0.874023,\n\t0.874023,\n\t0.874023,\n\t0.875000,\n\t0.875000,\n\t0.875977,\n\t0.875977,\n\t0.876953,\n\t0.876953,\n\t0.876953,\n\t0.877930,\n\t0.877930,\n\t0.878906,\n\t0.878906,\n\t0.879883,\n\t0.879883,\n\t0.879883,\n\t0.880859,\n\t0.880859,\n\t0.881836,\n\t0.881836,\n\t0.882812,\n\t0.882812,\n\t0.882812,\n\t0.883789,\n\t0.883789,\n\t0.884766,\n\t0.884766,\n\t0.884766,\n\t0.885742,\n\t0.885742,\n\t0.886719,\n\t0.886719,\n\t0.886719,\n\t0.887695,\n\t0.887695,\n\t0.888672,\n\t0.888672,\n\t0.888672,\n\t0.889648,\n\t0.889648,\n\t0.890625,\n\t0.890625,\n\t0.890625,\n\t0.891602,\n\t0.891602,\n\t0.891602,\n\t0.892578,\n\t0.892578,\n\t0.893555,\n\t0.893555,\n\t0.893555,\n\t0.894531,\n\t0.894531,\n\t0.895508,\n\t0.895508,\n\t0.895508,\n\t0.896484,\n\t0.896484,\n\t0.896484,\n\t0.897461,\n\t0.897461,\n\t0.897461,\n\t0.898438,\n\t0.898438,\n\t0.899414,\n\t0.899414,\n\t0.899414,\n\t0.900391,\n\t0.900391,\n\t0.900391,\n\t0.901367,\n\t0.901367,\n\t0.901367,\n\t0.902344,\n\t0.902344,\n\t0.902344,\n\t0.903320,\n\t0.903320,\n\t0.904297,\n\t0.904297,\n\t0.904297,\n\t0.905273,\n\t0.905273,\n\t0.905273,\n\t0.906250,\n\t0.906250,\n\t0.906250,\n\t0.907227,\n\t0.907227,\n\t0.907227,\n\t0.908203,\n\t0.908203,\n\t0.908203,\n\t0.909180,\n\t0.909180,\n\t0.909180,\n\t0.910156,\n\t0.910156,\n\t0.910156,\n\t0.911133,\n\t0.911133,\n\t0.911133,\n\t0.912109,\n\t0.912109,\n\t0.912109,\n\t0.912109,\n\t0.913086,\n\t0.913086,\n\t0.913086,\n\t0.914062,\n\t0.914062,\n\t0.914062,\n\t0.915039,\n\t0.915039,\n\t0.915039,\n\t0.916016,\n\t0.916016,\n\t0.916016,\n\t0.916992,\n\t0.916992,\n\t0.916992,\n\t0.916992,\n\t0.917969,\n\t0.917969,\n\t0.917969,\n\t0.918945,\n\t0.918945,\n\t0.918945,\n\t0.919922,\n\t0.919922,\n\t0.919922,\n\t0.919922,\n\t0.920898,\n\t0.920898,\n\t0.920898,\n\t0.921875,\n\t0.921875,\n\t0.921875,\n\t0.921875,\n\t0.922852,\n\t0.922852,\n\t0.922852,\n\t0.923828,\n\t0.923828,\n\t0.923828,\n\t0.923828,\n\t0.924805,\n\t0.924805,\n\t0.924805,\n\t0.924805,\n\t0.925781,\n\t0.925781,\n\t0.925781,\n\t0.926758,\n\t0.926758,\n\t0.926758,\n\t0.926758,\n\t0.927734,\n\t0.927734,\n\t0.927734,\n\t0.927734,\n\t0.928711,\n\t0.928711,\n\t0.928711,\n\t0.929688,\n\t0.929688,\n\t0.929688,\n\t0.929688,\n\t0.930664,\n\t0.930664,\n\t0.930664,\n\t0.930664,\n\t0.931641,\n\t0.931641,\n\t0.931641,\n\t0.931641,\n\t0.932617,\n\t0.932617,\n\t0.932617,\n\t0.932617,\n\t0.933594,\n\t0.933594,\n\t0.933594,\n\t0.933594,\n\t0.934570,\n\t0.934570,\n\t0.934570,\n\t0.934570,\n\t0.935547,\n\t0.935547,\n\t0.935547,\n\t0.935547,\n\t0.935547,\n\t0.936523,\n\t0.936523,\n\t0.936523,\n\t0.936523,\n\t0.937500,\n\t0.937500,\n\t0.937500,\n\t0.937500,\n\t0.938477,\n\t0.938477,\n\t0.938477,\n\t0.938477,\n\t0.939453,\n\t0.939453,\n\t0.939453,\n\t0.939453,\n\t0.939453,\n\t0.940430,\n\t0.940430,\n\t0.940430,\n\t0.940430,\n\t0.941406,\n\t0.941406,\n\t0.941406,\n\t0.941406,\n\t0.941406,\n\t0.942383,\n\t0.942383,\n\t0.942383,\n\t0.942383,\n\t0.942383,\n\t0.943359,\n\t0.943359,\n\t0.943359,\n\t0.943359,\n\t0.944336,\n\t0.944336,\n\t0.944336,\n\t0.944336,\n\t0.944336,\n\t0.945312,\n\t0.945312,\n\t0.945312,\n\t0.945312,\n\t0.945312,\n\t0.946289,\n\t0.946289,\n\t0.946289,\n\t0.946289,\n\t0.946289,\n\t0.947266,\n\t0.947266,\n\t0.947266,\n\t0.947266,\n\t0.947266,\n\t0.948242,\n\t0.948242,\n\t0.948242,\n\t0.948242,\n\t0.948242,\n\t0.949219,\n\t0.949219,\n\t0.949219,\n\t0.949219,\n\t0.949219,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.951172,\n\t0.951172,\n\t0.951172,\n\t0.951172,\n\t0.951172,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.953125,\n\t0.953125,\n\t0.953125,\n\t0.953125,\n\t0.953125,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.045898,\n\t0.045898,\n\t0.045898,\n\t0.045898,\n\t0.045898,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.047852,\n\t0.047852,\n\t0.047852,\n\t0.047852,\n\t0.047852,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.049805,\n\t0.049805,\n\t0.049805,\n\t0.049805,\n\t0.049805,\n\t0.050781,\n\t0.050781,\n\t0.050781,\n\t0.050781,\n\t0.050781,\n\t0.051758,\n\t0.051758,\n\t0.051758,\n\t0.051758,\n\t0.051758,\n\t0.052734,\n\t0.052734,\n\t0.052734,\n\t0.052734,\n\t0.052734,\n\t0.053711,\n\t0.053711,\n\t0.053711,\n\t0.053711,\n\t0.053711,\n\t0.054688,\n\t0.054688,\n\t0.054688,\n\t0.054688,\n\t0.054688,\n\t0.055664,\n\t0.055664,\n\t0.055664,\n\t0.055664,\n\t0.056641,\n\t0.056641,\n\t0.056641,\n\t0.056641,\n\t0.056641,\n\t0.057617,\n\t0.057617,\n\t0.057617,\n\t0.057617,\n\t0.057617,\n\t0.058594,\n\t0.058594,\n\t0.058594,\n\t0.058594,\n\t0.059570,\n\t0.059570,\n\t0.059570,\n\t0.059570,\n\t0.059570,\n\t0.060547,\n\t0.060547,\n\t0.060547,\n\t0.060547,\n\t0.061523,\n\t0.061523,\n\t0.061523,\n\t0.061523,\n\t0.062500,\n\t0.062500,\n\t0.062500,\n\t0.062500,\n\t0.063477,\n\t0.063477,\n\t0.063477,\n\t0.063477,\n\t0.063477,\n\t0.064453,\n\t0.064453,\n\t0.064453,\n\t0.064453,\n\t0.065430,\n\t0.065430,\n\t0.065430,\n\t0.065430,\n\t0.066406,\n\t0.066406,\n\t0.066406,\n\t0.066406,\n\t0.067383,\n\t0.067383,\n\t0.067383,\n\t0.067383,\n\t0.068359,\n\t0.068359,\n\t0.068359,\n\t0.068359,\n\t0.069336,\n\t0.069336,\n\t0.069336,\n\t0.069336,\n\t0.070312,\n\t0.070312,\n\t0.070312,\n\t0.071289,\n\t0.071289,\n\t0.071289,\n\t0.071289,\n\t0.072266,\n\t0.072266,\n\t0.072266,\n\t0.072266,\n\t0.073242,\n\t0.073242,\n\t0.073242,\n\t0.074219,\n\t0.074219,\n\t0.074219,\n\t0.074219,\n\t0.075195,\n\t0.075195,\n\t0.075195,\n\t0.075195,\n\t0.076172,\n\t0.076172,\n\t0.076172,\n\t0.077148,\n\t0.077148,\n\t0.077148,\n\t0.077148,\n\t0.078125,\n\t0.078125,\n\t0.078125,\n\t0.079102,\n\t0.079102,\n\t0.079102,\n\t0.079102,\n\t0.080078,\n\t0.080078,\n\t0.080078,\n\t0.081055,\n\t0.081055,\n\t0.081055,\n\t0.082031,\n\t0.082031,\n\t0.082031,\n\t0.082031,\n\t0.083008,\n\t0.083008,\n\t0.083008,\n\t0.083984,\n\t0.083984,\n\t0.083984,\n\t0.084961,\n\t0.084961,\n\t0.084961,\n\t0.085938,\n\t0.085938,\n\t0.085938,\n\t0.086914,\n\t0.086914,\n\t0.086914,\n\t0.086914,\n\t0.087891,\n\t0.087891,\n\t0.087891,\n\t0.088867,\n\t0.088867,\n\t0.088867,\n\t0.089844,\n\t0.089844,\n\t0.089844,\n\t0.090820,\n\t0.090820,\n\t0.090820,\n\t0.091797,\n\t0.091797,\n\t0.091797,\n\t0.092773,\n\t0.092773,\n\t0.092773,\n\t0.093750,\n\t0.093750,\n\t0.093750,\n\t0.094727,\n\t0.094727,\n\t0.094727,\n\t0.095703,\n\t0.095703,\n\t0.096680,\n\t0.096680,\n\t0.096680,\n\t0.097656,\n\t0.097656,\n\t0.097656,\n\t0.098633,\n\t0.098633,\n\t0.098633,\n\t0.099609,\n\t0.099609,\n\t0.099609,\n\t0.100586,\n\t0.100586,\n\t0.101562,\n\t0.101562,\n\t0.101562,\n\t0.102539,\n\t0.102539,\n\t0.102539,\n\t0.103516,\n\t0.103516,\n\t0.103516,\n\t0.104492,\n\t0.104492,\n\t0.105469,\n\t0.105469,\n\t0.105469,\n\t0.106445,\n\t0.106445,\n\t0.107422,\n\t0.107422,\n\t0.107422,\n\t0.108398,\n\t0.108398,\n\t0.108398,\n\t0.109375,\n\t0.109375,\n\t0.110352,\n\t0.110352,\n\t0.110352,\n\t0.111328,\n\t0.111328,\n\t0.112305,\n\t0.112305,\n\t0.112305,\n\t0.113281,\n\t0.113281,\n\t0.114258,\n\t0.114258,\n\t0.114258,\n\t0.115234,\n\t0.115234,\n\t0.116211,\n\t0.116211,\n\t0.116211,\n\t0.117188,\n\t0.117188,\n\t0.118164,\n\t0.118164,\n\t0.119141,\n\t0.119141,\n\t0.119141,\n\t0.120117,\n\t0.120117,\n\t0.121094,\n\t0.121094,\n\t0.122070,\n\t0.122070,\n\t0.122070,\n\t0.123047,\n\t0.123047,\n\t0.124023,\n\t0.124023,\n\t0.125000,\n\t0.125000,\n\t0.125000,\n\t0.125977,\n\t0.125977,\n\t0.126953,\n\t0.126953,\n\t0.127930,\n\t0.127930,\n\t0.128906,\n\t0.128906,\n\t0.128906,\n\t0.129883,\n\t0.129883,\n\t0.130859,\n\t0.130859,\n\t0.131836,\n\t0.131836,\n\t0.132812,\n\t0.132812,\n\t0.133789,\n\t0.133789,\n\t0.134766,\n\t0.134766,\n\t0.134766,\n\t0.135742,\n\t0.135742,\n\t0.136719,\n\t0.136719,\n\t0.137695,\n\t0.137695,\n\t0.138672,\n\t0.138672,\n\t0.139648,\n\t0.139648,\n\t0.140625,\n\t0.140625,\n\t0.141602,\n\t0.141602,\n\t0.142578,\n\t0.142578,\n\t0.143555,\n\t0.143555,\n\t0.144531,\n\t0.144531,\n\t0.145508,\n\t0.145508,\n\t0.146484,\n\t0.146484,\n\t0.147461,\n\t0.147461,\n\t0.148438,\n\t0.148438,\n\t0.149414,\n\t0.149414,\n\t0.150391,\n\t0.150391,\n\t0.151367,\n\t0.151367,\n\t0.152344,\n\t0.152344,\n\t0.153320,\n\t0.153320,\n\t0.154297,\n\t0.154297,\n\t0.155273,\n\t0.155273,\n\t0.156250,\n\t0.156250,\n\t0.157227,\n\t0.157227,\n\t0.158203,\n\t0.159180,\n\t0.159180,\n\t0.160156,\n\t0.160156,\n\t0.161133,\n\t0.161133,\n\t0.162109,\n\t0.162109,\n\t0.163086,\n\t0.163086,\n\t0.164062,\n\t0.165039,\n\t0.165039,\n\t0.166016,\n\t0.166016,\n\t0.166992,\n\t0.166992,\n\t0.167969,\n\t0.167969,\n\t0.168945,\n\t0.169922,\n\t0.169922,\n\t0.170898,\n\t0.170898,\n\t0.171875,\n\t0.171875,\n\t0.172852,\n\t0.173828,\n\t0.173828,\n\t0.174805,\n\t0.174805,\n\t0.175781,\n\t0.175781,\n\t0.176758,\n\t0.177734,\n\t0.177734,\n\t0.178711,\n\t0.178711,\n\t0.179688,\n\t0.180664,\n\t0.180664,\n\t0.181641,\n\t0.181641,\n\t0.182617,\n\t0.182617,\n\t0.183594,\n\t0.184570,\n\t0.184570,\n\t0.185547,\n\t0.186523,\n\t0.186523,\n\t0.187500,\n\t0.187500,\n\t0.188477,\n\t0.189453,\n\t0.189453,\n\t0.190430,\n\t0.190430,\n\t0.191406,\n\t0.192383,\n\t0.192383,\n\t0.193359,\n\t0.194336,\n\t0.194336,\n\t0.195312,\n\t0.195312,\n\t0.196289,\n\t0.197266,\n\t0.197266,\n\t0.198242,\n\t0.199219,\n\t0.199219,\n\t0.200195,\n\t0.201172,\n\t0.201172,\n\t0.202148,\n\t0.202148,\n\t0.203125,\n\t0.204102,\n\t0.204102,\n\t0.205078,\n\t0.206055,\n\t0.206055,\n\t0.207031,\n\t0.208008,\n\t0.208008,\n\t0.208984,\n\t0.209961,\n\t0.209961,\n\t0.210938,\n\t0.211914,\n\t0.211914,\n\t0.212891,\n\t0.213867,\n\t0.213867,\n\t0.214844,\n\t0.215820,\n\t0.215820,\n\t0.216797,\n\t0.217773,\n\t0.217773,\n\t0.218750,\n\t0.219727,\n\t0.219727,\n\t0.220703,\n\t0.221680,\n\t0.222656,\n\t0.222656,\n\t0.223633,\n\t0.224609,\n\t0.224609,\n\t0.225586,\n\t0.226562,\n\t0.226562,\n\t0.227539,\n\t0.228516,\n\t0.229492,\n\t0.229492,\n\t0.230469,\n\t0.231445,\n\t0.231445,\n\t0.232422,\n\t0.233398,\n\t0.234375,\n\t0.234375,\n\t0.235352,\n\t0.236328,\n\t0.236328,\n\t0.237305,\n\t0.238281,\n\t0.239258,\n\t0.239258,\n\t0.240234,\n\t0.241211,\n\t0.242188,\n\t0.242188,\n\t0.243164,\n\t0.244141,\n\t0.244141,\n\t0.245117,\n\t0.246094,\n\t0.247070,\n\t0.247070,\n\t0.248047,\n\t0.249023,\n\t0.250000,\n\t0.250000,\n\t0.250977,\n\t0.251953,\n\t0.252930,\n\t0.252930,\n\t0.253906,\n\t0.254883,\n\t0.255859,\n\t0.255859,\n\t0.256836,\n\t0.257812,\n\t0.258789,\n\t0.259766,\n\t0.259766,\n\t0.260742,\n\t0.261719,\n\t0.262695,\n\t0.262695,\n\t0.263672,\n\t0.264648,\n\t0.265625,\n\t0.266602,\n\t0.266602,\n\t0.267578,\n\t0.268555,\n\t0.269531,\n\t0.269531,\n\t0.270508,\n\t0.271484,\n\t0.272461,\n\t0.273438,\n\t0.273438,\n\t0.274414,\n\t0.275391,\n\t0.276367,\n\t0.277344,\n\t0.277344,\n\t0.278320,\n\t0.279297,\n\t0.280273,\n\t0.281250,\n\t0.281250,\n\t0.282227,\n\t0.283203,\n\t0.284180,\n\t0.285156,\n\t0.286133,\n\t0.286133,\n\t0.287109,\n\t0.288086,\n\t0.289062,\n\t0.290039,\n\t0.290039,\n\t0.291016,\n\t0.291992,\n\t0.292969,\n\t0.293945,\n\t0.294922,\n\t0.294922,\n\t0.295898,\n\t0.296875,\n\t0.297852,\n\t0.298828,\n\t0.299805,\n\t0.299805,\n\t0.300781,\n\t0.301758,\n\t0.302734,\n\t0.303711,\n\t0.304688,\n\t0.305664,\n\t0.305664,\n\t0.306641,\n\t0.307617,\n\t0.308594,\n\t0.309570,\n\t0.310547,\n\t0.311523,\n\t0.311523,\n\t0.312500,\n\t0.313477,\n\t0.314453,\n\t0.315430,\n\t0.316406,\n\t0.317383,\n\t0.317383,\n\t0.318359,\n\t0.319336,\n\t0.320312,\n\t0.321289,\n\t0.322266,\n\t0.323242,\n\t0.324219,\n\t0.324219,\n\t0.325195,\n\t0.326172,\n\t0.327148,\n\t0.328125,\n\t0.329102,\n\t0.330078,\n\t0.331055,\n\t0.331055,\n\t0.332031,\n\t0.333008,\n\t0.333984,\n\t0.334961,\n\t0.335938,\n\t0.336914,\n\t0.337891,\n\t0.338867,\n\t0.338867,\n\t0.339844,\n\t0.340820,\n\t0.341797,\n\t0.342773,\n\t0.343750,\n\t0.344727,\n\t0.345703,\n\t0.346680,\n\t0.347656,\n\t0.348633,\n\t0.348633,\n\t0.349609,\n\t0.350586,\n\t0.351562,\n\t0.352539,\n\t0.353516,\n\t0.354492,\n\t0.355469,\n\t0.356445,\n\t0.357422,\n\t0.358398,\n\t0.358398,\n\t0.359375,\n\t0.360352,\n\t0.361328,\n\t0.362305,\n\t0.363281,\n\t0.364258,\n\t0.365234,\n\t0.366211,\n\t0.367188,\n\t0.368164,\n\t0.369141,\n\t0.370117,\n\t0.371094,\n\t0.371094,\n\t0.372070,\n\t0.373047,\n\t0.374023,\n\t0.375000,\n\t0.375977,\n\t0.376953,\n\t0.377930,\n\t0.378906,\n\t0.379883,\n\t0.380859,\n\t0.381836,\n\t0.382812,\n\t0.383789,\n\t0.384766,\n\t0.385742,\n\t0.386719,\n\t0.386719,\n\t0.387695,\n\t0.388672,\n\t0.389648,\n\t0.390625,\n\t0.391602,\n\t0.392578,\n\t0.393555,\n\t0.394531,\n\t0.395508,\n\t0.396484,\n\t0.397461,\n\t0.398438,\n\t0.399414,\n\t0.400391,\n\t0.401367,\n\t0.402344,\n\t0.403320,\n\t0.404297,\n\t0.405273,\n\t0.406250,\n\t0.407227,\n\t0.408203,\n\t0.409180,\n\t0.410156,\n\t0.410156,\n\t0.411133,\n\t0.412109,\n\t0.413086,\n\t0.414062,\n\t0.415039,\n\t0.416016,\n\t0.416992,\n\t0.417969,\n\t0.418945,\n\t0.419922,\n\t0.420898,\n\t0.421875,\n\t0.422852,\n\t0.423828,\n\t0.424805,\n\t0.425781,\n\t0.426758,\n\t0.427734,\n\t0.428711,\n\t0.429688,\n\t0.430664,\n\t0.431641,\n\t0.432617,\n\t0.433594,\n\t0.434570,\n\t0.435547,\n\t0.436523,\n\t0.437500,\n\t0.438477,\n\t0.439453,\n\t0.440430,\n\t0.441406,\n\t0.442383,\n\t0.443359,\n\t0.444336,\n\t0.445312,\n\t0.446289,\n\t0.447266,\n\t0.448242,\n\t0.449219,\n\t0.450195,\n\t0.451172,\n\t0.452148,\n\t0.453125,\n\t0.454102,\n\t0.455078,\n\t0.456055,\n\t0.457031,\n\t0.458008,\n\t0.458984,\n\t0.459961,\n\t0.460938,\n\t0.461914,\n\t0.462891,\n\t0.463867,\n\t0.464844,\n\t0.465820,\n\t0.466797,\n\t0.467773,\n\t0.468750,\n\t0.469727,\n\t0.470703,\n\t0.471680,\n\t0.472656,\n\t0.473633,\n\t0.474609,\n\t0.475586,\n\t0.476562,\n\t0.477539,\n\t0.478516,\n\t0.479492,\n\t0.480469,\n\t0.481445,\n\t0.482422,\n\t0.483398,\n\t0.484375,\n\t0.485352,\n\t0.486328,\n\t0.487305,\n\t0.488281,\n\t0.489258,\n\t0.490234,\n\t0.491211,\n\t0.492188,\n\t0.493164,\n\t0.494141,\n\t0.495117,\n\t0.496094,\n\t0.497070,\n\t0.498047,\n\t0.499023\n};\n"
      }
    ],
    "code_length": 8639,
    "token_count": 2208,
    "pragma_number": 15,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/spmv_crs/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 7411,
    "Worst-caseLatency": 2474941.0,
    "BRAM_18K": 0,
    "LUT": 1133,
    "DSP": 11,
    "FF": 1102,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "spmv",
    "ResourceMetric": 0.0006276749,
    "design_id": "project",
    "algo_name": "spmv_crs",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "spmv.h",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"support.h\"\n\n// These constants valid for the IEEE 494 bus interconnect matrix\n#define NNZ 1666\n#define N 494\n\n#define TYPE double\n\nvoid spmv(TYPE val[NNZ], int32_t cols[NNZ], int32_t rowDelimiters[N + 1],\n          TYPE vec[N], TYPE out[N]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE val[NNZ];\n  int32_t cols[NNZ];\n  int32_t rowDelimiters[N+1];\n  TYPE vec[N];\n  TYPE out[N];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "spmv.c",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include \"spmv.h\"\n\nvoid spmv(TYPE val[NNZ], int32_t cols[NNZ], int32_t rowDelimiters[N+1], TYPE vec[N], TYPE out[N]){\n    int i, j;\n    TYPE sum, Si;\n\n    spmv_1 : for(i = 0; i < N; i++){\n        sum = 0; Si = 0;\n        int tmp_begin = rowDelimiters[i];\n        int tmp_end = rowDelimiters[i+1];\n        spmv_2 : for (j = tmp_begin; j < tmp_end; j++){\n        #pragma HLS loop_tripcount min=1 max=NNZ avg=5\n            Si = val[j] * vec[cols[j]];\n            sum = sum + Si;\n        }\n        out[i] = sum;\n    }\n}\n\n\n"
      }
    ],
    "code_length": 645,
    "token_count": 211,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/spmv_ellpack/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2503,
    "Worst-caseLatency": 2503.0,
    "BRAM_18K": 0,
    "LUT": 2736,
    "DSP": 22,
    "FF": 3335,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ellpack",
    "ResourceMetric": 0.0014539223,
    "design_id": "project",
    "algo_name": "spmv_ellpack",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "spmv.h",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"support.h\"\n\n// These constants valid for the IEEE 494 bus interconnect matrix\n#define NNZ 1666\n#define N 494\n#define L 10\n\n#define TYPE double\n\nvoid ellpack(TYPE nzval[N*L], int32_t cols[N*L], TYPE vec[N], TYPE out[N]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE nzval[N*L];\n  int32_t cols[N*L];\n  TYPE vec[N];\n  TYPE out[N];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "spmv.c",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include \"spmv.h\"\n\nvoid ellpack(TYPE nzval[N*L], int32_t cols[N*L], TYPE vec[N], TYPE out[N])\n{\n    int i, j;\n    TYPE Si;\n\n    ellpack_1 : for (i=0; i<N; i++) {\n        TYPE sum = out[i];\n        ellpack_2 : for (j=0; j<L; j++) {\n                Si = nzval[j + i*L] * vec[cols[j + i*L]];\n                sum += Si;\n        }\n        out[i] = sum;\n    }\n}\n"
      }
    ],
    "code_length": 483,
    "token_count": 158,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/static_array_ROM/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 1,
    "LUT": 31,
    "DSP": 0,
    "FF": 6,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 6.8524e-05,
    "design_id": "project",
    "algo_name": "static_array_ROM",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <ap_int.h>\n\nint test(int i);\n\nint test(int i) {\n    static const ap_int<10> A[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n#pragma HLS BIND_STORAGE variable = A type = ROM_1P impl = BRAM\n    static const ap_int<10> B[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n#pragma HLS BIND_STORAGE variable = B type = ROM_1P impl = LUTRAM\n    return A[i] + B[i];\n}\n"
      }
    ],
    "code_length": 1735,
    "token_count": 464,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/struct_ii_issue/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 525,
    "Worst-caseLatency": 525.0,
    "BRAM_18K": 43,
    "LUT": 8948,
    "DSP": 0,
    "FF": 6801,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 0.0050341789,
    "design_id": "project",
    "algo_name": "struct_ii_issue",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <iostream>\n#define NUM 100\n\n// struct alignas(32) A { /* Total size = 256 bits or 32 bytes */\nstruct A { /* Total size = 192 bits (32 x 6) or 24 bytes */\n    int s_1;\n    int s_2;\n    int s_3;\n    int s_4;\n    int s_5;\n    int s_6;\n};\n\n// Top function\nvoid dut(A a_in[NUM], A a_out[NUM], int size);\n\nvoid read(A* a_in, A buf_out[NUM]) {\nREAD:\n    for (int i = 0; i < NUM; i++) {\n        buf_out[i] = a_in[i];\n    }\n}\n\nvoid compute(A buf_in[NUM], A buf_out[NUM], int size) {\nCOMPUTE:\n    for (int j = 0; j < NUM; j++) {\n        buf_out[j].s_1 = buf_in[j].s_1 + size;\n        buf_out[j].s_2 = buf_in[j].s_2;\n        buf_out[j].s_3 = buf_in[j].s_3;\n        buf_out[j].s_4 = buf_in[j].s_4;\n        buf_out[j].s_5 = buf_in[j].s_5;\n        buf_out[j].s_6 = buf_in[j].s_6 % 2;\n    }\n}\n\nvoid write(A buf_in[NUM], A* a_out) {\nWRITE:\n    for (int k = 0; k < NUM; k++) {\n        a_out[k] = buf_in[k];\n    }\n}\n\nvoid dut(A a_in[NUM], A a_out[NUM], int size) {\n#pragma HLS INTERFACE m_axi port = a_in bundle = gmem0\n#pragma HLS INTERFACE m_axi port = a_out bundle = gmem1\n    A buffer_in[NUM];\n    A buffer_out[NUM];\n\n#pragma HLS dataflow\n    read(a_in, buffer_in);\n    compute(buffer_in, buffer_out, size);\n    write(buffer_out, a_out);\n}\n"
      },
      {
        "file_name": "xdut_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of a_in\n//        bit 31~0 - a_in[31:0] (Read/Write)\n// 0x14 : Data signal of a_in\n//        bit 31~0 - a_in[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of a_out\n//        bit 31~0 - a_out[31:0] (Read/Write)\n// 0x20 : Data signal of a_out\n//        bit 31~0 - a_out[63:32] (Read/Write)\n// 0x24 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XDUT_CONTROL_ADDR_A_IN_DATA  0x10\n#define XDUT_CONTROL_BITS_A_IN_DATA  64\n#define XDUT_CONTROL_ADDR_A_OUT_DATA 0x1c\n#define XDUT_CONTROL_BITS_A_OUT_DATA 64\n\n"
      },
      {
        "file_name": "xdut.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xdut.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XDut_CfgInitialize(XDut *InstancePtr, XDut_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XDut_Set_a_in(XDut *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA, (u32)(Data));\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDut_Get_a_in(XDut *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA);\n    Data += (u64)XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XDut_Set_a_out(XDut *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA, (u32)(Data));\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDut_Get_a_out(XDut *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA);\n    Data += (u64)XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xdut_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xdut.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XDut_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XDut_uio_map maps[ MAX_UIO_MAPS ];\n} XDut_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XDut_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XDut_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XDut_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XDut_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XDut_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XDut_Initialize(XDut *InstancePtr, const char* InstanceName) {\n\tXDut_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XDut_Release(XDut *InstancePtr) {\n\tXDut_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xdut.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XDUT_H\n#define XDUT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xdut_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XDut_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XDut;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XDut_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XDut_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XDut_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XDut_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XDut_Initialize(XDut *InstancePtr, UINTPTR BaseAddress);\nXDut_Config* XDut_LookupConfig(UINTPTR BaseAddress);\n#else\nint XDut_Initialize(XDut *InstancePtr, u16 DeviceId);\nXDut_Config* XDut_LookupConfig(u16 DeviceId);\n#endif\nint XDut_CfgInitialize(XDut *InstancePtr, XDut_Config *ConfigPtr);\n#else\nint XDut_Initialize(XDut *InstancePtr, const char* InstanceName);\nint XDut_Release(XDut *InstancePtr);\n#endif\n\n\nvoid XDut_Set_a_in(XDut *InstancePtr, u64 Data);\nu64 XDut_Get_a_in(XDut *InstancePtr);\nvoid XDut_Set_a_out(XDut *InstancePtr, u64 Data);\nu64 XDut_Get_a_out(XDut *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xdut_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xdut.h\"\n\nextern XDut_Config XDut_ConfigTable[];\n\n#ifdef SDT\nXDut_Config *XDut_LookupConfig(UINTPTR BaseAddress) {\n\tXDut_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XDut_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XDut_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XDut_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDut_Initialize(XDut *InstancePtr, UINTPTR BaseAddress) {\n\tXDut_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDut_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDut_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXDut_Config *XDut_LookupConfig(u16 DeviceId) {\n\tXDut_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XDUT_NUM_INSTANCES; Index++) {\n\t\tif (XDut_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XDut_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDut_Initialize(XDut *InstancePtr, u16 DeviceId) {\n\tXDut_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDut_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDut_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 11383,
    "token_count": 3187,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/temperature_based_shutdown/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "temperature_based_shutdown",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "temperature_based_shutdown",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "temperature_based_shutdown.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n#define THRESHOLD 75\n\nvoid temperature_based_shutdown(int temperature_readings[ARRAY_SIZE], int shutdown_flags[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (temperature_readings[i] > THRESHOLD) {\n            shutdown_flags[i] = 1;\n        } else {\n            shutdown_flags[i] = 0;\n        }\n    }\n}\n\n// Top function name: temperature_based_shutdown\n"
      }
    ],
    "code_length": 420,
    "token_count": 106,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/temporal_difference_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 26,
    "Worst-caseLatency": 26.0,
    "BRAM_18K": 0,
    "LUT": 1375,
    "DSP": 11,
    "FF": 1120,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "temporal_difference_learning",
    "ResourceMetric": 0.0006758079,
    "design_id": "project",
    "algo_name": "temporal_difference_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "temporal_difference_learning.cpp",
        "file_content": "#include <cmath>\n\n#define STATE_SIZE 1024\n#define ACTION_SIZE 4\n#define ALPHA 0.1\n#define GAMMA 0.9\n\nvoid temporal_difference_learning(\n    int state,\n    int action,\n    int next_state,\n    double reward,\n    double Q[STATE_SIZE][ACTION_SIZE])\n{\n    double max_next_Q = -INFINITY;\n    for (int a = 0; a < ACTION_SIZE; a++) {\n        if (Q[next_state][a] > max_next_Q) {\n            max_next_Q = Q[next_state][a];\n        }\n    }\n\n    Q[state][action] += ALPHA * (reward + GAMMA * max_next_Q - Q[state][action]);\n}\n\n// Top function name: temporal_difference_learning\n"
      }
    ],
    "code_length": 567,
    "token_count": 156,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/universal_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 293,
    "DSP": 0,
    "FF": 36,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "universal_shift_register",
    "ResourceMetric": 5.96389e-05,
    "design_id": "project",
    "algo_name": "universal_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "universal_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid universal_shift_register(ap_uint<1> mode, ap_uint<10> shift_amount, ap_uint<32> data_in[SIZE], ap_uint<32> data_out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (mode == 0) { // Logical left shift\n            data_out[i] = data_in[i] << shift_amount;\n        } else if (mode == 1) { // Logical right shift\n            data_out[i] = data_in[i] >> shift_amount;\n        } else if (mode == 2) { // Arithmetic right shift\n            data_out[i] = (ap_int<32>)data_in[i] >> shift_amount;\n        } else { // Rotate right\n            data_out[i] = (data_in[i] >> shift_amount) | (data_in[i] << (32 - shift_amount));\n        }\n    }\n}\n\n// Top function name: universal_shift_register\n"
      }
    ],
    "code_length": 734,
    "token_count": 212,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/unsynchronized_io_maxi/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9,
    "Worst-caseLatency": 9.0,
    "BRAM_18K": 4,
    "LUT": 1494,
    "DSP": 4,
    "FF": 1134,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "stable_pointer",
    "ResourceMetric": 0.0007540588,
    "design_id": "project",
    "algo_name": "unsynchronized_io_maxi",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"ap_axi_sdata.h\"\n#include \"ap_int.h\"\n#include \"hls_stream.h\"\n#define HLS_TASK_ALLOW_NON_STREAM_ARGS\n#include \"hls_print.h\"\n#include \"hls_task.h\"\n\nvoid process_23(hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS INLINE off\n    static int state = 0;\n    static int val;\n\n    in.read(val);\n    val = val * 23;\n    out.write(val);\n}\n\nvoid process_11(hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS INLINE off\n    static int state = 0;\n    static int val;\n\n    in.read(val);\n    val = val * 11;\n    out.write(val);\n}\n\nvoid write_process(hls::stream<int>& in, hls::stream<int>& out, int* mem) {\n    int val;\n    static int addr = 0;\n\n    in.read(val);\n    if (addr >= 32)\n        addr = 0;\n    mem[addr] = val;\n    addr++;\n    val = mem[addr - 1];\n    out.write(val);\n}\n\nextern \"C\" {\n\nvoid stable_pointer(int* mem, hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS DATAFLOW\n#pragma HLS INTERFACE mode = m_axi bundle = gmem depth =                       \\\n    256 max_read_burst_length = 16 max_widen_bitwidth =                        \\\n        512 max_write_burst_length = 16 num_read_outstanding =                 \\\n            16 num_write_outstanding = 16 port = mem\n#pragma HLS stable variable = mem\n\n    hls_thread_local hls::stream<int> int_fifo(\"int_fifo\");\n#pragma HLS STREAM depth = 512 type = fifo variable = int_fifo\n    hls_thread_local hls::stream<int> int_fifo2(\"int_fifo2\");\n#pragma HLS STREAM depth = 512 type = fifo variable = int_fifo2\n\n    hls_thread_local hls::task t1(process_23, in, int_fifo);\n    hls_thread_local hls::task t2(process_11, int_fifo, int_fifo2);\n    hls_thread_local hls::task t3(write_process, int_fifo2, out, mem);\n}\n\n} // extern \"C\"\n"
      },
      {
        "file_name": "xstable_pointer_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of mem\n//        bit 31~0 - mem[31:0] (Read/Write)\n// 0x14 : Data signal of mem\n//        bit 31~0 - mem[63:32] (Read/Write)\n// 0x18 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA 0x10\n#define XSTABLE_POINTER_CONTROL_BITS_MEM_DATA 64\n\n"
      },
      {
        "file_name": "xstable_pointer.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XSTABLE_POINTER_H\n#define XSTABLE_POINTER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xstable_pointer_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XStable_pointer_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XStable_pointer;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XStable_pointer_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XStable_pointer_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XStable_pointer_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XStable_pointer_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, UINTPTR BaseAddress);\nXStable_pointer_Config* XStable_pointer_LookupConfig(UINTPTR BaseAddress);\n#else\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, u16 DeviceId);\nXStable_pointer_Config* XStable_pointer_LookupConfig(u16 DeviceId);\n#endif\nint XStable_pointer_CfgInitialize(XStable_pointer *InstancePtr, XStable_pointer_Config *ConfigPtr);\n#else\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, const char* InstanceName);\nint XStable_pointer_Release(XStable_pointer *InstancePtr);\n#endif\n\n\nvoid XStable_pointer_Set_mem(XStable_pointer *InstancePtr, u64 Data);\nu64 XStable_pointer_Get_mem(XStable_pointer *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xstable_pointer.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xstable_pointer.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XStable_pointer_CfgInitialize(XStable_pointer *InstancePtr, XStable_pointer_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XStable_pointer_Set_mem(XStable_pointer *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XStable_pointer_WriteReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA, (u32)(Data));\n    XStable_pointer_WriteReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XStable_pointer_Get_mem(XStable_pointer *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XStable_pointer_ReadReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA);\n    Data += (u64)XStable_pointer_ReadReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xstable_pointer_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xstable_pointer.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XStable_pointer_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XStable_pointer_uio_map maps[ MAX_UIO_MAPS ];\n} XStable_pointer_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XStable_pointer_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XStable_pointer_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XStable_pointer_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XStable_pointer_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XStable_pointer_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, const char* InstanceName) {\n\tXStable_pointer_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XStable_pointer_Release(XStable_pointer *InstancePtr) {\n\tXStable_pointer_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xstable_pointer_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xstable_pointer.h\"\n\nextern XStable_pointer_Config XStable_pointer_ConfigTable[];\n\n#ifdef SDT\nXStable_pointer_Config *XStable_pointer_LookupConfig(UINTPTR BaseAddress) {\n\tXStable_pointer_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XStable_pointer_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XStable_pointer_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XStable_pointer_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, UINTPTR BaseAddress) {\n\tXStable_pointer_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XStable_pointer_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XStable_pointer_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXStable_pointer_Config *XStable_pointer_LookupConfig(u16 DeviceId) {\n\tXStable_pointer_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XSTABLE_POINTER_NUM_INSTANCES; Index++) {\n\t\tif (XStable_pointer_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XStable_pointer_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, u16 DeviceId) {\n\tXStable_pointer_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XStable_pointer_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XStable_pointer_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 11019,
    "token_count": 2946,
    "pragma_number": 7,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_C++_templates/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 103,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cpp_template",
    "ResourceMetric": 1.97518e-05,
    "design_id": "project",
    "algo_name": "using_C++_templates",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _CPP_TEMPLATE_H_\n#define _CPP_TEMPLATE_H_\n\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\n\n#define FIB_N 5\n\ntypedef int data_t;\n\nvoid cpp_template(data_t a, data_t b, data_t& dout);\n\n#endif\n\n// Tail recursive call\ntemplate <data_t N> struct fibon_s {\n    template <typename T> static T fibon_f(T a, T b) {\n        return fibon_s<N - 1>::fibon_f(b, (a + b));\n    }\n};\n\n// Termination condition\ntemplate <> struct fibon_s<1> {\n    template <typename T> static T fibon_f(T a, T b) { return b; }\n};\n\nvoid cpp_template(data_t a, data_t b, data_t& dout) {\n    dout = fibon_s<FIB_N>::fibon_f(a, b);\n}\n"
      }
    ],
    "code_length": 2041,
    "token_count": 506,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_C++_templates_for_multiple_instances/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 407,
    "DSP": 0,
    "FF": 326,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cpp_template",
    "ResourceMetric": 0.000109306,
    "design_id": "project",
    "algo_name": "using_C++_templates_for_multiple_instances",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _CPP_TEMPLATE_H_\n#define _CPP_TEMPLATE_H_\n\n#include <cstdio>\n\nvoid cpp_template(int inp, int* out);\n\ntemplate <int K> void func_with_static(int inp, int* dout) {\n    // Use inline off pragma to avoid automatic inlining\n#pragma HLS INLINE off\n    static int acc = 0;\n    acc += inp;\n    *dout = acc;\n}\n\n#endif\n\nvoid cpp_template(int inp, int* out) {\n    int out0, out1, out2, out3, out4;\n\n    // Use templated functions to get multiple instances\n    // of the same function.\n    func_with_static<1>(inp, &out0);\n    func_with_static<2>(inp, &out1);\n    func_with_static<3>(inp, &out2);\n    func_with_static<4>(inp, &out3);\n    func_with_static<5>(inp, &out4);\n\n    *out += out0 + out1 + out2 + out3 + out4;\n}\n"
      }
    ],
    "code_length": 2104,
    "token_count": 528,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_fifos/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 22,
    "Worst-caseLatency": 55.0,
    "BRAM_18K": 30,
    "LUT": 10068,
    "DSP": 0,
    "FF": 11830,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "diamond",
    "ResourceMetric": 0.0049250966,
    "design_id": "project",
    "algo_name": "using_fifos",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ntypedef unsigned int data_t;\n#include <hls_stream.h>\n#include <hls_vector.h>\n#include <iostream>\n#include <vector>\n\n#define NUM_WORDS 16\n\n// Each vector will be 64 bytes (16 x 4 bytes)\ntypedef hls::vector<uint32_t, NUM_WORDS> vecOf16Words;\n\nextern \"C\" {\n// Top function\nvoid diamond(vecOf16Words* vecIn, vecOf16Words* vecOut, int size);\n}\n\n// Sub functions\n\nvoid load(vecOf16Words* in, hls::stream<vecOf16Words>& out, int vSize);\nvoid compute_A(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out1,\n               hls::stream<vecOf16Words>& out2, int vSize);\nvoid compute_B(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int vSize);\nvoid compute_C(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int vSize);\nvoid compute_D(hls::stream<vecOf16Words>& in1, hls::stream<vecOf16Words>& in2,\n               hls::stream<vecOf16Words>& out, int vSize);\nvoid store(hls::stream<vecOf16Words>& in, vecOf16Words* out, int vSize);\n#define NUM_WORDS 16\nextern \"C\" {\n\nvoid diamond(vecOf16Words* vecIn, vecOf16Words* vecOut, int size) {\n// The depth setting is required for pointer to array in the interface.\n#pragma HLS INTERFACE m_axi port = vecIn depth = 32\n#pragma HLS INTERFACE m_axi port = vecOut depth = 32\n\n    hls::stream<vecOf16Words> c0, c1, c2, c3, c4, c5;\n    assert(size % 16 == 0);\n\n#pragma HLS dataflow\n    load(vecIn, c0, size);\n    compute_A(c0, c1, c2, size);\n    compute_B(c1, c3, size);\n    compute_C(c2, c4, size);\n    compute_D(c3, c4, c5, size);\n    store(c5, vecOut, size);\n}\n}\n\nvoid load(vecOf16Words* in, hls::stream<vecOf16Words>& out, int size) {\nLoop_Ld:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in[i]);\n    }\n}\n\nvoid compute_A(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out1,\n               hls::stream<vecOf16Words>& out2, int size) {\nLoop_A:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        vecOf16Words t = in.read();\n        out1.write(t * 3);\n        out2.write(t * 3);\n    }\n}\n\nvoid compute_B(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int size) {\nLoop_B:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in.read() + 25);\n    }\n}\n\nvoid compute_C(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int size) {\nLoop_C:\n    for (data_t i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in.read() * 2);\n    }\n}\nvoid compute_D(hls::stream<vecOf16Words>& in1, hls::stream<vecOf16Words>& in2,\n               hls::stream<vecOf16Words>& out, int size) {\nLoop_D:\n    for (data_t i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in1.read() + in2.read());\n    }\n}\n\nvoid store(hls::stream<vecOf16Words>& in, vecOf16Words* out, int size) {\nLoop_St:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out[i] = in.read();\n    }\n}\n"
      },
      {
        "file_name": "xdiamond.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xdiamond.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XDiamond_CfgInitialize(XDiamond *InstancePtr, XDiamond_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XDiamond_Set_vecIn(XDiamond *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA, (u32)(Data));\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDiamond_Get_vecIn(XDiamond *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA);\n    Data += (u64)XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XDiamond_Set_vecOut(XDiamond *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA, (u32)(Data));\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDiamond_Get_vecOut(XDiamond *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA);\n    Data += (u64)XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xdiamond_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of vecIn\n//        bit 31~0 - vecIn[31:0] (Read/Write)\n// 0x14 : Data signal of vecIn\n//        bit 31~0 - vecIn[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of vecOut\n//        bit 31~0 - vecOut[31:0] (Read/Write)\n// 0x20 : Data signal of vecOut\n//        bit 31~0 - vecOut[63:32] (Read/Write)\n// 0x24 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XDIAMOND_CONTROL_ADDR_VECIN_DATA  0x10\n#define XDIAMOND_CONTROL_BITS_VECIN_DATA  64\n#define XDIAMOND_CONTROL_ADDR_VECOUT_DATA 0x1c\n#define XDIAMOND_CONTROL_BITS_VECOUT_DATA 64\n\n"
      },
      {
        "file_name": "xdiamond.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XDIAMOND_H\n#define XDIAMOND_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xdiamond_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XDiamond_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XDiamond;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XDiamond_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XDiamond_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XDiamond_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XDiamond_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XDiamond_Initialize(XDiamond *InstancePtr, UINTPTR BaseAddress);\nXDiamond_Config* XDiamond_LookupConfig(UINTPTR BaseAddress);\n#else\nint XDiamond_Initialize(XDiamond *InstancePtr, u16 DeviceId);\nXDiamond_Config* XDiamond_LookupConfig(u16 DeviceId);\n#endif\nint XDiamond_CfgInitialize(XDiamond *InstancePtr, XDiamond_Config *ConfigPtr);\n#else\nint XDiamond_Initialize(XDiamond *InstancePtr, const char* InstanceName);\nint XDiamond_Release(XDiamond *InstancePtr);\n#endif\n\n\nvoid XDiamond_Set_vecIn(XDiamond *InstancePtr, u64 Data);\nu64 XDiamond_Get_vecIn(XDiamond *InstancePtr);\nvoid XDiamond_Set_vecOut(XDiamond *InstancePtr, u64 Data);\nu64 XDiamond_Get_vecOut(XDiamond *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xdiamond_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xdiamond.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XDiamond_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XDiamond_uio_map maps[ MAX_UIO_MAPS ];\n} XDiamond_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XDiamond_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XDiamond_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XDiamond_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XDiamond_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XDiamond_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XDiamond_Initialize(XDiamond *InstancePtr, const char* InstanceName) {\n\tXDiamond_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XDiamond_Release(XDiamond *InstancePtr) {\n\tXDiamond_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xdiamond_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xdiamond.h\"\n\nextern XDiamond_Config XDiamond_ConfigTable[];\n\n#ifdef SDT\nXDiamond_Config *XDiamond_LookupConfig(UINTPTR BaseAddress) {\n\tXDiamond_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XDiamond_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XDiamond_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XDiamond_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDiamond_Initialize(XDiamond *InstancePtr, UINTPTR BaseAddress) {\n\tXDiamond_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDiamond_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDiamond_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXDiamond_Config *XDiamond_LookupConfig(u16 DeviceId) {\n\tXDiamond_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XDIAMOND_NUM_INSTANCES; Index++) {\n\t\tif (XDiamond_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XDiamond_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDiamond_Initialize(XDiamond *InstancePtr, u16 DeviceId) {\n\tXDiamond_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDiamond_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDiamond_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 13661,
    "token_count": 3788,
    "pragma_number": 15,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_free_running_pipeline/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 28,
    "Worst-caseLatency": 28.0,
    "BRAM_18K": 0,
    "LUT": 1909,
    "DSP": 3,
    "FF": 549,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "accumulate",
    "ResourceMetric": 0.0005018303,
    "design_id": "project",
    "algo_name": "using_free_running_pipeline",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n// Missing include: #include \"math.h\"\nusing namespace hls;\n\ntypedef double data_t;\n#define SZ 8\n\nvoid free_pipe_mult(data_t A[SZ], hls::stream<data_t>& strm, data_t& out);\n#include <iostream>\n\nint accumulate(data_t A[]) {\n#pragma HLS inline off\n\n    data_t acc = 0.0;\n    for (int i = 0; i < SZ; i++) {\n        std::cout << \"A: \" << A[i] << std::endl;\n        acc += A[i];\n    }\n    return acc;\n}\n\nvoid process(hls::stream<data_t>& strm_in, hls::stream<data_t>& strm_out) {\n#pragma HLS inline off\n\n    for (int i = 0; i < SZ; i++) {\n        data_t tmp;\n        tmp = strm_in.read();\n        strm_out.write(tmp);\n    }\n}\n\nvoid inner(data_t A[SZ], hls::stream<data_t>& stream_in, data_t* out) {\n\n#pragma HLS INTERFACE ap_fifo port = stream_in\n    data_t regA[SZ];\n#pragma HLS ARRAY_PARTITION variable = regA complete\n    for (int i = 0; i < SZ; i++) {\n        data_t tmp;\n        tmp = stream_in.read();\n        regA[i] = A[i] + tmp;\n    }\n\n    *out = accumulate(regA);\n}\n\nvoid free_pipe_mult(data_t A[SZ], hls::stream<data_t>& strm, data_t& out) {\n#pragma HLS DATAFLOW\n#pragma HLS INTERFACE ap_fifo port = strm\n\n    data_t B[SZ];\n\n    for (int i = 0; i < SZ; i++)\n        B[i] = A[i] + i;\n\n    hls::stream<data_t> strm_out;\n    process(strm, strm_out);\n    inner(B, strm_out, &out);\n}\n"
      }
    ],
    "code_length": 2722,
    "token_count": 722,
    "pragma_number": 6,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/video_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2073602,
    "Worst-caseLatency": 2073602.0,
    "BRAM_18K": 0,
    "LUT": 258,
    "DSP": 0,
    "FF": 67,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_controller",
    "ResourceMetric": 5.58995e-05,
    "design_id": "project",
    "algo_name": "video_controller",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "video_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1920\n#define HEIGHT 1080\n\nvoid video_controller(ap_uint<8> input_frame[HEIGHT][WIDTH], ap_uint<8> output_frame[HEIGHT][WIDTH]) {\n    int i, j;\n    for (i = 0; i < HEIGHT; i++) {\n        for (j = 0; j < WIDTH; j++) {\n            // Example processing: Invert the pixel value\n            output_frame[i][j] = 255 - input_frame[i][j];\n        }\n    }\n}\n\n// Top function name: video_controller\n"
      }
    ],
    "code_length": 425,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/video_display_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 786434,
    "Worst-caseLatency": 786434.0,
    "BRAM_18K": 0,
    "LUT": 240,
    "DSP": 0,
    "FF": 64,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_display_processor",
    "ResourceMetric": 5.216e-05,
    "design_id": "project",
    "algo_name": "video_display_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "video_display_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define WIDTH 1024\n#define HEIGHT 768\n\nvoid video_display_processor(uint8_t input_frame[HEIGHT][WIDTH], uint8_t output_frame[HEIGHT][WIDTH]) {\n    for (int y = 0; y < HEIGHT; y++) {\n        for (int x = 0; x < WIDTH; x++) {\n            // Example processing: Invert colors\n            output_frame[y][x] = 255 - input_frame[y][x];\n        }\n    }\n}\n\n// Top function name: video_display_processor\n"
      }
    ],
    "code_length": 416,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/virtual_memory_management/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 226,
    "DSP": 0,
    "FF": 51,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "virtual_memory_management",
    "ResourceMetric": 4.82289e-05,
    "design_id": "project",
    "algo_name": "virtual_memory_management",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "virtual_memory_management.cpp",
        "file_content": "#include <iostream>\n\n#define PAGE_SIZE 4096\n#define NUM_PAGES 1024\n#define MEMORY_SIZE (PAGE_SIZE * NUM_PAGES)\n\nvoid virtual_memory_management(int virtual_address[NUM_PAGES], int physical_address[NUM_PAGES], int page_table[NUM_PAGES]) {\n    for (int i = 0; i < NUM_PAGES; i++) {\n        int page_number = virtual_address[i] / PAGE_SIZE;\n        int offset = virtual_address[i] % PAGE_SIZE;\n        physical_address[i] = page_table[page_number] * PAGE_SIZE + offset;\n    }\n}\n\n// Top function name: virtual_memory_management\n"
      }
    ],
    "code_length": 523,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  }
]