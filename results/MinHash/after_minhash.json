[
  {
    "File Path": "../data/kernels/PolyBench/2mm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6624000029,
    "Worst-caseLatency": 6624000029.0,
    "BRAM_18K": 0,
    "LUT": 2227,
    "DSP": 17,
    "FF": 2247,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_2mm",
    "ResourceMetric": 0.0011134744,
    "design_id": "project",
    "algo_name": "2mm",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "2mm.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* 2mm.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"2mm.h\"\n\n\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_2mm(int ni, int nj, int nk, int nl,\n\t\tDATA_TYPE alpha,\n\t\tDATA_TYPE beta,\n\t\tDATA_TYPE POLYBENCH_2D(tmp,NI,NJ,ni,nj),\n\t\tDATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),\n\t\tDATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),\n\t\tDATA_TYPE POLYBENCH_2D(C,NJ,NL,nj,nl),\n\t\tDATA_TYPE POLYBENCH_2D(D,NI,NL,ni,nl))\n{\n  int i, j, k;\n\n#pragma scop\n  /* D := alpha*A*B*C + beta*D */\n  for (i = 0; i < _PB_NI; i++)\n    for (j = 0; j < _PB_NJ; j++)\n      {\n\ttmp[i][j] = SCALAR_VAL(0.0);\n\tfor (k = 0; k < _PB_NK; ++k)\n\t  tmp[i][j] += alpha * A[i][k] * B[k][j];\n      }\n  for (i = 0; i < _PB_NI; i++)\n    for (j = 0; j < _PB_NL; j++)\n      {\n\tD[i][j] *= beta;\n\tfor (k = 0; k < _PB_NJ; ++k)\n\t  D[i][j] += tmp[i][k] * C[k][j];\n      }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "2mm.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _2MM_H\n# define _2MM_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(NI) && !defined(NJ) && !defined(NK) && !defined(NL)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define NI 16\n#   define NJ 18\n#   define NK 22\n#   define NL 24\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define NI 40\n#   define NJ 50\n#   define NK 70\n#   define NL 80\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define NI 180\n#   define NJ 190\n#   define NK 210\n#   define NL 220\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define NI 800\n#   define NJ 900\n#   define NK 1100\n#   define NL 1200\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define NI 1600\n#   define NJ 1800\n#   define NK 2200\n#   define NL 2400\n#  endif\n\n\n#endif /* !(NI NJ NK NL) */\n\n# define _PB_NI POLYBENCH_LOOP_BOUND(NI,ni)\n# define _PB_NJ POLYBENCH_LOOP_BOUND(NJ,nj)\n# define _PB_NK POLYBENCH_LOOP_BOUND(NK,nk)\n# define _PB_NL POLYBENCH_LOOP_BOUND(NL,nl)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_2MM_H */\n"
      }
    ],
    "code_length": 1279,
    "token_count": 483,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/3d-rendering/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 86612,
    "Worst-caseLatency": 1255311884.0,
    "BRAM_18K": 63,
    "LUT": 4239,
    "DSP": 3,
    "FF": 2623,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rendering",
    "ResourceMetric": 0.0050537525,
    "design_id": "project",
    "algo_name": "3d-rendering",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "rendering.cpp",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                        rendering.cpp                          */\n/*                                                               */\n/*                 C++ kernel for 3D Rendering                   */\n/*                                                               */\n/*===============================================================*/\n\n#include \"typedefs.h\"\n\n/*======================UTILITY FUNCTIONS========================*/\n\n\n// Determine whether three vertices of a trianlgLe\n// (x0,y0) (x1,y1) (x2,y2) are in clockwise order by Pineda algorithm\n// if so, return a number > 0\n// else if three points are in line, return a number == 0\n// else in counterclockwise order, return a number < 0\nint check_clockwise( Triangle_2D triangle_2d )\n{\n  int cw;\n\n  cw = (triangle_2d.x2 - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0)\n       - (triangle_2d.y2 - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n\n  return cw;\n\n}\n\n// swap (x0, y0) (x1, y1) of a Triangle_2D\nvoid clockwise_vertices( Triangle_2D *triangle_2d )\n{\n\n  bit8 tmp_x, tmp_y;\n\n  tmp_x = triangle_2d->x0;\n  tmp_y = triangle_2d->y0;\n\n  triangle_2d->x0 = triangle_2d->x1;\n  triangle_2d->y0 = triangle_2d->y1;\n\n  triangle_2d->x1 = tmp_x;\n  triangle_2d->y1 = tmp_y;\n\n}\n\n\n// Given a pixel, determine whether it is inside the triangle\n// by Pineda algorithm\n// if so, return true\n// else, return false\nbit1 pixel_in_triangle( bit8 x, bit8 y, Triangle_2D triangle_2d )\n{\n\n  int pi0, pi1, pi2;\n\n  pi0 = (x - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0) - (y - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n  pi1 = (x - triangle_2d.x1) * (triangle_2d.y2 - triangle_2d.y1) - (y - triangle_2d.y1) * (triangle_2d.x2 - triangle_2d.x1);\n  pi2 = (x - triangle_2d.x2) * (triangle_2d.y0 - triangle_2d.y2) - (y - triangle_2d.y2) * (triangle_2d.x0 - triangle_2d.x2);\n\n  return (pi0 >= 0 && pi1 >= 0 && pi2 >= 0);\n}\n\n// find the min from 3 integers\nbit8 find_min( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 < in1)\n  {\n    if (in0 < in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 < in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n\n// find the max from 3 integers\nbit8 find_max( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 > in1)\n  {\n    if (in0 > in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 > in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n/*======================PROCESSING STAGES========================*/\n\n// project a 3D triangle to a 2D triangle\nvoid projection ( Triangle_3D triangle_3d, Triangle_2D *triangle_2d, bit2 angle )\n{\n  #pragma HLS INLINE off\n  // Setting camera to (0,0,-1), the canvas at z=0 plane\n  // The 3D model lies in z>0 space\n  // The coordinate on canvas is proportional to the corresponding coordinate \n  // on space\n  if(angle == 0)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.z0 / 3 + triangle_3d.z1 / 3 + triangle_3d.z2 / 3;\n  }\n\n  else if(angle == 1)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.z0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.z1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.z2;\n    triangle_2d->z  = triangle_3d.y0 / 3 + triangle_3d.y1 / 3 + triangle_3d.y2 / 3;\n  }\n      \n  else if(angle == 2)\n  {\n    triangle_2d->x0 = triangle_3d.z0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.z1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.z2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.x0 / 3 + triangle_3d.x1 / 3 + triangle_3d.x2 / 3;\n  }\n}\n\n// calculate bounding box for a 2D triangle\nbit2 rasterization1 ( Triangle_2D triangle_2d, bit8 max_min[], Triangle_2D *triangle_2d_same, bit16 max_index[])\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( check_clockwise( triangle_2d ) == 0 )\n    return 1;\n  if ( check_clockwise( triangle_2d ) < 0 )\n    clockwise_vertices( &triangle_2d );\n\n  // copy the same 2D triangle\n  triangle_2d_same->x0 = triangle_2d.x0;\n  triangle_2d_same->y0 = triangle_2d.y0;\n  triangle_2d_same->x1 = triangle_2d.x1;\n  triangle_2d_same->y1 = triangle_2d.y1;\n  triangle_2d_same->x2 = triangle_2d.x2;\n  triangle_2d_same->y2 = triangle_2d.y2;\n  triangle_2d_same->z  = triangle_2d.z ;\n\n  // find the rectangle bounds of 2D triangles\n  max_min[0] = find_min( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[1] = find_max( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[2] = find_min( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[3] = find_max( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[4] = max_min[1] - max_min[0];\n\n  // calculate index for searching pixels\n  max_index[0] = (max_min[1] - max_min[0]) * (max_min[3] - max_min[2]);\n\n  return 0;\n}\n\n// find pixels in the triangles from the bounding box\nbit16 rasterization2 ( bit2 flag, bit8 max_min[], bit16 max_index[], Triangle_2D triangle_2d_same, CandidatePixel fragment2[] )\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( flag )\n  {\n    return 0;\n  }\n  bit8 color = 100;\n  bit16 i = 0;\n\n  RAST2: for ( bit16 k = 0; k < max_index[0]; k++ )\n  {\n    \n    bit8 x = max_min[0] + k%max_min[4];\n    bit8 y = max_min[2] + k/max_min[4];\n\n    if( pixel_in_triangle( x, y, triangle_2d_same ) )\n    {\n      fragment2[i].x = x;\n      fragment2[i].y = y;\n      fragment2[i].z = triangle_2d_same.z;\n      fragment2[i].color = color;\n      i++;\n    }\n  }\n\n  return i;\n}\n\n// filter hidden pixels\nbit16 zculling ( bit16 counter, CandidatePixel fragments[], bit16 size, Pixel pixels[])\n{\n  #pragma HLS INLINE off\n\n  // initilize the z-buffer in rendering first triangle for an image\n  static bit8 z_buffer[MAX_X][MAX_Y];\n  if (counter == 0)\n  {\n    ZCULLING_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n\n      ZCULLING_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n      {\n        z_buffer[i][j] = 255;\n      }\n    }\n  }\n\n  // pixel counter\n  bit16 pixel_cntr = 0;\n  \n  // update z-buffer and pixels\n  ZCULLING: for ( bit16 n = 0; n < size; n++ ) \n  {\n    \n    if( fragments[n].z < z_buffer[fragments[n].y][fragments[n].x] )\n    {\n      pixels[pixel_cntr].x     = fragments[n].x;\n      pixels[pixel_cntr].y     = fragments[n].y;\n      pixels[pixel_cntr].color = fragments[n].color;\n      pixel_cntr++;\n      z_buffer[fragments[n].y][fragments[n].x] = fragments[n].z;\n    }\n  }\n\n  return pixel_cntr;\n}\n\n// color the frame buffer\nvoid coloringFB(bit16 counter,  bit16 size_pixels, Pixel pixels[], bit8 frame_buffer[MAX_X][MAX_Y])\n{\n  #pragma HLS INLINE off\n\n  if ( counter == 0 )\n  {\n    // initilize the framebuffer for a new image\n    COLORING_FB_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      \n      COLORING_FB_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n        frame_buffer[i][j] = 0;\n    }\n  }\n\n  // update the framebuffer\n  COLORING_FB: for ( bit16 i = 0; i < size_pixels; i++)\n  {\n    \n    frame_buffer[ pixels[i].x ][ pixels[i].y ] = pixels[i].color;\n  }\n\n}\n\n// stream out the frame buffer\nvoid output_FB(bit8 frame_buffer[MAX_X][MAX_Y], bit32 output[NUM_FB])\n{\n  #pragma HLS INLINE\n  bit32 out_FB = 0;\n  OUTPUT_FB_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n  {\n\n    OUTPUT_FB_COL: for ( bit16 j = 0; j < MAX_Y; j = j + 4)\n    {\n      out_FB( 7,  0) = frame_buffer[i][j + 0];\n      out_FB(15,  8) = frame_buffer[i][j + 1];\n      out_FB(23, 16) = frame_buffer[i][j + 2];\n      out_FB(31, 24) = frame_buffer[i][j + 3];\n      output[i * MAX_Y / 4 + j / 4] = out_FB;\n    }\n  }\n}\n\n\n/*========================TOP FUNCTION===========================*/\nvoid rendering( bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB])\n{\n  // local variables\n  Triangle_3D triangle_3ds;\n  Triangle_2D triangle_2ds;\n  Triangle_2D triangle_2ds_same;\n\n  bit16 size_fragment;\n  CandidatePixel fragment[500];\n\n  bit16 size_pixels;\n  Pixel pixels[500];\n\n  bit8 frame_buffer[MAX_X][MAX_Y];\n  bit2 angle = 0;\n\n  bit8 max_min[5];\n  bit16 max_index[1];\n  bit2 flag;\n\n  // processing NUM_3D_TRI 3D triangles\n  TRIANGLES: for (bit16 i = 0; i < NUM_3D_TRI; i++)\n  {\n    bit32 input_lo  = input[3*i];\n    bit32 input_mi  = input[3*i+1];\n    bit32 input_hi  = input[3*i+2];\n\n    triangle_3ds.x0 = input_lo( 7,  0);\n    triangle_3ds.y0 = input_lo(15,  8);\n    triangle_3ds.z0 = input_lo(23, 16);\n    triangle_3ds.x1 = input_lo(31, 24);\n    triangle_3ds.y1 = input_mi( 7,  0);\n    triangle_3ds.z1 = input_mi(15,  8);\n    triangle_3ds.x2 = input_mi(23, 16);\n    triangle_3ds.y2 = input_mi(31, 24);\n    triangle_3ds.z2 = input_hi( 7,  0);\n\n    #ifdef USE_DATAFLOW\n      #pragma HLS dataflow\n    #endif\n\n    // five stages for processing each 3D triangle\n    projection( triangle_3ds, &triangle_2ds, angle );\n    flag = rasterization1( triangle_2ds, max_min, &triangle_2ds_same, max_index);\n    size_fragment = rasterization2( flag, max_min, max_index, triangle_2ds_same, fragment );\n    size_pixels = zculling( i, fragment, size_fragment, pixels);\n    coloringFB ( i, size_pixels, pixels, frame_buffer);\n  }\n\n  // output values: frame buffer\n  output_FB(frame_buffer,output);\n}\n"
      },
      {
        "file_name": "rendering.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                         rendering.h                           */\n/*                                                               */\n/*                 C++ kernel for 3D Rendering                   */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __RENDERING_H__\n#define __RENDERING_H__\n\n#include \"typedefs.h\"\n\n#define SDSOC\n#pragma SDS data access_pattern(input:SEQUENTIAL, output:SEQUENTIAL)\nvoid rendering(bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB]);\n\n#endif\n\n"
      },
      {
        "file_name": "typedefs.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          typedefs.h                           */\n/*                                                               */\n/*                     Typedefs for the host                     */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\n\n// resolution 256x256\nconst int MAX_X = 256;\nconst int MAX_Y = 256;\n\n// number of values in frame buffer: 32 bits\nconst int NUM_FB = MAX_X * MAX_Y / 4;\n// dataset information \nconst int NUM_3D_TRI = 3192;\n\n#ifdef OCL\n  #include <string>\n  // target device\n  // change here to map to a different device\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n#ifndef SW\n  // hls header\n  #include \"ap_int.h\"\n  // specialized datatypes\n  typedef ap_uint<1> bit1;\n  typedef ap_uint<2> bit2;\n  typedef ap_uint<8> bit8;\n  typedef ap_uint<16> bit16;\n  typedef ap_uint<32> bit32;\n#else\n  typedef unsigned char bit8;\n  typedef unsigned int bit32;\n#endif\n\n// struct: 3D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   z0;\n  bit8   x1;\n  bit8   y1;\n  bit8   z1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z2;\n} Triangle_3D;\n\n// struct: 2D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   x1;\n  bit8   y1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z;\n} Triangle_2D;\n\n// struct: candidate pixels\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   z;\n  bit8   color;\n} CandidatePixel;\n\n// struct: colored pixel\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   color;\n} Pixel;\n\n// dataflow switch\n#define ENABLE_DATAFLOW\n#endif\n"
      }
    ],
    "code_length": 9463,
    "token_count": 3212,
    "pragma_number": 8,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/AES_Encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 191489,
    "Worst-caseLatency": 191489.0,
    "BRAM_18K": 0,
    "LUT": 1369,
    "DSP": 0,
    "FF": 200,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "AES_Encrypt",
    "ResourceMetric": 0.0002817026,
    "design_id": "project",
    "algo_name": "AES_Encrypt",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "AES_Encrypt.cpp",
        "file_content": "#include <stdint.h>\n\n#define AES_BLOCK_SIZE 16\n#define LARGE_SCALE 1024\n\nvoid SubBytes(uint8_t state[AES_BLOCK_SIZE]) {\n    static const uint8_t sbox[256] = {\n        // S-box values here\n    };\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = sbox[state[i]];\n    }\n}\n\nvoid ShiftRows(uint8_t state[AES_BLOCK_SIZE]) {\n    uint8_t temp;\n    // Rotate first row 1 columns to left  \n    temp = state[1];\n    state[1] = state[5];\n    state[5] = state[9];\n    state[9] = state[13];\n    state[13] = temp;\n\n    // Rotate second row 2 columns to left  \n    temp = state[2];\n    state[2] = state[10];\n    state[10] = temp;\n    temp = state[6];\n    state[6] = state[14];\n    state[14] = temp;\n\n    // Rotate third row 3 columns to left\n    temp = state[3];\n    state[3] = state[15];\n    state[15] = state[11];\n    state[11] = state[7];\n    state[7] = temp;\n}\n\nvoid MixColumns(uint8_t state[AES_BLOCK_SIZE]) {\n    uint8_t temp[AES_BLOCK_SIZE];\n    for (int i = 0; i < 4; i++) {\n        temp[4*i] = (uint8_t)(0x02 * state[4*i] ^ 0x03 * state[4*i+1] ^ state[4*i+2] ^ state[4*i+3]);\n        temp[4*i+1] = (uint8_t)(state[4*i] ^ 0x02 * state[4*i+1] ^ 0x03 * state[4*i+2] ^ state[4*i+3]);\n        temp[4*i+2] = (uint8_t)(state[4*i] ^ state[4*i+1] ^ 0x02 * state[4*i+2] ^ 0x03 * state[4*i+3]);\n        temp[4*i+3] = (uint8_t)(0x03 * state[4*i] ^ state[4*i+1] ^ state[4*i+2] ^ 0x02 * state[4*i+3]);\n    }\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = temp[i];\n    }\n}\n\nvoid AddRoundKey(uint8_t state[AES_BLOCK_SIZE], const uint8_t roundKey[AES_BLOCK_SIZE]) {\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] ^= roundKey[i];\n    }\n}\n\nvoid AES_Encrypt(uint8_t input[LARGE_SCALE][AES_BLOCK_SIZE], uint8_t output[LARGE_SCALE][AES_BLOCK_SIZE], const uint8_t roundKeys[11][AES_BLOCK_SIZE]) {\n    for (int block = 0; block < LARGE_SCALE; block++) {\n        uint8_t state[AES_BLOCK_SIZE];\n        for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n            state[i] = input[block][i];\n        }\n\n        AddRoundKey(state, roundKeys[0]);\n\n        for (int round = 1; round < 10; round++) {\n            SubBytes(state);\n            ShiftRows(state);\n            MixColumns(state);\n            AddRoundKey(state, roundKeys[round]);\n        }\n\n        SubBytes(state);\n        ShiftRows(state);\n        AddRoundKey(state, roundKeys[10]);\n\n        for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n            output[block][i] = state[i];\n        }\n    }\n}\n\n// Top function name: AES_Encrypt\n"
      }
    ],
    "code_length": 2501,
    "token_count": 830,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/AES_Encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 14401,
    "Worst-caseLatency": 14401.0,
    "BRAM_18K": 0,
    "LUT": 1475,
    "DSP": 0,
    "FF": 310,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "AES_Encrypt",
    "ResourceMetric": 0.0003125767,
    "design_id": "project",
    "algo_name": "AES_Encrypt",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "AES_Encrypt.cpp",
        "file_content": "#include <stdint.h>\n\n#define AES_BLOCK_SIZE 16\n#define AES_KEY_SIZE 16\n#define DATA_SIZE (1 << 10)\n\nvoid SubBytes(uint8_t state[AES_BLOCK_SIZE]) {\n    static const uint8_t sbox[256] = {\n        // S-box values...\n    };\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = sbox[state[i]];\n    }\n}\n\nvoid ShiftRows(uint8_t state[AES_BLOCK_SIZE]) {\n    uint8_t temp[AES_BLOCK_SIZE];\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        temp[i] = state[i];\n    }\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            state[i * 4 + j] = temp[i * 4 + ((j + i) % 4)];\n        }\n    }\n}\n\nvoid MixColumns(uint8_t state[AES_BLOCK_SIZE]) {\n    uint8_t temp[AES_BLOCK_SIZE];\n    for (int i = 0; i < 4; i++) {\n        temp[i * 4 + 0] = (uint8_t)(0x02 * state[i * 4 + 0] ^ 0x03 * state[i * 4 + 1] ^ state[i * 4 + 2] ^ state[i * 4 + 3]);\n        temp[i * 4 + 1] = (uint8_t)(state[i * 4 + 0] ^ 0x02 * state[i * 4 + 1] ^ 0x03 * state[i * 4 + 2] ^ state[i * 4 + 3]);\n        temp[i * 4 + 2] = (uint8_t)(state[i * 4 + 0] ^ state[i * 4 + 1] ^ 0x02 * state[i * 4 + 2] ^ 0x03 * state[i * 4 + 3]);\n        temp[i * 4 + 3] = (uint8_t)(0x03 * state[i * 4 + 0] ^ state[i * 4 + 1] ^ state[i * 4 + 2] ^ 0x02 * state[i * 4 + 3]);\n    }\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = temp[i];\n    }\n}\n\nvoid AddRoundKey(uint8_t state[AES_BLOCK_SIZE], const uint8_t roundKey[AES_BLOCK_SIZE]) {\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] ^= roundKey[i];\n    }\n}\n\nvoid AES_Encrypt_Block(uint8_t input[AES_BLOCK_SIZE], const uint8_t key[AES_KEY_SIZE], uint8_t output[AES_BLOCK_SIZE]) {\n    uint8_t state[AES_BLOCK_SIZE];\n    uint8_t roundKey[AES_KEY_SIZE];\n\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        state[i] = input[i];\n        roundKey[i] = key[i];\n    }\n\n    AddRoundKey(state, roundKey);\n\n    for (int round = 1; round < 10; round++) {\n        SubBytes(state);\n        ShiftRows(state);\n        MixColumns(state);\n        AddRoundKey(state, roundKey);\n    }\n\n    SubBytes(state);\n    ShiftRows(state);\n    AddRoundKey(state, roundKey);\n\n    for (int i = 0; i < AES_BLOCK_SIZE; i++) {\n        output[i] = state[i];\n    }\n}\n\nvoid AES_Encrypt(uint8_t input[DATA_SIZE], const uint8_t key[AES_KEY_SIZE], uint8_t output[DATA_SIZE]) {\n    for (int i = 0; i < DATA_SIZE; i += AES_BLOCK_SIZE) {\n        AES_Encrypt_Block(&input[i], key, &output[i]);\n    }\n}\n\n// Top function name: AES_Encrypt\n"
      }
    ],
    "code_length": 2451,
    "token_count": 863,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/BNN/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4691,
    "Worst-caseLatency": 166859646537.0,
    "BRAM_18K": 59,
    "LUT": 29744,
    "DSP": 3,
    "FF": 6098,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "top",
    "ResourceMetric": 0.0100298906,
    "design_id": "project",
    "algo_name": "BNN",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "xf_video_mem.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * HLS Video Memory Partition Header File\n */\n\n#ifndef ___XF__VIDEO_MEM__\n#define ___XF__VIDEO_MEM__\n\n//#define __DEBUG__\n\n#ifdef AESL_SYN\n#undef __DEBUG__\n#endif\n\n#include \"string.h\"\n#include \"xf_params.hpp\"\n\ntypedef ap_uint<32> XF_SIZE_T;\n\nnamespace xf {\nnamespace cv {\n\n//--------------------------------------------------------------------------------------\n// Template class of Window\n//--------------------------------------------------------------------------------------\ntemplate <int ROWS, int COLS, typename T>\nclass Window {\n   public:\n    Window(){\n// clang-format off\n\t#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=2\n        // clang-format on\n    };\n\n    /* Window main APIs */\n    void shift_pixels_left();\n    void shift_pixels_right();\n    void shift_pixels_up();\n    void shift_pixels_down();\n    void insert_pixel(T value, int row, int col);\n    void insert_row(T value[COLS], int row);\n    void insert_top_row(T value[COLS]);\n    void insert_bottom_row(T value[COLS]);\n    void insert_col(T value[ROWS], int col);\n    void insert_left_col(T value[ROWS]);\n    void insert_right_col(T value[ROWS]);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_left();\n    void shift_right();\n    void shift_up();\n    void shift_down();\n    void insert(T value, int row, int col);\n    void insert_top(T value[COLS]);\n    void insert_bottom(T value[COLS]);\n    void insert_left(T value[ROWS]);\n    void insert_right(T value[ROWS]);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void window_print();\n    T val_t[ROWS][COLS];\n#endif\n};\n\n/* Member functions of Window class */\n/* Origin in upper-left point */\n/*       0   1        C-2 C-1\n *     +---+---+-...-+---+---+\n *  0  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *  1  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *       ...     ...    ...\n *     +---+---+-...-+---+---+\n * R-2 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n * R-1 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *\n */\n\n/*\n * Window content shift left\n * Assumes new values will be placed in right column = COLS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_left() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS - 1; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j + 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n            else\n                assert(val_t[i][j + 1] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift right\n * Assumes new values will be placed in left column = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_right() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = COLS - 1; j > 0; j--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j - 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n            else\n                assert(val_t[i][j - 1] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift up\n * Assumes new values will be placed in bottom row = ROWS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_up() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i + 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift down\n * Assumes new values will be placed in top row = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_down() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i - 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert pixel\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    val[row][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row && j != col) assert(val_t[i][j] == val[i][j] && \"*** window insert_pixel mismatch! ***\");\n        }\n    }\n    val_t[row][col] = value;\n    assert(val_t[row][col] == val[row][col] && \"*** window insert_pixel mismatch! ***\");\n#endif\n}\n\n/* Window insert row\n * Inserts a set of values in any row of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T j;\n    for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[row][j] = value[j];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert top row\n * Inserts a set of values in top row = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert bottom row\n * Inserts a set of values in bottom row = ROWS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, ROWS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert column\n * Inserts a set of values in any column of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = value[i];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != col)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert left column\n * Inserts a set of values in left column = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_left_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_left_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert right column\n * Inserts a set of values in right column = COLS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, COLS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_right_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_right_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n#ifdef __DEBUG__\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::window_print() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            std::cout << std::setw(20) << val[i][j];\n        }\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift left, while contents shift right\n * Assumes new values will be placed in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_left() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_left(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift right, while contents shift left\n * Assumes new values will be placed in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_right() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_right(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_up() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_down() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_pixel(value, row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert top\n * Inserts a set of values in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert bottom\n * Inserts a set of values in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert left\n * Inserts a set of values in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_right_col(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert right\n * Inserts a set of values in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_left_col(value);\n}\n\n//--------------------------------------------------------------------------------------\n// Template class of Line Buffer\n//--------------------------------------------------------------------------------------\n#define _LB_TPLT_DEC \\\n    template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE = RAM_S2P_BRAM, int RESHAPE_FACTOR = 1>\n#define _LB_TPLT template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR>\n#define _LB_ LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>\n\n_LB_TPLT_DEC class LineBuffer {\n   public:\n    LineBuffer() {\n// clang-format off\n\t#pragma HLS INLINE\n        #pragma HLS dependence variable=val inter false\n        #pragma HLS dependence variable=val intra false\n        // clang-format on\n\n        // #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n        //#pragma HLS array_reshape variable=val factor=RESHAPE_FACTOR  dim=1\n\n        switch (MEM_TYPE) {\n            case RAM_1P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_1P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=URAM\n                // clang-format on\n                break;\n            case RAM_2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_S2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_S2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_T2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_T2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=URAM\n                // clang-format on\n                break;\n            default:\n                assert(\"MEM_TYPE should be one of RAM_*_BRAM or RAM_*_URAM (*: 1P, 2P, S2P, T2P)\");\n        }\n\n        if (RESHAPE_FACTOR == 1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n            // clang-format on\n        } else {\n// clang-format off\n            #pragma HLS ARRAY_RESHAPE variable=val factor=RESHAPE_FACTOR  dim=1\n            // clang-format on\n        }\n    };\n\n    /* LineBuffer main APIs */\n    void shift_pixels_up(int col);\n    void shift_pixels_down(int col);\n    void insert_bottom_row(T value, int col);\n    void insert_top_row(T value, int col);\n    void get_col(T value[ROWS], int col);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_up(int col);\n    void shift_down(int col);\n    void insert_bottom(T value, int col);\n    void insert_top(T value, int col);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void linebuffer_print(int col);\n    T val_t[ROWS][COLS];\n#endif\n};\n/* Member functions of LineBuffer class */\n/* Origin in upper-left point */\n/*       0   1            C-2 C-1\n *     +---+---+-... ...-+---+---+\n *  0  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *  1  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *       ...     ... ...    ...\n *     +---+---+-... ...-+---+---+\n * R-2 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n * R-1 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *\n */\n\n/* Member functions of LineBuffer class */\n\n/*\n * LineBuffer content shift down\n * Assumes new values will be placed in top row = 0\n */\n_LB_TPLT void _LB_::shift_pixels_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i - 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == 0)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n                else\n                    assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * LineBuffer content shift up\n * Assumes new values will be placed in top row = ROWS-1\n */\n_LB_TPLT void _LB_::shift_pixels_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i + 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == ROWS - 1)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n                else\n                    assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert bottom row\n * Inserts a new value in bottom row= ROWS-1 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_bottom_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[ROWS - 1][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == ROWS - 1)\n                assert(val[i][j] == value && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert top row\n * Inserts a new value in top row=0 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_top_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[0][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == 0)\n                assert(val[i][j] == value && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer get a column\n * Get a column value of the linebuffer\n */\n_LB_TPLT void _LB_::get_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        value[i] = val[i][col];\n    }\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\n_LB_TPLT void _LB_::shift_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::shift_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in bottom row(=0)\n */\n_LB_TPLT void _LB_::insert_bottom(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::insert_top(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value, col);\n}\n\n#ifdef __DEBUG__\n_LB_TPLT void _LB_::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\n_LB_TPLT void _LB_::linebuffer_print(int col) {\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        std::cout << std::setw(20) << val[i][col];\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n#undef _LB_TPLT_DEC\n#undef _LB_TPLT\n#undef _LB_\n\n} // namespace cv\n} // namespace xf\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "Debug.h",
        "file_content": "#ifndef DEBUG_H\n#define DEBUG_H\n\n#ifndef DEBUG_LEVEL\n#define DEBUG_LEVEL 0\n#endif\n\n#ifdef HLS_COMPILE\n#undef DEBUG_LEVEL\n#endif\n\n#ifdef DEBUG_LEVEL\n\n  #define DB(lvl, x) if (lvl <= DEBUG_LEVEL) {x;}\n  #define DB_PRINT(lvl, ...) \\\n    if (lvl <= DEBUG_LEVEL) \\\n      printf (__VA_ARGS__)\n\n#else\n  \n  #define DB(lvl, x)   \n  #define DB_PRINT(lvl, ...)\n\n#endif\n\n#endif\n"
      },
      {
        "file_name": "Common.h",
        "file_content": "#ifndef COMMON_H\n#define COMMON_H\n\n#include <string>\n#include <cstdlib>\n#include <assert.h>\n#include <ap_int.h>\n\n#include \"Typedefs.h\"\n\n// Returns the repo's root dir or exits\nstd::string get_root_dir();\n\n// We encode negative to -1, positive to 0\ntemplate<typename T>\nBit sgn(const T x) {\n  #pragma HLS INLINE\n  return (x < 0) ? -1 : 0;\n}\n\n#endif\n"
      },
      {
        "file_name": "Accel.cpp",
        "file_content": "#include <iostream>\n#include <iomanip>\n#include <hls_stream.h>\n#include \"Accel.h\"\n#include \"AccelPrint.h\"\n\nconst static Word m1(\"0x5555555555555555\", 16);\nconst static Word m2(\"0x3333333333333333\", 16);\nconst static Word m4(\"0x0f0f0f0f0f0f0f0f\", 16);\nconst static Word h01(\"0x0101010101010101\", 16);\n\n// -----------------------------------------------------------------------\n// Hardware-specific print helpers\n// -----------------------------------------------------------------------\ntemplate<typename T>\nvoid print_ap_bits(const T& in, const unsigned W) {\n  printf (\"   \");\n  for (unsigned i = 0; i < W; ++i)\n    printf (\"%3d\", in[i] ? -1 : 0);\n  printf (\"\\n\");\n}\n\ntemplate<typename T>\nvoid print_params(T params[CONVOLVERS][K][K]) {\n  for (unsigned m = 0; m < CONVOLVERS; ++m) {\n    for (unsigned wr = 0; wr < K; ++wr) {\n      for (unsigned wc = 0; wc < K; ++wc) {\n        printf (\"%3d\", (params[m][wr][wc]==0) ? 0 : 1);\n      }\n      printf(\"\\n\");\n    }\n    printf(\"--\\n\");\n  }\n}\n\ntemplate<typename T>\nvoid print_line_buffer_m(T lbuf[CONV_BANKS]) {\n  for (unsigned wr = 0; wr < CONV_ROWS; ++wr) {\n  for (unsigned bank = 0; bank < CONV_BANKS; ++bank) {\n    for (unsigned wc = 0; wc < CONV_COLS; ++wc) {\n      printf (\"%3d\", lbuf[bank][wr][wc].to_int());\n    }\n    printf (\" |\");\n  }\n  printf (\"\\n\");\n  }\n}\n\nTwoBit encode_bit(const Bit& b) {\n  return (b == 0) ? TwoBit(1) : TwoBit(-1);\n}\n\n// -----------------------------------------------------------------------\n// Conv\n// -----------------------------------------------------------------------\nConvOut conv3x3b(\n    const TwoBit line_buffer_m[CONV_BANKS][CONV_ROWS][CONV_COLS],\n    const Bit conv_params_m[K][K],\n    const ap_uint<4> bank,\n    const IdxType cc\n) {\n  ConvOut sum = 0;\n  for (ap_uint<2> kr = 0; kr < K; ++kr) {\n    for (ap_uint<2> kc = 0; kc < K; ++kc) {\n      TwoBit data = line_buffer_m[bank][kr][cc+kc];\n      const Bit& wt = conv_params_m[2-kr][2-kc];\n      data[1] = (wt & data[0]) ^ data[1];\n      sum += data;\n    }\n  }\n  return sum;\n}\n\n// -----------------------------------------------------------------------\n// Produce 32 elements of conv results\n// -----------------------------------------------------------------------\nvoid conv_word(\n    const TwoBit line_buffer_m[CONV_BANKS][CONV_ROWS][CONV_COLS],\n    const Bit conv_params_m[K][K],\n    ConvOut conv_out_buffer_m[WORD_SIZE]\n) {\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    for (ap_uint<4> cc = 0; cc < BANK_WIDTH; ++cc) {\n      conv_out_buffer_m[bank*BANK_WIDTH+cc] = conv3x3b( line_buffer_m, conv_params_m, bank, cc );\n    }\n  }\n}\n\n// -----------------------------------------------------------------------\n// Process each line in a word, we need to outline this loop to\n// avoid false control dependencies in Vivado HLS\n// -----------------------------------------------------------------------\nvoid process_word(\n    const TwoBit  word_buffer_m[CONV_BANKS][CONV_COLS],\n    const TwoBit  old_word_buffer_m[CONV_BANKS][CONV_COLS],\n    const bool lb[CONV_BANKS],\n    const bool rb[CONV_BANKS],\n    TwoBit  line_buffer_m[CONV_BANKS][CONV_ROWS][CONV_COLS],\n    const   Bit conv_params_m[K][K],\n    ConvOut conv_out_buffer_m[WORD_SIZE],\n    const   ap_uint<3> log_width,\n    const   ap_uint<6> words_per_image,\n    const   IdxType wrd\n) {\n  // slices_per_line = width / BANK_WIDTH\n  const ap_uint<5> slices_per_line = 1 << (log_width - LOG_BANK_WIDTH);\n  const bool first_wrd = (wrd == 0);\n  const bool last_wrd = (wrd == words_per_image);\n  DB_PRINT(4, \"process word %d, spl=%d\\n\", wrd.to_int(), slices_per_line.to_int());\n\n  // Prologue\n  // Update bottom row, slices are shifted left. Some slices copied from previous word (middle row)\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    ap_int<6> s_idx = bank + slices_per_line - CONV_BANKS;\n    if (s_idx < 0) {\n      // set to zero or copy from old word (middle row)\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][CONV_ROWS-1][cc] = old_word_buffer_m[CONV_BANKS+s_idx][cc];\n      }\n      line_buffer_m[bank][CONV_ROWS-1][0          ] = lb[bank] ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx][0];\n      line_buffer_m[bank][CONV_ROWS-1][CONV_COLS-1] = rb[bank] ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx][CONV_COLS-1];\n    } else {\n      // fill from new word\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][CONV_ROWS-1][cc] = (last_wrd) ? TwoBit(0) : word_buffer_m[s_idx][cc];\n      }\n      line_buffer_m[bank][CONV_ROWS-1][0          ] = (last_wrd || lb[bank]) ? TwoBit(0) : word_buffer_m[s_idx][0];\n      line_buffer_m[bank][CONV_ROWS-1][CONV_COLS-1] = (last_wrd || rb[bank]) ? TwoBit(0) : word_buffer_m[s_idx][CONV_COLS-1];\n    }\n  }\n  \n  DB(4,\n    printf(\"Accel lbuf wrd%d before conv:\\n\", wrd.to_int());\n    print_line_buffer_m(line_buffer_m);\n  );\n\n  // Convolution\n  conv_word( line_buffer_m, conv_params_m, conv_out_buffer_m );\n  \n  // Update\n  // Fill line buffer with lines from the new word\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    // --------------------------------------------------------------\n    // Top row, slices are shifted right by slices_per_line\n    ap_int<6> s_idx0 = bank - slices_per_line;\n    if (s_idx0 >= 0) {\n      // slice from input word\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][0][cc] = word_buffer_m[s_idx0][cc];\n      }\n      line_buffer_m[bank][0][0          ] = lb[bank] ? TwoBit(0) : word_buffer_m[s_idx0][0];\n      line_buffer_m[bank][0][CONV_COLS-1] = rb[bank] ? TwoBit(0) : word_buffer_m[s_idx0][CONV_COLS-1];\n    } else {\n      // set to zero or copy from old word (middle row)\n      for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n        line_buffer_m[bank][0][cc] = (first_wrd) ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx0][cc];\n      }\n      line_buffer_m[bank][0][0          ] = (first_wrd || lb[bank]) ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx0][0];\n      line_buffer_m[bank][0][CONV_COLS-1] = (first_wrd || rb[bank]) ? TwoBit(0) : old_word_buffer_m[CONV_BANKS+s_idx0][CONV_COLS-1];\n    }\n\n    // --------------------------------------------------------------\n    // Middle row, simply copy the word into the line buffer\n    for (ap_uint<4> cc = 1; cc < CONV_COLS-1; ++cc) {\n      line_buffer_m[bank][1][cc] = word_buffer_m[bank][cc];\n    }\n    // Fill end buffer bits\n    line_buffer_m[bank][1][0          ] = lb[bank] ? TwoBit(0) : word_buffer_m[bank][0];\n    line_buffer_m[bank][1][CONV_COLS-1] = rb[bank] ? TwoBit(0) : word_buffer_m[bank][CONV_COLS-1];\n  }\n\n  DB(4,\n    printf(\"Accel lbuf wrd%d after conv:\\n\", wrd.to_int());\n    print_line_buffer_m(line_buffer_m);\n  );\n}\n\n// -----------------------------------------------------------------------\n// A single PE reads from all inputs and weights to generate a single\n// output feature map.\n// * Make sure this function gets inlined by VHLS, or cosim may fail!\n// -----------------------------------------------------------------------\nvoid bin_conv(\n    Word wt_mem[CONVOLVERS][C_WT_WORDS],\n    NormComp nc,\n    Word dmem[2][CONVOLVERS][C_DMEM_WORDS],\n    ap_uint<1> d_i_idx,\n    ap_uint<1> d_o_idx,\n    const unsigned   n_inputs,\n    const Address    o_index,\n    const ap_uint<1> new_batch,\n    const ap_uint<2> width_mode,  // 0=8'b, 1=16'b, 2=32'b\n    const ap_uint<2> norm_mode    // 0='do nothing', 1='do norm', 2='do pool'\n) {\n  const ap_uint<3> log_width = width_mode + LOG_BANK_WIDTH; // width_mode + 3 = 3,4,5\n  const ap_uint<5> words_per_image = 1 << (2*width_mode); // 1, 4, 16\n  const unsigned n_phases = n_inputs / CONVOLVERS;\n  const unsigned images_per_phase = PIX_PER_PHASE >> (2*log_width); // 2*32*32 / 2^3, 2^4, 2^5 = 2^8, 2^7, 2^6\n  const unsigned WORDS_PER_PHASE = PIX_PER_PHASE / WORD_SIZE; // 2*32*32 / 64 = 512\n\n  assert(n_phases % images_per_phase == 0);\n  assert(n_inputs % images_per_phase == 0);\n  assert(images_per_phase*words_per_image == WORDS_PER_PHASE);\n\n  // ---------------------------------------------------------------------\n  // buffers\n  // ---------------------------------------------------------------------\n  TwoBit  line_buffer[CONVOLVERS][CONV_BANKS][CONV_ROWS][CONV_COLS];\n  Bit     conv_params[CONVOLVERS][K][K];\n  ConvSum fixed_buffer[WORDS_PER_PHASE][WORD_SIZE];\n  ConvSum fixed_temp[WORD_SIZE];\n  // per-convolver buffers\n  TwoBit  word_buffer[CONVOLVERS][CONV_BANKS][CONV_COLS];\n  TwoBit  old_word_buffer[CONVOLVERS][CONV_BANKS][CONV_COLS];\n  ConvOut conv_out_buffer[CONVOLVERS][WORD_SIZE];\n  // edge padding flag bits\n  bool lb[CONV_BANKS];\n  bool rb[CONV_BANKS];\n\n  static Address wt_addr = 0;           // address of weight word\n  static ap_uint<3> wt_offset = 0;      // offset 0..6 of param\n  if (new_batch != 0) { wt_addr = 0; wt_offset = 0; }\n\n  // ---------------------------------------------------------------------\n  // Calculate edge padding flag bits\n  const ap_uint<4> log_slice = log_width - LOG_BANK_WIDTH;\n  const ap_uint<4> w_div_8 = (1 << log_width) >> 3;\n  assert (w_div_8 > 0);\n  ap_uint<4> mask = ~ap_uint<4>(0);   // set mask to all 1s\n  mask = mask >> (4-log_slice);\n  for (ap_uint<4> bank = 0; bank < CONV_BANKS; ++bank) {\n    \n    const ap_uint<4> x = bank & mask;\n    lb[bank] = (x == 0);          // (bank % w_div_8) == 0\n    rb[bank] = (x+1 == w_div_8);  // (bank % w_div_8) == w_div_8-1\n  }\n\n  // ---------------------------------------------------------------------\n  // Reset conv buffer\n  for (IdxType i = 0; i < WORDS_PER_PHASE; ++i) {\n    for (IdxType j = 0; j < WORD_SIZE; ++j) {\n      \n      fixed_buffer[i][j] = 0;\n    }\n  }\n\n  // ---------------------------------------------------------------------\n  // Compute in phases\n  // Each phase processes CONVOLVERS * WORDS_PER_PHASE input words\n  // ---------------------------------------------------------------------\n  LOOP_PHASES:\n  for (ap_uint<10> p = 0; p < n_phases; p += images_per_phase) {\n  #pragma HLS loop_tripcount min=8 max=64\n    DB(3, printf (\"=== PHASE %d ===\\n\", p.to_int()) );\n\n    // wrd = which word in the current image\n    // wrd_phase = which wrd in the current phase\n    ap_uint<8> wrd = 0;\n    ap_uint<8> wrd_phase = 0;\n\n    // Load a word each iteration, and then process it\n    // We load WORDS_PER_PHASE words per phase, however we also need 1 extra \"empty\"\n    // iteration per image in the phase to do the loop epilogue, so the loop bound\n    // is WORDS_PER_PHASE + images_per_phase\n    LOOP_WORDS_IN_PHASE:\n    for (ap_uint<8> count = 0; count < WORDS_PER_PHASE+images_per_phase; ++count) {\n    #pragma HLS loop_tripcount min=576 max=768\n      if (wrd == 0) {\n        Word wt_word_buffer[CONVOLVERS];\n\n        // -------------------------------------------------------------------\n        // Load param word\n        // Each word contains CONV_W_PER_WORD weight filters, after we use\n        // them all we should load the next word\n        // -------------------------------------------------------------------\n        LOOP_WT_WORDS:\n        for (IdxType m = 0; m < CONVOLVERS; ++m) {\n          /*if (wt_offset == 0)\n            wt_word_buffer[m] = wt_mem[m][wt_addr];\n          else\n            wt_word_buffer[m] = wt_word_buffer[m] >> WT_SIZE;\n          */\n          wt_word_buffer[m] = wt_mem[m][wt_addr] >> ap_uint<6>(WT_SIZE*wt_offset);\n        }\n        if (wt_offset == CONV_W_PER_WORD-1) {\n          ++wt_addr;\n          wt_offset = 0;\n        } else {\n          ++wt_offset;\n        }\n        //print_wt_word(wt_word_buffer[0]);\n\n        // -------------------------------------------------------------------\n        // Load params\n        // Each word contains CONV_W_PER_WORD weight filters packed into the first\n        // 63 bits, the last bit is unused. Wts are stored in output-major order.\n        // -------------------------------------------------------------------\n        LOOP_LOAD_WTS:\n        for (IdxType m = 0; m < CONVOLVERS; ++m) {\n          for (ap_uint<2> kr = 0; kr < K; ++kr) {\n            for (ap_uint<2> kc = 0; kc < K; ++kc)\n              conv_params[m][kr][kc] = wt_word_buffer[m][kr*K+kc];\n          }\n        }\n\n        DB(3, print_params(conv_params) );\n      }\n\n      // -------------------------------------------------------------------\n      // Every word in an image\n      // -------------------------------------------------------------------\n      // Load word\n      // (wrd_phase-wrd) is which wrd in the current phase, aligned to img boundary\n      if (wrd != words_per_image) {\n        LOOP_CONVOLVER_LOAD:\n        for (IdxType m = 0; m < CONVOLVERS; ++m) {\n          Word word = dmem[d_i_idx][m][p*words_per_image + wrd_phase];\n          for (IdxType bank = 0; bank < CONV_BANKS; ++bank) {\n            for (IdxType cc = 0; cc < CONV_COLS-2; ++cc) {\n              word_buffer[m][bank][cc+1] = encode_bit(word[ap_uint<6>(bank*BANK_WIDTH+cc)]);\n            }\n            word_buffer[m][bank][0          ] = (bank==0)            ?\n              TwoBit(0) : encode_bit(word[ap_uint<6>(bank*BANK_WIDTH-1)]);\n            word_buffer[m][bank][CONV_COLS-1] = (bank==CONV_BANKS-1) ?\n              TwoBit(0) : encode_bit(word[ap_uint<6>(bank*BANK_WIDTH+BANK_WIDTH)]);\n          }\n        }\n      }\n\n      // Compute\n      LOOP_CONVOLVERS:\n      for (IdxType m = 0; m < CONVOLVERS; ++m) {\n        // Do the following for each word in an image\n        process_word( word_buffer[m], old_word_buffer[m], lb, rb, line_buffer[m], conv_params[m],\n            conv_out_buffer[m], log_width, words_per_image, wrd );\n      } // CONVOLVERS\n\n      for (IdxType m = 0; m < CONVOLVERS; ++m) {\n        for (IdxType bank = 0; bank < CONV_BANKS; ++bank) {\n          for (IdxType cc = 0; cc < CONV_COLS; ++cc) {\n            old_word_buffer[m][bank][cc] = word_buffer[m][bank][cc];\n        } }\n      }\n\n      // -------------------------------------------------------------------\n      // Sum results across convolvers\n      // -------------------------------------------------------------------\n      for (IdxType i = 0; i < WORD_SIZE; ++i) {\n        // Ignore conv results after processing the first word\n        if (wrd > 0) {\n          ConvSum s = 0;\n          for (IdxType m = 0; m < CONVOLVERS; ++m)\n            s += conv_out_buffer[m][i];\n          fixed_buffer[wrd_phase-1][i] += s;\n        }\n      }\n\n      // -------------------------------------------------------------------\n      // Increment counters\n      // -------------------------------------------------------------------\n      if (wrd != words_per_image) {\n        wrd++;\n        wrd_phase++;\n      } else {\n        wrd = 0;\n      }\n    } // wrd_phase = 0 .. WORDS_PER_PHASE\n\n  } // n_phases\n\n  LOOP_ACC_PHASES:\n  for (ap_uint<5> w = 0; w < words_per_image; ++w) {\n    for (IdxType b = 0; b < WORD_SIZE; ++b) {\n      \n      fixed_temp[b] = fixed_buffer[w][b];\n    }\n\n    LOOP_ACC_PHASES_I:\n    for (ap_uint<8> i = words_per_image; i < WORDS_PER_PHASE; i += words_per_image) {\n    # pragma HLS loop_tripcount min= 32 max= 512\n      for (IdxType b = 0; b < WORD_SIZE; ++b) {\n        fixed_temp[b] += fixed_buffer[w+i][b];\n    } }\n\n    for (IdxType b = 0; b < WORD_SIZE; ++b) {\n      \n      fixed_buffer[w][b] = fixed_temp[b];\n    }\n  }\n\n  const Address bank_idx = o_index % CONVOLVERS;\n  const Address bank_off = o_index / CONVOLVERS;\n  const ap_uint<5> pool_width = 1 << (log_width-1);\n  DB(4,\n    unsigned width = 1 << log_width;\n    printf (\"=== conv result ===\\n\");\n    print_mat(fixed_buffer[0], width, 8, width);\n  );\n  DB_PRINT(2, \"  o_idx=%3d: nc=%6d\\n\", o_index.to_int(), nc.to_int());\n\n  static Word outword;\n  Word poolword;\n  LOOP_BATCH_NORM:\n  for (ap_uint<6> w = 0; w < words_per_image; ++w) {\n  # pragma HLS loop_tripcount min=1 max=16\n    Word binword;\n    Address o_bank_idx = bank_idx;\n    Address o_bank_offset = bank_off*words_per_image + w;\n    const ap_uint<6> out_offset = (w % 4) << 4;\n\n    for (ap_uint<7> i = 0; i < WORD_SIZE; ++i) {\n      binword[i] = (fixed_buffer[w][i] >= nc) ? 0 : 1;\n    }\n\n    if (norm_mode == 1) {\n      outword = binword;\n    }\n    else if (norm_mode == 2) {\n      // horizontal pooling first\n      ap_int<WORD_SIZE/2> poolword_h;\n      for (ap_uint<6> i = 0; i < WORD_SIZE/2; ++i) {\n        poolword_h[i] = binword[2*i] & binword[2*i+1];\n      }\n\n      // vertical pooling\n      for (ap_uint<6> i = 0; i < WORD_SIZE/4; ++i) {\n        // source indices\n        ap_uint<5> i0 = i >> (log_width-1);\n        i0 = (i0 << log_width) + i(log_width-2,0);\n        ap_uint<5> i1 = i0 + pool_width;\n        // dest index\n        ap_uint<6> d0 = out_offset + i;\n        poolword[d0] = poolword_h[i0] & poolword_h[i1];\n      }\n\n      // For log_width > 3 we can just assign the word, but log_width = 3 means width = 8,\n      // which means pooled width = 4, which is only 16 bits, which is less than 1 Word.\n      // So each time we get here we only have 16 bits, meaning we have to accumulate four\n      // of these 16-bit batches before writing a word out.\n      if (log_width != LOG_BANK_WIDTH) {\n        o_bank_offset /= 4;\n        outword = poolword;\n      } else {\n        outword = outword >> WORD_SIZE/4;\n        outword(63,48) = poolword(15,0);\n        o_bank_idx = (o_index/4)%CONVOLVERS;\n        o_bank_offset = (o_index/4)/CONVOLVERS;\n      }\n    }\n\n    dmem[d_o_idx][o_bank_idx][o_bank_offset] = outword;\n  }\n}\n\n// -----------------------------------------------------------------------\n// Module to do the first conv layer\n// -----------------------------------------------------------------------\nvoid fp_conv(\n    Word wt_mem[CONVOLVERS][C_WT_WORDS],\n    Word kh_mem[KH_WORDS],\n    Word dmem[2][CONVOLVERS][C_DMEM_WORDS],\n    ap_uint<1> d_i_idx,\n    ap_uint<1> d_o_idx,\n    const Address kh_index,\n    const Address o_index,\n    const unsigned N\n) {\n  const unsigned M = 3;\n  const unsigned S = 32;\n  const unsigned OUTWORDS = 16; // words per output image\n\n  C1InputType win[M][K][K];\n  C1InputType lbuf[M][K-1][S];\n  Word outwords[OUTWORDS];\n  WtType wtbuf[M];\n\n  Address wt_offset = 0;\n  ap_uint<3> wt_addr = 0;\n\n  // Parallelized across m, better for HLS\n  LOOP_FP_CONV_O:\n  for (IdxType n = 0; n < N; ++n) {\n  #pragma HLS loop_tripcount min=8 max=32\n    // clear linebuffers for each new output map\n    LOOP_RESET_LINEBUFFERS:\n    for (IdxType m = 0; m < M; ++m) {\n      PROLOG_COLS: for (IdxType c = 0; c < S; ++c) {\n        PROLOG_ROWS: for (IdxType r = 0; r < K/2; ++r) {\n          for (IdxType lr = 0; lr < K-2; ++lr) {\n            lbuf[m][lr][c] = lbuf[m][lr+1][c];\n          }\n          lbuf[m][K-2][c] = 0;\n      } }\n    }\n\n    // The weights for the 1st conv layer are just laid out\n    // linearly across wt_mem, 3 weights per 64-bit word\n    DB_PRINT(3, \"n = %u\\n\", n.to_int());\n    Word wt_word = wt_mem[n % CONVOLVERS][n / CONVOLVERS];\n    LOOP_LOAD_WTS:\n    for (ap_uint<2> m = 0; m < M; ++m) {\n      wtbuf[m] = wt_word((m+1)*WT_SIZE-1, m*WT_SIZE);\n      DB(3, print_wt(wtbuf[m]));\n      DB(3, printf(\"--\\n\"));\n    }\n\n    // load batch norm params\n    C1Comp nc;\n    load_kh(nc, kh_mem, (kh_index+n));\n    //printf (\"  n=%3d, nc=%6.3f\\n\", n.to_int(), nc.to_float());\n\n    // begin convolution\n    LOOP_CONV_ROWS: for (IdxType r = 0; r < S+1; ++r) {\n      LOOP_CONV_COLS: for (IdxType c = 0; c < S+1; ++c) {\n        // load input word\n        Word inword = 0;\n        if (r < S && c < S) {\n          const Address addr = r*S + c;\n          inword = dmem[d_i_idx][addr/C_DMEM_WORDS][addr%C_DMEM_WORDS];\n        }\n\n        for (ap_uint<2> m = 0; m < M; ++m) {\n          // load data: the value of pix is either the pixel at [r,c]\n          // 0 -> +1, -1 -> -1\n          // or -> 0 for padding around the boundaries\n          C1InputType pix;\n          const unsigned W = pix.length();\n          pix(W-1,0) = inword(W-1+m*W, m*W);\n\n          // window: shift left, leaving rightmost col for new data\n          for (IdxType wr = 0; wr < K; ++wr) {\n            for (IdxType wc = 0; wc < K-1; ++wc) {\n              win[m][wr][wc] = win[m][wr][wc+1];\n          } }\n\n          // window: fill top K-1 pixels of rightmost column from lbuf\n          for (IdxType wr = 0; wr < K-1; ++wr) {\n            C1InputType val = (c != S) ? lbuf[m][wr][c] : C1InputType(0);\n            win[m][wr][K-1] = val;\n          }\n\n          // window: fill bottom right with new input pixel\n          win[m][K-1][K-1] = pix;\n\n          // lbuf: shift up column c\n          if (c != S) {\n            for (IdxType lr = 0; lr < K-2; ++lr) {\n              lbuf[m][lr][c] = lbuf[m][lr+1][c];\n            }\n            lbuf[m][K-2][c] = pix;\n          }\n        } // m\n\n        // only perform the conv and store if legal position\n        if (r > 0 && c > 0) {\n          C1ConvType res = 0;\n          for (ap_uint<2> m = 0; m < M; ++m) {\n            for (ap_uint<2> wr = 0; wr < K; ++wr) {\n              for (ap_uint<2> wc = 0; wc < K; ++wc) {\n                const C1InputType& pix = win[m][wr][wc];\n                const Bit& b = wtbuf[m][8-(wr*K+wc)];\n                res += (b==0) ? pix : (C1InputType)(-pix);\n            } }\n          }\n\n          // perform normalization right here\n          outwords[(r-1)/2][((r-1)%2)*S + (c-1)] =\n            (res >= nc) ? Bit(0) : Bit(-1);\n        }\n\n      } // CONV_COLS\n    } // CONV_ROWS\n\n    // Here i is the word offset within the outwords buffer\n    LOOP_OUTPUT:\n    for (IdxType i = 0; i < OUTWORDS; ++i) {\n      Address img_idx = o_index+n;\n      Address bank_idx = img_idx % CONVOLVERS;\n      Address bank_off = img_idx / CONVOLVERS;\n      dmem[d_o_idx][bank_idx][bank_off*OUTWORDS + i] = outwords[i];\n    }\n  } // n\n}\n\nvoid bin_dense(\n    const Word wt_mem[CONVOLVERS][C_WT_WORDS],\n    const Word kh_mem[KH_WORDS],\n    Word dmem[2][CONVOLVERS][C_DMEM_WORDS],\n    ap_uint<2> layer_type,\n    ap_uint<1> d_i_idx,\n    ap_uint<1> d_o_idx,\n    const Address o_index,\n    const unsigned n_inputs,\n    const unsigned n_outputs\n) {\n  //assert(n_outputs % WORD_SIZE == 0);\n  assert(layer_type == LAYER_DENSE || n_outputs == 10);\n  assert(n_inputs/WORD_SIZE % CONVOLVERS == 0);\n\n  DenseSum sum_m[CONVOLVERS];\n  // for last layer\n  DenseNorm best_out = -1024;\n  ap_int<8> prediction = -1;\n\n  // read words from dmem and the wt store, dot them\n  // o is the output bit, i is the input bit\n  LOOP_DENSE_O:\n  for (Address o = 0; o < n_outputs; ++o) {\n  #pragma HLS loop_tripcount min=8 max=64\n    const Address o_addr = (o_index+o)/WORD_SIZE;\n    const ap_uint<6> o_offset = (o_index+o) % WORD_SIZE;\n    Word o_word = dmem[d_o_idx][o_addr%CONVOLVERS][o_addr/CONVOLVERS];\n\n    DenseSum sum = 0;\n\n    LOOP_DENSE_I:\n    for (Address i = 0; i < n_inputs; i+=CONVOLVERS*WORD_SIZE) {\n    #pragma HLS loop_tripcount min=8 max=64\n      const Address wt_addr = (o*n_inputs+i) / WORD_SIZE;\n\n      for (IdxType j = 0; j < CONVOLVERS; ++j) {\n        // in_wrd addr = [(i/WORD_SIZE+j) % CONVOLVERS][(i/WORD_SIZE+j) / CONVOLVERS]\n        // wt_wrd addr = [wt_addr % CONVOLVERS][wt_addr / CONVOLVERS]\n        const Word in_wrd = dmem[d_i_idx][j][i/WORD_SIZE/CONVOLVERS];\n        const Word wt_wrd = wt_mem[j][wt_addr / CONVOLVERS];\n\n        Word x = wt_wrd ^ in_wrd;\n\n        // count_set bit for 64 bits, returns 2*cnt\n        x -= (x >> 1) & m1;\n        x = (x & m2) + ((x >> 2) & m2);\n        x = (x + (x >> 4)) & m4;\n        x += x >> 8;\n        x += x >> 16;\n        x += x >> 32;\n        x = x & 0x7f;\n\n        sum_m[j] = WORD_SIZE - (DenseSum)(x<<1);\n      }\n\n      for (IdxType j = 0; j < CONVOLVERS; ++j)\n        sum += sum_m[j];\n    } // n_inputs\n\n    // not last layer -> biniarize,\n    // otherwise just store the value as a 64bit word\n    if (layer_type == LAYER_DENSE) {\n      Address kh_addr = o / KH_PER_WORD;\n      Word kh_word = kh_mem[kh_addr];\n\n      NormComp nc;\n      IdxType kh_off = o % KH_PER_WORD;\n      if (kh_off == 0)\n        nc(15,0) = kh_word(15, 0);\n      else if (kh_off == 1)\n        nc(15,0) = kh_word(31,16);\n      else if (kh_off == 2)\n        nc(15,0) = kh_word(47,32);\n      else\n        nc(15,0) = kh_word(63,48);\n\n      o_word[o_offset] = (sum >= nc) ? 0 : 1;\n    } else {\n      Address kh_addr = o / (const unsigned)2;\n      Word kh_word = kh_mem[kh_addr];\n\n      KType ki;  HType hi;\n      IdxType kh_off = o % 2;\n      if (kh_off == 0) {\n        ki(15,0) = kh_word(15, 0);\n        hi(15,0) = kh_word(31,16);\n      } else {\n        ki(15,0) = kh_word(47,32);\n        hi(15,0) = kh_word(63,48);\n      }\n\n      //printf (\" >> %d * %f + %f\\n\", sum.to_int(), ki.to_float(), hi.to_float());\n      ap_fixed<20,10> out = ap_fixed<20,10>(sum)*ki + hi;\n\n      if (o == 0 || out > best_out) {\n        prediction = o;\n        best_out = out;\n      }\n    }\n\n    dmem[d_o_idx][o_addr%CONVOLVERS][o_addr/CONVOLVERS] = o_word;\n  } // n_outputs\n\n  // Here we are using o_index as a bit index, not a word index!\n  if (layer_type == LAYER_LAST) {\n    Word o_word;\n    o_word(7,0) = prediction(7,0);\n    o_word(WORD_SIZE-1, 8) = 0;\n    dmem[d_o_idx][0][0] = o_word;\n  }\n}\n\n// -----------------------------------------------------------------------\n// Accelerator top module\n// -----------------------------------------------------------------------\nvoid top(\n    Word wt_i[WT_WORDS],\n    Word kh_i[KH_WORDS],\n    Word dmem_i[DMEM_WORDS],\n    Word dmem_o[DMEM_O_WORDS],\n    const Address    n_inputs,\n    const Address    n_outputs,\n    const Address    input_words,\n    const Address    output_words,\n    const ap_uint<3> layer_mode,  // [0]='new layer', [2:1]='conv1,conv,dense,last'\n    const ap_uint<1> dmem_mode,   // 0 means dmem[0] is input\n    const ap_uint<2> width_mode,  // 0=8'b, 1=16'b, 2=32'b\n    const ap_uint<2> norm_mode    // 0='do nothing', 1='do norm', 2='do pool'\n) {\n  DB_PRINT(2, \"==== Entering Accel ====\\n\");\n  const ap_uint<2> layer_type = layer_mode(2,1);\n  const unsigned width = 8 << width_mode;\n  DB_PRINT(1, \"  Inputs  = %d\\n\", n_inputs.to_int());\n  DB_PRINT(1, \"  Outputs = %d\\n\", n_outputs.to_int());\n  DB_PRINT(1, \"  i_words = %d\\n\", input_words.to_int());\n  DB_PRINT(1, \"  o_words = %d\\n\", output_words.to_int());\n  DB_PRINT(1, \"  Width = %d\\n\", width);\n  DB_PRINT(1, \"  layer_mode = %d %d\\n\", layer_mode[0]==0 ? 0 : 1, layer_type.to_int());\n  DB_PRINT(1, \"  dmem_mode = %d\\n\", dmem_mode.to_int());\n\n  assert(width <= MAX_WIDTH);\n  assert(n_inputs != 0);\n  if (layer_type <= LAYER_CONV) {\n    assert(input_words % CONVOLVERS == 0);\n    assert(n_inputs*width*width <= DMEM_WORDS*WORD_SIZE);\n    assert(n_inputs*WT_SIZE <= WT_WORDS*WORD_SIZE);\n  }\n\n  static Word dmem[2][CONVOLVERS][C_DMEM_WORDS];\n  static Word kh_mem[KH_WORDS];\n  static Word wt_mem[CONVOLVERS][C_WT_WORDS];\n  static Address kh_index = 0;\n  static Address o_index = 0;\n\n  if (layer_mode[0]) {\n    kh_index = 0;\n    o_index = 0;\n  } else {\n    kh_index = kh_index[0];\n  }\n\n  ap_uint<1> d_i_idx = dmem_mode;\n  ap_uint<1> d_o_idx = ~dmem_mode;\n\n  // Data input\n  const ap_uint<5> words_per_image = 1 << (2*width_mode);\n  Address img_idx = 0;  // i / words_per_image;\n  IdxType img_off = 0;  // i % words_per_image;\n  LOOP_DMEM_I: for (Address i = 0; i < input_words; ++i) {\n    if (layer_type == LAYER_CONV) {\n      Address bank_idx = img_idx % CONVOLVERS;\n      Address bank_off = img_idx / CONVOLVERS;\n      dmem[d_i_idx][bank_idx][(bank_off<<(2*width_mode)) + img_off] = dmem_i[i];\n    }\n    else if (layer_type == LAYER_CONV1)\n      dmem[d_i_idx][i/C_DMEM_WORDS][i%C_DMEM_WORDS] = dmem_i[i];\n    else\n      dmem[d_i_idx][i%CONVOLVERS][i/CONVOLVERS] = dmem_i[i];\n\n    if (++img_off == words_per_image) {\n      img_off = 0;\n      ++img_idx;\n    }\n  }\n\n  // Weight input, we must copy every 64-bit Word from the interface\n  // into the accelerator\n  LOOP_WT_I: for (Address i = 0; i < C_WT_WORDS*CONVOLVERS; ++i) {\n    wt_mem[i%CONVOLVERS][i/CONVOLVERS] = wt_i[i];\n  }\n  //printf (\"\\nAccel Weights:\\n\");\n  //print_params3d(wt_mem[0], 0, n_inputs*n_outputs);\n\n  LOOP_KH_I: for (ap_uint<16> i = 0; i < KH_WORDS; ++i)\n    kh_mem[i] = kh_i[i];\n\n  if (layer_type == LAYER_CONV1) {\n    assert(n_inputs == 3);\n\n    fp_conv(\n        wt_mem,\n        kh_mem,\n        dmem,\n        d_i_idx,\n        d_o_idx,\n        kh_index,\n        o_index,\n        n_outputs\n    );\n\n    kh_index += n_outputs;\n    o_index += n_outputs;\n  }\n  else if (layer_type == LAYER_CONV) {\n    assert(norm_mode != 2 || n_outputs % 4 == 0); // needed for pooling of 8x8 image\n    assert(n_inputs % CONVOLVERS == 0);\n\n    LOOP_IMG_BATCH:\n    for (IdxType i = 0; i < n_outputs; ++i) {\n      // Load the batch-norm parameters for this output\n      NormComp nc;\n      load_kh(nc, kh_mem, kh_index);\n\n      bin_conv(\n          wt_mem,\n          nc,\n          dmem,\n          d_i_idx, d_o_idx,\n          n_inputs,\n          o_index,\n          i == 0 ? 1 : 0,         // new_batch\n          width_mode,\n          norm_mode\n      );\n\n      kh_index++;\n      o_index++;\n    }\n  }\n  else {\n    bin_dense(\n        wt_mem,\n        kh_mem,\n        dmem,\n        layer_type,\n        d_i_idx, d_o_idx,\n        o_index,\n        n_inputs, n_outputs\n    );\n\n    o_index += n_outputs;\n  } // layer_type\n\n  // Data output\n  ap_uint<5> words_per_out = words_per_image / ((norm_mode!=2) ? 1 : 4);\n  img_idx = 0;\n  img_off = 0;\n  LOOP_DMEM_O: for (Address i = 0; i < output_words; ++i) {\n    // exclude conv6 (width==8, norm_mode==2) here because it writes\n    // the output fmaps linearly\n    if (layer_type <= LAYER_CONV && !(width_mode == 0 && norm_mode == 2)) {\n      Address bank_idx = img_idx % CONVOLVERS;\n      Address bank_off = img_idx / CONVOLVERS;\n      dmem_o[i] = dmem[d_o_idx][bank_idx][bank_off*words_per_out + img_off];\n    }\n    else\n      dmem_o[i] = dmem[d_o_idx][i%CONVOLVERS][i/CONVOLVERS];\n\n    if (++img_off == words_per_out) {\n      img_off = 0;\n      ++img_idx;\n    }\n  }\n}\n"
      },
      {
        "file_name": "Accel.h",
        "file_content": "#ifndef ACCEL_ACCEL_H\n#define ACCEL_ACCEL_H\n\n#include <cstddef>\n#include \"xf_utility.hpp\"\n#include \"xf_common.hpp\"\n#include <hls_stream.h>\n#include <stdlib.h>   // include this before sds_lib.h for size_t\n\n#include \"Typedefs.h\"\n#include \"Debug.h\"\n#include \"Common.h\"\n\n#ifdef __SDSCC__\n  #include \"sds_lib.h\"\n  #define MEM_ALLOC(size) sds_alloc(size)\n  #define MEM_FREE(ptr) sds_free(ptr)\n#else\n  #define MEM_ALLOC(size) malloc(size)\n  #define MEM_FREE(ptr) free(ptr)\n#endif\n\n//-------------------------------------------------------------------\n// Constants\n//-------------------------------------------------------------------\nconst unsigned CONVOLVERS = 2;\n\nconst unsigned WORD_SIZE = 64;\nconst unsigned WT_SIZE = 9;\nconst unsigned CONV_W_PER_WORD = 7;\nconst unsigned CONV1_W_PER_WORD = 4;\nconst unsigned KH_PER_WORD = 4;\nconst unsigned BYTE_SIZE = 8;\nconst unsigned K = 3;\nconst unsigned WT_L         = 16*4*512; // parameter to control wt mem size\nconst unsigned C_WT_WORDS   = ((WT_L+CONV_W_PER_WORD-1)/CONV_W_PER_WORD + CONVOLVERS-1) / CONVOLVERS;  // wt words per convolver\nconst unsigned WT_WORDS     = C_WT_WORDS*CONVOLVERS;\nconst unsigned KH_WORDS     = WT_L/128*16 / WORD_SIZE;\n\nconst unsigned DMEM_WORDS   = 128*32*32 / WORD_SIZE;\nconst unsigned C_DMEM_WORDS = DMEM_WORDS / CONVOLVERS;\nconst unsigned DMEM_O_WORDS = 512*4*4 / WORD_SIZE;\nconst unsigned DB_MEM_WORDS = 32*32;\n\nconst unsigned PIX_PER_PHASE = 2*32*32;\n\nconst unsigned MAX_WIDTH = WORD_SIZE;\nconst unsigned BANK_WIDTH = 8;\nconst unsigned LOG_BANK_WIDTH = 3;\n\nconst unsigned CONV_ROWS = 3;\nconst unsigned CONV_COLS = BANK_WIDTH+2;\nconst unsigned CONV_BANKS = WORD_SIZE / BANK_WIDTH;\n\n//-------------------------------------------------------------------\n// Typedefs\n//-------------------------------------------------------------------\nenum LayerTypeEnum {LAYER_CONV1, LAYER_CONV, LAYER_DENSE, LAYER_LAST};\n\ntypedef ap_int<WORD_SIZE> Word;\ntypedef ap_int<WT_SIZE> WtType;\ntypedef ap_uint<16> Address;\ntypedef ap_int<12> ConvSum;\ntypedef ap_int<5> ConvOut;\ntypedef ap_uint<10> IdxType;\ntypedef ap_fixed<16,4> C1Comp;\ntypedef ap_int<16> NormComp;\ntypedef ap_int<16> DenseSum;\ntypedef ap_fixed<16,12> DenseNorm;\n\ntypedef ap_fixed<20,2, AP_RND> C1InputType;\ntypedef ap_fixed<24,6, AP_RND> C1ConvType;\n\n\n//-------------------------------------------------------------------\n// Template functions\n//-------------------------------------------------------------------\ntemplate<typename T>\nvoid load_kh(T& comp, const Word kh_mem[KH_WORDS], Address idx) {\n  Word kh_word = kh_mem[idx/KH_PER_WORD];\n  IdxType off = idx % KH_PER_WORD;\n  if (off == 0)\n    comp(15,0) = kh_word(15, 0);\n  else if (off == 1)\n    comp(15,0) = kh_word(31,16);\n  else if (off == 2)\n    comp(15,0) = kh_word(47,32);\n  else\n    comp(15,0) = kh_word(63,48);\n}\n\n//-------------------------------------------------------------------\n// Accelerator synthesizable top-level function\n//-------------------------------------------------------------------\n#pragma SDS data copy(dmem_i[0:input_words], dmem_o[0:output_words])\n#pragma SDS data access_pattern(dmem_i:SEQUENTIAL, dmem_o:SEQUENTIAL)\n#pragma SDS data access_pattern(wt_i:SEQUENTIAL, kh_i:SEQUENTIAL)\n#pragma SDS data mem_attribute(dmem_i:PHYSICAL_CONTIGUOUS, dmem_o:PHYSICAL_CONTIGUOUS)\n#pragma SDS data mem_attribute(wt_i:PHYSICAL_CONTIGUOUS, kh_i:PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(dmem_i:AXIDMA_SIMPLE, dmem_o:AXIDMA_SIMPLE)\n#pragma SDS data data_mover(wt_i:AXIDMA_SIMPLE, kh_i:AXIDMA_SIMPLE)\nvoid top(\n    Word wt_i[WT_WORDS],\n    Word kh_i[KH_WORDS],\n    Word dmem_i[DMEM_WORDS],\n    Word dmem_o[DMEM_O_WORDS],\n    const Address    n_inputs,\n    const Address    n_outputs,\n    const Address    input_words,\n    const Address    output_words,\n    const ap_uint<3> layer_mode,  // [0]='new layer', [2:1]='conv1,conv,dense'\n    const ap_uint<1> dmem_mode,   // 0 means dmem[0] is input\n    const ap_uint<2> width_mode,  // 0=8'b, 1=16'b, 2=32'b\n    const ap_uint<2> norm_mode    // 0='do nothing', 1='do norm', 2='do pool'\n);\n\n#endif\n"
      },
      {
        "file_name": "xf_types.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_TYPES_H_\n#define _XF_TYPES_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n#include \"xf_params.hpp\"\n#include <stdint.h>\n\ntemplate <int N>\nstruct floatn {\n    float f[N];\n    float& operator[](int idx) { return f[idx]; }\n    const float& operator[](int idx) const { return f[idx]; }\n};\ntypedef floatn<3> float3;\n\ntemplate <int T>\nstruct StreamType {};\ntemplate <>\nstruct StreamType<XF_2UW> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct StreamType<XF_8UW> {\n    typedef ap_uint<8> name;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct StreamType<XF_9UW> {\n    typedef ap_uint<9> name;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct StreamType<XF_10UW> {\n    typedef ap_uint<10> name;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct StreamType<XF_12UW> {\n    typedef ap_uint<12> name;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct StreamType<XF_14UW> {\n    typedef ap_uint<14> name;\n    static const int bitdepth = 14;\n};\ntemplate <>\nstruct StreamType<XF_16UW> {\n    typedef ap_uint<16> name;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct StreamType<XF_19SW> {\n    typedef ap_int<19> name;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct StreamType<XF_20UW> {\n    typedef ap_uint<20> name;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct StreamType<XF_22UW> {\n    typedef ap_uint<22> name;\n    static const int bitdepth = 22;\n};\ntemplate <>\nstruct StreamType<XF_24UW> {\n    typedef ap_uint<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_24SW> {\n    typedef ap_int<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_28UW> {\n    typedef ap_uint<28> name;\n    static const int bitdepth = 28;\n};\ntemplate <>\nstruct StreamType<XF_30UW> {\n    typedef ap_uint<30> name;\n    static const int bitdepth = 30;\n};\ntemplate <>\nstruct StreamType<XF_32UW> {\n    typedef ap_uint<32> name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_32FW> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_96FW> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_192FW> {\n    typedef floatn<6> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_384FW> {\n    typedef floatn<12> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_768FW> {\n    typedef floatn<24> name;\n    static const int bitdepth = 768;\n};\ntemplate <>\nstruct StreamType<XF_1536FW> {\n    typedef floatn<48> name;\n    static const int bitdepth = 1536;\n};\ntemplate <>\nstruct StreamType<XF_35SW> {\n    typedef ap_int<35> name;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct StreamType<XF_36UW> {\n    typedef ap_uint<36> name;\n    static const int bitdepth = 36;\n};\ntemplate <>\nstruct StreamType<XF_40UW> {\n    typedef ap_uint<40> name;\n    static const int bitdepth = 40;\n};\ntemplate <>\nstruct StreamType<XF_42UW> {\n    typedef ap_uint<42> name;\n    static const int bitdepth = 42;\n};\ntemplate <>\nstruct StreamType<XF_48UW> {\n    typedef ap_uint<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_48SW> {\n    typedef ap_int<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_56UW> {\n    typedef ap_uint<56> name;\n    static const int bitdepth = 56;\n};\ntemplate <>\nstruct StreamType<XF_60UW> {\n    typedef ap_uint<60> name;\n    static const int bitdepth = 60;\n};\ntemplate <>\nstruct StreamType<XF_64UW> {\n    typedef ap_uint<64> name;\n    static const int bitdepth = 64;\n};\ntemplate <>\nstruct StreamType<XF_72UW> {\n    typedef ap_uint<72> name;\n    static const int bitdepth = 72;\n};\ntemplate <>\nstruct StreamType<XF_80UW> {\n    typedef ap_uint<80> name;\n    static const int bitdepth = 80;\n};\ntemplate <>\nstruct StreamType<XF_84UW> {\n    typedef ap_uint<84> name;\n    static const int bitdepth = 84;\n};\ntemplate <>\nstruct StreamType<XF_96UW> {\n    typedef ap_uint<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_96SW> {\n    typedef ap_int<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_112UW> {\n    typedef ap_uint<112> name;\n    static const int bitdepth = 112;\n};\ntemplate <>\nstruct StreamType<XF_120UW> {\n    typedef ap_uint<120> name;\n    static const int bitdepth = 120;\n};\ntemplate <>\nstruct StreamType<XF_128UW> {\n    typedef ap_uint<128> name;\n    static const int bitdepth = 128;\n};\ntemplate <>\nstruct StreamType<XF_144UW> {\n    typedef ap_uint<144> name;\n    static const int bitdepth = 144;\n};\ntemplate <>\nstruct StreamType<XF_152SW> {\n    typedef ap_int<152> name;\n    static const int bitdepth = 152;\n};\ntemplate <>\nstruct StreamType<XF_160UW> {\n    typedef ap_uint<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_160SW> {\n    typedef ap_int<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_168UW> {\n    typedef ap_int<168> name;\n    static const int bitdepth = 168;\n};\ntemplate <>\nstruct StreamType<XF_176UW> {\n    typedef ap_uint<176> name;\n    static const int bitdepth = 176;\n};\ntemplate <>\nstruct StreamType<XF_192UW> {\n    typedef ap_uint<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_192SW> {\n    typedef ap_int<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_256UW> {\n    typedef ap_uint<256> name;\n    static const int bitdepth = 256;\n};\ntemplate <>\nstruct StreamType<XF_280SW> {\n    typedef ap_int<280> name;\n    static const int bitdepth = 280;\n};\ntemplate <>\nstruct StreamType<XF_288UW> {\n    typedef ap_uint<288> name;\n    static const int bitdepth = 288;\n};\ntemplate <>\nstruct StreamType<XF_304SW> {\n    typedef ap_int<304> name;\n    static const int bitdepth = 304;\n};\ntemplate <>\nstruct StreamType<XF_320UW> {\n    typedef ap_int<320> name;\n    static const int bitdepth = 320;\n};\ntemplate <>\nstruct StreamType<XF_336UW> {\n    typedef ap_int<336> name;\n    static const int bitdepth = 336;\n};\ntemplate <>\nstruct StreamType<XF_352UW> {\n    typedef ap_uint<352> name;\n    static const int bitdepth = 352;\n};\ntemplate <>\nstruct StreamType<XF_384UW> {\n    typedef ap_uint<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_384SW> {\n    typedef ap_int<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_512UW> {\n    typedef ap_uint<512> name;\n    static const int bitdepth = 512;\n};\ntemplate <>\nstruct StreamType<XF_560SW> {\n    typedef ap_int<560> name;\n    static const int bitdepth = 560;\n};\ntemplate <>\nstruct StreamType<XF_576UW> {\n    typedef ap_uint<576> name;\n    static const int bitdepth = 576;\n};\n\ntemplate <int T>\nstruct PixelType {};\ntemplate <>\nstruct PixelType<XF_8UP> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef unsigned char name2;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_8SP> {\n    typedef ap_int<8> name;\n    typedef ap_uint<8> uname;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_9UP> {\n    typedef ap_uint<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_9SP> {\n    typedef ap_int<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_16UP> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_16SP> {\n    typedef ap_int<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_32UP> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_32SP> {\n    typedef ap_int<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_19SP> {\n    typedef ap_int<19> name;\n    typedef ap_uint<19> uname;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct PixelType<XF_35SP> {\n    typedef ap_int<35> name;\n    typedef ap_uint<35> uname;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct PixelType<XF_32FP> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_96FP> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct PixelType<XF_24SP> {\n    typedef ap_int<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct PixelType<XF_20SP> {\n    typedef ap_int<20> name;\n    typedef ap_uint<20> uname;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct PixelType<XF_48SP> {\n    typedef ap_int<48> name;\n    typedef ap_uint<48> uname;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct PixelType<XF_2UP> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct PixelType<XF_24UP> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\n\ntemplate <>\nstruct PixelType<XF_10UP> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct PixelType<XF_12UP> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct PixelType<XF_14UP> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    static const int bitdepth = 14;\n};\n#define XF_NPIXPERCYCLE(flags) xfNPixelsPerCycle<flags>::nppc\n\n#define XF_BITSHIFT(flags) xfNPixelsPerCycle<flags>::datashift\n\ntemplate <int T>\nstruct xfNPixelsPerCycle {};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC1> {\n    static const int datashift = 0;\n    static const int nppc = 1;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC2> {\n    static const int datashift = 1;\n    static const int nppc = 2;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC4> {\n    static const int datashift = 2;\n    static const int nppc = 4;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC8> {\n    static const int datashift = 3;\n    static const int nppc = 8;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC16> {\n    static const int datashift = 4;\n    static const int nppc = 16;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC32> {\n    static const int datashift = 5;\n    static const int nppc = 32;\n};\n\ntemplate <int T, int M>\nstruct DataType {};\n\n// One channel data types\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC1> {\n    typedef ap_uint<2> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_2UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC32> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC4> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC8> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC1> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned char wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC2> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC4> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC8> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC16> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC32> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC64> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC1> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_10UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC2> {\n    typedef ap_uint<20> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_20UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC4> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC8> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC16> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC1> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_12UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC2> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC4> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC8> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC16> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC1> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_14UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC2> {\n    typedef ap_uint<28> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_28UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC4> {\n    typedef ap_uint<56> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_56UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC8> {\n    typedef ap_uint<112> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_112UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_64UC1, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<64> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 64;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_32FW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC1> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<3> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_96FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC2> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<6> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_192FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC4> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<12> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_384FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC8> {\n    typedef ap_uint<768> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<24> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_768FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC16> {\n    typedef ap_uint<1536> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<48> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_1536FW;\n    static const int channel = 3;\n};\n\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\n// Two channels data types\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 2;\n};\n\n// template<> struct DataType <XF_10UC2, XF_NPPC1>   { typedef ap_uint<40>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; typedef unsigned  short int sname; typedef unsigned long long int wname; static const int\n// bitdepth = 10; static const int pixeldepth = XF_40UP;static const int wordwidth = XF_40UW; static const int channel =\n// 4;}; template<> struct DataType <XF_10UC2, XF_NPPC2>   { typedef ap_uint<80>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; static const int bitdepth = 10; static const int pixeldepth = XF_40UP;static const int\n// wordwidth = XF_80UW; static const int channel = 4;};\n\n// Three channels data types (TODO: Pixeldepth of XF_16U3 needs correction)\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC16> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC1> {\n    typedef ap_uint<30> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_30UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC2> {\n    typedef ap_uint<60> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_60UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC4> {\n    typedef ap_uint<120> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_120UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC8> {\n    typedef ap_uint<240> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_240UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC1> {\n    typedef ap_uint<36> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_36UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC2> {\n    typedef ap_uint<72> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_72UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC4> {\n    typedef ap_uint<144> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_144UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC8> {\n    typedef ap_uint<288> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_288UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC1> {\n    typedef ap_uint<42> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_42UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC2> {\n    typedef ap_uint<84> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_84UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC4> {\n    typedef ap_uint<168> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_168UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC8> {\n    typedef ap_uint<336> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_336UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_48SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_96SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_192SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_384SW;\n    static const int channel = 3;\n};\n// Four channels data types\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC1> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC2> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC4> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC8> {\n    typedef ap_uint<320> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_320UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC2> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC4> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC8> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\n\n#define TC(TYPE) TC##TYPE\n\n#define XF_TNAME(flags, npc) typename DataType<flags, npc>::name\n\n#define XF_DTUNAME(flags, npc) typename DataType<flags, npc>::uname\n\n#define XF_CTUNAME(flags, npc) typename DataType<flags, npc>::cname\n\n#define XF_PTSNAME(flags, npc) typename DataType<flags, npc>::sname\n\n#define XF_WTNAME(flags, npc) typename DataType<flags, npc>::wname\n\n#define XF_DTPIXELDEPTH(flags, npc) DataType<flags, npc>::bitdepth\n\n#define XF_DEPTH(flags, npc) DataType<flags, npc>::pixeldepth\n\n#define XF_WORDWIDTH(flags, npc) DataType<flags, npc>::wordwidth\n\n#define XF_CHANNELS(flags, npc) DataType<flags, npc>::channel\n\n#define XF_PIXELWIDTH(flags, npc) DataType<flags, npc>::pixelwidth\n\n#define XF_PTNAME(flags) typename PixelType<flags>::name\n\n#define XF_PIXELDEPTH(flags) PixelType<flags>::bitdepth\n\n#define XF_PTUNAME(flags) typename PixelType<flags>::uname\n\n#define XF_PTNAME2(flags) typename PixelType<flags>::name2\n\n#define XF_SNAME(flags) typename StreamType<flags>::name\n#define XF_WORDDEPTH(flags) StreamType<flags>::bitdepth\n\n#define XF_NAME(flags, npc) ap_uint<(XF_DTPIXELDEPTH(flags, npc) / XF_CHANNELS(flags, npc)) * XF_NPIXPERCYCLE(npc)>\n\n// find image width in terms of the number of words used to represent the data\n//#define IM_WIDTH(W,S) ((W)>>(S))\n\n// Xilinx headers\n#include <ap_int.h>\n#include <ap_fixed.h>\n#include <stdint.h>\n// Native types\n// typedef unsigned long     uint64_t;\ntypedef unsigned int uint32_t;\ntypedef unsigned short uint16_t;\n// typedef long int        int64_t;\ntypedef int int32_t;\ntypedef short int int16_t;\ntypedef unsigned char uchar_t;\ntypedef unsigned char uint8_t;\ntypedef signed char int8_t;\n\n// Arbitrary Precision integer types\ntypedef ap_uint<1> ap_uint1_t;\ntypedef ap_uint<2> ap_uint2_t;\ntypedef ap_uint<4> ap_uint4_t;\ntypedef ap_uint<5> ap_uint5_t;\ntypedef ap_uint<8> ap_uint8_t;\ntypedef ap_uint<9> ap_uint9_t;\ntypedef ap_uint<16> ap_uint16_t;\ntypedef ap_uint<17> ap_uint17_t;\ntypedef ap_uint<18> ap_uint18_t;\ntypedef ap_uint<20> ap_uint20_t;\ntypedef ap_uint<22> ap_uint22_t;\ntypedef ap_uint<23> ap_uint23_t;\ntypedef ap_uint<24> ap_uint24_t;\ntypedef ap_uint<32> ap_uint32_t;\ntypedef ap_uint<33> ap_uint33_t;\ntypedef ap_uint<34> ap_uint34_t;\ntypedef ap_uint<35> ap_uint35_t;\ntypedef ap_uint<38> ap_uint38_t;\ntypedef ap_uint<45> ap_uint45_t;\ntypedef ap_uint<48> ap_uint48_t;\ntypedef ap_uint<51> ap_uint51_t;\ntypedef ap_uint<64> ap_uint64_t;\ntypedef ap_uint<66> ap_uint66_t;\ntypedef ap_uint<72> ap_uint72_t;\ntypedef ap_uint<97> ap_uint97_t;\ntypedef ap_uint<101> ap_uint101_t;\ntypedef ap_uint<128> ap_uint128_t;\ntypedef ap_uint<144> ap_uint144_t;\ntypedef ap_uint<176> ap_uint176_t;\ntypedef ap_uint<192> ap_uint192_t;\ntypedef ap_uint<256> ap_uint256_t;\ntypedef ap_uint<352> ap_uint352_t;\ntypedef ap_uint<384> ap_uint384_t;\ntypedef ap_uint<512> ap_uint512_t;\ntypedef ap_uint<576> ap_uint576_t;\n\ntypedef ap_int<8> ap_int8_t;\ntypedef ap_int<9> ap_int9_t;\ntypedef ap_int<12> ap_int12_t;\ntypedef ap_int<15> ap_int15_t;\ntypedef ap_int<16> ap_int16_t;\ntypedef ap_int<18> ap_int18_t;\ntypedef ap_int<19> ap_int19_t;\ntypedef ap_int<20> ap_int20_t;\ntypedef ap_int<24> ap_int24_t;\ntypedef ap_int<32> ap_int32_t;\ntypedef ap_int<35> ap_int35_t;\ntypedef ap_int<36> ap_int36_t;\ntypedef ap_int<42> ap_int42_t;\ntypedef ap_int<48> ap_int48_t;\ntypedef ap_int<64> ap_int64_t;\ntypedef ap_int<152> ap_int152_t;\ntypedef ap_int<304> ap_int304_t;\ntypedef ap_int<280> ap_int280_t;\ntypedef ap_int<560> ap_int560_t;\n\n// Arbitrary Precision fixed-point types\ntypedef ap_ufixed<12, 12> uint12_q0;\ntypedef ap_ufixed<16, 16> uint16_q0; // 16-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<32, 32> uint32_q0; // 32-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<8, 8> uint8_q0;    // 8-bit unsigned with 0 fractional bits\n\n#endif //_XF_TYPES_H_\n"
      },
      {
        "file_name": "Typedefs.h",
        "file_content": "#ifndef TYPEDEFS_H\n#define TYPEDEFS_H\n\n#include <ap_int.h>\n\n//#define USE_FLOAT\n\n#ifdef USE_FLOAT\n\n  typedef float InputFixed;\n\n  // Types for weights\n  typedef ap_int<1> Bit;\n  typedef ap_int<2> TwoBit;\n\n  typedef float KType;\n  typedef float HType;\n\n  typedef float NormOutput;\n  typedef ap_int<14> ConvOutput;\n\n#else\n\n  // Quantized 32-bit input images in the range [-1,1]\n  typedef ap_fixed<32,2, AP_RND> InputFixed;\n\n  // Types for weights\n  typedef ap_int<1> Bit;\n  typedef ap_int<2> TwoBit;\n\n  typedef ap_fixed<16,2> KType;\n  typedef ap_fixed<16,4> HType;\n\n  typedef ap_fixed<16,5> NormOutput;\n  typedef ap_int<14> ConvOutput;\n\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xf_utility.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_UTILITY_H_\n#define _XF_UTILITY_H_\n\n#include \"ap_axi_sdata.h\"\n#include \"xf_common.hpp\"\n#include \"xf_video_mem.hpp\"\n#include <assert.h>\n#include <string.h>\n\nnamespace xf {\nnamespace cv {\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid Ptr2xfMat(ap_uint<BUS_WIDTH>* in_ptr, xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_mat.write(i, (XF_TNAME(TYPE, NPPC))in_ptr[i]);\n    }\n\n} // End of Ptr2xfMat()\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xfMat2Ptr(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat, ap_uint<BUS_WIDTH>* out_ptr) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_ptr[i] = in_mat.read(i);\n    }\n\n} // End of xfMat2Ptr()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                           ap_uint<BUS_WIDTH>* out_ptr,\n                           xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat.write(i, tmp);\n    }\n\n} // End of xFDuplicateMat_PTRMAT()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR and 2 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_1 = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_2 = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT2(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_1>& out_mat1,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_2>& out_mat2) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat1.write(i, tmp);\n        out_mat2.write(i, tmp);\n        // out_mat2.write(i, (XF_TNAME(XF_16SC1, NPPC))tmp); // TODO: Remove me as I am for experiment\n    }\n\n} // End of xFDuplicateMat_PTRMAT2()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR, 1 for xf::cv::Mat and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_MAT_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                                ap_uint<BUS_WIDTH>* out_ptr,\n                                xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat,\n                                hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n        out_mat.write(i, tmp);\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_MAT_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to stream out xf::cv::Mat on AXI bus for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFMat2AXI_Strm(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                    hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n\n        v.data = in_mat.read(i);\n        out_axi.write(v);\n    }\n\n} // End of xFMat2AXI_Strm()\n// ======================================================================================\n\n// ======================================================================================\n// Function to read AXI stream into xf::cv::Mat for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid AXI_Strm2xFMat(hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& in_axi,\n                    xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v = in_axi.read();\n\n        out_mat.write(i, v.data);\n    }\n\n} // End of AXI_Strm2xFMat()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to set border in the extracted kernel sized block\n// ======================================================================================\ntemplate <int K_ROWS, int K_COLS, typename SRC_T, int BORDER_T>\nvoid xFSetBorder(xf::cv::Window<K_ROWS, K_COLS, SRC_T>& src_blk,\n                 uint16_t _row,\n                 uint16_t _col,\n                 uint16_t _src_rows,\n                 uint16_t _src_cols) {\n#pragma HLS INLINE OFF\n\n    uint16_t blk_t_idx, blk_b_idx;\n    uint16_t blk_l_idx, blk_r_idx;\n\n    blk_t_idx = (K_ROWS - _row - 1);\n    blk_b_idx = (K_ROWS - (_row - _src_rows + 1) - 1);\n\n    blk_l_idx = (K_COLS - _col - 1);\n    blk_r_idx = (K_COLS - (_col - _src_cols + 1) - 1);\n\n    for (uint16_t r = 0; r < K_ROWS; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n        for (uint16_t c = 0; c < K_COLS; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n\n            bool top_border = ((r < blk_t_idx) && (_row < K_ROWS - 1)) ? true : false;\n            bool bottom_border = ((r > blk_b_idx) && (_row >= _src_rows)) ? true : false;\n            bool left_border = ((c < blk_l_idx) && (_col < K_COLS - 1)) ? true : false;\n            bool right_border = ((c > blk_r_idx) && (_col >= _src_cols)) ? true : false;\n\n            uint16_t r_idx = r, c_idx = c;\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                r_idx = top_border ? blk_t_idx : bottom_border ? blk_b_idx : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                r_idx = top_border ? (2 * blk_t_idx - r) : bottom_border ? (2 * blk_b_idx - r) : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                r_idx = top_border ? (2 * blk_t_idx - r - 1) : bottom_border ? (2 * blk_b_idx - r + 1) : r;\n\n            } else { // TODO: Need to add other modes support\n                r_idx = r;\n            }\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                c_idx = left_border ? blk_l_idx : right_border ? blk_r_idx : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                c_idx = left_border ? (2 * blk_l_idx - c) : right_border ? (2 * blk_r_idx - c) : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                c_idx = left_border ? (2 * blk_l_idx - c - 1) : right_border ? (2 * blk_r_idx - c + 1) : c;\n\n            } else { // TODO: Need to add other modes support\n                c_idx = c;\n            }\n\n            if ((top_border | bottom_border | left_border | right_border) && (BORDER_T == XF_BORDER_CONSTANT)) {\n                src_blk.val[r][c] = 0;\n            } else {\n                src_blk.val[r][c] = src_blk.val[r_idx][c_idx];\n            }\n        }\n    }\n\n} // End of xFSetBorder()\n// ======================================================================================\n\n/**\n * Extract Pixels from a packed word into an array from the index pos.\n * The number of pixels to be extracted is determined by the NPC.\n */\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfPackPixels(\n    XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val, uint16_t pos, int16_t loopIter, uint16_t& shift) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<8> STEP = XF_PIXELDEPTH(PIXELDEPTH);\n\n    for (ap_int<9> i = 0; i < loopIter; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        XF_PTUNAME(PIXELDEPTH) tmp = tmp_buf[pos];\n        val = val | (((XF_SNAME(WORDWIDTH))tmp) << (shift * STEP));\n        pos++;\n        shift++;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfExtractPixels(XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val1, int pos) {\n// clang-format off\n    #pragma HLS inline off\n    // clang-format on\n    XF_SNAME(WORDWIDTH) v = val1;\n\n    int shift = 0;\n    int STEP = XF_PIXELDEPTH(PIXELDEPTH);\nExtract_pixels_loop:\n    for (int i = 0; i < (1 << (XF_BITSHIFT(NPC))); i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        tmp_buf[pos + i] = v.range(shift + STEP - 1, shift);\n        shift = shift + STEP;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH_SRC, int DEPTH_SRC>\nvoid xfExtractData(XF_PTNAME(DEPTH_SRC) * src_buf1,\n                   XF_PTNAME(DEPTH_SRC) * src_buf2,\n                   XF_PTNAME(DEPTH_SRC) * src_buf3,\n                   XF_PTNAME(DEPTH_SRC) * src_buf4,\n                   XF_PTNAME(DEPTH_SRC) * src_buf5,\n                   XF_PTNAME(DEPTH_SRC) * src_buf6,\n                   XF_PTNAME(DEPTH_SRC) * src_buf7,\n                   XF_SNAME(WORDWIDTH_SRC) buf0,\n                   XF_SNAME(WORDWIDTH_SRC) buf1,\n                   XF_SNAME(WORDWIDTH_SRC) buf2,\n                   XF_SNAME(WORDWIDTH_SRC) buf3,\n                   XF_SNAME(WORDWIDTH_SRC) buf4,\n                   XF_SNAME(WORDWIDTH_SRC) buf5,\n                   XF_SNAME(WORDWIDTH_SRC) buf6) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf1[6], buf0, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf2[6], buf1, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf3[6], buf2, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf4[6], buf3, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf5[6], buf4, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf6[6], buf5, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf7[6], buf6, 0);\n}\n\ntemplate <int NPC, int DEPTH_SRC>\nvoid xfCopyData(XF_PTNAME(DEPTH_SRC) src_buf1[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf2[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf3[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf4[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf5[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf6[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf7[XF_NPIXPERCYCLE(NPC) + 6]) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<5> buf_size = (XF_NPIXPERCYCLE(NPC) + 6);\n    ap_uint<4> i = 0;\n    ap_uint<4> ind = buf_size - 6;\n\n    for (i = 0; i < 6; i++, ind++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=6 max=6\n#pragma HLS unroll factor=1\n        // clang-format on\n        src_buf1[i] = src_buf1[ind];\n        src_buf2[i] = src_buf2[ind];\n        src_buf3[i] = src_buf3[ind];\n        src_buf4[i] = src_buf4[ind];\n        src_buf5[i] = src_buf5[ind];\n        src_buf6[i] = src_buf6[ind];\n        src_buf7[i] = src_buf7[ind];\n    }\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut1(XF_SNAME(WORDWIDTH) * _src, unsigned long long int* _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, SIZE);\n#else\n    if (nbytes) memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn1(unsigned long long int* _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((AU_TNAME(WORDWIDTH)*)_dst, (AU_TNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\ntemplate <int WORDWIDTH, int NPC, int IN_BH, int IN_BW>\nvoid xFDuplicateStream(hls::stream<XF_SNAME(WORDWIDTH)>& in_strm,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm1,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm2,\n                       int imwidth,\n                       int imheight) {\n    for (int i = 0; i < imheight; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=IN_BH max=IN_BH\n        #pragma HLS LOOP_FLATTEN off\n        // clang-format on\n        for (int j = 0; j < (imwidth >> NPC); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS pipeline\n            #pragma HLS LOOP_TRIPCOUNT min=IN_BW max=IN_BW\n            // clang-format on\n            XF_SNAME(WORDWIDTH) tmp = in_strm.read();\n            out_strm1.write(tmp);\n            out_strm2.write(tmp);\n        }\n    }\n}\n\n// ==============================================================================\n// Class contains funcitons requried for accel file (top wrapper file)\n// ==============================================================================\nclass accel_utils {\n   public:\n    // ==============================================================================\n    // Read module(s) to handle data transfer from AXI/HLS stream to xfMat\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void Array2hlsStrm(ap_uint<PTR_WIDTH>* srcPtr, hls::stream<ap_uint<PTR_WIDTH> >& dstStrm, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstStrm.write(srcPtr[i]);\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void hlsStrm2xfMat(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat,\n                       int dstMat_cols_align_npc) {\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int loop_count = (rows * dstMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = dstMat_cols_align_npc - cols;\n        int in_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * dstMat_cols_align_npc; // channels\n        int ddr_read_cycles = (((in_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_read_cnt = 0;\n\n        int valid_bits = 0;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        int K_size;\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) out;\n        int ncpr = dstMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n        int strm_cnt_disply = 0;\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            int valid_bits_update;\n            int valid_bits_tmp = valid_bits - K_size;\n            XF_TNAME(MAT_T, NPC) out = 0;\n\n            if (valid_bits < K_size) {\n                if (valid_bits != 0) {\n                    out.range(valid_bits - 1, 0) = r.range(PTR_WIDTH - 1, PTR_WIDTH - valid_bits);\n                }\n                if (ddr_read_cnt < ddr_read_cycles) {\n                    r = srcStrm.read();\n                    ddr_read_cnt++;\n                } else {\n                    r = 0;\n                }\n                out.range(K_size - 1, valid_bits) = r.range(K_size - valid_bits - 1, 0);\n                valid_bits = PTR_WIDTH_min_Ksize + valid_bits;\n            } else {\n                out = r.range(PTR_WIDTH_plus_Ksize - valid_bits - 1, PTR_WIDTH - valid_bits);\n                valid_bits = valid_bits - K_size;\n            }\n\n            dstMat.write(i, out);\n        }\n        int stop = 0;\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\n    void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                     xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        Array2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH>(strm, dstMat,\n                                                                                         dstMat_cols_align_npc);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void axiStrm2hlsStrm(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                         hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = srcPtr.read();\n            dstStrm.write(v.data);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        axiStrm2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH_OUT>(strm, dstMat,\n                                                                                             dstMat_cols_align_npc);\n    }\n\n    // ==============================================================================\n    // Write module(s) to handle data transfer from xfMat to AXI/HLS stream\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void xfMat2hlsStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& srcMat,\n                       hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                       int srcMat_cols_align_npc) {\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int loop_count = (rows * srcMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = srcMat_cols_align_npc - cols;\n        int out_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * srcMat_cols_align_npc; // channels\n        int ddr_write_cycles = (((out_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_write_cnt = 0;\n\n        int bits_to_add = PTR_WIDTH;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) in;\n        int ncpr = srcMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            int K_size;\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            in = srcMat.read(i);\n\n            if (bits_to_add <= K_size) {\n                r.range(PTR_WIDTH - 1, PTR_WIDTH - bits_to_add) = in.range(bits_to_add - 1, 0);\n                dstStrm.write(r);\n\n                if (bits_to_add != K_size) {\n                    r.range(K_size - bits_to_add - 1, 0) = in.range(K_size - 1, bits_to_add);\n                }\n                bits_to_add = PTR_WIDTH_min_Ksize + bits_to_add;\n            } else {\n                r.range(PTR_WIDTH_plus_Ksize - bits_to_add - 1, PTR_WIDTH - bits_to_add) = in;\n                bits_to_add -= K_size;\n            }\n        }\n\n        if (bits_to_add != PTR_WIDTH) {\n            dstStrm.write(r);\n        }\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2Array(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstPtr[i] = srcStrm.read();\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int XFCVDEPTH = _XFCVDEPTH_DEFAULT,\n              int FILLZERO = 1>\n    void xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                     ap_uint<PTR_WIDTH>* dstPtr,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2Array<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2axiStrm(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                         hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = srcStrm.read();\n            dstPtr.write(v);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\n    void xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_IN>& srcMat,\n                       hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH_IN>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2axiStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT, int FILLZERO = 1>\nvoid xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat, ap_uint<PTR_WIDTH>* dstPtr, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n    accel_utils au;\n    au.xfMat2Array<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcMat, dstPtr);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n    accel_utils au;\n    au.Array2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcPtr, dstMat);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                   hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n    accel_utils au;\n    au.xfMat2axiStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>(srcMat, dstPtr);\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                   xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n    accel_utils au;\n    au.axiStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>(srcPtr, dstMat);\n}\n\n} // namespace cv\n} // namespace xf\n\n#endif //_XF_UTILITY_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "AccelPrint.h",
        "file_content": "#ifndef ACCEL_PRINT_H\n#define ACCEL_PRINT_H\n\n#include \"Accel.h\"\n#include <stdio.h>\n\n//------------------------------------------------------------------------\n// For an array of ap_int's, sets/gets the bit at bit_idx\n// calculated from the start of the array to val\n//------------------------------------------------------------------------\ntemplate<typename T>\ninline void set_bit(T array[], unsigned bit_idx, Bit val) {\n  unsigned W = array[0].length();\n  Address idx = bit_idx / W;\n  Address offset = bit_idx % W;\n  array[idx][offset] = val;\n}\n\ntemplate<typename T>\ninline Bit get_bit(T array[], unsigned bit_idx) {\n  unsigned W = array[0].length();\n  Address idx = bit_idx / W;\n  Address offset = bit_idx % W;\n  Bit result = array[idx][offset];\n  return result;\n}\n\n//------------------------------------------------------------------------\n// Printing matrices and bit arrays\n//------------------------------------------------------------------------\ntemplate<typename T>\nvoid print_mat(T in[], unsigned S, unsigned R, unsigned C) {\n  R = (R >= S) ? S : R;\n  C = (C >= S) ? S : C;\n  for (unsigned r = 0; r < R; ++r) {\n    for (unsigned c = 0; c < C; ++c)\n      std::cout << std::setw(4) << in[r*S+c] << \" \";\n    printf (\"\\n\");\n  }\n}\n\ntemplate<typename T>\nvoid print_mat3d(T in[], unsigned M, unsigned num, unsigned S, unsigned R, unsigned C) {\n  for (unsigned m = M; m < M+num; ++m) {\n    print_mat(in+m*S*S, S, R, C);\n    printf (\"--%u--\\n\", m+1);\n  }\n}\n\ntemplate<typename T>\nvoid print_bits(T in[], unsigned bit_offset, unsigned S, unsigned R, unsigned C) {\n  R = (R >= S) ? S : R;\n  C = (C >= S) ? S : C;\n  for (unsigned r = 0; r < R; ++r) {\n    for (unsigned c = 0; c < C; ++c)\n      std::cout << std::setw(2) << get_bit(in, bit_offset+r*S+c) << \" \";\n    printf (\"\\n\");\n  }\n}\n\ntemplate<typename T>\nvoid print_bits3d(T in[], unsigned M, unsigned num, unsigned S, unsigned R, unsigned C) {\n  for (unsigned m = M; m < M+num; ++m) {\n    print_bits(in, m*S*S, S, R, C);\n    printf (\"--%u--\\n\", m+1);\n  }\n}\n\nvoid print_params3d(Word in[], unsigned M, unsigned num);\nvoid print_wt_word(const Word& in);\nvoid print_wt(const WtType& in);\n\n#endif\n"
      },
      {
        "file_name": "xf_structs.hpp",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_STRUCTS_H_\n#define _XF_STRUCTS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#ifndef __SYNTHESIS__\n#include <iostream>\n#endif\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include \"xf_types.hpp\"\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <type_traits>\n\nnamespace xf {\nnamespace cv {\n\ntemplate <int T>\nap_uint<T> xf_satcast(int in_val) {\n    if (in_val > ((1 << T) - 1)) {\n        return ((1 << T) - 1);\n    } else if (in_val < 0) {\n        return 0;\n    } else {\n        return in_val;\n    }\n}\n\ntemplate <typename T>\nT float2ap_uint(float val) {\n    T* val_out = (T*)(&val);\n    return *val_out;\n}\n\ntemplate <typename T>\nfloat ap_uint2float(T val) {\n    float* val_out = (float*)(&val);\n    return *val_out;\n}\n\n//----------------------------------------------------------------------------------------------------//\n//  LOCAL STEREO BLOCK MATCHING UTILITY\n//----------------------------------------------------------------------------------------------------//\ntemplate <int WSIZE, int NDISP, int NDISP_UNIT>\nclass xFSBMState {\n   public:\n    // pre-filtering (normalization of input images)\n    int preFilterType; // =HLS_STEREO_BM_XSOBEL_TEST\n    int preFilterSize; // averaging window size: ~5x5..21x21\n    int preFilterCap;  // the output of pre-filtering is clipped by\n                       // [-preFilterCap,preFilterCap]\n\n    // correspondence using Sum of Absolute Difference (SAD)\n    int SADWindowSize;       // ~5x5..21x21 // defined in macro\n    int minDisparity;        // minimum disparity (can be negative)\n    int numberOfDisparities; // maximum disparity - minimum disparity (> 0)\n\n    // post-filtering\n    int textureThreshold; // the disparity is only computed for pixels\n\n    // with textured enough neighborhood\n    int uniquenessRatio; // accept the computed disparity d* only if\n    // SAD(d) >= SAD(d*)*(1 + uniquenessRatio/100.)\n    // for any d != d*+/-1 within the search range.\n\n    // int speckleWindowSize; // disparity variation window\n    // int speckleRange;      // acceptable range of variation in window\n\n    int ndisp_unit;\n    int sweepFactor;\n    int remainder;\n\n    xFSBMState() {\n        preFilterType = XF_STEREO_PREFILTER_SOBEL_TYPE; // Default Sobel filter\n        preFilterSize = WSIZE;\n        preFilterCap = 31;\n        SADWindowSize = WSIZE;\n        minDisparity = 0;\n        numberOfDisparities = NDISP;\n        textureThreshold = 10;\n        uniquenessRatio = 15;\n        sweepFactor = (NDISP / NDISP_UNIT) + ((NDISP % NDISP_UNIT) != 0);\n        ndisp_unit = NDISP_UNIT;\n        remainder = NDISP_UNIT * sweepFactor - NDISP;\n    }\n};\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Point_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Point_ {\n   public:\n    Point_();\n    Point_(T _x, T _y);\n    Point_(const Point_& pt);\n    ~Point_();\n\n    T x, y;\n};\n\n/* Member functions of Point_ class */\ntemplate <typename T>\ninline Point_<T>::Point_() {}\ntemplate <typename T>\ninline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}\ntemplate <typename T>\ninline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}\ntemplate <typename T>\ninline Point_<T>::~Point_() {}\n\ntypedef Point_<int> Point;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Size_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Size_ {\n   public:\n    Size_();\n    Size_(T _width, T _height);\n    Size_(const Size_<T>& sz);\n    Size_(const Point_<T>& pt);\n    T area();\n    ~Size_();\n\n    T width, height;\n};\n\n/* Member functions of Size_ class */\ntemplate <typename T>\ninline Size_<T>::Size_() {}\ntemplate <typename T>\ninline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}\ntemplate <typename T>\ninline T Size_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T>::~Size_() {}\n\ntypedef Size_<int> Size;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Rect_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Rect_ {\n   public:\n    Rect_();\n    Rect_(T _x, T _y, T _width, T _height);\n    Rect_(const Rect_& rect);\n    Rect_(const Point_<T>& pt, const Size_<T>& sz);\n    T area();\n    Size_<T> size();\n    Point_<T> tl(); // top-left point(inside);\n    Point_<T> tr(); // top-right point(outside);\n    Point_<T> bl(); // bottom-left point(outside);\n    Point_<T> br(); // bottom-right point(outside);\n    bool bContains(const Point_<T>& pt);\n    ~Rect_();\n\n    T x, y, width, height;\n};\n\n/* Member functions of Rect_ class */\ntemplate <typename T>\ninline Rect_<T>::Rect_() {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz)\n    : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline T Rect_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T> Rect_<T>::size() {\n    return Size_<T>(width, height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tl() {\n    return Point_<T>(x, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tr() {\n    return Point_<T>(x + width, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::bl() {\n    return Point_<T>(x, y + height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::br() {\n    return Point_<T>(x + width, y + height);\n}\ntemplate <typename T>\ninline bool Rect_<T>::bContains(const Point_<T>& pt) {\n    return (pt.x >= x && pt.x < x + width && pt.y >= y && pt.y < y + height);\n}\ntemplate <typename T>\ninline Rect_<T>::~Rect_() {}\n\ntypedef Rect_<int> Rect;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Scalar\n//----------------------------------------------------------------------------------------------------//\ntemplate <int N, typename T>\nclass Scalar {\n   public:\n    Scalar() {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N > 0);\n    }\n    Scalar(T v0) {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N >= 1 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n    }\n    Scalar(T v0, T v1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 2 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n    }\n    Scalar(T v0, T v1, T v2) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 3 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n    }\n    Scalar(T v0, T v1, T v2, T v3) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 4 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n        val[3] = v3;\n    }\n\n    void operator=(T value);\n    Scalar<N, T> operator+(T value);\n    Scalar<N, T> operator+(Scalar<N, T> s);\n    Scalar<N, T> operator-(T value);\n    Scalar<N, T> operator-(Scalar<N, T> s);\n    Scalar<N, T> operator*(T value);\n    Scalar<N, T> operator*(Scalar<N, T> s);\n    Scalar<N, T> operator/(T value);\n    Scalar<N, T> operator/(Scalar<N, T> s);\n\n    T val[N];\n};\n\ntemplate <int N, typename T>\nvoid Scalar<N, T>::operator=(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[k] = value;\n    }\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / s.val[k];\n    }\n    return res;\n}\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Mat\n//----------------------------------------------------------------------------------------------------//\n#if defined(__SYNTHESIS__) && !defined(__SDA_MEM_MAP__)\nstatic constexpr int _XFCVDEPTH_DEFAULT = 2;\n#else\nstatic constexpr int _XFCVDEPTH_DEFAULT = -1;\n#endif\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass Mat {\n   public:\n    unsigned char allocatedFlag; // flag to mark memory allocation in this class\n    int rows, cols, size;        // actual image size\n    //\tint cols_align_npc;\t\t\t\t\t\t// cols\n    // multiple\n    // of\n    // NPC\n\n    typedef XF_TNAME(T, NPC) DATATYPE;\n    using _DATATTYPE = typename std::conditional<\n        (XFCVDEPTH < 0),\n        DATATYPE*,                 // Case of Memory Mapped pointer\n        typename std::conditional< // Case of Stream\n            (XFCVDEPTH == 0),\n            hls::stream<DATATYPE>,           // Case of default Dtream depth or user can override outside\n            hls::stream<DATATYPE, XFCVDEPTH> // Case of Stream depth specified\n            >::type>::type;\n    _DATATTYPE data;\n\n    Mat(); // default constructor\n    Mat(Size _sz);\n    Mat(int _rows, int _cols);\n    Mat(int _size, int _rows, int _cols);\n    Mat(int _rows, int _cols, void* _data);\n    Mat(const Mat&); // copy constructor\n\n    ~Mat();\n\n    Mat& operator=(const Mat&); // Assignment operator\n    //  XF_TNAME(T, XF_NPPC1) operator() (unsigned int r, unsigned int c);\n    //  XF_CTUNAME(T, NPC) operator() (unsigned int r, unsigned int c, unsigned\n    //  int ch);\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void alloc_data() {\n#ifndef __SYNTHESIS__\n        data = (DATATYPE*)malloc(size * sizeof(DATATYPE));\n\n        if (data == NULL) {\n            fprintf(stderr, \"\\nFailed to allocate memory\\n\");\n        } else {\n            allocatedFlag = 1;\n        }\n#endif\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void alloc_data() {\n        // This is a stream\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void free_data() {\n        if (data != NULL) {\n#ifndef __SYNTHESIS__\n            free(data);\n#endif\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void free_data() {}\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        for (int i = 0; i < (rows * ((cols + NPC - 1) >> XF_BITSHIFT(NPC))); ++i) {\n#pragma HLS loop_tripcount min=1 max=1024\n            data[i] = src.data[i];\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        data = (DATATYPE*)_data;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data[index];\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data.read();\n    }\n    float read_float(int index);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data[index] = val;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data.write(val);\n    }\n    void write_float(int index, float val);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols);\n        copyTo(_data);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols, false);\n        assignDataPtr(_data);\n    }\n\n    void init(int _rows, int _cols, bool allocate = true);\n    void copyTo(void* fromData);\n    unsigned char* copyFrom();\n\n    const int type() const;\n    const int depth() const;\n    const int channels() const;\n\n    template <int DST_T>\n    void convertTo(Mat<DST_T, ROWS, COLS, NPC, XFCVDEPTH>& dst, int otype, double alpha = 1, double beta = 0);\n};\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::type() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return (T);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::depth() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_DTPIXELDEPTH(T, NPC);\n}\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::channels() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_CHANNELS(T, NPC);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::init(int _rows, int _cols, bool allocate) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    assert((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) &&\n           \"The number of rows and columns must be less than the template \"\n           \"arguments.\");\n\n    rows = _rows;\n    cols = _cols;\n    allocatedFlag = 0;\n    size = _rows * ((_cols + NPPC - 1) >> XF_BITSHIFT(NPPC));\n\n    if (allocate) {\n        alloc_data();\n    }\n}\n\n/*Copy constructor definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::Mat(const Mat& src) {\n    init(src.rows, src.cols);\n\n#ifndef __SYNTHESIS__\n    copyData(src);\n#endif\n}\n\n/*Assignment operator definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::operator=(const Mat& src) {\n    if (this == &src) {\n        return *this; // For self-assignment cases\n    }\n\n    // Cleaning up old data memory if any\n    free_data();\n    allocatedFlag = 0;\n\n    init(src.rows, src.cols);\n    copyData(src);\n\n    return *this;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(ROWS, COLS);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols, void* _data) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols, _data);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(Size _sz) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_sz.height, _sz.width);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline float Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::read_float(int index) {\n    union int2float {\n        unsigned I;\n        float F;\n    };\n    int2float val;\n    val.I = read(index).to_uint();\n    return val.F;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::write_float(int index, float float_val) {\n    float val = float_val;\n    ap_uint<32>* val_out = (ap_uint<32>*)(&val);\n    write(index, *val_out);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyTo(void* _input) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    XF_PTSNAME(T, NPPC)* input = (XF_PTSNAME(T, NPPC)*)_input;\n    XF_CTUNAME(T, NPPC) in_val;\n\n    int packcols = cols >> XF_BITSHIFT(NPPC);       // Total columns after considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < packcols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            for (int p = 0; p < nppc; p++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                DATATYPE out_val;\n                for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    if (T == XF_32FC1) {\n                        in_val = float2ap_uint<ap_uint<32> >(\n                            input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch]);\n                    } else {\n                        in_val = input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch];\n                    }\n\n                    out_val.range((p * pixdepth) + (ch + 1) * bitdepth - 1, (p * pixdepth) + ch * bitdepth) = in_val;\n                }\n                write((r * packcols + c), out_val);\n            }\n        }\n    }\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline unsigned char* Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyFrom() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    //\tint packcols  = cols >> XF_BITSHIFT(NPPC); //Total columns after\n    // considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    int cv_nbytes = bitdepth / 8;\n\n    unsigned char* value =\n        (unsigned char*)malloc(rows * cols * (XF_CHANNELS(T, NPPC)) * (sizeof(unsigned char)) * cv_nbytes);\n\n    int xf_npc_idx = 0;\n    int diff_ptr = 0;\n    int xf_ptr = 0;\n    int cv_ptr = 0;\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < cols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            DATATYPE in_val = read(xf_ptr);\n            for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                for (int b = 0; b < cv_nbytes; ++b) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    value[cv_ptr++] = in_val.range((xf_npc_idx * pixdepth) + (ch * bitdepth) + (b + 1) * 8 - 1,\n                                                   (xf_npc_idx * pixdepth) + (ch * bitdepth) + b * 8);\n                }\n            }\n            if (xf_npc_idx == nppc - 1) {\n                xf_npc_idx = 0;\n                xf_ptr++;\n            } else {\n                xf_npc_idx++;\n            }\n        }\n    }\n\n    return (unsigned char*)value;\n}\n\n/* Member functions of Mat class */\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ntemplate <int DST_T>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::convertTo(Mat<DST_T, ROWS, COLS, NPPC, XFCVDEPTH>& dst,\n                                                           int otype,\n                                                           double alpha,\n                                                           double beta) {\n    assert((XF_CHANNELS(T, NPPC) == 1) && \"Multi-channel images not supported\");\n\n    XF_TNAME(T, NPPC) tmp_in_pix;\n    XF_TNAME(DST_T, NPPC) tmp_out_pix;\n\n    XF_CTUNAME(T, NPPC) in_pix;\n    XF_CTUNAME(DST_T, NPPC) out_pix;\n\n    int min, max;\n\n    if (DST_T == XF_8UC1) {\n        min = 0;\n        max = 255;\n    } else if (DST_T == XF_16UC1) {\n        min = 0;\n        max = 65535;\n    } else if (DST_T == XF_16SC1) {\n        min = -32768;\n        max = 32767;\n    } else if (DST_T == XF_32SC1) {\n        min = -2147483648;\n        max = 2147483647;\n    } else {\n        assert(1 &&\n               \"Output image type not supoorted. XF_8UC1, XF_16UC1, XF_16SC1 \"\n               \"and XF_32SC1 are valid\");\n    }\n\n#define __SATCAST(X) (X >= max ? max : (X < 0 ? 0 : lround(X)))\n\n    for (int i = 0; i < rows; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int j = 0; j<cols>> (XF_BITSHIFT(NPPC)); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            int IN_STEP = XF_PIXELDEPTH(XF_DEPTH(T, NPPC));\n            int OUT_STEP = XF_PIXELDEPTH(XF_DEPTH(DST_T, NPPC));\n            int in_shift = 0;\n            int out_shift = 0;\n            DATATYPE in_val = read((i * cols >> (XF_BITSHIFT(NPPC))) + j);\n            DATATYPE out_val;\n\n            for (int k = 0; k < (1 << (XF_BITSHIFT(NPPC))); k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                in_pix = in_val.range(in_shift + IN_STEP - 1, in_shift);\n\n                if (otype == XF_CONVERT_16U_TO_8U || otype == XF_CONVERT_16S_TO_8U || otype == XF_CONVERT_32S_TO_8U ||\n                    otype == XF_CONVERT_32S_TO_16U || otype == XF_CONVERT_32S_TO_16S) {\n                    float tmp = (float)(in_pix * alpha + beta);\n                    in_pix = __SATCAST(tmp);\n\n                    if (in_pix < min) in_pix = min;\n                    if (in_pix > max) in_pix = max;\n\n                    tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = in_pix;\n                } else {\n                    if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) > max) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = max;\n\n                    } else if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) < min) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = min;\n\n                    } else {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = __SATCAST(in_pix * alpha + beta);\n                    }\n                }\n\n                out_pix = tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift);\n\n                out_val.range(out_shift + OUT_STEP - 1, out_shift) = out_pix;\n\n                in_shift = in_shift + IN_STEP;\n                out_shift = out_shift + OUT_STEP;\n            }\n            dst.write(((i * cols >> (XF_BITSHIFT(NPPC))) + j), out_val);\n        }\n    }\n}\n\ntemplate <int SRC_T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nMat<SRC_T, ROWS, COLS, NPC, XFCVDEPTH>::~Mat() {\n#ifndef __SYNTHESIS__\n    if (allocatedFlag == 1) {\n        free_data();\n    }\n#endif\n}\n//----------------------------------------------------------------------------------------------------//\n\n// Template metaprogramming implementation of floor log2 [[\ntemplate <int N>\nstruct log2 {\n   public:\n    static constexpr int fvalue = 1 + (log2<N / 2>::fvalue);                   // floor value\n    static constexpr int cvalue = (N > (1 << fvalue)) ? (fvalue + 1) : fvalue; // ceiling value\n};\n\ntemplate <>\nstruct log2<1> {\n   public:\n    static constexpr int fvalue = 0;\n    static constexpr int cvalue = 0;\n};\n\nstruct bgr2y8_params {\n    int black_Vmax = 20;\n    int black_Smax = 70;\n    int brown_Hmax = 15;\n    int brown_Vmax = 40;\n    int Smin = 60;\n    int Smax = 90;\n    int darkgreen_Vmax = 35;\n    int darkgreen_Hmin = 30;\n    int darkgreen_Hmax = 45;\n    int green_Hmax = 90;\n    int green_Hmin = 50;\n    int green_Vmax = 45;\n};\n//]]\n\n/*\n * The purpose of this class is to provide an interator over ap_uint<PTR_WIDTH>\n * object array such\n * that at each iter step one can get data bits corresponding to data to be\n * processed per cycle.\n *\n */\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIter : public Mat<T, ROWS, COLS, NPC, XFCVDEPTH> {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    static constexpr int XF_BITS_PER_CLOCK = XF_PIXELWIDTH(T, NPC) * XF_NPIXPERCYCLE(NPC);\n    static constexpr int COLS_BOUND_PER_NPC = ((COLS + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC));\n    static constexpr int LOOPBOUND = ROWS * COLS_BOUND_PER_NPC;\n    static constexpr int ADDRBOUND = ((ROWS * COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                     (log2<PTR_WIDTH>::cvalue);\n    static constexpr int LAST_BLK_PXL_WIDTH =\n        ((COLS >> XF_BITSHIFT(NPC)) == COLS_BOUND_PER_NPC)\n            ? XF_BITS_PER_CLOCK\n            : XF_PIXELWIDTH(T, NPC) * (COLS - ((COLS >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    static constexpr int COLS_ADDRBOUND = ((COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                          (log2<PTR_WIDTH>::cvalue);\n    static int cols_npc_aligned(int cols) { return ((cols + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC)); }\n\n    static int last_blk_pxl_width(int cols, int cols_bound_per_npc) {\n        return ((cols >> XF_BITSHIFT(NPC)) == cols_bound_per_npc)\n                   ? XF_BITS_PER_CLOCK\n                   : XF_PIXELWIDTH(T, NPC) * (cols - ((cols >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    }\n\n    static int loopbound(int rows, int cols) { return rows * cols_npc_aligned(cols); }\n\n    int loopbound() { return rows * cols_npc_aligned(cols); }\n\n    static int addrbound(int rows, int cols) {\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> cols_int16 = cols;\n\n        ap_uint<32> mul_rows_cols;\n\n// clang-format off\n#pragma HLS BIND_OP variable=mul_rows_cols op=mul impl=dsp latency=2\n        // clang-format on\n\n        mul_rows_cols = rows_int16 * cols_int16;\n\n        return ((mul_rows_cols * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >> (log2<PTR_WIDTH>::cvalue);\n    }\n    MMIter() : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>() {}\n\n    MMIter(int _rows, int _cols) : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {}\n};\n\n#define _MMITER MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterIn : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n    using _MMITER::COLS_ADDRBOUND;\n\n   private:\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop1:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    static void Axi2AxiStream(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = din.read();\n            dout.write(v.data);\n        }\n    }\n\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows_burst,\n                              int rows,\n                              int cols,\n                              int stride = -1) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> cols_addrbound = _MMITER::addrbound(rows_burst, cols);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> stride_addrbound = _MMITER::addrbound(rows_burst, stride);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> addrbound = (stride == -1) ? cols_addrbound : stride_addrbound;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> c;\n    MMIterInLoop1:\n        for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n            // clang-format on\n            for (c = 0; c < cols_addrbound; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_ADDRBOUND\n#pragma HLS pipeline\n                // clang-format on\n                dout.write(din[c + r * addrbound]);\n            }\n        }\n    }\n    template <int DEPTH>\n    static void AxiStream2MatStream(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                                    hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        int stride_bound_per_npc, strideBased_last_blk_width;\n\n        // if (stride == -1) {\n        stride_bound_per_npc = cols_bound_per_npc;\n        strideBased_last_blk_width = last_blk_width;\n        //} else {\n        //  stride_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        //  strideBased_last_blk_width = _MMITER::last_blk_pxl_width(stride, stride_bound_per_npc);\n        //}\n        int rd_cnt = 0;\n\n        int rem = 0;\n        ap_uint<PTR_WIDTH> val = 0;\n        int i;\n        int j = 0;\n        int bound = rows * stride_bound_per_npc;\n    MMIterInLoopRow:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            bool bLast = (j == (stride_bound_per_npc - 1));\n            int xf_bits_per_clock = bLast ? strideBased_last_blk_width : XF_BITS_PER_CLOCK;\n            int ptr_width_minus = bLast ? (PTR_WIDTH - strideBased_last_blk_width) : (PTR_WIDTH - XF_BITS_PER_CLOCK);\n            int ptr_width_plus = bLast ? (PTR_WIDTH + strideBased_last_blk_width) : (PTR_WIDTH + XF_BITS_PER_CLOCK);\n\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer = 0;\n            if (rem < xf_bits_per_clock) {\n                if (rem != 0) {\n                    localbuffer.range(rem - 1, 0) = val.range(PTR_WIDTH - 1, (PTR_WIDTH - rem));\n                }\n                val = din.read();\n                rd_cnt++;\n                localbuffer.range((xf_bits_per_clock - 1), rem) = val.range(((xf_bits_per_clock - 1) - rem), 0);\n                rem = ptr_width_minus + rem;\n            } else {\n                localbuffer = val.range(((ptr_width_plus - 1) - rem), (PTR_WIDTH - rem));\n                rem = rem - xf_bits_per_clock;\n            }\n            bool bLast_width = (j == (cols_bound_per_npc - 1));\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer2 = 0;\n            if (bLast_width == 0)\n                localbuffer2 = localbuffer;\n            else\n                localbuffer2 = localbuffer.range(last_blk_width - 1, 0);\n\n            if (j < cols_bound_per_npc) dout.write(localbuffer2);\n\n            j = (bLast) ? 0 : (j + 1);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2Mat(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterInLoop2:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, ldata, rows, cols_bound_per_npc, last_blk_width, stride);\n        MatStream2Mat(ldata, dout, rows, cols_bound_per_npc);\n    }\n\n    static void Axi2Mat(ap_uint<PTR_WIDTH>* din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n    static void Axi2Mat(\n        ap_uint<PTR_WIDTH>* din, ap_uint<XF_BITS_PER_CLOCK>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        ap_uint<XF_BITS_PER_CLOCK>* dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n   public:\n    MMIterIn(ap_uint<PTR_WIDTH>* d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(ap_uint<PTR_WIDTH>* d, int _rows, int _cols) : _MMITER(_rows, _cols) { Axi2Mat(d, data, rows, cols); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        Axi2Mat(d, data, rows, cols);\n    }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d) : _MMITER() { AxiStream2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        AxiStream2Mat(d, data, rows, cols);\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& din, int index) {\n        return din.read();\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(ap_uint<XF_BITS_PER_CLOCK>* din, int index) { return din[index]; }\n\n    ap_uint<XF_BITS_PER_CLOCK> read(int index) { return read(data, index); }\n\n    static void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                            xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                            int stride = -1) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols, stride);\n    }\n\n    static void Array2xfMat(\n        ap_uint<PTR_WIDTH>* srcPtr, ap_uint<XF_BITS_PER_CLOCK>* dstPtr, int rows, int cols, int stride = -1) {\n        Axi2Mat(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                              xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int FILLZERO = 1, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterOut : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n\n   private:\n    template <int DEPTH>\n    static void Mat2MatStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterOutLoop1:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                                    hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        ap_uint<16> strideBased_cols_bound_per_npc;\n        if (stride == -1 || FILLZERO == 0) {\n            strideBased_cols_bound_per_npc = cols_bound_per_npc;\n        } else {\n            strideBased_cols_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        }\n\n        ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled = 0; // valid bits remaining in current buffer\n        ap_uint<PTR_WIDTH> localbuffer = 0;\n        ap_uint<16> i;\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> j;\n\n    MMIterOutRow:\n        for (i = 0; i < rows_int16; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n        // clang-format on\n        MMIterOutCol:\n            for (j = 0; j < strideBased_cols_bound_per_npc; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_BOUND_PER_NPC\n#pragma HLS pipeline\n                // clang-format on\n\n                bool bLast = (j == (cols_bound_per_npc - 1));\n                int xf_bits_per_clock = bLast ? last_blk_width : XF_BITS_PER_CLOCK;\n                ap_uint<PTR_WIDTH> val;\n                if (j < cols_bound_per_npc || FILLZERO == 0)\n                    val = din.read();\n                else\n                    val = 0;\n\n                ap_uint<PTR_WIDTH> tempval = (val << filled);\n                localbuffer = (localbuffer | tempval);\n                ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled_next;\n\n                if (filled < (PTR_WIDTH - xf_bits_per_clock)) {\n                    filled_next = filled + xf_bits_per_clock;\n                } else if (j == cols_bound_per_npc - 1 && FILLZERO == 0) {\n                    dout.write(localbuffer);\n                    localbuffer = 0;\n                    filled_next = 0;\n                } else {\n                    dout.write(localbuffer);\n                    localbuffer = (val >> (PTR_WIDTH - filled));\n                    filled_next = filled + (xf_bits_per_clock - PTR_WIDTH);\n                }\n\n                filled = filled_next;\n            }\n        }\n\n        if (filled != 0) {\n            dout.write(localbuffer);\n        }\n    }\n\n    static void Mat2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        MatStream2AxiStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void Mat2AxiStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        Mat2MatStream(din, ldata, rows, cols_bound_per_npc);\n        MatStream2AxiStream(ldata, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<PTR_WIDTH>* dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop2:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = din.read();\n            dout.write(v);\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        ap_uint<PTR_WIDTH>* dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(\n        ap_uint<XF_BITS_PER_CLOCK>* din, ap_uint<PTR_WIDTH>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(ap_uint<XF_BITS_PER_CLOCK>* din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n   public:\n    MMIterOut() : _MMITER() {}\n\n    MMIterOut(int _rows, int _cols) : _MMITER(_rows, _cols) {}\n\n    inline static void write(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& dout,\n                             ap_uint<XF_BITS_PER_CLOCK>& val,\n                             int index) {\n        dout.write(val);\n    }\n\n    inline static void write(ap_uint<XF_BITS_PER_CLOCK>* dout, ap_uint<XF_BITS_PER_CLOCK>& val, int index) {\n        dout[index] = val;\n    }\n\n    void write(ap_uint<XF_BITS_PER_CLOCK>& val, int index) { write(data, val, index); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout) { Mat2Axi(data, dout); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout, int rows, int cols) { Mat2Axi(data, dout, rows, cols); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout) { Mat2Axi(data, dout); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout, int rows, int cols) {\n        Mat2Axi(data, dout, rows, cols);\n    }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout) { Mat2AxiStream(data, dout); }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout, int rows, int cols) { Mat2AxiStream(data, dout, rows, cols); }\n\n    static void xfMat2Array(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                            ap_uint<PTR_WIDTH>* dstPtr,\n                            int stride = -1) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols, stride);\n    }\n\n    static void xfMat2Array(\n        ap_uint<XF_BITS_PER_CLOCK>* srcPtr, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols, int stride = -1) {\n        Mat2Axi(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void xfMat2axiStrm(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dstPtr) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols);\n    }\n};\n\n} // namespace cv\n} // namespace xf\n\n#endif // _XF_STRUCTS_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "xf_common.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_COMMON_H_\n#define _XF_COMMON_H_\n\n#include \"xf_structs.hpp\"\n#include \"xf_params.hpp\"\n#include \"xf_types.hpp\"\n\nusing namespace xf::cv;\n#endif\n"
      },
      {
        "file_name": "xf_params.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_PARAMS_H_\n#define _XF_PARAMS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n\n#define __ABS(X) ((X) < 0 ? (-(X)) : (X))\n\n// Channels of an image\nenum _channel_extract {\n    XF_EXTRACT_CH_0, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_1, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_2, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_3, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_R, // Used to extract the RED channel\n    XF_EXTRACT_CH_G, // Used to extract the GREEN channel\n    XF_EXTRACT_CH_B, // Used to extract the BLUE channel\n    XF_EXTRACT_CH_A, // Used to extract the ALPHA channel\n    XF_EXTRACT_CH_Y, // Used to extract the LUMA channel\n    XF_EXTRACT_CH_U, // Used to extract the Cb/U channel\n    XF_EXTRACT_CH_V  // Used to extract the Cr/V/Value channel\n};\ntypedef _channel_extract XF_channel_extract_e;\n\n// Conversion Policy for fixed point arithmetic\nenum _convert_policy { XF_CONVERT_POLICY_SATURATE, XF_CONVERT_POLICY_TRUNCATE };\ntypedef _convert_policy XF_convert_policy_e;\n\n// Bit-depth conversion types\nenum _convert_bit_depth {\n    // Down-convert\n    XF_CONVERT_16U_TO_8U,\n    XF_CONVERT_16S_TO_8U,\n    XF_CONVERT_32S_TO_8U,\n    XF_CONVERT_32S_TO_16U,\n    XF_CONVERT_32S_TO_16S,\n    // Up-convert\n    XF_CONVERT_8U_TO_16U,\n    XF_CONVERT_8U_TO_16S,\n    XF_CONVERT_8U_TO_32S,\n    XF_CONVERT_16U_TO_32S,\n    XF_CONVERT_16S_TO_32S\n};\ntypedef _convert_bit_depth XF_convert_bit_depth_e;\n\n// Thresholding types\nenum _threshold_type {\n    XF_THRESHOLD_TYPE_BINARY = 0,\n    XF_THRESHOLD_TYPE_BINARY_INV = 1,\n    XF_THRESHOLD_TYPE_TRUNC = 2,\n    XF_THRESHOLD_TYPE_TOZERO = 3,\n    XF_THRESHOLD_TYPE_TOZERO_INV = 4,\n};\ntypedef _threshold_type XF_threshold_type_e;\n\n// Thresholding types\nenum _ccm_type {\n    XF_CCM_bt2020_bt709 = 0,\n    XF_CCM_bt709_bt2020 = 1,\n    XF_CCM_rgb_yuv_601 = 2,\n    XF_CCM_rgb_yuv_709 = 3,\n    XF_CCM_rgb_yuv_2020 = 4,\n    XF_CCM_yuv_rgb_601 = 5,\n    XF_CCM_yuv_rgb_709 = 6,\n    XF_CCM_yuv_rgb_2020 = 7,\n    XF_CCM_full_from_16_235 = 8,\n    XF_CCM_full_to_16_235 = 9,\n\n};\ntypedef _ccm_type XF_ccm_type_e;\n\n// Comparision types\nenum _comparison_op { XF_CMP_EQ = 0, XF_CMP_GT = 1, XF_CMP_GE = 2, XF_CMP_LT = 3, XF_CMP_LE = 4, XF_CMP_NE = 5 };\ntypedef _comparison_op _comparison_op_e;\n\n// Comparision types\nenum _reduction_op { REDUCE_SUM = 0, REDUCE_AVG = 1, REDUCE_MAX = 2, REDUCE_MIN = 3 };\ntypedef _reduction_op _reduction_op_e;\n\n// Pixel Per Cycle\nenum _pixel_per_cycle {\n    XF_NPPC1 = 1,\n    XF_NPPC2 = 2,\n    XF_NPPC4 = 4,\n    XF_NPPC8 = 8,\n    XF_NPPC16 = 16,\n    XF_NPPC32 = 32,\n    XF_NPPC64 = 64\n};\ntypedef _pixel_per_cycle XF_nppc_e;\n\n// Pixel types\nenum _pixel_type {\n    XF_8UP = 0,\n    XF_8SP = 1,\n    XF_14UP = 2,\n    XF_16UP = 3,\n    XF_16SP = 4,\n    XF_32UP = 5,\n    XF_32SP = 6,\n    XF_19SP = 7,\n    XF_32FP = 8,\n    XF_35SP = 9,\n    XF_24SP = 10,\n    XF_20SP = 11,\n    XF_48SP = 12,\n    XF_2UP = 13,\n    XF_9SP = 14,\n    XF_9UP = 15,\n    XF_24UP = 16,\n    XF_64UP = 17,\n    XF_10UP = 18,\n    XF_12UP = 19,\n    XF_40UP = 20,\n    XF_42UP = 20,\n    XF_48UP = 21,\n    XF_30UP = 22,\n    XF_36UP = 23,\n    XF_96FP = 24\n};\ntypedef _pixel_type XF_pixel_type_e;\n\n// Word width\nenum _word_width {\n    XF_2UW = 0,\n    XF_8UW = 1,\n    XF_9UW = 2,\n    XF_10UW = 3,\n    XF_12UW = 4,\n    XF_14UW = 5,\n    XF_16UW = 6,\n    XF_19SW = 7,\n    XF_20UW = 8,\n    XF_22UW = 9,\n    XF_24UW = 10,\n    XF_24SW = 11,\n    XF_28UW = 12,\n    XF_30UW = 13,\n    XF_32UW = 14,\n    XF_32FW = 15,\n    XF_35SW = 16,\n    XF_36UW = 17,\n    XF_40UW = 18,\n    XF_42UW = 19,\n    XF_48UW = 20,\n    XF_48SW = 21,\n    XF_56UW = 22,\n    XF_60UW = 23,\n    XF_64UW = 24,\n    XF_72UW = 25,\n    XF_80UW = 26,\n    XF_84UW = 27,\n    XF_96UW = 28,\n    XF_96SW = 29,\n    XF_112UW = 30,\n    XF_120UW = 31,\n    XF_128UW = 32,\n    XF_144UW = 33,\n    XF_152SW = 34,\n    XF_160UW = 35,\n    XF_160SW = 36,\n    XF_168UW = 37,\n    XF_176UW = 38,\n    XF_192UW = 39,\n    XF_192SW = 40,\n    XF_240UW = 41,\n    XF_256UW = 42,\n    XF_280SW = 43,\n    XF_288UW = 44,\n    XF_304SW = 45,\n    XF_320UW = 46,\n    XF_336UW = 47,\n    XF_352UW = 48,\n    XF_384UW = 49,\n    XF_384SW = 50,\n    XF_512UW = 51,\n    XF_560SW = 52,\n    XF_576UW = 53,\n    XF_96FW = 54,\n    XF_192FW = 55,\n    XF_384FW = 56,\n    XF_768FW = 57,\n    XF_1536FW = 58\n};\ntypedef _word_width XF_word_width_e;\n\n// Filter size\nenum _filter_size { XF_FILTER_3X3 = 3, XF_FILTER_5X5 = 5, XF_FILTER_7X7 = 7 };\ntypedef _filter_size XF_filter_size_e;\n\n// Radius size for Non Maximum Suppression\nenum _nms_radius { XF_NMS_RADIUS_1 = 1, XF_NMS_RADIUS_2 = 2, XF_NMS_RADIUS_3 = 3 };\ntypedef _nms_radius XF_nms_radius_e;\n\n// Image Pyramid Parameters\nenum _image_pyramid_params {\n    XF_PYRAMID_TYPE_GXFSSIAN = 0,\n    XF_PYRAMID_TYPE_LAPLACIAN = 1,\n    XF_PYRAMID_SCALE_HALF = 2,\n    XF_PYRAMID_SCALE_ORB = 3,\n    XF_PYRAMID_SCALE_DOUBLE = 4\n};\ntypedef _image_pyramid_params XF_image_pyramid_params_e;\n\n// Magnitude computation\nenum _normalisation_params { XF_L1NORM = 0, XF_L2NORM = 1 };\ntypedef _normalisation_params XF_normalisation_params_e;\n\nenum _border_type {\n    XF_BORDER_CONSTANT = 0,\n    XF_BORDER_REPLICATE = 1,\n    XF_BORDER_REFLECT = 2,\n    XF_BORDER_WRAP = 3,\n    XF_BORDER_REFLECT_101 = 4,\n    XF_BORDER_TRANSPARENT = 5,\n    XF_BORDER_REFLECT101 = XF_BORDER_REFLECT_101,\n    XF_BORDER_DEFAULT = XF_BORDER_REFLECT_101,\n    XF_BORDER_ISOLATED = 16,\n};\ntypedef _border_type XF_border_type_e;\n\nenum _structuring_element_shape {\n    XF_SHAPE_RECT = 0,\n    XF_SHAPE_ELLIPSE = 1,\n    XF_SHAPE_CROSS = 2,\n\n};\nenum _wb_type {\n    XF_WB_GRAY = 0,\n    XF_WB_SIMPLE = 1,\n};\n\nenum multistream {\n    SLICES_DEFAULT = 1,\n};\n// Phase computation\nenum _phase_params { XF_RADIANS = 0, XF_DEGREES = 1 };\ntypedef _phase_params XF_phase_params_e;\n\n// Types of Interpolaton techniques used in resize, affine and perspective\nenum _interpolation_types { XF_INTERPOLATION_NN = 0, XF_INTERPOLATION_BILINEAR = 1, XF_INTERPOLATION_AREA = 2 };\ntypedef _interpolation_types _interpolation_types_e;\n\n// loop dependent variables used in image pyramid\nenum _loop_dependent_vars { XF_GXFSSIANLOOP = 8, XF_BUFSIZE = 12 };\ntypedef _loop_dependent_vars loop_dependent_vars_e;\n\n// loop dependent variables used in image pyramid\nenum _image_size { XF_SDIMAGE = 0, XF_HDIMAGE = 1 };\ntypedef _image_size image_size_e;\n\n// enumerations for HOG feature descriptor\nenum _input_image_type { XF_GRAY = 1, XF_RGB = 3 };\ntypedef _input_image_type input_image_type_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_output_type { XF_HOG_RB = 0, XF_HOG_NRB = 1 };\ntypedef _HOG_output_type HOG_output_type_e;\n\nenum use_model { XF_STANDALONE = 0, XF_PIPELINE = 1 };\ntypedef use_model use_model_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_type { XF_DHOG = 0, XF_SHOG = 1 };\ntypedef _HOG_type HOG_type_e;\n\n// enumerations for Stereo BM\nenum XF_stereo_prefilter_type { XF_STEREO_PREFILTER_SOBEL_TYPE, XF_STEREO_PREFILTER_NORM_TYPE };\n/****************************new************************/\n// enumerations for Demosaicing\nenum XF_demosaicing {\n    XF_BAYER_BG,\n    XF_BAYER_GB,\n    XF_BAYER_GR,\n    XF_BAYER_RG,\n};\n// typedef XF_stereo_prefilter_type XF_stereo_pre_filter_type_e;\n// enum _pixel_percycle\n//{\n//\tXF_NPPC1  = 0,\n//\tXF_NPPC8  = 3,\n//\tXF_NPPC16 = 4\n//};\n// typedef _pixel_percycle XF_nppc_e;\n\n// enumerations for Architecture\nenum _ARCH_type {\n    XF_STREAM = 0,\n    XF_MEMORYMAPPED = 1\n\n};\ntypedef _ARCH_type _ARCH_type_e;\n\nenum _pixeltype {\n    XF_8UC1 = 0,\n    XF_14UC1 = 1,\n    XF_16UC1 = 2,\n    XF_16SC1 = 3,\n    XF_24UC1 = 4,\n    XF_24SC1 = 5,\n    XF_32UC1 = 6,\n    XF_32FC1 = 7,\n    XF_32SC1 = 8,\n    XF_8UC2 = 9,\n    XF_8UC4 = 10,\n    XF_2UC1 = 11,\n    XF_8UC3 = 16,\n    XF_16UC3 = 13,\n    XF_16SC3 = 14,\n    XF_16UC4 = 15,\n    XF_10UC1 = 12,\n    XF_10UC4 = 17,\n    XF_12UC1 = 18,\n    XF_12UC4 = 19,\n    XF_10UC3 = 20,\n    XF_12UC3 = 21,\n    XF_14UC3 = 22,\n    XF_32FC3 = 23,\n    XF_64UC1 = 24\n};\ntypedef _pixeltype XF_npt_e;\n\nenum _ramtype {\n    RAM_1P_BRAM = 0,\n    RAM_1P_LUTRAM = 1,\n    RAM_1P_URAM = 2,\n    RAM_2P_BRAM = 3,\n    RAM_2P_LUTRAM = 4,\n    RAM_2P_URAM = 5,\n    RAM_S2P_BRAM = 6,\n    RAM_S2P_LUTRAM = 7,\n    RAM_S2P_URAM = 8,\n    RAM_T2P_BRAM = 9,\n    RAM_T2P_URAM = 10\n};\ntypedef _ramtype XF_ramtype_e;\n\n#endif //_XF_PARAMS_H_\n"
      }
    ],
    "code_length": 29660,
    "token_count": 9181,
    "pragma_number": 310,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/DES_encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1047,
    "Worst-caseLatency": 1047.0,
    "BRAM_18K": 0,
    "LUT": 665,
    "DSP": 0,
    "FF": 1126,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "DES_encrypt",
    "ResourceMetric": 0.0002354872,
    "design_id": "project",
    "algo_name": "DES_encrypt",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "DES_encrypt.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid DES_encrypt(ap_uint<64> plaintext[DATA_SIZE], ap_uint<64> key, ap_uint<64> ciphertext[DATA_SIZE]) {\n    ap_uint<48> subkeys[16];\n    ap_uint<64> permuted_text;\n    ap_uint<32> left, right, temp;\n\n    // Key schedule (simplified)\n    for (int i = 0; i < 16; i++) {\n        subkeys[i] = key.range(47, 0); // Simplified key schedule\n    }\n\n    // Initial permutation (simplified)\n    for (int i = 0; i < DATA_SIZE; i++) {\n        permuted_text = plaintext[i]; // Simplified initial permutation\n        left = permuted_text.range(63, 32);\n        right = permuted_text.range(31, 0);\n\n        // 16 rounds of DES\n        for (int round = 0; round < 16; round++) {\n            temp = right;\n            right = left ^ (right ^ subkeys[round]); // Simplified Feistel function\n            left = temp;\n        }\n\n        // Final permutation (simplified)\n        ciphertext[i] = (ap_uint<64>(right), ap_uint<64>(left)); // Simplified final permutation\n    }\n}\n\n// Top function name: DES_encrypt\n"
      }
    ],
    "code_length": 1037,
    "token_count": 292,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/Decoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 110,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "Decoder",
    "ResourceMetric": 2.55047e-05,
    "design_id": "project",
    "algo_name": "Decoder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "Decoder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid Decoder(ap_uint<8> encoded_data[DATA_SIZE], ap_uint<8> decoded_data[DATA_SIZE]) {\n    ap_uint<8> decode_table[256];\n    \n    // Initialize the decode table\n    for (int i = 0; i < 256; i++) {\n        decode_table[i] = 255 - i; // Example transformation\n    }\n\n    // Decode the data\n    for (int i = 0; i < DATA_SIZE; i++) {\n        decoded_data[i] = decode_table[encoded_data[i]];\n    }\n}\n\n// Top function name: Decoder\n"
      }
    ],
    "code_length": 471,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/NBCD_ADDER/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 128,
    "DSP": 0,
    "FF": 28,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "NBCD_ADDER",
    "ResourceMetric": 2.72306e-05,
    "design_id": "project",
    "algo_name": "NBCD_ADDER",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "NBCD_ADDER.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid NBCD_ADDER(ap_uint<4> A[SIZE], ap_uint<4> B[SIZE], ap_uint<4> C[SIZE]) {\n    ap_uint<4> carry = 0;\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<4> sum = A[i] + B[i] + carry;\n        if (sum > 9) {\n            sum = sum + 6;\n            carry = 1;\n        } else {\n            carry = 0;\n        }\n        C[i] = sum & 0xF;\n    }\n}\n\n// Top function name: NBCD_ADDER\n"
      }
    ],
    "code_length": 418,
    "token_count": 149,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/NanoPowerComparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "NanoPowerComparator",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "NanoPowerComparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "NanoPowerComparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid NanoPowerComparator(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<1> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input1[i] > input2[i]) {\n            output[i] = 1;\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: NanoPowerComparator\n"
      }
    ],
    "code_length": 377,
    "token_count": 114,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/PICO/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 245,
    "DSP": 0,
    "FF": 66,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "PICO",
    "ResourceMetric": 5.33106e-05,
    "design_id": "project",
    "algo_name": "PICO",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "PICO.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid PICO(ap_uint<8> input_image[HEIGHT][WIDTH], ap_uint<8> output_image[HEIGHT][WIDTH]) {\n    for (int i = 0; i < HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            // Example processing: Invert pixel values\n            output_image[i][j] = 255 - input_image[i][j];\n        }\n    }\n}\n\n// Top function name: PICO\n"
      }
    ],
    "code_length": 392,
    "token_count": 118,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/accuracy/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1033,
    "Worst-caseLatency": 1033.0,
    "BRAM_18K": 0,
    "LUT": 561,
    "DSP": 4,
    "FF": 584,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "accuracy",
    "ResourceMetric": 0.000274391,
    "design_id": "project",
    "algo_name": "accuracy",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "accuracy.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid accuracy(float input1[SIZE], float input2[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        float diff = input1[i] - input2[i];\n        output[i] = 1.0f - std::abs(diff);\n    }\n}\n\n// Top function name: accuracy\n"
      }
    ],
    "code_length": 277,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/activation_functions/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1063,
    "Worst-caseLatency": 1063.0,
    "BRAM_18K": 5,
    "LUT": 10940,
    "DSP": 79,
    "FF": 9760,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "activation_functions",
    "ResourceMetric": 0.0055323479,
    "design_id": "project",
    "algo_name": "activation_functions",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "activation_functions.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid activation_functions(float input[SIZE], float output_relu[SIZE], float output_sigmoid[SIZE], float output_tanh[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        // ReLU\n        output_relu[i] = (input[i] > 0) ? input[i] : 0;\n\n        // Sigmoid\n        output_sigmoid[i] = 1.0 / (1.0 + exp(-input[i]));\n\n        // Tanh\n        output_tanh[i] = tanh(input[i]);\n    }\n}\n\n// Top function name: activation_functions\n"
      }
    ],
    "code_length": 459,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/active_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 410,
    "DSP": 3,
    "FF": 518,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "active_learning",
    "ResourceMetric": 0.0002114024,
    "design_id": "project",
    "algo_name": "active_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "active_learning.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid active_learning(float input_data[ARRAY_SIZE], float output_data[ARRAY_SIZE], float threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_data[i] > threshold) {\n            output_data[i] = input_data[i] * 1.5f;\n        } else {\n            output_data[i] = input_data[i] * 0.5f;\n        }\n    }\n}\n\n// Top function name: active_learning\n"
      }
    ],
    "code_length": 407,
    "token_count": 111,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/actor_critic/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1053759,
    "Worst-caseLatency": 1053759.0,
    "BRAM_18K": 0,
    "LUT": 2439,
    "DSP": 24,
    "FF": 2920,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "actor_critic",
    "ResourceMetric": 0.0014125848,
    "design_id": "project",
    "algo_name": "actor_critic",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "actor_critic.cpp",
        "file_content": "#include <cmath>\n\n#define STATE_DIM 1024\n#define ACTION_DIM 1024\n#define GAMMA 0.99\n#define ALPHA 0.01\n#define BETA 0.01\n\nvoid actor_critic(float state[STATE_DIM], float action[STATE_DIM], float reward, float next_state[STATE_DIM], float policy[STATE_DIM][ACTION_DIM], float value[STATE_DIM]) {\n    float td_error;\n    float value_next_state = 0.0;\n    float value_state = 0.0;\n\n    // Calculate value of current state\n    for (int i = 0; i < STATE_DIM; i++) {\n        value_state += state[i] * value[i];\n    }\n\n    // Calculate value of next state\n    for (int i = 0; i < STATE_DIM; i++) {\n        value_next_state += next_state[i] * value[i];\n    }\n\n    // Calculate TD error\n    td_error = reward + GAMMA * value_next_state - value_state;\n\n    // Update value function\n    for (int i = 0; i < STATE_DIM; i++) {\n        value[i] += ALPHA * td_error * state[i];\n    }\n\n    // Update policy\n    for (int i = 0; i < STATE_DIM; i++) {\n        for (int j = 0; j < ACTION_DIM; j++) {\n            policy[i][j] += BETA * td_error * state[i] * action[j];\n        }\n    }\n}\n\n// Top function name: actor_critic\n"
      }
    ],
    "code_length": 1102,
    "token_count": 320,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/ad_da/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ad_da",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "ad_da",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "ad_da.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid ad_da(int input[SIZE], int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        // Analog to Digital Conversion (ADC)\n        int adc_value = input[i] * 2; // Simplified ADC operation\n\n        // Digital to Analog Conversion (DAC)\n        output[i] = adc_value / 2; // Simplified DAC operation\n    }\n}\n\n// Top function name: ad_da\n"
      }
    ],
    "code_length": 384,
    "token_count": 104,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/adadelta/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1074,
    "Worst-caseLatency": 1074.0,
    "BRAM_18K": 0,
    "LUT": 2158,
    "DSP": 39,
    "FF": 3549,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adadelta",
    "ResourceMetric": 0.0018345674,
    "design_id": "project",
    "algo_name": "adadelta",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "adadelta.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid adadelta(float grad[ARRAY_SIZE], float accum_grad[ARRAY_SIZE], float accum_update[ARRAY_SIZE], float update[ARRAY_SIZE], float learning_rate, float decay_rate, float epsilon) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Accumulate gradient\n        accum_grad[i] = decay_rate * accum_grad[i] + (1 - decay_rate) * grad[i] * grad[i];\n        \n        // Compute update\n        update[i] = sqrt(accum_update[i] + epsilon) / sqrt(accum_grad[i] + epsilon) * grad[i];\n        \n        // Apply update\n        grad[i] -= learning_rate * update[i];\n        \n        // Accumulate updates\n        accum_update[i] = decay_rate * accum_update[i] + (1 - decay_rate) * update[i] * update[i];\n    }\n}\n\n// Top function name: adadelta\n"
      }
    ],
    "code_length": 777,
    "token_count": 202,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/adam_optimizer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1101,
    "Worst-caseLatency": 1101.0,
    "BRAM_18K": 10,
    "LUT": 25992,
    "DSP": 188,
    "FF": 13072,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adam_optimizer",
    "ResourceMetric": 0.0120661001,
    "design_id": "project",
    "algo_name": "adam_optimizer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "adam_optimizer.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid adam_optimizer(\n    float alpha, \n    float beta1, \n    float beta2, \n    float epsilon, \n    float weights[ARRAY_SIZE], \n    float gradients[ARRAY_SIZE], \n    float m[ARRAY_SIZE], \n    float v[ARRAY_SIZE], \n    float t)\n{\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Update biased first moment estimate\n        m[i] = beta1 * m[i] + (1 - beta1) * gradients[i];\n        \n        // Update biased second raw moment estimate\n        v[i] = beta2 * v[i] + (1 - beta2) * gradients[i] * gradients[i];\n        \n        // Compute bias-corrected first moment estimate\n        float m_hat = m[i] / (1 - pow(beta1, t));\n        \n        // Compute bias-corrected second raw moment estimate\n        float v_hat = v[i] / (1 - pow(beta2, t));\n        \n        // Update weights\n        weights[i] -= alpha * m_hat / (sqrt(v_hat) + epsilon);\n    }\n}\n\n// Top function name: adam_optimizer\n"
      }
    ],
    "code_length": 932,
    "token_count": 253,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adc_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adc_16bit",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "adc_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adc_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid adc_16bit(uint16_t input[ARRAY_SIZE], uint16_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint16_t sample = input[i];\n        // Simulate ADC processing (e.g., scaling, offset correction)\n        uint16_t processed_sample = (sample * 2) + 10;\n        output[i] = processed_sample;\n    }\n}\n\n// Top function name: adc_16bit\n"
      }
    ],
    "code_length": 403,
    "token_count": 113,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adc_24bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adc_24bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "adc_24bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adc_24bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid adc_24bit(uint32_t input[ARRAY_SIZE], uint32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t sample = input[i];\n        uint32_t processed_sample = (sample & 0xFFFFFF); // Mask to 24 bits\n        output[i] = processed_sample;\n    }\n}\n\n// Top function name: adc_24bit\n"
      }
    ],
    "code_length": 354,
    "token_count": 102,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adc_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adc_8bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "adc_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adc_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid adc_8bit(uint8_t input[SIZE], uint8_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        uint8_t sample = input[i];\n        output[i] = sample;\n    }\n}\n\n// Top function name: adc_8bit\n"
      }
    ],
    "code_length": 239,
    "token_count": 76,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adder_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adder_16bit",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "adder_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adder_16bit.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid adder_16bit(uint16_t A[ARRAY_SIZE], uint16_t B[ARRAY_SIZE], uint16_t C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: adder_16bit\n"
      }
    ],
    "code_length": 250,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adder_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adder_32bit",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "adder_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adder_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid adder_32bit(uint32_t in1[ARRAY_SIZE], uint32_t in2[ARRAY_SIZE], uint32_t out[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        out[i] = in1[i] + in2[i];\n    }\n}\n\n// Top function name: adder_32bit\n"
      }
    ],
    "code_length": 263,
    "token_count": 90,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adder_64bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 148,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adder_64bit",
    "ResourceMetric": 3.07783e-05,
    "design_id": "project",
    "algo_name": "adder_64bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adder_64bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid adder_64bit(ap_uint<64> in1[ARRAY_SIZE], ap_uint<64> in2[ARRAY_SIZE], ap_uint<64> out[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        out[i] = in1[i] + in2[i];\n    }\n}\n\n// Top function name: adder_64bit\n"
      }
    ],
    "code_length": 272,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/adder_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 92,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adder_8bit",
    "ResourceMetric": 2.00394e-05,
    "design_id": "project",
    "algo_name": "adder_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "adder_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid adder_8bit(uint8_t A[ARRAY_SIZE], uint8_t B[ARRAY_SIZE], uint8_t C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: adder_8bit\n"
      }
    ],
    "code_length": 246,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/address_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "address_comparator",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "address_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "address_comparator.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid address_comparator(uint32_t addr1[ARRAY_SIZE], uint32_t addr2[ARRAY_SIZE], bool result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result[i] = (addr1[i] == addr2[i]);\n    }\n}\n\n// Top function name: address_comparator\n"
      }
    ],
    "code_length": 290,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/adi/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 24920061501,
    "Worst-caseLatency": 24920061501.0,
    "BRAM_18K": 0,
    "LUT": 2976,
    "DSP": 17,
    "FF": 3019,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_adi",
    "ResourceMetric": 0.0013311275,
    "design_id": "project",
    "algo_name": "adi",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "adi.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _ADI_H\n# define _ADI_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(TSTEPS) && !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define TSTEPS 20\n#   define N 20\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define TSTEPS 40\n#   define N 60\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define TSTEPS 100\n#   define N 200\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define TSTEPS 500\n#   define N 1000\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define TSTEPS 1000\n#   define N 2000\n#  endif\n\n\n#endif /* !(TSTEPS N) */\n\n# define _PB_TSTEPS POLYBENCH_LOOP_BOUND(TSTEPS,tsteps)\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_ADI_H */\n"
      },
      {
        "file_name": "adi.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* adi.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"adi.h\"\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Based on a Fortran code fragment from Figure 5 of\n * \"Automatic Data and Computation Decomposition on Distributed Memory Parallel Computers\"\n * by Peizong Lee and Zvi Meir Kedem, TOPLAS, 2002\n */\nvoid kernel_adi(int tsteps, int n,\n\t\tDATA_TYPE POLYBENCH_2D(u,N,N,n,n),\n\t\tDATA_TYPE POLYBENCH_2D(v,N,N,n,n),\n\t\tDATA_TYPE POLYBENCH_2D(p,N,N,n,n),\n\t\tDATA_TYPE POLYBENCH_2D(q,N,N,n,n))\n{\n  int t, i, j;\n  DATA_TYPE DX, DY, DT;\n  DATA_TYPE B1, B2;\n  DATA_TYPE mul1, mul2;\n  DATA_TYPE a, b, c, d, e, f;\n\n#pragma scop\n\n  DX = SCALAR_VAL(1.0)/(DATA_TYPE)_PB_N;\n  DY = SCALAR_VAL(1.0)/(DATA_TYPE)_PB_N;\n  DT = SCALAR_VAL(1.0)/(DATA_TYPE)_PB_TSTEPS;\n  B1 = SCALAR_VAL(2.0);\n  B2 = SCALAR_VAL(1.0);\n  mul1 = B1 * DT / (DX * DX);\n  mul2 = B2 * DT / (DY * DY);\n\n  a = -mul1 /  SCALAR_VAL(2.0);\n  b = SCALAR_VAL(1.0)+mul1;\n  c = a;\n  d = -mul2 / SCALAR_VAL(2.0);\n  e = SCALAR_VAL(1.0)+mul2;\n  f = d;\n\n for (t=1; t<=_PB_TSTEPS; t++) {\n    //Column Sweep\n    for (i=1; i<_PB_N-1; i++) {\n      v[0][i] = SCALAR_VAL(1.0);\n      p[i][0] = SCALAR_VAL(0.0);\n      q[i][0] = v[0][i];\n      for (j=1; j<_PB_N-1; j++) {\n        p[i][j] = -c / (a*p[i][j-1]+b);\n        q[i][j] = (-d*u[j][i-1]+(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*d)*u[j][i] - f*u[j][i+1]-a*q[i][j-1])/(a*p[i][j-1]+b);\n      }\n\n      v[_PB_N-1][i] = SCALAR_VAL(1.0);\n      for (j=_PB_N-2; j>=1; j--) {\n        v[j][i] = p[i][j] * v[j+1][i] + q[i][j];\n      }\n    }\n    //Row Sweep\n    for (i=1; i<_PB_N-1; i++) {\n      u[i][0] = SCALAR_VAL(1.0);\n      p[i][0] = SCALAR_VAL(0.0);\n      q[i][0] = u[i][0];\n      for (j=1; j<_PB_N-1; j++) {\n        p[i][j] = -f / (d*p[i][j-1]+e);\n        q[i][j] = (-a*v[i-1][j]+(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*a)*v[i][j] - c*v[i+1][j]-d*q[i][j-1])/(d*p[i][j-1]+e);\n      }\n      u[i][_PB_N-1] = SCALAR_VAL(1.0);\n      for (j=_PB_N-2; j>=1; j--) {\n        u[i][j] = p[i][j] * u[i][j+1] + q[i][j];\n      }\n    }\n  }\n#pragma endscop\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 2457,
    "token_count": 1008,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/adjusted_mutual_information/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8392862,
    "Worst-caseLatency": 8392862.0,
    "BRAM_18K": 2052,
    "LUT": 6224,
    "DSP": 74,
    "FF": 6044,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adjusted_mutual_information",
    "ResourceMetric": 0.1310552893,
    "design_id": "project",
    "algo_name": "adjusted_mutual_information",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "adjusted_mutual_information.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid adjusted_mutual_information(int labels_true[N], int labels_pred[N], double *ami) {\n    int contingency[N][N] = {0};\n    int true_sum[N] = {0};\n    int pred_sum[N] = {0};\n    int total_sum = 0;\n\n    // Calculate contingency matrix\n    for (int i = 0; i < N; i++) {\n        contingency[labels_true[i]][labels_pred[i]]++;\n    }\n\n    // Calculate sums for true and predicted labels\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            true_sum[i] += contingency[i][j];\n            pred_sum[j] += contingency[i][j];\n            total_sum += contingency[i][j];\n        }\n    }\n\n    // Calculate mutual information\n    double mi = 0.0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (contingency[i][j] > 0) {\n                mi += contingency[i][j] * log((double)contingency[i][j] * total_sum / (true_sum[i] * pred_sum[j]));\n            }\n        }\n    }\n    mi /= total_sum;\n\n    // Calculate entropy for true and predicted labels\n    double h_true = 0.0;\n    double h_pred = 0.0;\n    for (int i = 0; i < N; i++) {\n        if (true_sum[i] > 0) {\n            h_true -= true_sum[i] * log((double)true_sum[i] / total_sum);\n        }\n        if (pred_sum[i] > 0) {\n            h_pred -= pred_sum[i] * log((double)pred_sum[i] / total_sum);\n        }\n    }\n    h_true /= total_sum;\n    h_pred /= total_sum;\n\n    // Calculate expected mutual information\n    double emi = 0.0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (true_sum[i] > 0 && pred_sum[j] > 0) {\n                emi += (double)true_sum[i] * pred_sum[j] / total_sum * log((double)true_sum[i] * pred_sum[j] / total_sum / total_sum);\n            }\n        }\n    }\n    emi /= total_sum;\n\n    // Calculate adjusted mutual information\n    *ami = (mi - emi) / (std::max(h_true, h_pred) - emi);\n}\n\n// Top function name: adjusted_mutual_information\n"
      }
    ],
    "code_length": 1964,
    "token_count": 591,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/adjusted_r_squared/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6202,
    "Worst-caseLatency": 6202.0,
    "BRAM_18K": 0,
    "LUT": 2353,
    "DSP": 14,
    "FF": 2136,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adjusted_r_squared",
    "ResourceMetric": 0.0010438822,
    "design_id": "project",
    "algo_name": "adjusted_r_squared",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "adjusted_r_squared.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid adjusted_r_squared(double y[N], double y_pred[N], int p, double &adj_r2) {\n    double ss_tot = 0.0;\n    double ss_res = 0.0;\n    double mean_y = 0.0;\n\n    // Calculate mean of y\n    for (int i = 0; i < N; i++) {\n        mean_y += y[i];\n    }\n    mean_y /= N;\n\n    // Calculate ss_tot and ss_res\n    for (int i = 0; i < N; i++) {\n        ss_tot += (y[i] - mean_y) * (y[i] - mean_y);\n        ss_res += (y[i] - y_pred[i]) * (y[i] - y_pred[i]);\n    }\n\n    // Calculate R-squared\n    double r2 = 1.0 - (ss_res / ss_tot);\n\n    // Calculate Adjusted R-squared\n    adj_r2 = 1.0 - ((1.0 - r2) * (N - 1) / (N - p - 1));\n}\n\n// Top function name: adjusted_r_squared\n"
      }
    ],
    "code_length": 693,
    "token_count": 249,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/adpcm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1596,
    "Worst-caseLatency": 1596.0,
    "BRAM_18K": 0,
    "LUT": 15849,
    "DSP": 149,
    "FF": 6264,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "main",
    "ResourceMetric": 0.0077677698,
    "design_id": "project",
    "algo_name": "adpcm",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "adpcm.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*************************************************************************/\n/*                                                                       */\n/*   SNU-RT Benchmark Suite for Worst Case Timing Analysis               */\n/*   =====================================================               */\n/*                              Collected and Modified by S.-S. Lim      */\n/*                                           sslim@archi.snu.ac.kr       */\n/*                                         Real-Time Research Group      */\n/*                                        Seoul National University      */\n/*                                                                       */\n/*                                                                       */\n/*        < Features > - restrictions for our experimental environment   */\n/*                                                                       */\n/*          1. Completely structured.                                    */\n/*               - There are no unconditional jumps.                     */\n/*               - There are no exit from loop bodies.                   */\n/*                 (There are no 'break' or 'return' in loop bodies)     */\n/*          2. No 'switch' statements.                                   */\n/*          3. No 'do..while' statements.                                */\n/*          4. Expressions are restricted.                               */\n/*               - There are no multiple expressions joined by 'or',     */\n/*                'and' operations.                                      */\n/*          5. No library calls.                                         */\n/*               - All the functions needed are implemented in the       */\n/*                 source file.                                          */\n/*                                                                       */\n/*                                                                       */\n/*************************************************************************/\n/*                                                                       */\n/*  FILE: adpcm.c                                                        */\n/*  SOURCE : C Algorithms for Real-Time DSP by P. M. Embree              */\n/*                                                                       */\n/*  DESCRIPTION :                                                        */\n/*                                                                       */\n/*     CCITT G.722 ADPCM (Adaptive Differential Pulse Code Modulation)   */\n/*     algorithm.                                                        */\n/*     16khz sample rate data is stored in the array test_data[SIZE].    */\n/*     Results are stored in the array compressed[SIZE] and result[SIZE].*/\n/*     Execution time is determined by the constant SIZE (default value  */\n/*     is 2000).                                                         */\n/*                                                                       */\n/*  REMARK :                                                             */\n/*                                                                       */\n/*  EXECUTION TIME :                                                     */\n/*                                                                       */\n/*                                                                       */\n/*************************************************************************/\n#include <stdio.h>\n\nint encode (int, int);\nvoid decode (int);\nint filtez (int *bpl, int *dlt);\nvoid upzero (int dlt, int *dlti, int *bli);\nint filtep (int rlt1, int al1, int rlt2, int al2);\nint quantl (int el, int detl);\nint logscl (int il, int nbl);\nint scalel (int nbl, int shift_constant);\nint uppol2 (int al1, int al2, int plt, int plt1, int plt2);\nint uppol1 (int al1, int apl2, int plt, int plt1);\nint logsch (int ih, int nbh);\nvoid reset ();\n\n/* G722 C code */\n\n/* variables for transimit quadrature mirror filter here */\nint tqmf[24];\n\n/* QMF filter coefficients:\nscaled by a factor of 4 compared to G722 CCITT recomendation */\nconst int h[24] = {\n  12, -44, -44, 212, 48, -624, 128, 1448,\n  -840, -3220, 3804, 15504, 15504, 3804, -3220, -840,\n  1448, 128, -624, 48, 212, -44, -44, 12\n};\n\nint xl, xh;\n\n/* variables for receive quadrature mirror filter here */\nint accumc[11], accumd[11];\n\n/* outputs of decode() */\nint xout1, xout2;\n\nint xs, xd;\n\n/* variables for encoder (hi and lo) here */\n\nint il, szl, spl, sl, el;\n\nconst int qq4_code4_table[16] = {\n  0, -20456, -12896, -8968, -6288, -4240, -2584, -1200,\n  20456, 12896, 8968, 6288, 4240, 2584, 1200, 0\n};\n\n\nconst int qq6_code6_table[64] = {\n  -136, -136, -136, -136, -24808, -21904, -19008, -16704,\n  -14984, -13512, -12280, -11192, -10232, -9360, -8576, -7856,\n  -7192, -6576, -6000, -5456, -4944, -4464, -4008, -3576,\n  -3168, -2776, -2400, -2032, -1688, -1360, -1040, -728,\n  24808, 21904, 19008, 16704, 14984, 13512, 12280, 11192,\n  10232, 9360, 8576, 7856, 7192, 6576, 6000, 5456,\n  4944, 4464, 4008, 3576, 3168, 2776, 2400, 2032,\n  1688, 1360, 1040, 728, 432, 136, -432, -136\n};\n\nint delay_bpl[6];\n\nint delay_dltx[6];\n\nconst int wl_code_table[16] = {\n  -60, 3042, 1198, 538, 334, 172, 58, -30,\n  3042, 1198, 538, 334, 172, 58, -30, -60\n};\n\nconst int ilb_table[32] = {\n  2048, 2093, 2139, 2186, 2233, 2282, 2332, 2383,\n  2435, 2489, 2543, 2599, 2656, 2714, 2774, 2834,\n  2896, 2960, 3025, 3091, 3158, 3228, 3298, 3371,\n  3444, 3520, 3597, 3676, 3756, 3838, 3922, 4008\n};\n\nint nbl;\t\t\t/* delay line */\nint al1, al2;\nint plt, plt1, plt2;\nint dlt;\nint rlt, rlt1, rlt2;\n\n/* decision levels - pre-multiplied by 8, 0 to indicate end */\nconst int decis_levl[30] = {\n  280, 576, 880, 1200, 1520, 1864, 2208, 2584,\n  2960, 3376, 3784, 4240, 4696, 5200, 5712, 6288,\n  6864, 7520, 8184, 8968, 9752, 10712, 11664, 12896,\n  14120, 15840, 17560, 20456, 23352, 32767\n};\n\nint detl;\n\n/* quantization table 31 long to make quantl look-up easier,\nlast entry is for mil=30 case when wd is max */\nconst int quant26bt_pos[31] = {\n  61, 60, 59, 58, 57, 56, 55, 54,\n  53, 52, 51, 50, 49, 48, 47, 46,\n  45, 44, 43, 42, 41, 40, 39, 38,\n  37, 36, 35, 34, 33, 32, 32\n};\n\n/* quantization table 31 long to make quantl look-up easier,\nlast entry is for mil=30 case when wd is max */\nconst int quant26bt_neg[31] = {\n  63, 62, 31, 30, 29, 28, 27, 26,\n  25, 24, 23, 22, 21, 20, 19, 18,\n  17, 16, 15, 14, 13, 12, 11, 10,\n  9, 8, 7, 6, 5, 4, 4\n};\n\n\nint deth;\nint sh;\t\t\t\t/* this comes from adaptive predictor */\nint eh;\n\nconst int qq2_code2_table[4] = {\n  -7408, -1616, 7408, 1616\n};\n\nconst int wh_code_table[4] = {\n  798, -214, 798, -214\n};\n\n\nint dh, ih;\nint nbh, szh;\nint sph, ph, yh, rh;\n\nint delay_dhx[6];\n\nint delay_bph[6];\n\nint ah1, ah2;\nint ph1, ph2;\nint rh1, rh2;\n\n/* variables for decoder here */\nint ilr, rl;\nint dec_deth, dec_detl, dec_dlt;\n\nint dec_del_bpl[6];\n\nint dec_del_dltx[6];\n\nint dec_plt, dec_plt1, dec_plt2;\nint dec_szl, dec_spl, dec_sl;\nint dec_rlt1, dec_rlt2, dec_rlt;\nint dec_al1, dec_al2;\nint dl;\nint dec_nbl, dec_dh, dec_nbh;\n\n/* variables used in filtez */\nint dec_del_bph[6];\n\nint dec_del_dhx[6];\n\nint dec_szh;\n/* variables used in filtep */\nint dec_rh1, dec_rh2;\nint dec_ah1, dec_ah2;\nint dec_ph, dec_sph;\n\nint dec_sh;\n\nint dec_ph1, dec_ph2;\n\n/* G722 encode function two ints in, one 8 bit output */\n\n/* put input samples in xin1 = first value, xin2 = second value */\n/* returns il and ih stored together */\n\nint\nabs (int n)\n{\n  int m;\n\n  if (n >= 0)\n    m = n;\n  else\n    m = -n;\n  return m;\n}\n\nint\nencode (int xin1, int xin2)\n{\n  int i;\n  const int *h_ptr;\n  int *tqmf_ptr, *tqmf_ptr1;\n  long int xa, xb;\n  int decis;\n\n/* transmit quadrature mirror filters implemented here */\n  h_ptr = h;\n  tqmf_ptr = tqmf;\n  xa = (long) (*tqmf_ptr++) * (*h_ptr++);\n  xb = (long) (*tqmf_ptr++) * (*h_ptr++);\n/* main multiply accumulate loop for samples and coefficients */\n  for (i = 0; i < 10; i++)\n    {\n      xa += (long) (*tqmf_ptr++) * (*h_ptr++);\n      xb += (long) (*tqmf_ptr++) * (*h_ptr++);\n    }\n/* final mult/accumulate */\n  xa += (long) (*tqmf_ptr++) * (*h_ptr++);\n  xb += (long) (*tqmf_ptr) * (*h_ptr++);\n\n/* update delay line tqmf */\n  tqmf_ptr1 = tqmf_ptr - 2;\n  for (i = 0; i < 22; i++)\n    *tqmf_ptr-- = *tqmf_ptr1--;\n  *tqmf_ptr-- = xin1;\n  *tqmf_ptr = xin2;\n\n/* scale outputs */\n  xl = (xa + xb) >> 15;\n  xh = (xa - xb) >> 15;\n\n/* end of quadrature mirror filter code */\n\n/* starting with lower sub band encoder */\n\n/* filtez - compute predictor output section - zero section */\n  szl = filtez (delay_bpl, delay_dltx);\n\n/* filtep - compute predictor output signal (pole section) */\n  spl = filtep (rlt1, al1, rlt2, al2);\n\n/* compute the predictor output value in the lower sub_band encoder */\n  sl = szl + spl;\n  el = xl - sl;\n\n/* quantl: quantize the difference signal */\n  il = quantl (el, detl);\n\n/* computes quantized difference signal */\n/* for invqbl, truncate by 2 lsbs, so mode = 3 */\n  dlt = ((long) detl * qq4_code4_table[il >> 2]) >> 15;\n\n/* logscl: updates logarithmic quant. scale factor in low sub band */\n  nbl = logscl (il, nbl);\n\n/* scalel: compute the quantizer scale factor in the lower sub band */\n/* calling parameters nbl and 8 (constant such that scalel can be scaleh) */\n  detl = scalel (nbl, 8);\n\n/* parrec - simple addition to compute recontructed signal for adaptive pred */\n  plt = dlt + szl;\n\n/* upzero: update zero section predictor coefficients (sixth order)*/\n/* calling parameters: dlt, dlt1, dlt2, ..., dlt6 from dlt */\n/*  bpli (linear_buffer in which all six values are delayed */\n/* return params:      updated bpli, delayed dltx */\n  upzero (dlt, delay_dltx, delay_bpl);\n\n/* uppol2- update second predictor coefficient apl2 and delay it as al2 */\n/* calling parameters: al1, al2, plt, plt1, plt2 */\n  al2 = uppol2 (al1, al2, plt, plt1, plt2);\n\n/* uppol1 :update first predictor coefficient apl1 and delay it as al1 */\n/* calling parameters: al1, apl2, plt, plt1 */\n  al1 = uppol1 (al1, al2, plt, plt1);\n\n/* recons : compute recontructed signal for adaptive predictor */\n  rlt = sl + dlt;\n\n/* done with lower sub_band encoder; now implement delays for next time*/\n  rlt2 = rlt1;\n  rlt1 = rlt;\n  plt2 = plt1;\n  plt1 = plt;\n\n/* high band encode */\n\n  szh = filtez (delay_bph, delay_dhx);\n\n  sph = filtep (rh1, ah1, rh2, ah2);\n\n/* predic: sh = sph + szh */\n  sh = sph + szh;\n/* subtra: eh = xh - sh */\n  eh = xh - sh;\n\n/* quanth - quantization of difference signal for higher sub-band */\n/* quanth: in-place for speed params: eh, deth (has init. value) */\n  if (eh >= 0)\n    {\n      ih = 3;\t\t\t/* 2,3 are pos codes */\n    }\n  else\n    {\n      ih = 1;\t\t\t/* 0,1 are neg codes */\n    }\n  decis = (564L * (long) deth) >> 12L;\n  if (abs (eh) > decis)\n    ih--;\t\t\t/* mih = 2 case */\n\n/* compute the quantized difference signal, higher sub-band*/\n  dh = ((long) deth * qq2_code2_table[ih]) >> 15L;\n\n/* logsch: update logarithmic quantizer scale factor in hi sub-band*/\n  nbh = logsch (ih, nbh);\n\n/* note : scalel and scaleh use same code, different parameters */\n  deth = scalel (nbh, 10);\n\n/* parrec - add pole predictor output to quantized diff. signal */\n  ph = dh + szh;\n\n/* upzero: update zero section predictor coefficients (sixth order) */\n/* calling parameters: dh, dhi, bphi */\n/* return params: updated bphi, delayed dhx */\n  upzero (dh, delay_dhx, delay_bph);\n\n/* uppol2: update second predictor coef aph2 and delay as ah2 */\n/* calling params: ah1, ah2, ph, ph1, ph2 */\n  ah2 = uppol2 (ah1, ah2, ph, ph1, ph2);\n\n/* uppol1:  update first predictor coef. aph2 and delay it as ah1 */\n  ah1 = uppol1 (ah1, ah2, ph, ph1);\n\n/* recons for higher sub-band */\n  yh = sh + dh;\n\n/* done with higher sub-band encoder, now Delay for next time */\n  rh2 = rh1;\n  rh1 = yh;\n  ph2 = ph1;\n  ph1 = ph;\n\n/* multiplex ih and il to get signals together */\n  return (il | (ih << 6));\n}\n\n/* decode function, result in xout1 and xout2 */\n\nvoid\ndecode (int input)\n{\n  int i;\n  long int xa1, xa2;\t\t/* qmf accumulators */\n  const int *h_ptr;\n  int *ac_ptr, *ac_ptr1, *ad_ptr, *ad_ptr1;\n\n/* split transmitted word from input into ilr and ih */\n  ilr = input & 0x3f;\n  ih = input >> 6;\n\n/* LOWER SUB_BAND DECODER */\n\n/* filtez: compute predictor output for zero section */\n  dec_szl = filtez (dec_del_bpl, dec_del_dltx);\n\n/* filtep: compute predictor output signal for pole section */\n  dec_spl = filtep (dec_rlt1, dec_al1, dec_rlt2, dec_al2);\n\n  dec_sl = dec_spl + dec_szl;\n\n/* compute quantized difference signal for adaptive predic */\n  dec_dlt = ((long) dec_detl * qq4_code4_table[ilr >> 2]) >> 15;\n\n/* compute quantized difference signal for decoder output */\n  dl = ((long) dec_detl * qq6_code6_table[il]) >> 15;\n\n  rl = dl + dec_sl;\n\n/* logscl: quantizer scale factor adaptation in the lower sub-band */\n  dec_nbl = logscl (ilr, dec_nbl);\n\n/* scalel: computes quantizer scale factor in the lower sub band */\n  dec_detl = scalel (dec_nbl, 8);\n\n/* parrec - add pole predictor output to quantized diff. signal */\n/* for partially reconstructed signal */\n  dec_plt = dec_dlt + dec_szl;\n\n/* upzero: update zero section predictor coefficients */\n  upzero (dec_dlt, dec_del_dltx, dec_del_bpl);\n\n/* uppol2: update second predictor coefficient apl2 and delay it as al2 */\n  dec_al2 = uppol2 (dec_al1, dec_al2, dec_plt, dec_plt1, dec_plt2);\n\n/* uppol1: update first predictor coef. (pole setion) */\n  dec_al1 = uppol1 (dec_al1, dec_al2, dec_plt, dec_plt1);\n\n/* recons : compute recontructed signal for adaptive predictor */\n  dec_rlt = dec_sl + dec_dlt;\n\n/* done with lower sub band decoder, implement delays for next time */\n  dec_rlt2 = dec_rlt1;\n  dec_rlt1 = dec_rlt;\n  dec_plt2 = dec_plt1;\n  dec_plt1 = dec_plt;\n\n/* HIGH SUB-BAND DECODER */\n\n/* filtez: compute predictor output for zero section */\n  dec_szh = filtez (dec_del_bph, dec_del_dhx);\n\n/* filtep: compute predictor output signal for pole section */\n  dec_sph = filtep (dec_rh1, dec_ah1, dec_rh2, dec_ah2);\n\n/* predic:compute the predictor output value in the higher sub_band decoder */\n  dec_sh = dec_sph + dec_szh;\n\n/* in-place compute the quantized difference signal */\n  dec_dh = ((long) dec_deth * qq2_code2_table[ih]) >> 15L;\n\n/* logsch: update logarithmic quantizer scale factor in hi sub band */\n  dec_nbh = logsch (ih, dec_nbh);\n\n/* scalel: compute the quantizer scale factor in the higher sub band */\n  dec_deth = scalel (dec_nbh, 10);\n\n/* parrec: compute partially recontructed signal */\n  dec_ph = dec_dh + dec_szh;\n\n/* upzero: update zero section predictor coefficients */\n  upzero (dec_dh, dec_del_dhx, dec_del_bph);\n\n/* uppol2: update second predictor coefficient aph2 and delay it as ah2 */\n  dec_ah2 = uppol2 (dec_ah1, dec_ah2, dec_ph, dec_ph1, dec_ph2);\n\n/* uppol1: update first predictor coef. (pole setion) */\n  dec_ah1 = uppol1 (dec_ah1, dec_ah2, dec_ph, dec_ph1);\n\n/* recons : compute recontructed signal for adaptive predictor */\n  rh = dec_sh + dec_dh;\n\n/* done with high band decode, implementing delays for next time here */\n  dec_rh2 = dec_rh1;\n  dec_rh1 = rh;\n  dec_ph2 = dec_ph1;\n  dec_ph1 = dec_ph;\n\n/* end of higher sub_band decoder */\n\n/* end with receive quadrature mirror filters */\n  xd = rl - rh;\n  xs = rl + rh;\n\n/* receive quadrature mirror filters implemented here */\n  h_ptr = h;\n  ac_ptr = accumc;\n  ad_ptr = accumd;\n  xa1 = (long) xd *(*h_ptr++);\n  xa2 = (long) xs *(*h_ptr++);\n/* main multiply accumulate loop for samples and coefficients */\n  for (i = 0; i < 10; i++)\n    {\n      xa1 += (long) (*ac_ptr++) * (*h_ptr++);\n      xa2 += (long) (*ad_ptr++) * (*h_ptr++);\n    }\n/* final mult/accumulate */\n  xa1 += (long) (*ac_ptr) * (*h_ptr++);\n  xa2 += (long) (*ad_ptr) * (*h_ptr++);\n\n/* scale by 2^14 */\n  xout1 = xa1 >> 14;\n  xout2 = xa2 >> 14;\n\n/* update delay lines */\n  ac_ptr1 = ac_ptr - 1;\n  ad_ptr1 = ad_ptr - 1;\n  for (i = 0; i < 10; i++)\n    {\n      *ac_ptr-- = *ac_ptr1--;\n      *ad_ptr-- = *ad_ptr1--;\n    }\n  *ac_ptr = xd;\n  *ad_ptr = xs;\n}\n\n/* clear all storage locations */\n\nvoid\nreset ()\n{\n  int i;\n\n  detl = dec_detl = 32;\t\t/* reset to min scale factor */\n  deth = dec_deth = 8;\n  nbl = al1 = al2 = plt1 = plt2 = rlt1 = rlt2 = 0;\n  nbh = ah1 = ah2 = ph1 = ph2 = rh1 = rh2 = 0;\n  dec_nbl = dec_al1 = dec_al2 = dec_plt1 = dec_plt2 = dec_rlt1 = dec_rlt2 = 0;\n  dec_nbh = dec_ah1 = dec_ah2 = dec_ph1 = dec_ph2 = dec_rh1 = dec_rh2 = 0;\n\n  for (i = 0; i < 6; i++)\n    {\n      delay_dltx[i] = 0;\n      delay_dhx[i] = 0;\n      dec_del_dltx[i] = 0;\n      dec_del_dhx[i] = 0;\n    }\n\n  for (i = 0; i < 6; i++)\n    {\n      delay_bpl[i] = 0;\n      delay_bph[i] = 0;\n      dec_del_bpl[i] = 0;\n      dec_del_bph[i] = 0;\n    }\n\n  for (i = 0; i < 24; i++)\n    tqmf[i] = 0;\t\t// i<23\n\n  for (i = 0; i < 11; i++)\n    {\n      accumc[i] = 0;\n      accumd[i] = 0;\n    }\n}\n\n/* filtez - compute predictor output signal (zero section) */\n/* input: bpl1-6 and dlt1-6, output: szl */\n\nint\nfiltez (int *bpl, int *dlt)\n{\n  int i;\n  long int zl;\n  zl = (long) (*bpl++) * (*dlt++);\n  for (i = 1; i < 6; i++)\n    zl += (long) (*bpl++) * (*dlt++);\n\n  return ((int) (zl >> 14));\t/* x2 here */\n}\n\n/* filtep - compute predictor output signal (pole section) */\n/* input rlt1-2 and al1-2, output spl */\n\nint\nfiltep (int rlt1, int al1, int rlt2, int al2)\n{\n  long int pl, pl2;\n  pl = 2 * rlt1;\n  pl = (long) al1 *pl;\n  pl2 = 2 * rlt2;\n  pl += (long) al2 *pl2;\n  return ((int) (pl >> 15));\n}\n\n/* quantl - quantize the difference signal in the lower sub-band */\nint\nquantl (int el, int detl)\n{\n  int ril, mil;\n  long int wd, decis;\n\n/* abs of difference signal */\n  wd = abs (el);\n/* determine mil based on decision levels and detl gain */\n  for (mil = 0; mil < 30; mil++)\n    {\n      decis = (decis_levl[mil] * (long) detl) >> 15L;\n      if (wd <= decis)\n\tbreak;\n    }\n/* if mil=30 then wd is less than all decision levels */\n  if (el >= 0)\n    ril = quant26bt_pos[mil];\n  else\n    ril = quant26bt_neg[mil];\n  return (ril);\n}\n\n/* logscl - update log quantizer scale factor in lower sub-band */\n/* note that nbl is passed and returned */\n\nint\nlogscl (int il, int nbl)\n{\n  long int wd;\n  wd = ((long) nbl * 127L) >> 7L;\t/* leak factor 127/128 */\n  nbl = (int) wd + wl_code_table[il >> 2];\n  if (nbl < 0)\n    nbl = 0;\n  if (nbl > 18432)\n    nbl = 18432;\n  return (nbl);\n}\n\n/* scalel: compute quantizer scale factor in lower or upper sub-band*/\n\nint\nscalel (int nbl, int shift_constant)\n{\n  int wd1, wd2, wd3;\n  wd1 = (nbl >> 6) & 31;\n  wd2 = nbl >> 11;\n  wd3 = ilb_table[wd1] >> (shift_constant + 1 - wd2);\n  return (wd3 << 3);\n}\n\n/* upzero - inputs: dlt, dlti[0-5], bli[0-5], outputs: updated bli[0-5] */\n/* also implements delay of bli and update of dlti from dlt */\n\nvoid\nupzero (int dlt, int *dlti, int *bli)\n{\n  int i, wd2, wd3;\n/*if dlt is zero, then no sum into bli */\n  if (dlt == 0)\n    {\n      for (i = 0; i < 6; i++)\n\t{\n\t  bli[i] = (int) ((255L * bli[i]) >> 8L);\t/* leak factor of 255/256 */\n\t}\n    }\n  else\n    {\n      for (i = 0; i < 6; i++)\n\t{\n\t  if ((long) dlt * dlti[i] >= 0)\n\t    wd2 = 128;\n\t  else\n\t    wd2 = -128;\n\t  wd3 = (int) ((255L * bli[i]) >> 8L);\t/* leak factor of 255/256 */\n\t  bli[i] = wd2 + wd3;\n\t}\n    }\n/* implement delay line for dlt */\n  dlti[5] = dlti[4];\n  dlti[4] = dlti[3];\n  dlti[3] = dlti[2];\n  dlti[2] = dlti[1];\n  dlti[1] = dlti[0];\n  dlti[0] = dlt;\n}\n\n/* uppol2 - update second predictor coefficient (pole section) */\n/* inputs: al1, al2, plt, plt1, plt2. outputs: apl2 */\n\nint\nuppol2 (int al1, int al2, int plt, int plt1, int plt2)\n{\n  long int wd2, wd4;\n  int apl2;\n  wd2 = 4L * (long) al1;\n  if ((long) plt * plt1 >= 0L)\n    wd2 = -wd2;\t\t\t/* check same sign */\n  wd2 = wd2 >> 7;\t\t/* gain of 1/128 */\n  if ((long) plt * plt2 >= 0L)\n    {\n      wd4 = wd2 + 128;\t\t/* same sign case */\n    }\n  else\n    {\n      wd4 = wd2 - 128;\n    }\n  apl2 = wd4 + (127L * (long) al2 >> 7L);\t/* leak factor of 127/128 */\n\n/* apl2 is limited to +-.75 */\n  if (apl2 > 12288)\n    apl2 = 12288;\n  if (apl2 < -12288)\n    apl2 = -12288;\n  return (apl2);\n}\n\n/* uppol1 - update first predictor coefficient (pole section) */\n/* inputs: al1, apl2, plt, plt1. outputs: apl1 */\n\nint\nuppol1 (int al1, int apl2, int plt, int plt1)\n{\n  long int wd2;\n  int wd3, apl1;\n  wd2 = ((long) al1 * 255L) >> 8L;\t/* leak factor of 255/256 */\n  if ((long) plt * plt1 >= 0L)\n    {\n      apl1 = (int) wd2 + 192;\t/* same sign case */\n    }\n  else\n    {\n      apl1 = (int) wd2 - 192;\n    }\n/* note: wd3= .9375-.75 is always positive */\n  wd3 = 15360 - apl2;\t\t/* limit value */\n  if (apl1 > wd3)\n    apl1 = wd3;\n  if (apl1 < -wd3)\n    apl1 = -wd3;\n  return (apl1);\n}\n\n/* logsch - update log quantizer scale factor in higher sub-band */\n/* note that nbh is passed and returned */\n\nint\nlogsch (int ih, int nbh)\n{\n  int wd;\n  wd = ((long) nbh * 127L) >> 7L;\t/* leak factor 127/128 */\n  nbh = wd + wh_code_table[ih];\n  if (nbh < 0)\n    nbh = 0;\n  if (nbh > 22528)\n    nbh = 22528;\n  return (nbh);\n}\n\n/*\n+--------------------------------------------------------------------------+\n| * Test Vectors (added for CHStone)                                       |\n|     test_data : input data                                               |\n|     test_compressed : expected output data for \"encode\"                  |\n|     test_result : expected output data for \"decode\"                      |\n+--------------------------------------------------------------------------+\n*/\n\n#define SIZE 100\n#define IN_END 100\n\nconst int test_data[SIZE] = {\n  0x44, 0x44, 0x44, 0x44, 0x44,\n  0x44, 0x44, 0x44, 0x44, 0x44,\n  0x44, 0x44, 0x44, 0x44, 0x44,\n  0x44, 0x44, 0x43, 0x43, 0x43,\n  0x43, 0x43, 0x43, 0x43, 0x42,\n  0x42, 0x42, 0x42, 0x42, 0x42,\n  0x41, 0x41, 0x41, 0x41, 0x41,\n  0x40, 0x40, 0x40, 0x40, 0x40,\n  0x40, 0x40, 0x40, 0x3f, 0x3f,\n  0x3f, 0x3f, 0x3f, 0x3e, 0x3e,\n  0x3e, 0x3e, 0x3e, 0x3e, 0x3d,\n  0x3d, 0x3d, 0x3d, 0x3d, 0x3d,\n  0x3c, 0x3c, 0x3c, 0x3c, 0x3c,\n  0x3c, 0x3c, 0x3c, 0x3c, 0x3b,\n  0x3b, 0x3b, 0x3b, 0x3b, 0x3b,\n  0x3b, 0x3b, 0x3b, 0x3b, 0x3b,\n  0x3b, 0x3b, 0x3b, 0x3b, 0x3b,\n  0x3b, 0x3b, 0x3b, 0x3b, 0x3b,\n  0x3b, 0x3b, 0x3c, 0x3c, 0x3c,\n  0x3c, 0x3c, 0x3c, 0x3c, 0x3c\n};\nint compressed[SIZE], result[SIZE];\nconst int test_compressed[SIZE] = {\n  0xfd, 0xde, 0x77, 0xba, 0xf2, \n  0x90, 0x20, 0xa0, 0xec, 0xed, \n  0xef, 0xf1, 0xf3, 0xf4, 0xf5, \n  0xf5, 0xf5, 0xf5, 0xf6, 0xf6, \n  0xf6, 0xf7, 0xf8, 0xf7, 0xf8, \n  0xf7, 0xf9, 0xf8, 0xf7, 0xf9, \n  0xf8, 0xf8, 0xf6, 0xf8, 0xf8, \n  0xf7, 0xf9, 0xf9, 0xf9, 0xf8, \n  0xf7, 0xfa, 0xf8, 0xf8, 0xf7, \n  0xfb, 0xfa, 0xf9, 0xf8, 0xf8\n};\nconst int test_result[SIZE] = {\n  0, 0xffffffff, 0xffffffff, 0, 0, \n  0xffffffff, 0, 0, 0xffffffff, 0xffffffff, \n  0, 0, 0x1, 0x1, 0, \n  0xfffffffe, 0xffffffff, 0xfffffffe, 0, 0xfffffffc, \n  0x1, 0x1, 0x1, 0xfffffffb, 0x2, \n  0x2, 0x3, 0xb, 0x14, 0x14, \n  0x16, 0x18, 0x20, 0x21, 0x26, \n  0x27, 0x2e, 0x2f, 0x33, 0x32, \n  0x35, 0x33, 0x36, 0x34, 0x37, \n  0x34, 0x37, 0x35, 0x38, 0x36, \n  0x39, 0x38, 0x3b, 0x3a, 0x3f, \n  0x3f, 0x40, 0x3a, 0x3d, 0x3e, \n  0x41, 0x3c, 0x3e, 0x3f, 0x42, \n  0x3e, 0x3b, 0x37, 0x3b, 0x3e, \n  0x41, 0x3b, 0x3b, 0x3a, 0x3b, \n  0x36, 0x39, 0x3b, 0x3f, 0x3c, \n  0x3b, 0x37, 0x3b, 0x3d, 0x41, \n  0x3d, 0x3e, 0x3c, 0x3e, 0x3b, \n  0x3a, 0x37, 0x3b, 0x3e, 0x41, \n  0x3c, 0x3b, 0x39, 0x3a, 0x36\n};\n\nvoid\nadpcm_main ()\n{\n  int i, j;\n\n/* reset, initialize required memory */\n  reset ();\n\n  j = 10;\n\n  for (i = 0; i < IN_END; i += 2)\n    {\n      compressed[i / 2] = encode (test_data[i], test_data[i + 1]);\n    }\n  for (i = 0; i < IN_END; i += 2)\n    {\n      decode (compressed[i / 2]);\n      result[i] = xout1;\n      result[i + 1] = xout2;\n    }\n}\n\nint\nmain ()\n{\n  int i;\n  int main_result;\n\n      main_result = 0;\n      adpcm_main ();\n      for (i = 0; i < IN_END / 2; i++)\n\t{\n\t  if (compressed[i] != test_compressed[i])\n\t    {\n\t      main_result += 1;\n\t    }\n\t}\n      for (i = 0; i < IN_END; i++)\n\t{\n\t  if (result[i] != test_result[i])\n\t    {\n\t      main_result += 1;\n\t    }\n\t}\n      printf (\"%d\\n\", main_result);\n      return main_result;\n    }\n"
      }
    ],
    "code_length": 25116,
    "token_count": 8805,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/adpcm_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2050,
    "Worst-caseLatency": 2050.0,
    "BRAM_18K": 0,
    "LUT": 638,
    "DSP": 0,
    "FF": 141,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adpcm_processor",
    "ResourceMetric": 0.0001358654,
    "design_id": "project",
    "algo_name": "adpcm_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "adpcm_processor.cpp",
        "file_content": "#include <stdint.h>\n\n#define N 1024\n\nvoid adpcm_processor(int16_t input[N], int16_t output[N]) {\n    int16_t prevsample = 0;\n    int16_t previndex = 0;\n    const int16_t indexTable[16] = {\n        -1, -1, -1, -1, 2, 4, 6, 8,\n        -1, -1, -1, -1, 2, 4, 6, 8\n    };\n    const int16_t stepsizeTable[89] = {\n        7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31,\n        34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143,\n        157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658,\n        724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,\n        3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\n        15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767\n    };\n\n    for (int i = 0; i < N; i++) {\n        int16_t sample = input[i];\n        int16_t diff = sample - prevsample;\n        int16_t step = stepsizeTable[previndex];\n        int16_t code = 0;\n\n        if (diff < 0) {\n            code = 8;\n            diff = -diff;\n        }\n\n        if (diff >= step) {\n            code |= 4;\n            diff -= step;\n        }\n        step >>= 1;\n        if (diff >= step) {\n            code |= 2;\n            diff -= step;\n        }\n        step >>= 1;\n        if (diff >= step) {\n            code |= 1;\n        }\n\n        int16_t delta = step >> 1;\n        if (code & 4) delta += step;\n        if (code & 2) delta += step >> 1;\n        if (code & 1) delta += step >> 2;\n        if (code & 8) delta = -delta;\n\n        prevsample += delta;\n        if (prevsample > 32767) prevsample = 32767;\n        else if (prevsample < -32768) prevsample = -32768;\n\n        previndex += indexTable[code];\n        if (previndex < 0) previndex = 0;\n        else if (previndex > 88) previndex = 88;\n\n        output[i] = code;\n    }\n}\n\n// Top function name: adpcm_processor\n"
      }
    ],
    "code_length": 1914,
    "token_count": 753,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/adversarial_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1037,
    "Worst-caseLatency": 1037.0,
    "BRAM_18K": 0,
    "LUT": 779,
    "DSP": 10,
    "FF": 1073,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "adversarial_training",
    "ResourceMetric": 0.0005293057,
    "design_id": "project",
    "algo_name": "adversarial_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "adversarial_training.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid adversarial_training(float data[N], float labels[N], float adversarial_data[N], float epsilon) {\n    for (int i = 0; i < N; i++) {\n        float gradient = 2.0f * (data[i] - labels[i]); // Simplified gradient calculation\n        adversarial_data[i] = data[i] + epsilon * gradient;\n    }\n}\n\n// Top function name: adversarial_training\n"
      }
    ],
    "code_length": 372,
    "token_count": 99,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/aes/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 605,
    "Worst-caseLatency": 605.0,
    "BRAM_18K": 0,
    "LUT": 33929,
    "DSP": 0,
    "FF": 3474,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "main",
    "ResourceMetric": 0.0068394851,
    "design_id": "project",
    "algo_name": "aes",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "aes.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/* aes.c */\n/*\n * Copyright (C) 2005\n * Akira Iwata & Masayuki Sato\n * Akira Iwata Laboratory,\n * Nagoya Institute of Technology in Japan.\n *\n * All rights reserved.\n *\n * This software is written by Masayuki Sato.\n * And if you want to contact us, send an email to Kimitake Wakayama\n * (wakayama@elcom.nitech.ac.jp)\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. All advertising materials mentioning features or use of this software must\n *    display the following acknowledgment:\n *    \"This product includes software developed by Akira Iwata Laboratory,\n *    Nagoya Institute of Technology in Japan (http://mars.elcom.nitech.ac.jp/).\"\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Akira Iwata Laboratory,\n *     Nagoya Institute of Technology in Japan (http://mars.elcom.nitech.ac.jp/).\"\n *\n *   THIS SOFTWARE IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED WARRANTY.\n *   AKIRA IWATA LABORATORY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n *   SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,\n *   IN NO EVENT SHALL AKIRA IWATA LABORATORY BE LIABLE FOR ANY SPECIAL,\n *   INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\n *   FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n *   NEGLIGENCE OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION\n *   WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n */\n#include <stdio.h>\n\n\nint main_result;\n\n#include \"aes.h\"\n\n/* **************key generate & key display *******************/\nconst int Rcon0[30] = {\n  0x01, 0x02, 0x04, 0x08,\n  0x10, 0x20, 0x40, 0x80,\n  0x1b, 0x36, 0x6c, 0xd8,\n  0xab, 0x4d, 0x9a, 0x2f,\n  0x5e, 0xbc, 0x63, 0xc6,\n  0x97, 0x35, 0x6a, 0xd4,\n  0xb3, 0x7d, 0xfa, 0xef,\n  0xc5, 0x91,\n};\n\n/*  **************** key expand ************************ */\nint\nKeySchedule (int type, int key[32])\n{\n  int nk, nb, round_val;\n  int i, j, temp[4];\n\n  switch (type)\n    {\n    case 128128:\n      nk = 4;\n      nb = 4;\n      round_val = 10;\n      break;\n    case 128192:\n      nk = 4;\n      nb = 6;\n      round_val = 12;\n      break;\n    case 128256:\n      nk = 4;\n      nb = 8;\n      round_val = 14;\n      break;\n    case 192128:\n      nk = 6;\n      nb = 4;\n      round_val = 12;\n      break;\n    case 192192:\n      nk = 6;\n      nb = 6;\n      round_val = 12;\n      break;\n    case 192256:\n      nk = 6;\n      nb = 8;\n      round_val = 14;\n      break;\n    case 256128:\n      nk = 8;\n      nb = 4;\n      round_val = 14;\n      break;\n    case 256192:\n      nk = 8;\n      nb = 6;\n      round_val = 14;\n      break;\n    case 256256:\n      nk = 8;\n      nb = 8;\n      round_val = 14;\n      break;\n    default:\n      return -1;\n    }\n  \n\n  for (j = 0; j < nk; ++j)\n    for (i = 0; i < 4; ++i)\n/* 0 word */\n      word[i][j] = key[i + j * 4];\n\n/* expanded key is generated */\n  for (j = nk; j < nb * (round_val + 1); ++j)\n    {\n\n/* RotByte */\n      if ((j % nk) == 0)\n\t{\n\t  temp[0] = SubByte (word[1][j - 1]) ^ Rcon0[(j / nk) - 1];\n\t  temp[1] = SubByte (word[2][j - 1]);\n\t  temp[2] = SubByte (word[3][j - 1]);\n\t  temp[3] = SubByte (word[0][j - 1]);\n\t}\n      if ((j % nk) != 0)\n\t{\n\t  temp[0] = word[0][j - 1];\n\t  temp[1] = word[1][j - 1];\n\t  temp[2] = word[2][j - 1];\n\t  temp[3] = word[3][j - 1];\n\t}\n      if (nk > 6 && j % nk == 4)\n\tfor (i = 0; i < 4; ++i)\n\t  temp[i] = SubByte (temp[i]);\n      for (i = 0; i < 4; ++i)\n\tword[i][j] = word[i][j - nk] ^ temp[i];\n    }\n  return 0;\n}\n\nconst int Sbox[16][16] = {\n  {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,\n   0xfe, 0xd7, 0xab, 0x76},\n  {0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf,\n   0x9c, 0xa4, 0x72, 0xc0},\n  {0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,\n   0x71, 0xd8, 0x31, 0x15},\n  {0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,\n   0xeb, 0x27, 0xb2, 0x75},\n  {0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3,\n   0x29, 0xe3, 0x2f, 0x84},\n  {0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39,\n   0x4a, 0x4c, 0x58, 0xcf},\n  {0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,\n   0x50, 0x3c, 0x9f, 0xa8},\n  {0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21,\n   0x10, 0xff, 0xf3, 0xd2},\n  {0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d,\n   0x64, 0x5d, 0x19, 0x73},\n  {0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,\n   0xde, 0x5e, 0x0b, 0xdb},\n  {0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62,\n   0x91, 0x95, 0xe4, 0x79},\n  {0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea,\n   0x65, 0x7a, 0xae, 0x08},\n  {0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,\n   0x4b, 0xbd, 0x8b, 0x8a},\n  {0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,\n   0x86, 0xc1, 0x1d, 0x9e},\n  {0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9,\n   0xce, 0x55, 0x28, 0xdf},\n  {0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,\n   0xb0, 0x54, 0xbb, 0x16}\n};\nconst int invSbox[16][16] = {\n  {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e,\n   0x81, 0xf3, 0xd7, 0xfb},\n  {0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44,\n   0xc4, 0xde, 0xe9, 0xcb},\n  {0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b,\n   0x42, 0xfa, 0xc3, 0x4e},\n  {0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,\n   0x6d, 0x8b, 0xd1, 0x25},\n  {0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc,\n   0x5d, 0x65, 0xb6, 0x92},\n  {0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57,\n   0xa7, 0x8d, 0x9d, 0x84},\n  {0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05,\n   0xb8, 0xb3, 0x45, 0x06},\n  {0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03,\n   0x01, 0x13, 0x8a, 0x6b},\n  {0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce,\n   0xf0, 0xb4, 0xe6, 0x73},\n  {0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8,\n   0x1c, 0x75, 0xdf, 0x6e},\n  {0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e,\n   0xaa, 0x18, 0xbe, 0x1b},\n  {0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe,\n   0x78, 0xcd, 0x5a, 0xf4},\n  {0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59,\n   0x27, 0x80, 0xec, 0x5f},\n  {0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f,\n   0x93, 0xc9, 0x9c, 0xef},\n  {0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c,\n   0x83, 0x53, 0x99, 0x61},\n  {0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63,\n   0x55, 0x21, 0x0c, 0x7d}\n};\n\n/* ********* ByteSub & ShiftRow ********* */\nvoid\nByteSub_ShiftRow (int statemt[32], int nb)\n{\n  int temp;\n\n  switch (nb)\n    {\n    case 4:\n      temp = Sbox[statemt[1] >> 4][statemt[1] & 0xf];\n      statemt[1] = Sbox[statemt[5] >> 4][statemt[5] & 0xf];\n      statemt[5] = Sbox[statemt[9] >> 4][statemt[9] & 0xf];\n      statemt[9] = Sbox[statemt[13] >> 4][statemt[13] & 0xf];\n      statemt[13] = temp;\n\n      temp = Sbox[statemt[2] >> 4][statemt[2] & 0xf];\n      statemt[2] = Sbox[statemt[10] >> 4][statemt[10] & 0xf];\n      statemt[10] = temp;\n      temp = Sbox[statemt[6] >> 4][statemt[6] & 0xf];\n      statemt[6] = Sbox[statemt[14] >> 4][statemt[14] & 0xf];\n      statemt[14] = temp;\n\n      temp = Sbox[statemt[3] >> 4][statemt[3] & 0xf];\n      statemt[3] = Sbox[statemt[15] >> 4][statemt[15] & 0xf];\n      statemt[15] = Sbox[statemt[11] >> 4][statemt[11] & 0xf];\n      statemt[11] = Sbox[statemt[7] >> 4][statemt[7] & 0xf];\n      statemt[7] = temp;\n\n      statemt[0] = Sbox[statemt[0] >> 4][statemt[0] & 0xf];\n      statemt[4] = Sbox[statemt[4] >> 4][statemt[4] & 0xf];\n      statemt[8] = Sbox[statemt[8] >> 4][statemt[8] & 0xf];\n      statemt[12] = Sbox[statemt[12] >> 4][statemt[12] & 0xf];\n      break;\n    case 6:\n      temp = Sbox[statemt[1] >> 4][statemt[1] & 0xf];\n      statemt[1] = Sbox[statemt[5] >> 4][statemt[5] & 0xf];\n      statemt[5] = Sbox[statemt[9] >> 4][statemt[9] & 0xf];\n      statemt[9] = Sbox[statemt[13] >> 4][statemt[13] & 0xf];\n      statemt[13] = Sbox[statemt[17] >> 4][statemt[17] & 0xf];\n      statemt[17] = Sbox[statemt[21] >> 4][statemt[21] & 0xf];\n      statemt[21] = temp;\n\n      temp = Sbox[statemt[2] >> 4][statemt[2] & 0xf];\n      statemt[2] = Sbox[statemt[10] >> 4][statemt[10] & 0xf];\n      statemt[10] = Sbox[statemt[18] >> 4][statemt[18] & 0xf];\n      statemt[18] = temp;\n      temp = Sbox[statemt[6] >> 4][statemt[6] & 0xf];\n      statemt[6] = Sbox[statemt[14] >> 4][statemt[14] & 0xf];\n      statemt[14] = Sbox[statemt[22] >> 4][statemt[22] & 0xf];\n      statemt[22] = temp;\n\n      temp = Sbox[statemt[3] >> 4][statemt[3] & 0xf];\n      statemt[3] = Sbox[statemt[15] >> 4][statemt[15] & 0xf];\n      statemt[15] = temp;\n      temp = Sbox[statemt[7] >> 4][statemt[7] & 0xf];\n      statemt[7] = Sbox[statemt[19] >> 4][statemt[19] & 0xf];\n      statemt[19] = temp;\n      temp = Sbox[statemt[11] >> 4][statemt[11] & 0xf];\n      statemt[11] = Sbox[statemt[23] >> 4][statemt[23] & 0xf];\n      statemt[23] = temp;\n\n      statemt[0] = Sbox[statemt[0] >> 4][statemt[0] & 0xf];\n      statemt[4] = Sbox[statemt[4] >> 4][statemt[4] & 0xf];\n      statemt[8] = Sbox[statemt[8] >> 4][statemt[8] & 0xf];\n      statemt[12] = Sbox[statemt[12] >> 4][statemt[12] & 0xf];\n      statemt[16] = Sbox[statemt[16] >> 4][statemt[16] & 0xf];\n      statemt[20] = Sbox[statemt[20] >> 4][statemt[20] & 0xf];\n      break;\n    case 8:\n      temp = Sbox[statemt[1] >> 4][statemt[1] & 0xf];\n      statemt[1] = Sbox[statemt[5] >> 4][statemt[5] & 0xf];\n      statemt[5] = Sbox[statemt[9] >> 4][statemt[9] & 0xf];\n      statemt[9] = Sbox[statemt[13] >> 4][statemt[13] & 0xf];\n      statemt[13] = Sbox[statemt[17] >> 4][statemt[17] & 0xf];\n      statemt[17] = Sbox[statemt[21] >> 4][statemt[21] & 0xf];\n      statemt[21] = Sbox[statemt[25] >> 4][statemt[25] & 0xf];\n      statemt[25] = Sbox[statemt[29] >> 4][statemt[29] & 0xf];\n      statemt[29] = temp;\n\n      temp = Sbox[statemt[2] >> 4][statemt[2] & 0xf];\n      statemt[2] = Sbox[statemt[14] >> 4][statemt[14] & 0xf];\n      statemt[14] = Sbox[statemt[26] >> 4][statemt[26] & 0xf];\n      statemt[26] = Sbox[statemt[6] >> 4][statemt[6] & 0xf];\n      statemt[6] = Sbox[statemt[18] >> 4][statemt[18] & 0xf];\n      statemt[18] = Sbox[statemt[30] >> 4][statemt[30] & 0xf];\n      statemt[30] = Sbox[statemt[10] >> 4][statemt[10] & 0xf];\n      statemt[10] = Sbox[statemt[22] >> 4][statemt[22] & 0xf];\n      statemt[22] = temp;\n\n      temp = Sbox[statemt[3] >> 4][statemt[3] & 0xf];\n      statemt[3] = Sbox[statemt[19] >> 4][statemt[19] & 0xf];\n      statemt[19] = temp;\n      temp = Sbox[statemt[7] >> 4][statemt[7] & 0xf];\n      statemt[7] = Sbox[statemt[23] >> 4][statemt[23] & 0xf];\n      statemt[23] = temp;\n      temp = Sbox[statemt[11] >> 4][statemt[11] & 0xf];\n      statemt[11] = Sbox[statemt[27] >> 4][statemt[27] & 0xf];\n      statemt[27] = temp;\n      temp = Sbox[statemt[15] >> 4][statemt[15] & 0xf];\n      statemt[15] = Sbox[statemt[31] >> 4][statemt[31] & 0xf];\n      statemt[31] = temp;\n\n      statemt[0] = Sbox[statemt[0] >> 4][statemt[0] & 0xf];\n      statemt[4] = Sbox[statemt[4] >> 4][statemt[4] & 0xf];\n      statemt[8] = Sbox[statemt[8] >> 4][statemt[8] & 0xf];\n      statemt[12] = Sbox[statemt[12] >> 4][statemt[12] & 0xf];\n      statemt[16] = Sbox[statemt[16] >> 4][statemt[16] & 0xf];\n      statemt[20] = Sbox[statemt[20] >> 4][statemt[20] & 0xf];\n      statemt[24] = Sbox[statemt[24] >> 4][statemt[24] & 0xf];\n      statemt[28] = Sbox[statemt[28] >> 4][statemt[28] & 0xf];\n      break;\n    }\n}\n\nint\nSubByte (int in)\n{\n  return Sbox[(in / 16)][(in % 16)];\n}\n\n/* ********* InversShiftRow & ByteSub ********* */\nvoid\nInversShiftRow_ByteSub (int statemt[32], int nb)\n{\n  int temp;\n\n  switch (nb)\n    {\n    case 4:\n      temp = invSbox[statemt[13] >> 4][statemt[13] & 0xf];\n      statemt[13] = invSbox[statemt[9] >> 4][statemt[9] & 0xf];\n      statemt[9] = invSbox[statemt[5] >> 4][statemt[5] & 0xf];\n      statemt[5] = invSbox[statemt[1] >> 4][statemt[1] & 0xf];\n      statemt[1] = temp;\n\n      temp = invSbox[statemt[14] >> 4][statemt[14] & 0xf];\n      statemt[14] = invSbox[statemt[6] >> 4][statemt[6] & 0xf];\n      statemt[6] = temp;\n      temp = invSbox[statemt[2] >> 4][statemt[2] & 0xf];\n      statemt[2] = invSbox[statemt[10] >> 4][statemt[10] & 0xf];\n      statemt[10] = temp;\n\n      temp = invSbox[statemt[15] >> 4][statemt[15] & 0xf];\n      statemt[15] = invSbox[statemt[3] >> 4][statemt[3] & 0xf];\n      statemt[3] = invSbox[statemt[7] >> 4][statemt[7] & 0xf];\n      statemt[7] = invSbox[statemt[11] >> 4][statemt[11] & 0xf];\n      statemt[11] = temp;\n\n      statemt[0] = invSbox[statemt[0] >> 4][statemt[0] & 0xf];\n      statemt[4] = invSbox[statemt[4] >> 4][statemt[4] & 0xf];\n      statemt[8] = invSbox[statemt[8] >> 4][statemt[8] & 0xf];\n      statemt[12] = invSbox[statemt[12] >> 4][statemt[12] & 0xf];\n      break;\n    case 6:\n      temp = invSbox[statemt[21] >> 4][statemt[21] & 0xf];\n      statemt[21] = invSbox[statemt[17] >> 4][statemt[17] & 0xf];\n      statemt[17] = invSbox[statemt[13] >> 4][statemt[13] & 0xf];\n      statemt[13] = invSbox[statemt[9] >> 4][statemt[9] & 0xf];\n      statemt[9] = invSbox[statemt[5] >> 4][statemt[5] & 0xf];\n      statemt[5] = invSbox[statemt[1] >> 4][statemt[1] & 0xf];\n      statemt[1] = temp;\n\n      temp = invSbox[statemt[22] >> 4][statemt[22] & 0xf];\n      statemt[22] = invSbox[statemt[14] >> 4][statemt[14] & 0xf];\n      statemt[14] = invSbox[statemt[6] >> 4][statemt[6] & 0xf];\n      statemt[6] = temp;\n      temp = invSbox[statemt[18] >> 4][statemt[18] & 0xf];\n      statemt[18] = invSbox[statemt[10] >> 4][statemt[10] & 0xf];\n      statemt[10] = invSbox[statemt[2] >> 4][statemt[2] & 0xf];\n      statemt[2] = temp;\n\n      temp = invSbox[statemt[15] >> 4][statemt[15] & 0xf];\n      statemt[15] = invSbox[statemt[3] >> 4][statemt[3] & 0xf];\n      statemt[3] = temp;\n      temp = invSbox[statemt[19] >> 4][statemt[19] & 0xf];\n      statemt[19] = invSbox[statemt[7] >> 4][statemt[7] & 0xf];\n      statemt[7] = temp;\n      temp = invSbox[statemt[23] >> 4][statemt[23] & 0xf];\n      statemt[23] = invSbox[statemt[11] >> 4][statemt[11] & 0xf];\n      statemt[11] = temp;\n\n      statemt[0] = invSbox[statemt[0] >> 4][statemt[0] & 0xf];\n      statemt[4] = invSbox[statemt[4] >> 4][statemt[4] & 0xf];\n      statemt[8] = invSbox[statemt[8] >> 4][statemt[8] & 0xf];\n      statemt[12] = invSbox[statemt[12] >> 4][statemt[12] & 0xf];\n      statemt[16] = invSbox[statemt[16] >> 4][statemt[16] & 0xf];\n      statemt[20] = invSbox[statemt[20] >> 4][statemt[20] & 0xf];\n      break;\n    case 8:\n      temp = invSbox[statemt[29] >> 4][statemt[29] & 0xf];\n      statemt[29] = invSbox[statemt[25] >> 4][statemt[25] & 0xf];\n      statemt[25] = invSbox[statemt[21] >> 4][statemt[21] & 0xf];\n      statemt[21] = invSbox[statemt[17] >> 4][statemt[17] & 0xf];\n      statemt[17] = invSbox[statemt[13] >> 4][statemt[13] & 0xf];\n      statemt[13] = invSbox[statemt[9] >> 4][statemt[9] & 0xf];\n      statemt[9] = invSbox[statemt[5] >> 4][statemt[5] & 0xf];\n      statemt[5] = invSbox[statemt[1] >> 4][statemt[1] & 0xf];\n      statemt[1] = temp;\n\n      temp = invSbox[statemt[30] >> 4][statemt[30] & 0xf];\n      statemt[30] = invSbox[statemt[18] >> 4][statemt[18] & 0xf];\n      statemt[18] = invSbox[statemt[6] >> 4][statemt[6] & 0xf];\n      statemt[6] = invSbox[statemt[26] >> 4][statemt[26] & 0xf];\n      statemt[26] = invSbox[statemt[14] >> 4][statemt[14] & 0xf];\n      statemt[14] = invSbox[statemt[2] >> 4][statemt[2] & 0xf];\n      statemt[2] = invSbox[statemt[22] >> 4][statemt[22] & 0xf];\n      statemt[22] = invSbox[statemt[10] >> 4][statemt[10] & 0xf];\n      statemt[10] = temp;\n\n      temp = invSbox[statemt[31] >> 4][statemt[31] & 0xf];\n      statemt[31] = invSbox[statemt[15] >> 4][statemt[15] & 0xf];\n      statemt[15] = temp;\n      temp = invSbox[statemt[27] >> 4][statemt[27] & 0xf];\n      statemt[27] = invSbox[statemt[11] >> 4][statemt[11] & 0xf];\n      statemt[11] = temp;\n      temp = invSbox[statemt[23] >> 4][statemt[23] & 0xf];\n      statemt[23] = invSbox[statemt[7] >> 4][statemt[7] & 0xf];\n      statemt[7] = temp;\n      temp = invSbox[statemt[19] >> 4][statemt[19] & 0xf];\n      statemt[19] = invSbox[statemt[3] >> 4][statemt[3] & 0xf];\n      statemt[3] = temp;\n\n      statemt[0] = invSbox[statemt[0] >> 4][statemt[0] & 0xf];\n      statemt[4] = invSbox[statemt[4] >> 4][statemt[4] & 0xf];\n      statemt[8] = invSbox[statemt[8] >> 4][statemt[8] & 0xf];\n      statemt[12] = invSbox[statemt[12] >> 4][statemt[12] & 0xf];\n      statemt[16] = invSbox[statemt[16] >> 4][statemt[16] & 0xf];\n      statemt[20] = invSbox[statemt[20] >> 4][statemt[20] & 0xf];\n      statemt[24] = invSbox[statemt[24] >> 4][statemt[24] & 0xf];\n      statemt[28] = invSbox[statemt[28] >> 4][statemt[28] & 0xf];\n      break;\n    }\n}\n\n/* ******** MixColumn ********** */\nint\nMixColumn_AddRoundKey (int statemt[32], int nb, int n)\n{\n  int ret[8 * 4], j;\n  register int x;\n\n  for (j = 0; j < nb; ++j)\n    {\n      ret[j * 4] = (statemt[j * 4] << 1);\n      if ((ret[j * 4] >> 8) == 1)\n\tret[j * 4] ^= 283;\n      x = statemt[1 + j * 4];\n      x ^= (x << 1);\n      if ((x >> 8) == 1)\n\tret[j * 4] ^= (x ^ 283);\n      else\n\tret[j * 4] ^= x;\n      ret[j * 4] ^=\n\tstatemt[2 + j * 4] ^ statemt[3 + j * 4] ^ word[0][j + nb * n];\n\n      ret[1 + j * 4] = (statemt[1 + j * 4] << 1);\n      if ((ret[1 + j * 4] >> 8) == 1)\n\tret[1 + j * 4] ^= 283;\n      x = statemt[2 + j * 4];\n      x ^= (x << 1);\n      if ((x >> 8) == 1)\n\tret[1 + j * 4] ^= (x ^ 283);\n      else\n\tret[1 + j * 4] ^= x;\n      ret[1 + j * 4] ^=\n\tstatemt[3 + j * 4] ^ statemt[j * 4] ^ word[1][j + nb * n];\n\n      ret[2 + j * 4] = (statemt[2 + j * 4] << 1);\n      if ((ret[2 + j * 4] >> 8) == 1)\n\tret[2 + j * 4] ^= 283;\n      x = statemt[3 + j * 4];\n      x ^= (x << 1);\n      if ((x >> 8) == 1)\n\tret[2 + j * 4] ^= (x ^ 283);\n      else\n\tret[2 + j * 4] ^= x;\n      ret[2 + j * 4] ^=\n\tstatemt[j * 4] ^ statemt[1 + j * 4] ^ word[2][j + nb * n];\n\n      ret[3 + j * 4] = (statemt[3 + j * 4] << 1);\n      if ((ret[3 + j * 4] >> 8) == 1)\n\tret[3 + j * 4] ^= 283;\n      x = statemt[j * 4];\n      x ^= (x << 1);\n      if ((x >> 8) == 1)\n\tret[3 + j * 4] ^= (x ^ 283);\n      else\n\tret[3 + j * 4] ^= x;\n      ret[3 + j * 4] ^=\n\tstatemt[1 + j * 4] ^ statemt[2 + j * 4] ^ word[3][j + nb * n];\n    }\n  for (j = 0; j < nb; ++j)\n    {\n      statemt[j * 4] = ret[j * 4];\n      statemt[1 + j * 4] = ret[1 + j * 4];\n      statemt[2 + j * 4] = ret[2 + j * 4];\n      statemt[3 + j * 4] = ret[3 + j * 4];\n    }\n  return 0;\n}\n\n/* ******** InversMixColumn ********** */\nint\nAddRoundKey_InversMixColumn (int statemt[32], int nb, int n)\n{\n  int ret[8 * 4], i, j;\n  register int x;\n\n  for (j = 0; j < nb; ++j)\n    {\n      statemt[j * 4] ^= word[0][j + nb * n];\n      statemt[1 + j * 4] ^= word[1][j + nb * n];\n      statemt[2 + j * 4] ^= word[2][j + nb * n];\n      statemt[3 + j * 4] ^= word[3][j + nb * n];\n    }\n  for (j = 0; j < nb; ++j)\n    for (i = 0; i < 4; ++i)\n      {\n\tx = (statemt[i + j * 4] << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[i + j * 4];\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[i + j * 4];\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tret[i + j * 4] = x;\n\n\tx = (statemt[(i + 1) % 4 + j * 4] << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[(i + 1) % 4 + j * 4];\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[(i + 1) % 4 + j * 4];\n\tret[i + j * 4] ^= x;\n\n\tx = (statemt[(i + 2) % 4 + j * 4] << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[(i + 2) % 4 + j * 4];\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[(i + 2) % 4 + j * 4];\n\tret[i + j * 4] ^= x;\n\n\tx = (statemt[(i + 3) % 4 + j * 4] << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx = (x << 1);\n\tif ((x >> 8) == 1)\n\t  x ^= 283;\n\tx ^= statemt[(i + 3) % 4 + j * 4];\n\tret[i + j * 4] ^= x;\n      }\n  for (i = 0; i < nb; ++i)\n    {\n      statemt[i * 4] = ret[i * 4];\n      statemt[1 + i * 4] = ret[1 + i * 4];\n      statemt[2 + i * 4] = ret[2 + i * 4];\n      statemt[3 + i * 4] = ret[3 + i * 4];\n    }\n  return 0;\n}\n\n/* ******** AddRoundKey ********** */\nint\nAddRoundKey (int statemt[32], int type, int n)\n{\n  int j, nb;\n\n  switch (type)\n    {\n    case 128128:\n    case 192128:\n    case 256128:\n      nb = 4;\n      break;\n    case 128192:\n    case 192192:\n    case 256192:\n      nb = 6;\n      break;\n    case 128256:\n    case 192256:\n    case 256256:\n      nb = 8;\n      break;\n    }\n  for (j = 0; j < nb; ++j)\n    {\n      statemt[j * 4] ^= word[0][j + nb * n];\n      statemt[1 + j * 4] ^= word[1][j + nb * n];\n      statemt[2 + j * 4] ^= word[2][j + nb * n];\n      statemt[3 + j * 4] ^= word[3][j + nb * n];\n    }\n  return 0;\n}\n\n/*  ******* encrypto ************ */\nint\nencrypt (int statemt[32], int key[32], int type)\n{\n  int i, nb, round_val;\n/*\n+--------------------------------------------------------------------------+\n| * Test Vector (added for CHStone)                                        |\n|     out_enc_statemt : expected output data for \"encrypt\"                 |\n+--------------------------------------------------------------------------+\n*/\n  const int out_enc_statemt[16] =\n    { 0x39, 0x25, 0x84, 0x1d, 0x2, 0xdc, 0x9, 0xfb, 0xdc, 0x11, 0x85, 0x97,\n    0x19, 0x6a, 0xb, 0x32\n  };\n\n  KeySchedule (type, key);\n  switch (type)\n    {\n    case 128128:\n      round_val = 0;\n      nb = 4;\n      break;\n    case 192128:\n      round_val = 2;\n      nb = 4;\n      break;\n    case 256128:\n      round_val = 4;\n      nb = 4;\n      break;\n    case 128192:\n    case 192192:\n      round_val = 2;\n      nb = 6;\n      break;\n    case 256192:\n      round_val = 4;\n      nb = 6;\n      break;\n    case 128256:\n    case 192256:\n    case 256256:\n      round_val = 4;\n      nb = 8;\n      break;\n    }\n  AddRoundKey (statemt, type, 0);\n  for (i = 1; i <= round_val + 9; ++i)\n    {\n      ByteSub_ShiftRow (statemt, nb);\n      MixColumn_AddRoundKey (statemt, nb, i);\n    }\n  ByteSub_ShiftRow (statemt, nb);\n  AddRoundKey (statemt, type, i);\n\n  return 0;\n}\n\nint\ndecrypt (int statemt[32], int key[32], int type)\n{\n  int i, nb, round_val;\n/*\n+--------------------------------------------------------------------------+\n| * Test Vector (added for CHStone)                                        |\n|     out_enc_statemt : expected output data for \"decrypt\"                 |\n+--------------------------------------------------------------------------+\n*/\n  const int out_dec_statemt[16] =\n    { 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2,\n    0xe0, 0x37, 0x7, 0x34\n  };\n  KeySchedule (type, key);\n\n  switch (type)\n    {\n    case 128128:\n      round_val = 10;\n      nb = 4;\n      break;\n    case 128192:\n    case 192192:\n      round_val = 12;\n      nb = 6;\n      break;\n    case 192128:\n      round_val = 12;\n      nb = 4;\n      break;\n    case 128256:\n    case 192256:\n      round_val = 14;\n      nb = 8;\n      break;\n    case 256128:\n      round_val = 14;\n      nb = 4;\n      break;\n    case 256192:\n      round_val = 14;\n      nb = 6;\n      break;\n    case 256256:\n      round_val = 14;\n      nb = 8;\n      break;\n    }\n\n  AddRoundKey (statemt, type, round_val);\n\n  InversShiftRow_ByteSub (statemt, nb);\n\n  for (i = round_val - 1; i >= 1; --i)\n    {\n      AddRoundKey_InversMixColumn (statemt, nb, i);\n      InversShiftRow_ByteSub (statemt, nb);\n    }\n\n  AddRoundKey (statemt, type, 0);\n\n  return 0;\n}\n\n/* ***************** main **************************** */\nint\naes_main (void)\n{\n/*\n+--------------------------------------------------------------------------+\n| * Test Vectors (added for CHStone)                                       |\n|     statemt, key : input data                                            |\n+--------------------------------------------------------------------------+\n*/\n  statemt[0] = 50;\n  statemt[1] = 67;\n  statemt[2] = 246;\n  statemt[3] = 168;\n  statemt[4] = 136;\n  statemt[5] = 90;\n  statemt[6] = 48;\n  statemt[7] = 141;\n  statemt[8] = 49;\n  statemt[9] = 49;\n  statemt[10] = 152;\n  statemt[11] = 162;\n  statemt[12] = 224;\n  statemt[13] = 55;\n  statemt[14] = 7;\n  statemt[15] = 52;\n\n  key[0] = 43;\n  key[1] = 126;\n  key[2] = 21;\n  key[3] = 22;\n  key[4] = 40;\n  key[5] = 174;\n  key[6] = 210;\n  key[7] = 166;\n  key[8] = 171;\n  key[9] = 247;\n  key[10] = 21;\n  key[11] = 136;\n  key[12] = 9;\n  key[13] = 207;\n  key[14] = 79;\n  key[15] = 60;\n\n  encrypt (statemt, key, 128128);\n  decrypt (statemt, key, 128128);\n  return 0;\n}\n\nint\nmain ()\n{\n      main_result = 0;\n      aes_main ();\n      printf (\"\\n%d\\n\", main_result);\n      return main_result;\n    }\n"
      },
      {
        "file_name": "aes.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/* aes.h */\n/*\n * Copyright (C) 2005\n * Akira Iwata & Masayuki Sato\n * Akira Iwata Laboratory,\n * Nagoya Institute of Technology in Japan.\n *\n * All rights reserved.\n *\n * This software is written by Masayuki Sato.\n * And if you want to contact us, send an email to Kimitake Wakayama\n * (wakayama@elcom.nitech.ac.jp)\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. All advertising materials mentioning features or use of this software must\n *    display the following acknowledgment:\n *    \"This product includes software developed by Akira Iwata Laboratory,\n *    Nagoya Institute of Technology in Japan (http://mars.elcom.nitech.ac.jp/).\"\n *\n * 4. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by Akira Iwata Laboratory,\n *     Nagoya Institute of Technology in Japan (http://mars.elcom.nitech.ac.jp/).\"\n *\n *   THIS SOFTWARE IS PROVIDED \"AS IS\" WITHOUT EXPRESS OR IMPLIED WARRANTY.\n *   AKIRA IWATA LABORATORY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS\n *   SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,\n *   IN NO EVENT SHALL AKIRA IWATA LABORATORY BE LIABLE FOR ANY SPECIAL,\n *   INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\n *   FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n *   NEGLIGENCE OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN CONNECTION\n *   WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n */\n\n/* ************* data type define ************************* */\nint type;\nint nb;\nint round_val;\nint key[32];\nint statemt[32];\nint word[4][120];\n\n\n/* key generate */\nint KeySchedule (int, int *);\nint SubByte (int);\n\n/* encrypto decrypto */\nvoid ByteSub_ShiftRow (int *, int);\nvoid InversShiftRow_ByteSub (int *, int);\nint MixColumn_AddRoundKey (int *, int, int);\nint AddRoundKey_InversMixColumn (int *, int, int);\nint AddRoundKey (int *, int, int);\nint encrypt (int *, int *, int);\nint decrypt (int *, int *, int);\n\n"
      }
    ],
    "code_length": 26666,
    "token_count": 12390,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/aes/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 585,
    "Worst-caseLatency": 585.0,
    "BRAM_18K": 0,
    "LUT": 394696,
    "DSP": 0,
    "FF": 45309,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "aes256_encrypt_ecb",
    "ResourceMetric": 0.0800331561,
    "design_id": "project",
    "algo_name": "aes",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "aes.c",
        "file_content": "/*\n*   Byte-oriented AES-256 implementation.\n*   All lookup tables replaced with 'on the fly' calculations.\n*/\n#include \"aes.h\"\n\n#define F(x)   (((x)<<1) ^ ((((x)>>7) & 1) * 0x1b))\n#define FD(x)  (((x) >> 1) ^ (((x) & 1) ? 0x8d : 0))\n\n#define BACK_TO_TABLES\n#ifdef BACK_TO_TABLES\n\nconst uint8_t sbox[256] = {\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,\n    0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,\n    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,\n    0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,\n    0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,\n    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,\n    0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,\n    0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,\n    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,\n    0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,\n    0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,\n    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,\n    0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,\n    0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,\n    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,\n    0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,\n    0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n};\n\n#define rj_sbox(x)     sbox[(x)]\n\n#else /* tableless subroutines */\n\n/* -------------------------------------------------------------------------- */\nuint8_t gf_alog(uint8_t x) // calculate anti-logarithm gen 3\n{\n    uint8_t atb = 1, z;\n\n    alog : while (x--) {z = atb; atb <<= 1; if (z & 0x80) atb^= 0x1b; atb ^= z;}\n\n    return atb;\n} /* gf_alog */\n\n/* -------------------------------------------------------------------------- */\nuint8_t gf_log(uint8_t x) // calculate logarithm gen 3\n{\n    uint8_t atb = 1, i = 0, z;\n\n    glog : do {\n        if (atb == x) break;\n        z = atb; atb <<= 1; if (z & 0x80) atb^= 0x1b; atb ^= z;\n    } while (++i > 0);\n\n    return i;\n} /* gf_log */\n\n\n/* -------------------------------------------------------------------------- */\nuint8_t gf_mulinv(uint8_t x) // calculate multiplicative inverse\n{\n    return (x) ? gf_alog(255 - gf_log(x)) : 0;\n} /* gf_mulinv */\n\n/* -------------------------------------------------------------------------- */\nuint8_t rj_sbox(uint8_t x)\n{\n    uint8_t y, sb;\n\n    sb = y = gf_mulinv(x);\n    y = (y<<1)|(y>>7); sb ^= y;  y = (y<<1)|(y>>7); sb ^= y;\n    y = (y<<1)|(y>>7); sb ^= y;  y = (y<<1)|(y>>7); sb ^= y;\n\n    return (sb ^ 0x63);\n} /* rj_sbox */\n#endif\n\n/* -------------------------------------------------------------------------- */\nuint8_t rj_xtime(uint8_t x)\n{\n    return (x & 0x80) ? ((x << 1) ^ 0x1b) : (x << 1);\n} /* rj_xtime */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_subBytes(uint8_t *buf)\n{\n    register uint8_t i = 16;\n\n    sub : while (i--) buf[i] = rj_sbox(buf[i]);\n} /* aes_subBytes */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_addRoundKey(uint8_t *buf, uint8_t *key)\n{\n    register uint8_t i = 16;\n\n    addkey : while (i--) buf[i] ^= key[i];\n} /* aes_addRoundKey */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_addRoundKey_cpy(uint8_t *buf, uint8_t *key, uint8_t *cpk)\n{\n    register uint8_t i = 16;\n\n    cpkey : while (i--)  buf[i] ^= (cpk[i] = key[i]), cpk[16+i] = key[16 + i];\n} /* aes_addRoundKey_cpy */\n\n\n/* -------------------------------------------------------------------------- */\nvoid aes_shiftRows(uint8_t *buf)\n{\n    register uint8_t i, j; /* to make it potentially parallelable :) */\n\n    i = buf[1]; buf[1] = buf[5]; buf[5] = buf[9]; buf[9] = buf[13]; buf[13] = i;\n    i = buf[10]; buf[10] = buf[2]; buf[2] = i;\n    j = buf[3]; buf[3] = buf[15]; buf[15] = buf[11]; buf[11] = buf[7]; buf[7] = j;\n    j = buf[14]; buf[14] = buf[6]; buf[6]  = j;\n\n} /* aes_shiftRows */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_mixColumns(uint8_t *buf)\n{\n    register uint8_t i, a, b, c, d, e;\n\n    mix : for (i = 0; i < 16; i += 4)\n    {\n        a = buf[i]; b = buf[i + 1]; c = buf[i + 2]; d = buf[i + 3];\n        e = a ^ b ^ c ^ d;\n        buf[i] ^= e ^ rj_xtime(a^b);   buf[i+1] ^= e ^ rj_xtime(b^c);\n        buf[i+2] ^= e ^ rj_xtime(c^d); buf[i+3] ^= e ^ rj_xtime(d^a);\n    }\n} /* aes_mixColumns */\n\n/* -------------------------------------------------------------------------- */\nvoid aes_expandEncKey(uint8_t *k, uint8_t *rc)\n{\n    register uint8_t i;\n\n    k[0] ^= rj_sbox(k[29]) ^ (*rc);\n    k[1] ^= rj_sbox(k[30]);\n    k[2] ^= rj_sbox(k[31]);\n    k[3] ^= rj_sbox(k[28]);\n    *rc = F( *rc);\n\n    exp1 : for(i = 4; i < 16; i += 4)  k[i] ^= k[i-4],   k[i+1] ^= k[i-3],\n        k[i+2] ^= k[i-2], k[i+3] ^= k[i-1];\n    k[16] ^= rj_sbox(k[12]);\n    k[17] ^= rj_sbox(k[13]);\n    k[18] ^= rj_sbox(k[14]);\n    k[19] ^= rj_sbox(k[15]);\n\n    exp2 : for(i = 20; i < 32; i += 4) k[i] ^= k[i-4],   k[i+1] ^= k[i-3],\n        k[i+2] ^= k[i-2], k[i+3] ^= k[i-1];\n\n} /* aes_expandEncKey */\n\n/* -------------------------------------------------------------------------- */\nvoid aes256_encrypt_ecb(aes256_context *ctx, uint8_t k[32], uint8_t buf[16])\n{\n    //INIT\n    uint8_t rcon = 1;\n    uint8_t i;\n\n    ecb1 : for (i = 0; i < sizeof(ctx->key); i++){\n        ctx->enckey[i] = ctx->deckey[i] = k[i];\n    }\n    ecb2 : for (i = 8;--i;){\n        aes_expandEncKey(ctx->deckey, &rcon);\n    }\n\n    //DEC\n    aes_addRoundKey_cpy(buf, ctx->enckey, ctx->key);\n    ecb3 : for(i = 1, rcon = 1; i < 14; ++i)\n    {\n        aes_subBytes(buf);\n        aes_shiftRows(buf);\n        aes_mixColumns(buf);\n        if( i & 1 ) aes_addRoundKey( buf, &ctx->key[16]);\n        else aes_expandEncKey(ctx->key, &rcon), aes_addRoundKey(buf, ctx->key);\n    }\n    aes_subBytes(buf);\n    aes_shiftRows(buf);\n    aes_expandEncKey(ctx->key, &rcon);\n    aes_addRoundKey(buf, ctx->key);\n} /* aes256_encrypt */\n\n"
      },
      {
        "file_name": "aes.h",
        "file_content": "/*\n*   Byte-oriented AES-256 implementation.\n*   All lookup tables replaced with 'on the fly' calculations.\n*/\n#include \"support.h\"\n\ntypedef struct {\n  uint8_t key[32];\n  uint8_t enckey[32];\n  uint8_t deckey[32];\n} aes256_context;\n\nvoid aes256_encrypt_ecb(aes256_context *ctx, uint8_t k[32], uint8_t buf[16]);\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  aes256_context ctx;\n  uint8_t k[32];\n  uint8_t buf[16];\n};\n\n"
      }
    ],
    "code_length": 6621,
    "token_count": 2990,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/aes128_encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 174333,
    "Worst-caseLatency": 174333.0,
    "BRAM_18K": 0,
    "LUT": 4920,
    "DSP": 0,
    "FF": 1006,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "aes128_encrypt",
    "ResourceMetric": 0.0010399408,
    "design_id": "project",
    "algo_name": "aes128_encrypt",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "aes128_encrypt.cpp",
        "file_content": "#include <ap_int.h>\n\n#define AES_BLOCK_SIZE 16\n#define AES_KEY_SIZE 16\n#define NUM_BLOCKS 1024\n\nvoid aes128_encrypt(ap_uint<128> input[NUM_BLOCKS], ap_uint<128> output[NUM_BLOCKS], ap_uint<128> key) {\n    ap_uint<8> sbox[256] = {\n        // S-box values\n        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n        // ... (remaining S-box values)\n    };\n\n    ap_uint<32> rcon[10] = {\n        0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000\n    };\n\n    ap_uint<128> round_keys[11];\n    round_keys[0] = key;\n\n    for (int i = 1; i < 11; i++) {\n        ap_uint<32> temp = round_keys[i-1].range(127, 96);\n        temp = (temp.range(23, 0), temp.range(31, 24));\n        for (int j = 0; j < 4; j++) {\n            temp.range(8*j+7, 8*j) = sbox[temp.range(8*j+7, 8*j)];\n        }\n        temp ^= rcon[i-1];\n        round_keys[i].range(127, 96) = round_keys[i-1].range(127, 96) ^ temp;\n        for (int j = 1; j < 4; j++) {\n            round_keys[i].range(32*j+31, 32*j) = round_keys[i-1].range(32*j+31, 32*j) ^ round_keys[i].range(32*(j-1)+31, 32*(j-1));\n        }\n    }\n\n    for (int block = 0; block < NUM_BLOCKS; block++) {\n        ap_uint<128> state = input[block];\n        state ^= round_keys[0];\n\n        for (int round = 1; round < 10; round++) {\n            ap_uint<128> new_state;\n            for (int i = 0; i < 16; i++) {\n                new_state.range(8*i+7, 8*i) = sbox[state.range(8*i+7, 8*i)];\n            }\n            state = new_state;\n            // ShiftRows\n            state = (state.range(127, 120), state.range(87, 80), state.range(47, 40), state.range(7, 0),\n                     state.range(95, 88), state.range(55, 48), state.range(15, 8), state.range(103, 96),\n                     state.range(63, 56), state.range(23, 16), state.range(111, 104), state.range(71, 64),\n                     state.range(31, 24), state.range(119, 112), state.range(79, 72), state.range(39, 32));\n            // MixColumns (simplified for clarity)\n            // ...\n            state ^= round_keys[round];\n        }\n\n        ap_uint<128> final_state;\n        for (int i = 0; i < 16; i++) {\n            final_state.range(8*i+7, 8*i) = sbox[state.range(8*i+7, 8*i)];\n        }\n        state = final_state;\n        // ShiftRows\n        state = (state.range(127, 120), state.range(87, 80), state.range(47, 40), state.range(7, 0),\n                 state.range(95, 88), state.range(55, 48), state.range(15, 8), state.range(103, 96),\n                 state.range(63, 56), state.range(23, 16), state.range(111, 104), state.range(71, 64),\n                 state.range(31, 24), state.range(119, 112), state.range(79, 72), state.range(39, 32));\n        state ^= round_keys[10];\n\n        output[block] = state;\n    }\n}\n\n// Top function name: aes128_encrypt\n"
      }
    ],
    "code_length": 2868,
    "token_count": 1007,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/aggregation_of_m_axi_ports/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 31,
    "Worst-caseLatency": 31.0,
    "BRAM_18K": 2,
    "LUT": 1385,
    "DSP": 0,
    "FF": 1284,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 0.0005127153,
    "design_id": "project",
    "algo_name": "aggregation_of_m_axi_ports",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <iostream>\n#define N 10\n\nstruct A {\n    char foo;\n    short bar;\n};\n\n// Top function\nint dut(A* arr);\n\nint dut(A* arr) {\n#pragma HLS interface m_axi port = arr depth = 10\n#pragma HLS interface s_axilite port = arr\n#pragma HLS aggregate variable = arr compact = auto\n    int sum = 0;\n    for (unsigned i = 0; i < N; i++) {\n        auto tmp = arr[i];\n        sum += tmp.foo + tmp.bar;\n    }\n    return sum;\n}\n"
      },
      {
        "file_name": "xdut_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of arr\n//        bit 31~0 - arr[31:0] (Read/Write)\n// 0x14 : Data signal of arr\n//        bit 31~0 - arr[63:32] (Read/Write)\n// 0x18 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XDUT_CONTROL_ADDR_ARR_DATA 0x10\n#define XDUT_CONTROL_BITS_ARR_DATA 64\n\n"
      },
      {
        "file_name": "xdut.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xdut.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XDut_CfgInitialize(XDut *InstancePtr, XDut_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XDut_Set_arr(XDut *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_ARR_DATA, (u32)(Data));\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_ARR_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDut_Get_arr(XDut *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_ARR_DATA);\n    Data += (u64)XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_ARR_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xdut_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xdut.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XDut_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XDut_uio_map maps[ MAX_UIO_MAPS ];\n} XDut_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XDut_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XDut_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XDut_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XDut_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XDut_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XDut_Initialize(XDut *InstancePtr, const char* InstanceName) {\n\tXDut_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XDut_Release(XDut *InstancePtr) {\n\tXDut_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xdut.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XDUT_H\n#define XDUT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xdut_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XDut_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XDut;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XDut_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XDut_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XDut_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XDut_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XDut_Initialize(XDut *InstancePtr, UINTPTR BaseAddress);\nXDut_Config* XDut_LookupConfig(UINTPTR BaseAddress);\n#else\nint XDut_Initialize(XDut *InstancePtr, u16 DeviceId);\nXDut_Config* XDut_LookupConfig(u16 DeviceId);\n#endif\nint XDut_CfgInitialize(XDut *InstancePtr, XDut_Config *ConfigPtr);\n#else\nint XDut_Initialize(XDut *InstancePtr, const char* InstanceName);\nint XDut_Release(XDut *InstancePtr);\n#endif\n\n\nvoid XDut_Set_arr(XDut *InstancePtr, u64 Data);\nu64 XDut_Get_arr(XDut *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xdut_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xdut.h\"\n\nextern XDut_Config XDut_ConfigTable[];\n\n#ifdef SDT\nXDut_Config *XDut_LookupConfig(UINTPTR BaseAddress) {\n\tXDut_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XDut_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XDut_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XDut_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDut_Initialize(XDut *InstancePtr, UINTPTR BaseAddress) {\n\tXDut_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDut_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDut_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXDut_Config *XDut_LookupConfig(u16 DeviceId) {\n\tXDut_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XDUT_NUM_INSTANCES; Index++) {\n\t\tif (XDut_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XDut_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDut_Initialize(XDut *InstancePtr, u16 DeviceId) {\n\tXDut_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDut_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDut_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 9807,
    "token_count": 2643,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/aggregation_of_nested_structs/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 10,
    "Worst-caseLatency": 10.0,
    "BRAM_18K": 0,
    "LUT": 153,
    "DSP": 0,
    "FF": 11,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "top",
    "ResourceMetric": 3.03947e-05,
    "design_id": "project",
    "algo_name": "aggregation_of_nested_structs",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <iostream>\n\n#define N 8\n\nstruct T {\n    int m;\n    int n;\n    bool o;\n};\n\nstruct S {\n    int p;\n    T q;\n};\n\n// Top function\nvoid top(S a[N], S b[N], S c[N]);\n\nvoid top(S a[N], S b[N], S c[N]) {\n\n#pragma HLS interface bram port = c\n#pragma HLS interface ap_memory port = a\n#pragma HLS aggregate variable = a compact = byte\n#pragma HLS aggregate variable = c compact = byte\n\ntop_label0:\n    for (int i = 0; i < N; i++) {\n        c[i].q.m = a[i].q.m + b[i].q.m;\n        c[i].q.n = a[i].q.n - b[i].q.n;\n        c[i].q.o = a[i].q.o || b[i].q.o;\n        c[i].p = a[i].q.n;\n    }\n}\n"
      }
    ],
    "code_length": 1973,
    "token_count": 514,
    "pragma_number": 4,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/aggregation_of_struct/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 12,
    "Worst-caseLatency": 12.0,
    "BRAM_18K": 0,
    "LUT": 240,
    "DSP": 0,
    "FF": 39,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 4.9763e-05,
    "design_id": "project",
    "algo_name": "aggregation_of_struct",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_int.h\"\n#include <iostream>\n\n#define N 10\n\nstruct A {\n    int foo[3];\n    ap_int<23> bar;\n};\n\n// Top function\nint dut(A arr[N]);\n\nint dut(A arr[N]) {\n#pragma HLS interface ap_fifo port = arr\n#pragma HLS aggregate variable = arr\n    int sum = 0;\n    for (unsigned i = 0; i < N; i++) {\n        auto tmp = arr[i];\n        sum += tmp.foo[0] + tmp.foo[1] + tmp.foo[2] + tmp.bar;\n    }\n    return sum;\n}\n"
      }
    ],
    "code_length": 1798,
    "token_count": 441,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/aliasing_axi_master_ports/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1061,
    "Worst-caseLatency": 1061.0,
    "BRAM_18K": 4,
    "LUT": 2244,
    "DSP": 0,
    "FF": 1671,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 0.0008385557,
    "design_id": "project",
    "algo_name": "aliasing_axi_master_ports",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <hls_stream.h>\n#include <hls_math.h>\n\nconst unsigned SIZE = 1024;\n\ntemplate <typename T>\nstruct dat_t {\n\tT data;\n};\n\ntypedef dat_t<uint32_t> A_t;\ntypedef dat_t<uint32_t> B_t;\n\nconst unsigned RATIO  = (sizeof(A_t)/sizeof(B_t));\nconst unsigned DEPTHA = SIZE/RATIO;\nconst unsigned DEPTHB = SIZE;\n\nvoid dut(hls::stream<A_t> &inputStream, A_t *aximA, B_t *aximB,\n         hls::stream<B_t> &outputStream);\n// Missing include: #include \"etc/ap_utils.h\"\n\nvoid write(hls::stream<A_t> &inputStream, A_t *aximA,\n           hls::stream<bool> &done) {\n#pragma HLS INLINE OFF\n\n    for (unsigned i=0; i<SIZE/RATIO; i++) {\n        aximA[i] = inputStream.read();\n    }\n    \n    // Required to separate the write to aximA and write to done. \n    ap_wait();\n    \n    // This stream acts like a barrier to prevent the read process from\n    // starting\n    done.write(true);\n}\n\nvoid read(B_t *aximB, hls::stream<B_t> &outputStream,\n          hls::stream<bool> &done)\n{\n#pragma HLS INLINE OFF \n           \n    done.read();\n    \n    ap_wait(); // Required to separate the read of done and read of aximB\n           \n    for (unsigned i=0; i<SIZE; i++) {\n        A_t tmp = aximB[i];\n        outputStream << tmp;\n    }\n}\n\nvoid dut(hls::stream<A_t> &inputStream, A_t *aximA, B_t *aximB,\n         hls::stream<B_t> &outputStream) {\n#pragma HLS INTERFACE axis  port=inputStream\n#pragma HLS INTERFACE m_axi port=aximA depth=DEPTHA latency=8 offset=direct max_widen_bitwidth=128 max_read_burst_length=256 max_write_burst_length=256 bundle=axim1\n#pragma HLS INTERFACE m_axi port=aximB depth=DEPTHB latency=8 offset=direct max_widen_bitwidth=128 max_read_burst_length=256 max_write_burst_length=256 bundle=axim2\n#pragma HLS INTERFACE axis  port=outputStream\n\n// Needed to support overlap calls to dut\n//#pragma HLS STABLE variable=aximA \n//#pragma HLS STABLE variable=aximB\n           \n// The ALIAS pragma lets you treat aximA and aximB as pointers to the same memory location. \n#pragma HLS ALIAS ports=aximA,aximB distance=0\n\n#pragma HLS DATAFLOW\n    hls::stream<bool> done;\n\n    write(inputStream, aximA, done);\n    read(aximB, outputStream, done);\n}\n"
      }
    ],
    "code_length": 3515,
    "token_count": 917,
    "pragma_number": 10,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/all_reduce/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2106372,
    "Worst-caseLatency": 2106372.0,
    "BRAM_18K": 2,
    "LUT": 438,
    "DSP": 0,
    "FF": 82,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "all_reduce",
    "ResourceMetric": 0.0002158633,
    "design_id": "project",
    "algo_name": "all_reduce",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "all_reduce.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid all_reduce(int input[SIZE], int output[SIZE]) {\n    int temp[SIZE];\n\n    // Initialize the output array\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = 0;\n    }\n\n    // Perform the all-reduce operation\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            temp[j] = input[j];\n        }\n        for (int j = 0; j < SIZE; j++) {\n            output[j] += temp[j];\n        }\n    }\n}\n\n// Top function name: all_reduce\n"
      }
    ],
    "code_length": 503,
    "token_count": 153,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/alu_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 313,
    "DSP": 1,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "alu_16bit",
    "ResourceMetric": 9.2041e-05,
    "design_id": "project",
    "algo_name": "alu_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "alu_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid alu_16bit(uint16_t A[ARRAY_SIZE], uint16_t B[ARRAY_SIZE], uint16_t C[ARRAY_SIZE], uint8_t opcode[ARRAY_SIZE], uint16_t result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (opcode[i]) {\n            case 0: // Addition\n                result[i] = A[i] + B[i];\n                break;\n            case 1: // Subtraction\n                result[i] = A[i] - B[i];\n                break;\n            case 2: // Multiplication\n                result[i] = A[i] * B[i];\n                break;\n            case 3: // Bitwise AND\n                result[i] = A[i] & B[i];\n                break;\n            case 4: // Bitwise OR\n                result[i] = A[i] | B[i];\n                break;\n            case 5: // Bitwise XOR\n                result[i] = A[i] ^ B[i];\n                break;\n            case 6: // Logical Shift Left\n                result[i] = A[i] << 1;\n                break;\n            case 7: // Logical Shift Right\n                result[i] = A[i] >> 1;\n                break;\n            default: // Default case\n                result[i] = 0;\n                break;\n        }\n    }\n}\n\n// Top function name: alu_16bit\n"
      }
    ],
    "code_length": 1208,
    "token_count": 313,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/alu_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 555,
    "DSP": 3,
    "FF": 77,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "alu_32bit",
    "ResourceMetric": 0.0001969241,
    "design_id": "project",
    "algo_name": "alu_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "alu_32bit.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid alu_32bit(uint32_t A[ARRAY_SIZE], uint32_t B[ARRAY_SIZE], uint8_t op[ARRAY_SIZE], uint32_t result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (op[i]) {\n            case 0: // Addition\n                result[i] = A[i] + B[i];\n                break;\n            case 1: // Subtraction\n                result[i] = A[i] - B[i];\n                break;\n            case 2: // Multiplication\n                result[i] = A[i] * B[i];\n                break;\n            case 3: // Bitwise AND\n                result[i] = A[i] & B[i];\n                break;\n            case 4: // Bitwise OR\n                result[i] = A[i] | B[i];\n                break;\n            case 5: // Bitwise XOR\n                result[i] = A[i] ^ B[i];\n                break;\n            case 6: // Logical left shift\n                result[i] = A[i] << (B[i] & 0x1F);\n                break;\n            case 7: // Logical right shift\n                result[i] = A[i] >> (B[i] & 0x1F);\n                break;\n            default: // Default case (NOP)\n                result[i] = A[i];\n                break;\n        }\n    }\n}\n\n// Top function name: alu_32bit\n"
      }
    ],
    "code_length": 1208,
    "token_count": 322,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/alu_4bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 375,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "alu_4bit",
    "ResourceMetric": 7.44048e-05,
    "design_id": "project",
    "algo_name": "alu_4bit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "alu_4bit.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid alu_4bit(uint8_t A[ARRAY_SIZE], uint8_t B[ARRAY_SIZE], uint8_t ALU_Sel[ARRAY_SIZE], uint8_t ALU_Result[ARRAY_SIZE], uint8_t CarryOut[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t a = A[i];\n        uint8_t b = B[i];\n        uint8_t sel = ALU_Sel[i];\n        uint8_t result = 0;\n        uint8_t carry = 0;\n\n        switch (sel) {\n            case 0: // Addition\n                result = a + b;\n                carry = (result < a) ? 1 : 0;\n                break;\n            case 1: // Subtraction\n                result = a - b;\n                carry = (a < b) ? 1 : 0;\n                break;\n            case 2: // AND\n                result = a & b;\n                break;\n            case 3: // OR\n                result = a | b;\n                break;\n            case 4: // XOR\n                result = a ^ b;\n                break;\n            case 5: // NOT\n                result = ~a;\n                break;\n            case 6: // NAND\n                result = ~(a & b);\n                break;\n            case 7: // NOR\n                result = ~(a | b);\n                break;\n            case 8: // XNOR\n                result = ~(a ^ b);\n                break;\n            case 9: // Increment\n                result = a + 1;\n                carry = (result == 0) ? 1 : 0;\n                break;\n            case 10: // Decrement\n                result = a - 1;\n                carry = (a == 0) ? 1 : 0;\n                break;\n            default:\n                result = 0;\n                carry = 0;\n                break;\n        }\n\n        ALU_Result[i] = result;\n        CarryOut[i] = carry;\n    }\n}\n\n// Top function name: alu_4bit\n"
      }
    ],
    "code_length": 1728,
    "token_count": 454,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/alu_64bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 969,
    "DSP": 10,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "alu_64bit",
    "ResourceMetric": 0.0004671739,
    "design_id": "project",
    "algo_name": "alu_64bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "alu_64bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid alu_64bit(uint64_t op1[ARRAY_SIZE], uint64_t op2[ARRAY_SIZE], uint64_t result[ARRAY_SIZE], uint8_t operation[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (operation[i]) {\n            case 0: // Addition\n                result[i] = op1[i] + op2[i];\n                break;\n            case 1: // Subtraction\n                result[i] = op1[i] - op2[i];\n                break;\n            case 2: // Multiplication\n                result[i] = op1[i] * op2[i];\n                break;\n            case 3: // Bitwise AND\n                result[i] = op1[i] & op2[i];\n                break;\n            case 4: // Bitwise OR\n                result[i] = op1[i] | op2[i];\n                break;\n            case 5: // Bitwise XOR\n                result[i] = op1[i] ^ op2[i];\n                break;\n            case 6: // Logical left shift\n                result[i] = op1[i] << (op2[i] % 64);\n                break;\n            case 7: // Logical right shift\n                result[i] = op1[i] >> (op2[i] % 64);\n                break;\n            default:\n                result[i] = 0; // Default case\n                break;\n        }\n    }\n}\n\n// Top function name: alu_64bit\n"
      }
    ],
    "code_length": 1246,
    "token_count": 333,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/alu_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 270,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "alu_8bit",
    "ResourceMetric": 5.60912e-05,
    "design_id": "project",
    "algo_name": "alu_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "alu_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid alu_8bit(uint8_t op1[ARRAY_SIZE], uint8_t op2[ARRAY_SIZE], uint8_t result[ARRAY_SIZE], uint8_t operation[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (operation[i]) {\n            case 0: // Addition\n                result[i] = op1[i] + op2[i];\n                break;\n            case 1: // Subtraction\n                result[i] = op1[i] - op2[i];\n                break;\n            case 2: // Bitwise AND\n                result[i] = op1[i] & op2[i];\n                break;\n            case 3: // Bitwise OR\n                result[i] = op1[i] | op2[i];\n                break;\n            case 4: // Bitwise XOR\n                result[i] = op1[i] ^ op2[i];\n                break;\n            case 5: // Bitwise NOT (only op1)\n                result[i] = ~op1[i];\n                break;\n            case 6: // Logical shift left\n                result[i] = op1[i] << 1;\n                break;\n            case 7: // Logical shift right\n                result[i] = op1[i] >> 1;\n                break;\n            default:\n                result[i] = 0; // Default case\n                break;\n        }\n    }\n}\n\n// Top function name: alu_8bit\n"
      }
    ],
    "code_length": 1217,
    "token_count": 322,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/analog_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "analog_multiplier",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "analog_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "analog_multiplier.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define SIZE 1024\n\nvoid analog_multiplier(ap_fixed<16, 8> input1[SIZE], ap_fixed<16, 8> input2[SIZE], ap_fixed<32, 16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] * input2[i];\n    }\n}\n\n// Top function name: analog_multiplier\n"
      }
    ],
    "code_length": 287,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/and_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 79,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "and_gate",
    "ResourceMetric": 1.75465e-05,
    "design_id": "project",
    "algo_name": "and_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "and_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid and_gate(ap_uint<1> input1[SIZE], ap_uint<1> input2[SIZE], ap_uint<1> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] & input2[i];\n    }\n}\n\n// Top function name: and_gate\n"
      }
    ],
    "code_length": 251,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/anova/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8296,
    "Worst-caseLatency": 8296.0,
    "BRAM_18K": 0,
    "LUT": 1897,
    "DSP": 10,
    "FF": 1479,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "anova",
    "ResourceMetric": 0.000782627,
    "design_id": "project",
    "algo_name": "anova",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "anova.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid anova(float data[N], float &mean, float &variance, float &sum_squares_between, float &sum_squares_within) {\n    float sum = 0.0;\n    float sum_of_squares = 0.0;\n    float overall_mean = 0.0;\n    float group_mean = 0.0;\n    int group_size = N / 4; // Assuming 4 groups for simplicity\n\n    // Calculate overall mean\n    for (int i = 0; i < N; i++) {\n        sum += data[i];\n    }\n    overall_mean = sum / N;\n\n    // Calculate sum of squares within groups\n    sum_squares_within = 0.0;\n    for (int g = 0; g < 4; g++) {\n        sum = 0.0;\n        for (int i = 0; i < group_size; i++) {\n            sum += data[g * group_size + i];\n        }\n        group_mean = sum / group_size;\n        for (int i = 0; i < group_size; i++) {\n            sum_squares_within += (data[g * group_size + i] - group_mean) * (data[g * group_size + i] - group_mean);\n        }\n    }\n\n    // Calculate sum of squares between groups\n    sum_squares_between = 0.0;\n    for (int g = 0; g < 4; g++) {\n        sum = 0.0;\n        for (int i = 0; i < group_size; i++) {\n            sum += data[g * group_size + i];\n        }\n        group_mean = sum / group_size;\n        sum_squares_between += group_size * (group_mean - overall_mean) * (group_mean - overall_mean);\n    }\n\n    // Calculate variance\n    variance = sum_squares_within / (N - 1);\n\n    // Output mean\n    mean = overall_mean;\n}\n\n// Top function name: anova\n"
      }
    ],
    "code_length": 1426,
    "token_count": 425,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/ant_colony_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 434845721892,
    "Worst-caseLatency": 1185940813092.0,
    "BRAM_18K": 11142,
    "LUT": 23808,
    "DSP": 89,
    "FF": 9195,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ant_colony_optimization",
    "ResourceMetric": 0.6987610379,
    "design_id": "project",
    "algo_name": "ant_colony_optimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "ant_colony_optimization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define M 1024\n#define ALPHA 1.0\n#define BETA 0.5\n#define Q 100\n#define RHO 0.5\n#define PHEROMONE_INIT 1.0\n\nvoid ant_colony_optimization(double distance[N][N], double pheromone[N][N], int best_path[N], double &best_cost) {\n    double heuristic[N][N];\n    double probability[N][N];\n    int path[N];\n    double path_cost;\n    double pheromone_delta[N][N];\n\n    // Initialize heuristic information\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (distance[i][j] != 0) {\n                heuristic[i][j] = 1.0 / distance[i][j];\n            } else {\n                heuristic[i][j] = 0.0;\n            }\n        }\n    }\n\n    // Initialize pheromone levels\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            pheromone[i][j] = PHEROMONE_INIT;\n        }\n    }\n\n    best_cost = 1e9;\n\n    for (int iter = 0; iter < Q; iter++) {\n        for (int ant = 0; ant < M; ant++) {\n            // Initialize path\n            for (int i = 0; i < N; i++) {\n                path[i] = -1;\n            }\n\n            int current_city = ant % N;\n            path[0] = current_city;\n\n            for (int step = 1; step < N; step++) {\n                double sum_prob = 0.0;\n                for (int j = 0; j < N; j++) {\n                    if (j != current_city && path[j] == -1) {\n                        probability[current_city][j] = pow(pheromone[current_city][j], ALPHA) * pow(heuristic[current_city][j], BETA);\n                        sum_prob += probability[current_city][j];\n                    } else {\n                        probability[current_city][j] = 0.0;\n                    }\n                }\n\n                double rand_val = (double)(ant % 100) / 100.0 * sum_prob;\n                double cumulative_prob = 0.0;\n                for (int j = 0; j < N; j++) {\n                    if (probability[current_city][j] > 0) {\n                        cumulative_prob += probability[current_city][j];\n                        if (cumulative_prob >= rand_val) {\n                            current_city = j;\n                            path[step] = current_city;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Calculate path cost\n            path_cost = 0.0;\n            for (int i = 0; i < N - 1; i++) {\n                path_cost += distance[path[i]][path[i + 1]];\n            }\n            path_cost += distance[path[N - 1]][path[0]];\n\n            // Update best path and cost\n            if (path_cost < best_cost) {\n                best_cost = path_cost;\n                for (int i = 0; i < N; i++) {\n                    best_path[i] = path[i];\n                }\n            }\n\n            // Update pheromone delta\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    pheromone_delta[i][j] = 0.0;\n                }\n            }\n            for (int i = 0; i < N - 1; i++) {\n                pheromone_delta[path[i]][path[i + 1]] += 1.0 / path_cost;\n            }\n            pheromone_delta[path[N - 1]][path[0]] += 1.0 / path_cost;\n        }\n\n        // Update pheromone levels\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                pheromone[i][j] = (1 - RHO) * pheromone[i][j] + pheromone_delta[i][j];\n            }\n        }\n    }\n}\n\n// Top function name: ant_colony_optimization\n"
      }
    ],
    "code_length": 3454,
    "token_count": 940,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/arbiter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 2054.0,
    "BRAM_18K": 0,
    "LUT": 252,
    "DSP": 0,
    "FF": 69,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "arbiter",
    "ResourceMetric": 5.49406e-05,
    "design_id": "project",
    "algo_name": "arbiter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "arbiter.cpp",
        "file_content": "#include <stdint.h>\n\n#define NUM_REQUESTS 1024\n\nvoid arbiter(uint8_t requests[NUM_REQUESTS], uint8_t grants[NUM_REQUESTS]) {\n    for (int i = 0; i < NUM_REQUESTS; i++) {\n        grants[i] = 0;\n    }\n\n    for (int i = 0; i < NUM_REQUESTS; i++) {\n        if (requests[i] == 1) {\n            grants[i] = 1;\n            break;\n        }\n    }\n}\n\n// Top function name: arbiter\n"
      }
    ],
    "code_length": 372,
    "token_count": 114,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/arithmetic_converter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "arithmetic_converter",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "arithmetic_converter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "arithmetic_converter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid arithmetic_converter(ap_int<32> input[SIZE], ap_int<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<32> temp = input[i];\n        output[i] = temp * 2 + 3;\n    }\n}\n\n// Top function name: arithmetic_converter\n"
      }
    ],
    "code_length": 276,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/arithmetic_logic_unit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 424,
    "DSP": 3,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "arithmetic_logic_unit",
    "ResourceMetric": 0.0001668171,
    "design_id": "project",
    "algo_name": "arithmetic_logic_unit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "arithmetic_logic_unit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid arithmetic_logic_unit(ap_int<32> A[SIZE], ap_int<32> B[SIZE], ap_int<32> C[SIZE], ap_int<32> D[SIZE], ap_int<32> E[SIZE], ap_int<32> F[SIZE], ap_int<32> G[SIZE], ap_int<32> H[SIZE], ap_int<32> result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<32> add_res = A[i] + B[i];\n        ap_int<32> sub_res = C[i] - D[i];\n        ap_int<32> mul_res = E[i] * F[i];\n        ap_int<32> and_res = G[i] & H[i];\n        ap_int<32> or_res = G[i] | H[i];\n        ap_int<32> xor_res = G[i] ^ H[i];\n        \n        result[i] = add_res + sub_res + mul_res + and_res + or_res + xor_res;\n    }\n}\n\n// Top function name: arithmetic_logic_unit\n"
      }
    ],
    "code_length": 682,
    "token_count": 246,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/array_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "array_multiplier",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "array_multiplier",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "array_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid array_multiplier(ap_int<16> A[ARRAY_SIZE], ap_int<16> B[ARRAY_SIZE], ap_int<32> C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: array_multiplier\n"
      }
    ],
    "code_length": 267,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/array_partition_block_cyclic/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 530,
    "Worst-caseLatency": 1066.0,
    "BRAM_18K": 3,
    "LUT": 7718,
    "DSP": 63,
    "FF": 3691,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "matmul_partition",
    "ResourceMetric": 0.0037653008,
    "design_id": "project",
    "algo_name": "array_partition_block_cyclic",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n// Includes\n/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n#define MAX_DIM 16\n\nvoid matmul_partition(int* in1, int* in2, int* out_r, int dim, int rep_count);\n\n// TRIPCOUNT identifier\nconst unsigned int c_dim = MAX_DIM;\n\nvoid matmul_partition(int* in1, int* in2, int* out_r, int dim, int rep_count) { // Matrix Dimension. Assuming Square Matrix\n#pragma HLS INTERFACE m_axi port = in1 depth = 256\n#pragma HLS INTERFACE m_axi port = in2 depth = 256\n#pragma HLS INTERFACE m_axi port = out_r depth = 256\n\n    int A[MAX_DIM * MAX_DIM];\n    int B[MAX_DIM * MAX_DIM];\n    int C[MAX_DIM * MAX_DIM];\n// Cyclic Partition for A as matrix multiplication needs row-wise parallel\n// access\n#pragma HLS ARRAY_PARTITION variable = A dim = 1 cyclic factor = 16\n// Block Partition for B as matrix multiplication needs column-wise parallel\n// access\n#pragma HLS ARRAY_PARTITION variable = B dim = 1 block factor = 16\n\n// As A and B Matrix are partitioned with the factor of MAX_DIM, so to get\n// parallel row/column access, input square matrix[dimXdim] should be written\n// into local Array in MATRIX[MAX_DIM * MAX_DIM] format\n\n// Burst read for matrix A\n// Auto-pipeline is going to apply pipeline to these loops\nreadA:\n    for (int itr = 0, i = 0, j = 0; itr < dim * dim; itr++, j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim* c_dim max = c_dim * c_dim\n        if (j == dim) {\n            j = 0;\n            i++;\n        }\n        A[i * MAX_DIM + j] = in1[itr];\n    }\n\n// Burst read for matrix B\nreadB:\n    for (int itr = 0, i = 0, j = 0; itr < dim * dim; itr++, j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim* c_dim max = c_dim * c_dim\n        if (j == dim) {\n            j = 0;\n            i++;\n        }\n        B[i * MAX_DIM + j] = in2[itr];\n    }\n\nloop2:\n    for (int x = 0; x < rep_count; x++) {\n#pragma HLS LOOP_TRIPCOUNT min = 1 max = 1\n    lreorder1:\n        for (int i = 0; i < dim; i++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim\n        // As A and B are partition correctly so loop pipelining is applied\n        // at 2nd level loop and which will eventually unroll the lower loop\n        lreorder2:\n            for (int j = 0; j < dim; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim\n                int result = 0;\n            lreorder3:\n                for (int k = 0; k < MAX_DIM; k++) {\n                    //#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim\n                    result += A[i * MAX_DIM + k] * B[k * MAX_DIM + j];\n                }\n                C[i * MAX_DIM + j] = result;\n            }\n        }\n    }\n\n// Burst write from output matrices to global memory\n// Burst write from matrix C\nwriteC:\n    for (int itr = 0, i = 0, j = 0; itr < dim * dim; itr++, j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_dim* c_dim max = c_dim * c_dim\n        if (j == dim) {\n            j = 0;\n            i++;\n        }\n        out_r[itr] = C[i * MAX_DIM + j];\n    }\n}\n"
      },
      {
        "file_name": "xmatmul_partition.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xmatmul_partition.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XMatmul_partition_CfgInitialize(XMatmul_partition *InstancePtr, XMatmul_partition_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XMatmul_partition_Set_in1(XMatmul_partition *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA, (u32)(Data));\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XMatmul_partition_Get_in1(XMatmul_partition *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA);\n    Data += (u64)XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XMatmul_partition_Set_in2(XMatmul_partition *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA, (u32)(Data));\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XMatmul_partition_Get_in2(XMatmul_partition *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA);\n    Data += (u64)XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XMatmul_partition_Set_out_r(XMatmul_partition *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA, (u32)(Data));\n    XMatmul_partition_WriteReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XMatmul_partition_Get_out_r(XMatmul_partition *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA);\n    Data += (u64)XMatmul_partition_ReadReg(InstancePtr->Control_BaseAddress, XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xmatmul_partition_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xmatmul_partition.h\"\n\nextern XMatmul_partition_Config XMatmul_partition_ConfigTable[];\n\n#ifdef SDT\nXMatmul_partition_Config *XMatmul_partition_LookupConfig(UINTPTR BaseAddress) {\n\tXMatmul_partition_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XMatmul_partition_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XMatmul_partition_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XMatmul_partition_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, UINTPTR BaseAddress) {\n\tXMatmul_partition_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XMatmul_partition_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XMatmul_partition_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXMatmul_partition_Config *XMatmul_partition_LookupConfig(u16 DeviceId) {\n\tXMatmul_partition_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XMATMUL_PARTITION_NUM_INSTANCES; Index++) {\n\t\tif (XMatmul_partition_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XMatmul_partition_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, u16 DeviceId) {\n\tXMatmul_partition_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XMatmul_partition_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XMatmul_partition_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xmatmul_partition_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xmatmul_partition.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XMatmul_partition_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XMatmul_partition_uio_map maps[ MAX_UIO_MAPS ];\n} XMatmul_partition_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XMatmul_partition_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XMatmul_partition_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XMatmul_partition_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XMatmul_partition_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XMatmul_partition_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, const char* InstanceName) {\n\tXMatmul_partition_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XMatmul_partition_Release(XMatmul_partition *InstancePtr) {\n\tXMatmul_partition_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xmatmul_partition_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of in1\n//        bit 31~0 - in1[31:0] (Read/Write)\n// 0x14 : Data signal of in1\n//        bit 31~0 - in1[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of in2\n//        bit 31~0 - in2[31:0] (Read/Write)\n// 0x20 : Data signal of in2\n//        bit 31~0 - in2[63:32] (Read/Write)\n// 0x24 : reserved\n// 0x28 : Data signal of out_r\n//        bit 31~0 - out_r[31:0] (Read/Write)\n// 0x2c : Data signal of out_r\n//        bit 31~0 - out_r[63:32] (Read/Write)\n// 0x30 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XMATMUL_PARTITION_CONTROL_ADDR_IN1_DATA   0x10\n#define XMATMUL_PARTITION_CONTROL_BITS_IN1_DATA   64\n#define XMATMUL_PARTITION_CONTROL_ADDR_IN2_DATA   0x1c\n#define XMATMUL_PARTITION_CONTROL_BITS_IN2_DATA   64\n#define XMATMUL_PARTITION_CONTROL_ADDR_OUT_R_DATA 0x28\n#define XMATMUL_PARTITION_CONTROL_BITS_OUT_R_DATA 64\n\n"
      },
      {
        "file_name": "xmatmul_partition.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XMATMUL_PARTITION_H\n#define XMATMUL_PARTITION_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xmatmul_partition_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XMatmul_partition_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XMatmul_partition;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XMatmul_partition_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XMatmul_partition_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XMatmul_partition_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XMatmul_partition_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, UINTPTR BaseAddress);\nXMatmul_partition_Config* XMatmul_partition_LookupConfig(UINTPTR BaseAddress);\n#else\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, u16 DeviceId);\nXMatmul_partition_Config* XMatmul_partition_LookupConfig(u16 DeviceId);\n#endif\nint XMatmul_partition_CfgInitialize(XMatmul_partition *InstancePtr, XMatmul_partition_Config *ConfigPtr);\n#else\nint XMatmul_partition_Initialize(XMatmul_partition *InstancePtr, const char* InstanceName);\nint XMatmul_partition_Release(XMatmul_partition *InstancePtr);\n#endif\n\n\nvoid XMatmul_partition_Set_in1(XMatmul_partition *InstancePtr, u64 Data);\nu64 XMatmul_partition_Get_in1(XMatmul_partition *InstancePtr);\nvoid XMatmul_partition_Set_in2(XMatmul_partition *InstancePtr, u64 Data);\nu64 XMatmul_partition_Get_in2(XMatmul_partition *InstancePtr);\nvoid XMatmul_partition_Set_out_r(XMatmul_partition *InstancePtr, u64 Data);\nu64 XMatmul_partition_Get_out_r(XMatmul_partition *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      }
    ],
    "code_length": 14547,
    "token_count": 3920,
    "pragma_number": 12,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/asynchronous_federated_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1050636,
    "Worst-caseLatency": 1050636.0,
    "BRAM_18K": 2,
    "LUT": 806,
    "DSP": 4,
    "FF": 221,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "asynchronous_federated_learning",
    "ResourceMetric": 0.000410576,
    "design_id": "project",
    "algo_name": "asynchronous_federated_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "asynchronous_federated_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid asynchronous_federated_learning(ap_int<32> global_model[DATA_SIZE], ap_int<32> local_models[DATA_SIZE][DATA_SIZE], ap_int<32> updated_global_model[DATA_SIZE]) {\n    ap_int<32> temp_model[DATA_SIZE] = {0};\n    ap_int<32> model_count = 0;\n\n    for (int i = 0; i < DATA_SIZE; i++) {\n        for (int j = 0; j < DATA_SIZE; j++) {\n            temp_model[i] += local_models[j][i];\n        }\n    }\n\n    for (int i = 0; i < DATA_SIZE; i++) {\n        updated_global_model[i] = (global_model[i] + temp_model[i]) / (DATA_SIZE + 1);\n    }\n}\n\n// Top function name: asynchronous_federated_learning\n"
      }
    ],
    "code_length": 634,
    "token_count": 191,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/asynchronous_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 12302,
    "Worst-caseLatency": 12302.0,
    "BRAM_18K": 1,
    "LUT": 463,
    "DSP": 1,
    "FF": 187,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "asynchronous_training",
    "ResourceMetric": 0.000196425,
    "design_id": "project",
    "algo_name": "asynchronous_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "asynchronous_training.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid asynchronous_training(ap_int<16> input[SIZE], ap_int<16> output[SIZE]) {\n    ap_int<16> weights[SIZE];\n    ap_int<16> bias = 1;\n\n    // Initialize weights\n    for (int i = 0; i < SIZE; i++) {\n        weights[i] = i % 256;\n    }\n\n    // Training loop\n    for (int epoch = 0; epoch < 10; epoch++) {\n        for (int i = 0; i < SIZE; i++) {\n            ap_int<16> prediction = input[i] * weights[i] + bias;\n            ap_int<16> error = input[i] - prediction;\n            weights[i] += error;\n        }\n    }\n\n    // Output the trained weights\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = weights[i];\n    }\n}\n\n// Top function name: asynchronous_training\n"
      }
    ],
    "code_length": 709,
    "token_count": 211,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/atax/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16003904,
    "Worst-caseLatency": 16003904.0,
    "BRAM_18K": 0,
    "LUT": 1526,
    "DSP": 11,
    "FF": 1490,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_atax",
    "ResourceMetric": 0.0007402409,
    "design_id": "project",
    "algo_name": "atax",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "atax.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _ATAX_H\n# define _ATAX_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(M) && !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define M 38\n#   define N 42\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define M 116\n#   define N 124\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define M 390\n#   define N 410\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define M 1900\n#   define N 2100\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define M 1800\n#   define N 2200\n#  endif\n\n\n#endif /* !(M N) */\n\n# define _PB_M POLYBENCH_LOOP_BOUND(M,m)\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_ATAX_H */\n"
      },
      {
        "file_name": "atax.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* atax.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"atax.h\"\n\n\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_atax(int m, int n,\n\t\t DATA_TYPE POLYBENCH_2D(A,M,N,m,n),\n\t\t DATA_TYPE POLYBENCH_1D(x,N,n),\n\t\t DATA_TYPE POLYBENCH_1D(y,N,n),\n\t\t DATA_TYPE POLYBENCH_1D(tmp,M,m))\n{\n  int i, j;\n\n#pragma scop\n  for (i = 0; i < _PB_N; i++)\n    y[i] = 0;\n  for (i = 0; i < _PB_M; i++)\n    {\n      tmp[i] = SCALAR_VAL(0.0);\n      for (j = 0; j < _PB_N; j++)\n\ttmp[i] = tmp[i] + A[i][j] * x[j];\n      for (j = 0; j < _PB_N; j++)\n\ty[j] = y[j] + A[i][j] * tmp[i];\n    }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 1033,
    "token_count": 356,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/attention_augmented_convolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 15738863,
    "Worst-caseLatency": 15738863.0,
    "BRAM_18K": 4096,
    "LUT": 2673,
    "DSP": 10,
    "FF": 2925,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "attention_augmented_convolution",
    "ResourceMetric": 0.2550383365,
    "design_id": "project",
    "algo_name": "attention_augmented_convolution",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "attention_augmented_convolution.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 1024\n#define KERNEL_SIZE 3\n#define ATTENTION_HEADS 8\n\nvoid attention_augmented_convolution(\n    float input[INPUT_SIZE][INPUT_SIZE],\n    float output[OUTPUT_SIZE][OUTPUT_SIZE],\n    float kernel[KERNEL_SIZE][KERNEL_SIZE],\n    float attention_weights[ATTENTION_HEADS][INPUT_SIZE][INPUT_SIZE])\n{\n    float conv_result[INPUT_SIZE][INPUT_SIZE] = {0};\n    float attention_result[INPUT_SIZE][INPUT_SIZE] = {0};\n\n    // Convolution\n    for (int i = 0; i < INPUT_SIZE - KERNEL_SIZE + 1; i++) {\n        for (int j = 0; j < INPUT_SIZE - KERNEL_SIZE + 1; j++) {\n            float sum = 0.0;\n            for (int ki = 0; ki < KERNEL_SIZE; ki++) {\n                for (int kj = 0; kj < KERNEL_SIZE; kj++) {\n                    sum += input[i + ki][j + kj] * kernel[ki][kj];\n                }\n            }\n            conv_result[i][j] = sum;\n        }\n    }\n\n    // Attention Mechanism\n    for (int h = 0; h < ATTENTION_HEADS; h++) {\n        for (int i = 0; i < INPUT_SIZE; i++) {\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                attention_result[i][j] += input[i][j] * attention_weights[h][i][j];\n            }\n        }\n    }\n\n    // Combining Convolution and Attention Results\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            output[i][j] = conv_result[i][j] + attention_result[i][j];\n        }\n    }\n}\n\n// Top function name: attention_augmented_convolution\n"
      }
    ],
    "code_length": 1502,
    "token_count": 418,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/attention_based_image_generation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13634609,
    "Worst-caseLatency": 13634609.0,
    "BRAM_18K": 1024,
    "LUT": 2924,
    "DSP": 1,
    "FF": 2098,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "attention_based_image_generation",
    "ResourceMetric": 0.0642816491,
    "design_id": "project",
    "algo_name": "attention_based_image_generation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "attention_based_image_generation.cpp",
        "file_content": "#include <cmath>\n#include <ap_fixed.h>\n\n#define IMG_SIZE 1024\n#define ATTENTION_HEADS 8\n#define FEATURE_DIM 64\n\ntypedef ap_fixed<16, 8> fixed_t;\n\nvoid attention_based_image_generation(fixed_t input_image[IMG_SIZE][IMG_SIZE], fixed_t output_image[IMG_SIZE][IMG_SIZE], fixed_t attention_weights[ATTENTION_HEADS][IMG_SIZE][IMG_SIZE], fixed_t generated_image[IMG_SIZE][IMG_SIZE]) {\n    fixed_t intermediate_image[IMG_SIZE][IMG_SIZE] = {0};\n\n    // Apply attention weights to the input image\n    for (int h = 0; h < ATTENTION_HEADS; h++) {\n        for (int i = 0; i < IMG_SIZE; i++) {\n            for (int j = 0; j < IMG_SIZE; j++) {\n                intermediate_image[i][j] += input_image[i][j] * attention_weights[h][i][j];\n            }\n        }\n    }\n\n    // Normalize the intermediate image\n    fixed_t max_val = 0;\n    for (int i = 0; i < IMG_SIZE; i++) {\n        for (int j = 0; j < IMG_SIZE; j++) {\n            if (intermediate_image[i][j] > max_val) {\n                max_val = intermediate_image[i][j];\n            }\n        }\n    }\n\n    for (int i = 0; i < IMG_SIZE; i++) {\n        for (int j = 0; j < IMG_SIZE; j++) {\n            intermediate_image[i][j] /= max_val;\n        }\n    }\n\n    // Generate the final image\n    for (int i = 0; i < IMG_SIZE; i++) {\n        for (int j = 0; j < IMG_SIZE; j++) {\n            generated_image[i][j] = intermediate_image[i][j];\n        }\n    }\n\n    // Copy the generated image to the output\n    for (int i = 0; i < IMG_SIZE; i++) {\n        for (int j = 0; j < IMG_SIZE; j++) {\n            output_image[i][j] = generated_image[i][j];\n        }\n    }\n}\n\n// Top function name: attention_based_image_generation\n"
      }
    ],
    "code_length": 1651,
    "token_count": 469,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/attention_based_text_generation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3224399917,
    "Worst-caseLatency": 3224399917.0,
    "BRAM_18K": 8192,
    "LUT": 5970,
    "DSP": 36,
    "FF": 3895,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "attention_based_text_generation",
    "ResourceMetric": 0.5104521466,
    "design_id": "project",
    "algo_name": "attention_based_text_generation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "attention_based_text_generation.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define SEQ_LENGTH 1024\n#define EMBEDDING_DIM 512\n#define HIDDEN_DIM 512\n\nvoid attention_based_text_generation(\n    float input_seq[SEQ_LENGTH][EMBEDDING_DIM],\n    float query_weights[EMBEDDING_DIM][HIDDEN_DIM],\n    float key_weights[EMBEDDING_DIM][HIDDEN_DIM],\n    float value_weights[EMBEDDING_DIM][HIDDEN_DIM],\n    float output_seq[SEQ_LENGTH][EMBEDDING_DIM])\n{\n    float queries[SEQ_LENGTH][HIDDEN_DIM];\n    float keys[SEQ_LENGTH][HIDDEN_DIM];\n    float values[SEQ_LENGTH][HIDDEN_DIM];\n    float attention_scores[SEQ_LENGTH][SEQ_LENGTH];\n    float attention_weights[SEQ_LENGTH][SEQ_LENGTH];\n    float context_vectors[SEQ_LENGTH][HIDDEN_DIM];\n\n    // Compute queries, keys, and values\n    for (int i = 0; i < SEQ_LENGTH; i++) {\n        for (int j = 0; j < HIDDEN_DIM; j++) {\n            queries[i][j] = 0;\n            keys[i][j] = 0;\n            values[i][j] = 0;\n            for (int k = 0; k < EMBEDDING_DIM; k++) {\n                queries[i][j] += input_seq[i][k] * query_weights[k][j];\n                keys[i][j] += input_seq[i][k] * key_weights[k][j];\n                values[i][j] += input_seq[i][k] * value_weights[k][j];\n            }\n        }\n    }\n\n    // Compute attention scores\n    for (int i = 0; i < SEQ_LENGTH; i++) {\n        for (int j = 0; j < SEQ_LENGTH; j++) {\n            attention_scores[i][j] = 0;\n            for (int k = 0; k < HIDDEN_DIM; k++) {\n                attention_scores[i][j] += queries[i][k] * keys[j][k];\n            }\n            attention_scores[i][j] /= sqrt(HIDDEN_DIM);\n        }\n    }\n\n    // Compute attention weights using softmax\n    for (int i = 0; i < SEQ_LENGTH; i++) {\n        float sum_exp = 0;\n        for (int j = 0; j < SEQ_LENGTH; j++) {\n            attention_weights[i][j] = exp(attention_scores[i][j]);\n            sum_exp += attention_weights[i][j];\n        }\n        for (int j = 0; j < SEQ_LENGTH; j++) {\n            attention_weights[i][j] /= sum_exp;\n        }\n    }\n\n    // Compute context vectors\n    for (int i = 0; i < SEQ_LENGTH; i++) {\n        for (int j = 0; j < HIDDEN_DIM; j++) {\n            context_vectors[i][j] = 0;\n            for (int k = 0; k < SEQ_LENGTH; k++) {\n                context_vectors[i][j] += attention_weights[i][k] * values[k][j];\n            }\n        }\n    }\n\n    // Generate output sequence\n    for (int i = 0; i < SEQ_LENGTH; i++) {\n        for (int j = 0; j < EMBEDDING_DIM; j++) {\n            output_seq[i][j] = 0;\n            for (int k = 0; k < HIDDEN_DIM; k++) {\n                output_seq[i][j] += context_vectors[i][k] * value_weights[j][k];\n            }\n        }\n    }\n}\n\n// Top function name: attention_based_text_generation\n"
      }
    ],
    "code_length": 2671,
    "token_count": 761,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/attention_over_image_patches/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 26194,
    "Worst-caseLatency": 26194.0,
    "BRAM_18K": 0,
    "LUT": 7704,
    "DSP": 36,
    "FF": 9637,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "attention_over_image_patches",
    "ResourceMetric": 0.0033987158,
    "design_id": "project",
    "algo_name": "attention_over_image_patches",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "attention_over_image_patches.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define PATCH_SIZE 16\n#define NUM_PATCHES 64\n#define FEATURE_DIM 128\n\nvoid attention_over_image_patches(\n    float patches[NUM_PATCHES][PATCH_SIZE][PATCH_SIZE],\n    float query[FEATURE_DIM],\n    float key[NUM_PATCHES][FEATURE_DIM],\n    float value[NUM_PATCHES][FEATURE_DIM],\n    float output[PATCH_SIZE][PATCH_SIZE])\n{\n    float scores[NUM_PATCHES];\n    float sum_scores = 0.0f;\n\n    // Compute attention scores\n    for (int i = 0; i < NUM_PATCHES; i++) {\n        scores[i] = 0.0f;\n        for (int j = 0; j < FEATURE_DIM; j++) {\n            scores[i] += query[j] * key[i][j];\n        }\n        scores[i] = exp(scores[i]);\n        sum_scores += scores[i];\n    }\n\n    // Normalize scores\n    for (int i = 0; i < NUM_PATCHES; i++) {\n        scores[i] /= sum_scores;\n    }\n\n    // Compute weighted sum of values\n    for (int i = 0; i < PATCH_SIZE; i++) {\n        for (int j = 0; j < PATCH_SIZE; j++) {\n            output[i][j] = 0.0f;\n            for (int k = 0; k < NUM_PATCHES; k++) {\n                output[i][j] += scores[k] * patches[k][i][j];\n            }\n        }\n    }\n}\n\n// Top function name: attention_over_image_patches\n"
      }
    ],
    "code_length": 1167,
    "token_count": 329,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/attention_pooling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5142,
    "Worst-caseLatency": 5142.0,
    "BRAM_18K": 0,
    "LUT": 752,
    "DSP": 5,
    "FF": 564,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "attention_pooling",
    "ResourceMetric": 0.0003368044,
    "design_id": "project",
    "algo_name": "attention_pooling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "attention_pooling.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid attention_pooling(float input[N], float weights[N], float output[N]) {\n    float sum_weights = 0.0;\n    float weighted_sum = 0.0;\n\n    // Calculate the sum of weights\n    for (int i = 0; i < N; i++) {\n        sum_weights += weights[i];\n    }\n\n    // Calculate the weighted sum of inputs\n    for (int i = 0; i < N; i++) {\n        weighted_sum += input[i] * weights[i];\n    }\n\n    // Normalize the weighted sum by the sum of weights\n    float attention_output = weighted_sum / sum_weights;\n\n    // Fill the output array with the attention output\n    for (int i = 0; i < N; i++) {\n        output[i] = attention_output;\n    }\n}\n\n// Top function name: attention_pooling\n"
      }
    ],
    "code_length": 704,
    "token_count": 188,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/auc/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2059,
    "Worst-caseLatency": 2059.0,
    "BRAM_18K": 0,
    "LUT": 787,
    "DSP": 7,
    "FF": 924,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "auc",
    "ResourceMetric": 0.0004334416,
    "design_id": "project",
    "algo_name": "auc",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "auc.cpp",
        "file_content": "#include <iostream>\n\n#define N 1024\n\nvoid auc(float x[N], float y[N], float &area) {\n    area = 0.0f;\n    for (int i = 0; i < N - 1; i++) {\n        float width = x[i + 1] - x[i];\n        float height = (y[i] + y[i + 1]) / 2.0f;\n        area += width * height;\n    }\n}\n\n// Top function name: auc\n"
      }
    ],
    "code_length": 295,
    "token_count": 106,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/audio_compression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2066,
    "Worst-caseLatency": 2066.0,
    "BRAM_18K": 0,
    "LUT": 899,
    "DSP": 3,
    "FF": 788,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "audio_compression",
    "ResourceMetric": 0.0003310637,
    "design_id": "project",
    "algo_name": "audio_compression",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "audio_compression.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid audio_compression(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    const float quantization_step = 0.1f;\n    const float dequantization_step = 0.1f;\n    const float threshold = 0.5f;\n\n    // Quantization\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (std::abs(input[i]) > threshold) {\n            output[i] = std::round(input[i] / quantization_step) * quantization_step;\n        } else {\n            output[i] = 0.0f;\n        }\n    }\n\n    // Dequantization\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (output[i] != 0.0f) {\n            output[i] = output[i] * dequantization_step;\n        }\n    }\n}\n\n// Top function name: audio_compression\n"
      }
    ],
    "code_length": 732,
    "token_count": 210,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/audio_mixing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 489,
    "DSP": 8,
    "FF": 692,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "audio_mixing",
    "ResourceMetric": 0.0003817549,
    "design_id": "project",
    "algo_name": "audio_mixing",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "audio_mixing.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid audio_mixing(float input1[SIZE], float input2[SIZE], float output[SIZE], float volume1, float volume2) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (input1[i] * volume1) + (input2[i] * volume2);\n    }\n}\n\n// Top function name: audio_mixing\n"
      }
    ],
    "code_length": 298,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/audio_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 562,
    "DSP": 3,
    "FF": 708,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "audio_processor",
    "ResourceMetric": 0.0002587683,
    "design_id": "project",
    "algo_name": "audio_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "audio_processor.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid audio_processor(float input[N], float output[N], float gain, float threshold) {\n    for (int i = 0; i < N; i++) {\n        // Apply gain\n        float amplified = input[i] * gain;\n\n        // Apply threshold\n        if (amplified > threshold) {\n            output[i] = threshold;\n        } else if (amplified < -threshold) {\n            output[i] = -threshold;\n        } else {\n            output[i] = amplified;\n        }\n    }\n}\n\n// Top function name: audio_processor\n"
      }
    ],
    "code_length": 508,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/augmented_lagrangian/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8391727,
    "Worst-caseLatency": 8391727.0,
    "BRAM_18K": 16,
    "LUT": 5031,
    "DSP": 28,
    "FF": 4622,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "augmented_lagrangian",
    "ResourceMetric": 0.0031757102,
    "design_id": "project",
    "algo_name": "augmented_lagrangian",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "augmented_lagrangian.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid augmented_lagrangian(double x[N], double y[N], double z[N], double lambda[N], double mu, double rho, double A[N][N], double b[N], double c[N]) {\n    double Ax[N];\n    double ATlambda[N];\n    double gradL[N];\n    double r[N];\n\n    // Compute Ax = A * x\n    for (int i = 0; i < N; i++) {\n        Ax[i] = 0;\n        for (int j = 0; j < N; j++) {\n            Ax[i] += A[i][j] * x[j];\n        }\n    }\n\n    // Compute ATlambda = A^T * lambda\n    for (int i = 0; i < N; i++) {\n        ATlambda[i] = 0;\n        for (int j = 0; j < N; j++) {\n            ATlambda[i] += A[j][i] * lambda[j];\n        }\n    }\n\n    // Compute gradient of Lagrangian: gradL = c + ATlambda + rho * (x - z)\n    for (int i = 0; i < N; i++) {\n        gradL[i] = c[i] + ATlambda[i] + rho * (x[i] - z[i]);\n    }\n\n    // Update x: x = x - mu * gradL\n    for (int i = 0; i < N; i++) {\n        x[i] -= mu * gradL[i];\n    }\n\n    // Compute residual: r = Ax - b\n    for (int i = 0; i < N; i++) {\n        r[i] = Ax[i] - b[i];\n    }\n\n    // Update lambda: lambda = lambda + rho * r\n    for (int i = 0; i < N; i++) {\n        lambda[i] += rho * r[i];\n    }\n\n    // Update z: z = x\n    for (int i = 0; i < N; i++) {\n        z[i] = x[i];\n    }\n}\n\n// Top function name: augmented_lagrangian\n"
      }
    ],
    "code_length": 1281,
    "token_count": 453,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/automl/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2062,
    "Worst-caseLatency": 2062.0,
    "BRAM_18K": 4,
    "LUT": 657,
    "DSP": 5,
    "FF": 633,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "automl",
    "ResourceMetric": 0.0005732185,
    "design_id": "project",
    "algo_name": "automl",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "automl.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid automl(float input[SIZE], float output[SIZE]) {\n    float weights[SIZE];\n    float biases[SIZE];\n\n    // Initialize weights and biases\n    for (int i = 0; i < SIZE; i++) {\n        weights[i] = 0.5f;  // Example initialization\n        biases[i] = 0.1f;   // Example initialization\n    }\n\n    // Perform a simple linear transformation\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] * weights[i] + biases[i];\n    }\n\n    // Apply a non-linear activation function (ReLU)\n    for (int i = 0; i < SIZE; i++) {\n        if (output[i] < 0) {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: automl\n"
      }
    ],
    "code_length": 671,
    "token_count": 194,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/backprop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4466201,
    "Worst-caseLatency": 4466201.0,
    "BRAM_18K": 6,
    "LUT": 29862,
    "DSP": 92,
    "FF": 55246,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "backprop",
    "ResourceMetric": 0.0139443851,
    "design_id": "project",
    "algo_name": "backprop",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "backprop.h",
        "file_content": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"support.h\"\n\n// Fixed parameters\n#define input_dimension  13\n#define possible_outputs  3\n#define training_sets   163\n#define nodes_per_layer  64\n#define layers            2\n#define learning_rate  0.01\n#define epochs            1\n#define test_sets        15\n#define norm_param    0.005\n\n#define max 1.0\n#define offset 0.5\n\n//Data Bounds\n#define TYPE double\n#define MAX 1000\n#define MIN 1\n\nvoid backprop(\n    TYPE weights1[input_dimension*nodes_per_layer],\n    TYPE weights2[nodes_per_layer*nodes_per_layer],\n    TYPE weights3[nodes_per_layer*possible_outputs],\n    TYPE biases1[nodes_per_layer],\n    TYPE biases2[nodes_per_layer],\n    TYPE biases3[possible_outputs],\n    TYPE training_data[training_sets*input_dimension],\n    TYPE training_targets[training_sets*possible_outputs]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n    TYPE weights1[input_dimension*nodes_per_layer];\n    TYPE weights2[nodes_per_layer*nodes_per_layer];\n    TYPE weights3[nodes_per_layer*possible_outputs];\n    TYPE biases1[nodes_per_layer];\n    TYPE biases2[nodes_per_layer];\n    TYPE biases3[possible_outputs];\n    TYPE training_data[training_sets*input_dimension];\n    TYPE training_targets[training_sets*possible_outputs];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "backprop.c",
        "file_content": "#include \"backprop.h\"\n\nvoid soft_max(TYPE net_outputs[possible_outputs], TYPE activations[possible_outputs]) {\n    int i;\n    TYPE sum;\n    sum = (TYPE) 0.0;\n\n    for(i=0; i < possible_outputs; i++) {\n        sum += exp(-activations[i]);\n    }\n    for(i=0; i < possible_outputs; i++) {\n        net_outputs[i] = exp(-activations[i])/sum;\n    }\n}\n\nvoid RELU(TYPE activations[nodes_per_layer], TYPE dactivations[nodes_per_layer], int size) {\n    int i;\n    for( i = 0; i < size; i++) {\n        dactivations[i] = activations[i]*(1.0-activations[i]);\n        activations[i] = 1.0/(1.0+exp(-activations[i]));\n    }\n}\n\nvoid add_bias_to_activations(TYPE biases[nodes_per_layer], \n                               TYPE activations[nodes_per_layer],\n                               int size) {\n    int i;\n    for( i = 0; i < size; i++){\n        activations[i] = activations[i] + biases[i];\n    }\n}\n\nvoid matrix_vector_product_with_bias_input_layer(TYPE biases[nodes_per_layer],\n                                                 TYPE weights[input_dimension*nodes_per_layer],\n                                                 TYPE activations[nodes_per_layer],\n                                                 TYPE input_sample[input_dimension]){\n    int i,j;\n    for(j = 0; j < nodes_per_layer; j++){\n        activations[j] = (TYPE)0.0;\n        for (i = 0; i < input_dimension; i++){\n            activations[j] += weights[j*input_dimension + i] * input_sample[i];\n        }\n    }\n    add_bias_to_activations(biases, activations, nodes_per_layer);\n}\n\nvoid matrix_vector_product_with_bias_second_layer(TYPE biases[nodes_per_layer],\n                                                 TYPE weights[nodes_per_layer*nodes_per_layer],\n                                                 TYPE activations[nodes_per_layer],\n                                                 TYPE input_activations[nodes_per_layer]){\n    int i,j;\n    for (i = 0; i < nodes_per_layer; i++){\n        activations[i] = (TYPE)0.0;\n        for(j = 0; j < nodes_per_layer; j++){\n            activations[i] += weights[i*nodes_per_layer + j] * input_activations[j];\n        }\n    }\n    add_bias_to_activations(biases, activations, nodes_per_layer);\n}\n\nvoid matrix_vector_product_with_bias_output_layer(TYPE biases[possible_outputs],\n                                                 TYPE weights[nodes_per_layer*possible_outputs],\n                                                 TYPE activations[possible_outputs],\n                                                 TYPE input_activations[nodes_per_layer]){\n    int i, j;\n    for(j = 0; j < possible_outputs; j++){\n        activations[j] = (TYPE)0.0;\n        for (i = 0; i < nodes_per_layer; i++){\n            activations[j] += weights[j*nodes_per_layer + i] * input_activations[i];\n        }\n    }\n    add_bias_to_activations(biases, activations, possible_outputs);\n}\n\nvoid take_difference(TYPE net_outputs[possible_outputs], \n                     TYPE solutions[possible_outputs], \n                     TYPE output_difference[possible_outputs],\n                     TYPE dactivations[possible_outputs]) {\n    int i;\n    for( i = 0; i < possible_outputs; i++){\n        output_difference[i] = (((net_outputs[i]) - solutions[i]) * -1.0) * dactivations[i];\n    }\n}\n\nvoid get_delta_matrix_weights3(TYPE delta_weights3[nodes_per_layer*possible_outputs],\n                               TYPE output_difference[possible_outputs],\n                               TYPE last_activations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        for( j = 0; j < possible_outputs; j++) {\n            delta_weights3[i*possible_outputs + j] = last_activations[i] * output_difference[j];\n        }\n    }\n}\n\nvoid get_oracle_activations2(TYPE weights3[nodes_per_layer*possible_outputs], \n                             TYPE output_differences[possible_outputs], \n                             TYPE oracle_activations[nodes_per_layer],\n                             TYPE dactivations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        oracle_activations[i] = (TYPE)0.0;\n        for( j = 0; j < possible_outputs; j++) {\n            oracle_activations[i] += output_differences[j] * weights3[i*possible_outputs + j];\n        }\n        oracle_activations[i] = oracle_activations[i] * dactivations[i];\n    }\n}\n\nvoid get_delta_matrix_weights2(TYPE delta_weights2[nodes_per_layer*nodes_per_layer],\n                               TYPE output_difference[nodes_per_layer],\n                               TYPE last_activations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        for( j = 0; j < nodes_per_layer; j++) {\n            delta_weights2[i*nodes_per_layer + j] = last_activations[i] * output_difference[j];\n        }\n    }\n}\n\nvoid get_oracle_activations1(TYPE weights2[nodes_per_layer*nodes_per_layer], \n                             TYPE output_differences[nodes_per_layer], \n                             TYPE oracle_activations[nodes_per_layer],\n                             TYPE dactivations[nodes_per_layer]) {\n    int i, j;\n    for( i = 0; i < nodes_per_layer; i++) {\n        oracle_activations[i] = (TYPE)0.0;\n        for( j = 0; j < nodes_per_layer; j++) {\n            oracle_activations[i] += output_differences[j] * weights2[i*nodes_per_layer + j];\n        }\n        oracle_activations[i] = oracle_activations[i] * dactivations[i];\n    }\n}\n\nvoid get_delta_matrix_weights1(TYPE delta_weights1[input_dimension*nodes_per_layer],\n                               TYPE output_difference[nodes_per_layer],\n                               TYPE last_activations[input_dimension]) {\n    int i, j;\n    for( i = 0; i < input_dimension; i++) {\n        for( j = 0; j < nodes_per_layer; j++) {\n            delta_weights1[i*nodes_per_layer + j] = last_activations[i] * output_difference[j];\n        }\n    }\n}\n\nvoid update_weights(TYPE weights1[input_dimension*nodes_per_layer],\n                    TYPE weights2[nodes_per_layer*nodes_per_layer],\n                    TYPE weights3[nodes_per_layer*possible_outputs],\n                    TYPE d_weights1[input_dimension*nodes_per_layer],\n                    TYPE d_weights2[nodes_per_layer*nodes_per_layer],\n                    TYPE d_weights3[nodes_per_layer*possible_outputs],\n                    TYPE biases1[nodes_per_layer],\n                    TYPE biases2[nodes_per_layer],\n                    TYPE biases3[possible_outputs],\n                    TYPE d_biases1[nodes_per_layer],\n                    TYPE d_biases2[nodes_per_layer],\n                    TYPE d_biases3[possible_outputs]) {\n    int i, j;\n    double norm, bias_norm;\n    norm = 0.0;\n    bias_norm = 0.0;\n\n    for(i=0; i < input_dimension; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights1[i*nodes_per_layer + j] -= (d_weights1[i*nodes_per_layer + j] * learning_rate);\n            norm += weights1[i*nodes_per_layer + j]*weights1[i*nodes_per_layer + j];\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases1[i] -= (d_biases1[i]*learning_rate);\n        bias_norm += biases1[i]*biases1[i];\n    }\n    \n    norm = sqrt(norm);\n    bias_norm = sqrt(bias_norm);\n\n    for(i=0; i < input_dimension; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights1[i*nodes_per_layer + j] = (weights1[i*nodes_per_layer + j]/norm);\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases1[i] = (biases1[i]/bias_norm);\n    }\n\n    norm = (double)0.0;\n    bias_norm = (double)0.0;\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights2[i*nodes_per_layer + j] -= (d_weights2[i*nodes_per_layer + j] * learning_rate);\n            norm += weights2[i*nodes_per_layer + j]*weights2[i*nodes_per_layer + j];\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases2[i] -= (d_biases2[i]*learning_rate);\n        bias_norm += biases2[i]*biases2[i];\n    }\n\n    norm = sqrt(norm);\n    bias_norm = sqrt(bias_norm);\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < nodes_per_layer; j++){\n            weights2[i*nodes_per_layer + j] = (weights2[i*nodes_per_layer + j]/norm);\n        }\n    }\n    for(i=0; i < nodes_per_layer; i++){\n        biases2[i] = (biases2[i]/bias_norm);\n    }\n\n    norm = (double)0.0;\n    bias_norm = (double)0.0;\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < possible_outputs; j++){\n            weights3[i*possible_outputs + j] -= (d_weights3[i*possible_outputs + j] * learning_rate);\n            norm += weights3[i*possible_outputs + j]*weights3[i*possible_outputs + j];\n        }\n    }\n    for(i=0; i<possible_outputs;i++){\n        biases3[i] -= d_biases3[i]*learning_rate;\n        bias_norm += biases3[i]*biases3[i];\n    }\n\n    norm = sqrt(norm);\n    bias_norm = sqrt(bias_norm);\n\n    for(i=0; i < nodes_per_layer; i++){\n        for(j = 0; j < possible_outputs; j++){\n            weights3[i*possible_outputs + j] = (weights3[i*possible_outputs + j]/norm);\n        }\n    }\n    for(i=0; i < possible_outputs; i++){\n        biases3[i] = (biases3[i]/bias_norm);\n    }\n}\n\nvoid backprop(TYPE weights1[input_dimension*nodes_per_layer], \n                TYPE weights2[nodes_per_layer*nodes_per_layer],\n                TYPE weights3[nodes_per_layer*possible_outputs],\n                TYPE biases1[nodes_per_layer], \n                TYPE biases2[nodes_per_layer],\n                TYPE biases3[possible_outputs],\n                TYPE training_data[training_sets*input_dimension],\n                TYPE training_targets[training_sets*possible_outputs]) {\n    int i,j;\n    //Forward and training structures\n    TYPE activations1[nodes_per_layer];\n    TYPE activations2[nodes_per_layer];\n    TYPE activations3[possible_outputs];\n    TYPE dactivations1[nodes_per_layer];\n    TYPE dactivations2[nodes_per_layer];\n    TYPE dactivations3[possible_outputs];\n    TYPE net_outputs[possible_outputs];\n    //Training structure\n    TYPE output_difference[possible_outputs];\n    TYPE delta_weights1[input_dimension*nodes_per_layer]; \n    TYPE delta_weights2[nodes_per_layer*nodes_per_layer];\n    TYPE delta_weights3[nodes_per_layer*possible_outputs];\n    TYPE oracle_activations1[nodes_per_layer];\n    TYPE oracle_activations2[nodes_per_layer];\n\n    for(i=0; i<training_sets; i++){\n        for(j=0;j<nodes_per_layer;j++){\n            activations1[j] = (TYPE)0.0;\n            activations2[j] = (TYPE)0.0;\n            if(j<possible_outputs){\n                activations3[j] = (TYPE)0.0;\n            }\n        }\n        matrix_vector_product_with_bias_input_layer(biases1, weights1, activations1, &training_data[i*input_dimension]);\n        RELU(activations1, dactivations1, nodes_per_layer);\n        matrix_vector_product_with_bias_second_layer(biases2, weights2, activations2, activations1);\n        RELU(activations2, dactivations2, nodes_per_layer);\n        matrix_vector_product_with_bias_output_layer(biases3, weights3, activations3, activations2);\n        RELU(activations3, dactivations3, possible_outputs);\n        soft_max(net_outputs, activations3);\n        take_difference(net_outputs, &training_targets[i*possible_outputs], output_difference, dactivations3);\n        get_delta_matrix_weights3(delta_weights3, output_difference, activations2);\n        get_oracle_activations2(weights3, output_difference, oracle_activations2, dactivations2);\n        get_delta_matrix_weights2(delta_weights2, oracle_activations2, activations1);\n        get_oracle_activations1(weights2, oracle_activations2, oracle_activations1, dactivations1);\n        get_delta_matrix_weights1(delta_weights1, oracle_activations1, &training_data[i*input_dimension]);\n        update_weights(weights1, weights2, weights3, delta_weights1, delta_weights2, delta_weights3, \n                       biases1, biases2, biases3, oracle_activations1, oracle_activations2, output_difference);\n    }\n}\n"
      }
    ],
    "code_length": 11867,
    "token_count": 2849,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/backpropagation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2122796,
    "Worst-caseLatency": 2122796.0,
    "BRAM_18K": 4,
    "LUT": 6900,
    "DSP": 63,
    "FF": 6208,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "backpropagation",
    "ResourceMetric": 0.0039117772,
    "design_id": "project",
    "algo_name": "backpropagation",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "backpropagation.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 256\n\nvoid backpropagation(\n    float input[INPUT_SIZE],\n    float hidden_weights[INPUT_SIZE][HIDDEN_SIZE],\n    float output_weights[HIDDEN_SIZE][OUTPUT_SIZE],\n    float hidden_bias[HIDDEN_SIZE],\n    float output_bias[OUTPUT_SIZE],\n    float target[OUTPUT_SIZE],\n    float learning_rate)\n{\n    float hidden_layer[HIDDEN_SIZE];\n    float output_layer[OUTPUT_SIZE];\n    float hidden_delta[HIDDEN_SIZE];\n    float output_delta[OUTPUT_SIZE];\n\n    // Forward pass\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        hidden_layer[i] = hidden_bias[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            hidden_layer[i] += input[j] * hidden_weights[j][i];\n        }\n        hidden_layer[i] = 1.0 / (1.0 + exp(-hidden_layer[i])); // Sigmoid activation\n    }\n\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output_layer[i] = output_bias[i];\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            output_layer[i] += hidden_layer[j] * output_weights[j][i];\n        }\n        output_layer[i] = 1.0 / (1.0 + exp(-output_layer[i])); // Sigmoid activation\n    }\n\n    // Backward pass\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output_delta[i] = (target[i] - output_layer[i]) * output_layer[i] * (1.0 - output_layer[i]);\n    }\n\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        hidden_delta[i] = 0.0;\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            hidden_delta[i] += output_delta[j] * output_weights[i][j];\n        }\n        hidden_delta[i] *= hidden_layer[i] * (1.0 - hidden_layer[i]);\n    }\n\n    // Update weights and biases\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output_bias[i] += learning_rate * output_delta[i];\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            output_weights[j][i] += learning_rate * hidden_layer[j] * output_delta[i];\n        }\n    }\n\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        hidden_bias[i] += learning_rate * hidden_delta[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            hidden_weights[j][i] += learning_rate * input[j] * hidden_delta[i];\n        }\n    }\n}\n\n// Top function name: backpropagation\n"
      }
    ],
    "code_length": 2179,
    "token_count": 612,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bagging/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2099246,
    "Worst-caseLatency": 2099246.0,
    "BRAM_18K": 4,
    "LUT": 2695,
    "DSP": 0,
    "FF": 3917,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bagging",
    "ResourceMetric": 0.0011403936,
    "design_id": "project",
    "algo_name": "bagging",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bagging.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid bagging(ap_int<32> data[N], ap_int<32> labels[N], ap_int<32> output[N]) {\n    ap_int<32> sum[N] = {0};\n    ap_int<32> count[N] = {0};\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (labels[j] == i) {\n                sum[i] += data[j];\n                count[i]++;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (count[i] != 0) {\n            output[i] = sum[i] / count[i];\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: bagging\n"
      }
    ],
    "code_length": 576,
    "token_count": 190,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/barrel_shifter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 165,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "barrel_shifter",
    "ResourceMetric": 3.60518e-05,
    "design_id": "project",
    "algo_name": "barrel_shifter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "barrel_shifter.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid barrel_shifter(uint8_t input[ARRAY_SIZE], uint8_t shift_amount, uint8_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t value = input[i];\n        if (shift_amount < 8) {\n            output[i] = (value << shift_amount) | (value >> (8 - shift_amount));\n        } else {\n            output[i] = value;\n        }\n    }\n}\n\n// Top function name: barrel_shifter\n"
      }
    ],
    "code_length": 439,
    "token_count": 121,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/barrel_shifter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 307,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "barrel_shifter",
    "ResourceMetric": 6.12689e-05,
    "design_id": "project",
    "algo_name": "barrel_shifter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "barrel_shifter.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid barrel_shifter(uint32_t input[ARRAY_SIZE], uint32_t shift_amount[ARRAY_SIZE], uint32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t value = input[i];\n        uint32_t shift = shift_amount[i] & 0x1F; // Only consider the lower 5 bits for 32-bit shift\n        output[i] = (value << shift) | (value >> (32 - shift));\n    }\n}\n\n// Top function name: barrel_shifter\n"
      }
    ],
    "code_length": 447,
    "token_count": 129,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/baseband_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1032,
    "Worst-caseLatency": 1032.0,
    "BRAM_18K": 0,
    "LUT": 225,
    "DSP": 4,
    "FF": 323,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "baseband_signal_processor",
    "ResourceMetric": 0.0001849327,
    "design_id": "project",
    "algo_name": "baseband_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "baseband_signal_processor.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define N 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid baseband_signal_processor(fixed_point_t input_signal[N], fixed_point_t output_signal[N]) {\n    fixed_point_t filter_coeffs[5] = {0.1, 0.15, 0.5, 0.15, 0.1};\n    fixed_point_t buffer[5] = {0};\n\n    for (int i = 0; i < N; i++) {\n        // Shift the buffer\n        for (int j = 4; j > 0; j--) {\n            buffer[j] = buffer[j-1];\n        }\n        buffer[0] = input_signal[i];\n\n        // Apply the filter\n        fixed_point_t result = 0;\n        for (int j = 0; j < 5; j++) {\n            result += buffer[j] * filter_coeffs[j];\n        }\n\n        output_signal[i] = result;\n    }\n}\n\n// Top function name: baseband_signal_processor\n"
      }
    ],
    "code_length": 717,
    "token_count": 220,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/basic_arithmetic/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6,
    "Worst-caseLatency": 6.0,
    "BRAM_18K": 0,
    "LUT": 108,
    "DSP": 0,
    "FF": 70,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pointer_arith",
    "ResourceMetric": 2.74224e-05,
    "design_id": "project",
    "algo_name": "basic_arithmetic",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.c",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _POINTER_ARITH_H_\n#define _POINTER_ARITH_H_\n\n// Missing include: #include <stdio.h>\n\ntypedef int dio_t;\n\nvoid pointer_arith(dio_t* d);\n\n#endif\n\nvoid pointer_arith(dio_t *d) {\n  static int acc = 0;\n  int i;\n\n  for (i = 0; i < 4; i++) {\n    acc += *(d + i + 1);\n    *(d + i) = acc;\n  }\n}\n"
      }
    ],
    "code_length": 1583,
    "token_count": 394,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/basic_loops_primer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 12,
    "Worst-caseLatency": 12.0,
    "BRAM_18K": 0,
    "LUT": 106,
    "DSP": 0,
    "FF": 19,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 2.21488e-05,
    "design_id": "project",
    "algo_name": "basic_loops_primer",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _TEST_LOOPS_H_\n#define _TEST_LOOPS_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 10\n\ntypedef ap_int<8> din_t;\ntypedef ap_int<13> dout_t;\ntypedef ap_uint<5> dsel_t;\n\ndout_t test(din_t A[N]);\n\n#endif\n\ndout_t test(din_t A[N]) {\n\n    dout_t out_accum = 0;\n    dsel_t x;\n\nLOOP_1:\n    for (x = 0; x < N; x++) {\n        out_accum += A[x];\n    }\n\n    return out_accum;\n}\n"
      }
    ],
    "code_length": 1808,
    "token_count": 451,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/basic_pointers/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 39,
    "DSP": 0,
    "FF": 33,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pointer_basic",
    "ResourceMetric": 1.06429e-05,
    "design_id": "project",
    "algo_name": "basic_pointers",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.c",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _POINTER_BASIC_H_\n#define _POINTER_BASIC_H_\n\n// Missing include: #include <stdio.h>\n\ntypedef int dio_t;\n\nvoid pointer_basic(dio_t* d);\n\n#endif\n\nvoid pointer_basic(dio_t *d) {\n  static dio_t acc = 0;\n\n  acc += *d;\n  *d = acc;\n}\n"
      }
    ],
    "code_length": 1524,
    "token_count": 361,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/batch_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 444,
    "DSP": 5,
    "FF": 564,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "batch_learning",
    "ResourceMetric": 0.0002777408,
    "design_id": "project",
    "algo_name": "batch_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "batch_learning.cpp",
        "file_content": "#include <iostream>\n\n#define N 1024\n\nvoid batch_learning(float input[N], float weights[N], float bias, float output[N]) {\n    for (int i = 0; i < N; i++) {\n        output[i] = input[i] * weights[i] + bias;\n    }\n}\n\n// Top function name: batch_learning\n"
      }
    ],
    "code_length": 252,
    "token_count": 71,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/batch_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1065,
    "Worst-caseLatency": 1065.0,
    "BRAM_18K": 0,
    "LUT": 1281,
    "DSP": 13,
    "FF": 1525,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "batch_normalization",
    "ResourceMetric": 0.0007520222,
    "design_id": "project",
    "algo_name": "batch_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "batch_normalization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid batch_normalization(float input[N], float output[N], float mean, float variance, float gamma, float beta) {\n    for (int i = 0; i < N; i++) {\n        output[i] = gamma * ((input[i] - mean) / sqrt(variance + 1e-5)) + beta;\n    }\n}\n\n// Top function name: batch_normalization\n"
      }
    ],
    "code_length": 312,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/batch_renormalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1065,
    "Worst-caseLatency": 1065.0,
    "BRAM_18K": 0,
    "LUT": 895,
    "DSP": 10,
    "FF": 1167,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "batch_renormalization",
    "ResourceMetric": 0.0005605633,
    "design_id": "project",
    "algo_name": "batch_renormalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "batch_renormalization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid batch_renormalization(float input[N], float output[N], float mean, float variance, float r, float d) {\n    float epsilon = 1e-5;\n    float inv_std = 1.0 / sqrt(variance + epsilon);\n\n    for (int i = 0; i < N; i++) {\n        float normalized = (input[i] - mean) * inv_std;\n        output[i] = r * normalized + d;\n    }\n}\n\n// Top function name: batch_renormalization\n"
      }
    ],
    "code_length": 404,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/battery_operated_power_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 105,
    "DSP": 1,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "battery_operated_power_comparator",
    "ResourceMetric": 5.17704e-05,
    "design_id": "project",
    "algo_name": "battery_operated_power_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "battery_operated_power_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid battery_operated_power_comparator(ap_int<16> voltage[ARRAY_SIZE], ap_int<16> current[ARRAY_SIZE], ap_int<16> power[ARRAY_SIZE], ap_int<16> threshold, ap_int<1> result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        power[i] = voltage[i] * current[i];\n        if (power[i] > threshold) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n}\n\n// Top function name: battery_operated_power_comparator\n"
      }
    ],
    "code_length": 502,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bayesian_inference/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097164,
    "Worst-caseLatency": 2097164.0,
    "BRAM_18K": 0,
    "LUT": 786,
    "DSP": 5,
    "FF": 762,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bayesian_inference",
    "ResourceMetric": 0.0003623091,
    "design_id": "project",
    "algo_name": "bayesian_inference",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bayesian_inference.cpp",
        "file_content": "#include <cmath>\n#include <iostream>\n\n#define N 1024\n\nvoid bayesian_inference(float prior[N], float likelihood[N][N], float evidence[N], float posterior[N]) {\n    for (int i = 0; i < N; i++) {\n        posterior[i] = 0.0;\n        for (int j = 0; j < N; j++) {\n            posterior[i] += likelihood[i][j] * prior[j];\n        }\n        posterior[i] /= evidence[i];\n    }\n}\n\n// Top function name: bayesian_inference\n"
      }
    ],
    "code_length": 413,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bayesian_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1037,
    "Worst-caseLatency": 1037.0,
    "BRAM_18K": 0,
    "LUT": 444,
    "DSP": 5,
    "FF": 640,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bayesian_optimization",
    "ResourceMetric": 0.0002850278,
    "design_id": "project",
    "algo_name": "bayesian_optimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bayesian_optimization.cpp",
        "file_content": "#include <cmath>\n#include <limits>\n\n#define ARRAY_SIZE 1024\n\nvoid bayesian_optimization(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float mean[ARRAY_SIZE], float variance[ARRAY_SIZE], float beta) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float ucb = mean[i] + beta * std::sqrt(variance[i]);\n        output[i] = ucb;\n    }\n}\n\n// Top function name: bayesian_optimization\n"
      }
    ],
    "code_length": 387,
    "token_count": 104,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/bcd_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 118,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bcd_adder",
    "ResourceMetric": 2.50253e-05,
    "design_id": "project",
    "algo_name": "bcd_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "bcd_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bcd_adder(ap_uint<4> A[ARRAY_SIZE], ap_uint<4> B[ARRAY_SIZE], ap_uint<4> Sum[ARRAY_SIZE], ap_uint<1> Carry[ARRAY_SIZE]) {\n    ap_uint<5> temp_sum;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp_sum = A[i] + B[i];\n        if (temp_sum > 9) {\n            temp_sum = temp_sum + 6; // Adjust for BCD\n        }\n        Sum[i] = temp_sum.range(3, 0);\n        Carry[i] = temp_sum[4];\n    }\n}\n\n// Top function name: bcd_adder\n"
      }
    ],
    "code_length": 478,
    "token_count": 161,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/bcd_rate_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 129,
    "DSP": 0,
    "FF": 30,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bcd_rate_multiplier",
    "ResourceMetric": 2.76141e-05,
    "design_id": "project",
    "algo_name": "bcd_rate_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "bcd_rate_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid bcd_rate_multiplier(ap_uint<4> bcd_input[N], ap_uint<4> rate, ap_uint<4> output[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<4> count = 0;\n        ap_uint<4> temp_output = 0;\n        for (int j = 0; j < 4; j++) {\n            if (rate[j] == 1) {\n                temp_output += bcd_input[i];\n            }\n            count++;\n        }\n        output[i] = temp_output;\n    }\n}\n\n// Top function name: bcd_rate_multiplier\n"
      }
    ],
    "code_length": 472,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bcd_to_7_segment_decoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 105,
    "DSP": 0,
    "FF": 47,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bcd_to_7_segment_decoder",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "bcd_to_7_segment_decoder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bcd_to_7_segment_decoder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid bcd_to_7_segment_decoder(ap_uint<4> bcd_input[SIZE], ap_uint<7> segment_output[SIZE]) {\n    const ap_uint<7> bcd_to_segment_map[10] = {\n        0x3F, // 0\n        0x06, // 1\n        0x5B, // 2\n        0x4F, // 3\n        0x66, // 4\n        0x6D, // 5\n        0x7D, // 6\n        0x07, // 7\n        0x7F, // 8\n        0x6F  // 9\n    };\n\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<4> bcd_digit = bcd_input[i];\n        if (bcd_digit < 10) {\n            segment_output[i] = bcd_to_segment_map[bcd_digit];\n        } else {\n            segment_output[i] = 0x00; // Invalid BCD input\n        }\n    }\n}\n\n// Top function name: bcd_to_7_segment_decoder\n"
      }
    ],
    "code_length": 696,
    "token_count": 263,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/beam_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 15373,
    "Worst-caseLatency": 15373.0,
    "BRAM_18K": 0,
    "LUT": 5013,
    "DSP": 12,
    "FF": 2783,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "beam_search",
    "ResourceMetric": 0.0015606048,
    "design_id": "project",
    "algo_name": "beam_search",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "beam_search.cpp",
        "file_content": "#include <iostream>\n#include <limits>\n\n#define BEAM_WIDTH 4\n#define SEQUENCE_LENGTH 1024\n\nvoid beam_search(float input[SEQUENCE_LENGTH][BEAM_WIDTH], int output[SEQUENCE_LENGTH]) {\n    float scores[SEQUENCE_LENGTH][BEAM_WIDTH];\n    int paths[SEQUENCE_LENGTH][BEAM_WIDTH];\n\n    // Initialize scores and paths\n    for (int i = 0; i < SEQUENCE_LENGTH; i++) {\n        for (int j = 0; j < BEAM_WIDTH; j++) {\n            scores[i][j] = input[i][j];\n            paths[i][j] = j;\n        }\n    }\n\n    // Beam search algorithm\n    for (int t = 1; t < SEQUENCE_LENGTH; t++) {\n        float temp_scores[BEAM_WIDTH][BEAM_WIDTH];\n        int temp_paths[BEAM_WIDTH][BEAM_WIDTH];\n\n        // Calculate new scores and paths\n        for (int i = 0; i < BEAM_WIDTH; i++) {\n            for (int j = 0; j < BEAM_WIDTH; j++) {\n                temp_scores[i][j] = scores[t-1][i] + input[t][j];\n                temp_paths[i][j] = paths[t-1][i];\n            }\n        }\n\n        // Select top BEAM_WIDTH scores and paths\n        for (int i = 0; i < BEAM_WIDTH; i++) {\n            float max_score = -std::numeric_limits<float>::infinity();\n            int max_index = 0;\n            for (int j = 0; j < BEAM_WIDTH; j++) {\n                if (temp_scores[j][i] > max_score) {\n                    max_score = temp_scores[j][i];\n                    max_index = j;\n                }\n            }\n            scores[t][i] = max_score;\n            paths[t][i] = temp_paths[max_index][i];\n        }\n    }\n\n    // Extract the best path\n    int best_index = 0;\n    float best_score = -std::numeric_limits<float>::infinity();\n    for (int i = 0; i < BEAM_WIDTH; i++) {\n        if (scores[SEQUENCE_LENGTH-1][i] > best_score) {\n            best_score = scores[SEQUENCE_LENGTH-1][i];\n            best_index = i;\n        }\n    }\n\n    for (int t = 0; t < SEQUENCE_LENGTH; t++) {\n        output[t] = paths[t][best_index];\n    }\n}\n\n// Top function name: beam_search\n"
      }
    ],
    "code_length": 1924,
    "token_count": 531,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/beam_search_decoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1082196999,
    "Worst-caseLatency": 1082196999.0,
    "BRAM_18K": 2050,
    "LUT": 1940,
    "DSP": 2,
    "FF": 1232,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "beam_search_decoding",
    "ResourceMetric": 0.1276536937,
    "design_id": "project",
    "algo_name": "beam_search_decoding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "beam_search_decoding.cpp",
        "file_content": "#include <iostream>\n#include <limits>\n\n#define BEAM_WIDTH 4\n#define SEQ_LENGTH 1024\n#define VOCAB_SIZE 256\n\nvoid beam_search_decoding(\n    float probabilities[SEQ_LENGTH][VOCAB_SIZE],\n    int output_sequences[BEAM_WIDTH][SEQ_LENGTH],\n    float output_scores[BEAM_WIDTH])\n{\n    int beam_sequences[BEAM_WIDTH][SEQ_LENGTH] = {0};\n    float beam_scores[BEAM_WIDTH] = {0.0f};\n\n    for (int t = 0; t < SEQ_LENGTH; ++t) {\n        float temp_scores[BEAM_WIDTH * VOCAB_SIZE];\n        int temp_sequences[BEAM_WIDTH * VOCAB_SIZE][SEQ_LENGTH];\n\n        for (int i = 0; i < BEAM_WIDTH; ++i) {\n            for (int j = 0; j < VOCAB_SIZE; ++j) {\n                float score = beam_scores[i] + probabilities[t][j];\n                temp_scores[i * VOCAB_SIZE + j] = score;\n\n                for (int k = 0; k < SEQ_LENGTH; ++k) {\n                    temp_sequences[i * VOCAB_SIZE + j][k] = beam_sequences[i][k];\n                }\n                temp_sequences[i * VOCAB_SIZE + j][t] = j;\n            }\n        }\n\n        for (int i = 0; i < BEAM_WIDTH; ++i) {\n            float max_score = -std::numeric_limits<float>::infinity();\n            int max_index = 0;\n\n            for (int j = 0; j < BEAM_WIDTH * VOCAB_SIZE; ++j) {\n                if (temp_scores[j] > max_score) {\n                    max_score = temp_scores[j];\n                    max_index = j;\n                }\n            }\n\n            beam_scores[i] = temp_scores[max_index];\n            for (int k = 0; k < SEQ_LENGTH; ++k) {\n                beam_sequences[i][k] = temp_sequences[max_index][k];\n            }\n\n            temp_scores[max_index] = -std::numeric_limits<float>::infinity();\n        }\n    }\n\n    for (int i = 0; i < BEAM_WIDTH; ++i) {\n        output_scores[i] = beam_scores[i];\n        for (int j = 0; j < SEQ_LENGTH; ++j) {\n            output_sequences[i][j] = beam_sequences[i][j];\n        }\n    }\n}\n\n// Top function name: beam_search_decoding\n"
      }
    ],
    "code_length": 1913,
    "token_count": 510,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/bellman_ford/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6286352,
    "Worst-caseLatency": 6295571.0,
    "BRAM_18K": 0,
    "LUT": 1063,
    "DSP": 0,
    "FF": 278,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bellman_ford",
    "ResourceMetric": 0.0002305014,
    "design_id": "project",
    "algo_name": "bellman_ford",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "bellman_ford.cpp",
        "file_content": "#include <limits.h>\n\n#define V 1024 // Number of vertices in the graph\n#define E 2048 // Number of edges in the graph\n\nvoid bellman_ford(int graph[E][3], int src, int dist[V]) {\n    int i, j;\n\n    // Step 1: Initialize distances from src to all other vertices as INFINITE\n    for (i = 0; i < V; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[src] = 0;\n\n    // Step 2: Relax all edges |V| - 1 times.\n    for (i = 1; i <= V - 1; i++) {\n        for (j = 0; j < E; j++) {\n            int u = graph[j][0];\n            int v = graph[j][1];\n            int weight = graph[j][2];\n            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n            }\n        }\n    }\n\n    // Step 3: Check for negative-weight cycles.\n    for (i = 0; i < E; i++) {\n        int u = graph[i][0];\n        int v = graph[i][1];\n        int weight = graph[i][2];\n        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {\n            // If we get here, then there is a negative weight cycle.\n            // For simplicity, we will just set all distances to INT_MAX to indicate this.\n            for (j = 0; j < V; j++) {\n                dist[j] = INT_MAX;\n            }\n            return;\n        }\n    }\n}\n\n// Top function name: bellman_ford\n"
      }
    ],
    "code_length": 1274,
    "token_count": 371,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/benjamini_hochberg_procedure/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 15371,
    "Worst-caseLatency": 4197395.0,
    "BRAM_18K": 3,
    "LUT": 1190,
    "DSP": 3,
    "FF": 675,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "benjamini_hochberg_procedure",
    "ResourceMetric": 0.0005620444,
    "design_id": "project",
    "algo_name": "benjamini_hochberg_procedure",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "benjamini_hochberg_procedure.cpp",
        "file_content": "#include <algorithm>\n\n#define ARRAY_SIZE 1024\n\nvoid benjamini_hochberg_procedure(float p_values[ARRAY_SIZE], float q_values[ARRAY_SIZE], float alpha) {\n    int i, j;\n    float sorted_p_values[ARRAY_SIZE];\n    int indices[ARRAY_SIZE];\n\n    // Initialize indices\n    for (i = 0; i < ARRAY_SIZE; i++) {\n        indices[i] = i;\n    }\n\n    // Sort p-values and keep track of original indices\n    for (i = 0; i < ARRAY_SIZE - 1; i++) {\n        for (j = 0; j < ARRAY_SIZE - i - 1; j++) {\n            if (p_values[j] > p_values[j + 1]) {\n                std::swap(p_values[j], p_values[j + 1]);\n                std::swap(indices[j], indices[j + 1]);\n            }\n        }\n    }\n\n    // Apply the Benjamini-Hochberg procedure\n    for (i = 0; i < ARRAY_SIZE; i++) {\n        sorted_p_values[i] = p_values[i];\n    }\n\n    for (i = 0; i < ARRAY_SIZE; i++) {\n        q_values[indices[i]] = sorted_p_values[i] * ARRAY_SIZE / (i + 1);\n    }\n\n    // Ensure q_values are non-decreasing\n    for (i = ARRAY_SIZE - 2; i >= 0; i--) {\n        if (q_values[indices[i]] > q_values[indices[i + 1]]) {\n            q_values[indices[i]] = q_values[indices[i + 1]];\n        }\n    }\n}\n// Top function name: benjamini_hochberg_procedure\n"
      }
    ],
    "code_length": 1206,
    "token_count": 359,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bfgs/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9438254,
    "Worst-caseLatency": 9438254.0,
    "BRAM_18K": 0,
    "LUT": 3443,
    "DSP": 30,
    "FF": 3599,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bfgs",
    "ResourceMetric": 0.0018364442,
    "design_id": "project",
    "algo_name": "bfgs",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bfgs.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define N 1024\n\nvoid bfgs(double x[N], double g[N], double H[N][N], double s[N], double y[N], double rho, double alpha[N], double q[N], double r[N]) {\n    int i, j, k;\n\n    // Compute q = H * g\n    for (i = 0; i < N; i++) {\n        q[i] = 0;\n        for (j = 0; j < N; j++) {\n            q[i] += H[i][j] * g[j];\n        }\n    }\n\n    // Compute alpha\n    for (i = 0; i < N; i++) {\n        alpha[i] = 0;\n        for (j = 0; j < N; j++) {\n            alpha[i] += s[j] * H[j][i];\n        }\n        alpha[i] *= rho;\n    }\n\n    // Compute r = q - alpha\n    for (i = 0; i < N; i++) {\n        r[i] = q[i] - alpha[i];\n    }\n\n    // Update H\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            H[i][j] += rho * (s[i] * s[j] - r[i] * r[j]);\n        }\n    }\n}\n\n// Top function name: bfgs\n"
      }
    ],
    "code_length": 837,
    "token_count": 309,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/bfs_bulk/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 770,
    "Worst-caseLatency": 1328660.0,
    "BRAM_18K": 0,
    "LUT": 697,
    "DSP": 0,
    "FF": 454,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bfs",
    "ResourceMetric": 0.0001771907,
    "design_id": "project",
    "algo_name": "bfs_bulk",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "bfs.h",
        "file_content": "/*\nImplementations based on:\nHarish and Narayanan. \"Accelerating large graph algorithms on the GPU using CUDA.\" HiPC, 2007.\nHong, Oguntebi, Olukotun. \"Efficient Parallel Graph Exploration on Multi-Core CPU and GPU.\" PACT, 2011.\n*/\n\n#include <stdlib.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include \"support.h\"\n\n// Terminology (but not values) from graph500 spec\n//   graph density = 2^-(2*SCALE - EDGE_FACTOR)\n#define SCALE 8\n#define EDGE_FACTOR 16\n\n#define N_NODES (1LL<<SCALE)\n#define N_EDGES (N_NODES*EDGE_FACTOR)\n\n// upper limit\n#define N_LEVELS 10\n\n// Larger than necessary for small graphs, but appropriate for large ones\ntypedef uint64_t edge_index_t;\ntypedef uint64_t node_index_t;\n\ntypedef struct edge_t_struct {\n  // These fields are common in practice, but we elect not to use them.\n  //weight_t weight;\n  //node_index_t src;\n  node_index_t dst;\n} edge_t;\n\ntypedef struct node_t_struct {\n  edge_index_t edge_begin;\n  edge_index_t edge_end;\n} node_t;\n\ntypedef int8_t level_t;\n#define MAX_LEVEL INT8_MAX\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  node_t nodes[N_NODES];\n  edge_t edges[N_EDGES];\n  node_index_t starting_node;\n  level_t level[N_NODES];\n  edge_index_t level_counts[N_LEVELS];\n};\n\nvoid bfs(node_t nodes[N_NODES], edge_t edges[N_EDGES], node_index_t starting_node, level_t level[N_NODES], edge_index_t level_counts[N_LEVELS]);\n\n"
      },
      {
        "file_name": "bfs.c",
        "file_content": "/*\nImplementations based on:\nHarish and Narayanan. \"Accelerating large graph algorithms on the GPU using CUDA.\" HiPC, 2007.\nHong, Oguntebi, Olukotun. \"Efficient Parallel Graph Exploration on Multi-Core CPU and GPU.\" PACT, 2011.\n*/\n\n#include \"bfs.h\"\n\nvoid bfs(node_t nodes[N_NODES], edge_t edges[N_EDGES],\n            node_index_t starting_node, level_t level[N_NODES],\n            edge_index_t level_counts[N_LEVELS])\n{\n  node_index_t n;\n  edge_index_t e;\n  level_t horizon;\n  edge_index_t cnt;\n\n  level[starting_node] = 0;\n  level_counts[0] = 1;\n\n  loop_horizons: for( horizon=0; horizon<N_LEVELS; horizon++ ) {\n    #pragma HLS loop_tripcount min=1 max=N_LEVELS\n    cnt = 0;\n    // Add unmarked neighbors of the current horizon to the next horizon\n    loop_nodes: for( n=0; n<N_NODES; n++ ) {\n      if( level[n]==horizon ) {\n        edge_index_t tmp_begin = nodes[n].edge_begin;\n        edge_index_t tmp_end = nodes[n].edge_end;\n        loop_neighbors: for( e=tmp_begin; e<tmp_end; e++ ) {\n          #pragma HLS loop_tripcount min=1 max=N_NODES\n          node_index_t tmp_dst = edges[e].dst;\n          level_t tmp_level = level[tmp_dst];\n\n          if( tmp_level ==MAX_LEVEL ) { // Unmarked\n            level[tmp_dst] = horizon+1;\n            ++cnt;\n          }\n        }\n      }\n    }\n    if( (level_counts[horizon+1]=cnt)==0 )\n      break;\n  }\n}\n"
      }
    ],
    "code_length": 1349,
    "token_count": 375,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/bfs_queue/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 198401.0,
    "BRAM_18K": 0,
    "LUT": 995,
    "DSP": 0,
    "FF": 339,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bfs",
    "ResourceMetric": 0.0002233102,
    "design_id": "project",
    "algo_name": "bfs_queue",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "bfs.h",
        "file_content": "/*\nImplementation based on:\nHong, Oguntebi, Olukotun. \"Efficient Parallel Graph Exploration on Multi-Core CPU and GPU.\" PACT, 2011.\n*/\n\n#include <stdlib.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <string.h>\n#include \"support.h\"\n\n// Terminology (but not values) from graph500 spec\n//   graph density = 2^-(2*SCALE - EDGE_FACTOR)\n#define SCALE 8\n#define EDGE_FACTOR 16\n\n#define N_NODES (1<<SCALE)\n#define N_EDGES (N_NODES*EDGE_FACTOR)\n\n// upper limit\n#define N_LEVELS 10\n\n// Larger than necessary for small graphs, but appropriate for large ones\ntypedef uint64_t edge_index_t;\ntypedef uint64_t node_index_t;\n\ntypedef struct edge_t_struct {\n  // These fields are common in practice, but we elect not to use them.\n  //weight_t weight;\n  //node_index_t src;\n  node_index_t dst;\n} edge_t;\n\ntypedef struct node_t_struct {\n  edge_index_t edge_begin;\n  edge_index_t edge_end;\n} node_t;\n\ntypedef int8_t level_t;\n#define MAX_LEVEL INT8_MAX\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  node_t nodes[N_NODES];\n  edge_t edges[N_EDGES];\n  node_index_t starting_node;\n  level_t level[N_NODES];\n  edge_index_t level_counts[N_LEVELS];\n};\n\nvoid bfs(node_t nodes[N_NODES], edge_t edges[N_EDGES], node_index_t starting_node, level_t level[N_NODES], edge_index_t level_counts[N_LEVELS]);\n"
      },
      {
        "file_name": "bfs.c",
        "file_content": "/*\nImplementation based on:\nHong, Oguntebi, Olukotun. \"Efficient Parallel Graph Exploration on Multi-Core CPU and GPU.\" PACT, 2011.\n*/\n\n#include \"bfs.h\"\n\n#define Q_PUSH(node) { queue[q_in==0?N_NODES-1:q_in-1]=node; q_in=(q_in+1)%N_NODES; }\n#define Q_PEEK() (queue[q_out])\n#define Q_POP() { q_out = (q_out+1)%N_NODES; }\n#define Q_EMPTY() (q_in>q_out ? q_in==q_out+1 : (q_in==0)&&(q_out==N_NODES-1))\n\nvoid bfs(node_t nodes[N_NODES], edge_t edges[N_EDGES],\n            node_index_t starting_node, level_t level[N_NODES],\n            edge_index_t level_counts[N_LEVELS])\n{\n  node_index_t queue[N_NODES];\n  node_index_t q_in, q_out;\n  node_index_t dummy;\n  node_index_t n;\n  edge_index_t e;\n\n  /*init_levels: for( n=0; n<N_NODES; n++ )*/\n  /*level[n] = MAX_LEVEL;*/\n  /*init_horizons: for( i=0; i<N_LEVELS; i++ )*/\n  /*level_counts[i] = 0;*/\n\n  q_in = 1;\n  q_out = 0;\n  level[starting_node] = 0;\n  level_counts[0] = 1;\n  Q_PUSH(starting_node);\n\n  loop_queue: for( dummy=0; dummy<N_NODES; dummy++ ) { // Typically while(not_empty(queue)){\n    if( Q_EMPTY() )\n      break;\n    n = Q_PEEK();\n    Q_POP();\n    edge_index_t tmp_begin = nodes[n].edge_begin;\n    edge_index_t tmp_end = nodes[n].edge_end;\n    loop_neighbors: for( e=tmp_begin; e<tmp_end; e++ ) {\n      #pragma HLS loop_tripcount min=1 max=N_NODES\n      node_index_t tmp_dst = edges[e].dst;\n      level_t tmp_level = level[tmp_dst];\n\n      if( tmp_level ==MAX_LEVEL ) { // Unmarked\n        level_t tmp_level = level[n]+1;\n        level[tmp_dst] = tmp_level;\n        ++level_counts[tmp_level];\n        Q_PUSH(tmp_dst);\n      }\n    }\n  }\n\n  /*\n  printf(\"Horizons:\");\n  for( i=0; i<N_LEVELS; i++ )\n    printf(\" %d\", level_counts[i]);\n  printf(\"\\n\");\n  */\n}\n"
      }
    ],
    "code_length": 1707,
    "token_count": 537,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bidirectional_rnn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16777229,
    "Worst-caseLatency": 16777229.0,
    "BRAM_18K": 0,
    "LUT": 1140,
    "DSP": 2,
    "FF": 738,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bidirectional_rnn",
    "ResourceMetric": 0.000344781,
    "design_id": "project",
    "algo_name": "bidirectional_rnn",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bidirectional_rnn.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SEQ_LEN 1024\n#define INPUT_SIZE 128\n#define HIDDEN_SIZE 64\n\nvoid bidirectional_rnn(\n    ap_int<16> input[SEQ_LEN][INPUT_SIZE],\n    ap_int<16> forward_weights[INPUT_SIZE][HIDDEN_SIZE],\n    ap_int<16> backward_weights[INPUT_SIZE][HIDDEN_SIZE],\n    ap_int<16> forward_hidden[HIDDEN_SIZE],\n    ap_int<16> backward_hidden[HIDDEN_SIZE],\n    ap_int<16> forward_output[SEQ_LEN][HIDDEN_SIZE],\n    ap_int<16> backward_output[SEQ_LEN][HIDDEN_SIZE]\n) {\n    // Forward pass\n    for (int t = 0; t < SEQ_LEN; t++) {\n        for (int h = 0; h < HIDDEN_SIZE; h++) {\n            ap_int<16> sum = 0;\n            for (int i = 0; i < INPUT_SIZE; i++) {\n                sum += input[t][i] * forward_weights[i][h];\n            }\n            forward_hidden[h] = sum;\n            forward_output[t][h] = forward_hidden[h];\n        }\n    }\n\n    // Backward pass\n    for (int t = SEQ_LEN - 1; t >= 0; t--) {\n        for (int h = 0; h < HIDDEN_SIZE; h++) {\n            ap_int<16> sum = 0;\n            for (int i = 0; i < INPUT_SIZE; i++) {\n                sum += input[t][i] * backward_weights[i][h];\n            }\n            backward_hidden[h] = sum;\n            backward_output[t][h] = backward_hidden[h];\n        }\n    }\n}\n\n// Top function name: bidirectional_rnn\n"
      }
    ],
    "code_length": 1268,
    "token_count": 367,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/bidirectional_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2056,
    "Worst-caseLatency": 3083.0,
    "BRAM_18K": 0,
    "LUT": 707,
    "DSP": 0,
    "FF": 139,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bidirectional_shift_register",
    "ResourceMetric": 0.0001489054,
    "design_id": "project",
    "algo_name": "bidirectional_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "bidirectional_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid bidirectional_shift_register(ap_uint<1> direction, ap_uint<1> load, ap_uint<1> data_in, ap_uint<1> data_out[SIZE], ap_uint<1> register_array[SIZE]) {\n    ap_uint<1> temp[SIZE];\n\n    // Load new data into the register if load is high\n    if (load) {\n        for (int i = 0; i < SIZE; i++) {\n            register_array[i] = data_out[i];\n        }\n    } else {\n        // Shift left or right based on direction\n        if (direction) {\n            // Shift right\n            temp[0] = data_in;\n            for (int i = 1; i < SIZE; i++) {\n                temp[i] = register_array[i - 1];\n            }\n        } else {\n            // Shift left\n            temp[SIZE - 1] = data_in;\n            for (int i = 0; i < SIZE - 1; i++) {\n                temp[i] = register_array[i + 1];\n            }\n        }\n\n        // Update the register array\n        for (int i = 0; i < SIZE; i++) {\n            register_array[i] = temp[i];\n        }\n    }\n\n    // Output the current state of the register\n    for (int i = 0; i < SIZE; i++) {\n        data_out[i] = register_array[i];\n    }\n}\n\n// Top function name: bidirectional_shift_register\n"
      }
    ],
    "code_length": 1170,
    "token_count": 322,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/binary_adder_4bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 101,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_adder_4bit",
    "ResourceMetric": 2.17653e-05,
    "design_id": "project",
    "algo_name": "binary_adder_4bit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "binary_adder_4bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid binary_adder_4bit(ap_uint<4> A[N], ap_uint<4> B[N], ap_uint<4> Sum[N], ap_uint<1> Carry[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<5> temp = A[i] + B[i];\n        Sum[i] = temp.range(3, 0);\n        Carry[i] = temp[4];\n    }\n}\n\n// Top function name: binary_adder_4bit\n"
      }
    ],
    "code_length": 321,
    "token_count": 120,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/binary_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 386,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_counter",
    "ResourceMetric": 7.64183e-05,
    "design_id": "project",
    "algo_name": "binary_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "binary_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid binary_counter(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<32> count = 0;\n        ap_uint<32> value = input[i];\n        for (int j = 0; j < 32; j++) {\n            count += value[j];\n        }\n        output[i] = count;\n    }\n}\n\n// Top function name: binary_counter\n"
      }
    ],
    "code_length": 372,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/binary_encoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 2094,
    "DSP": 0,
    "FF": 97,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_encoding",
    "ResourceMetric": 0.0004108562,
    "design_id": "project",
    "algo_name": "binary_encoding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "binary_encoding.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid binary_encoding(uint32_t input[ARRAY_SIZE], uint32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t value = input[i];\n        uint32_t encoded_value = 0;\n        for (int bit = 0; bit < 32; bit++) {\n            if (value & (1 << bit)) {\n                encoded_value |= (1 << (31 - bit));\n            }\n        }\n        output[i] = encoded_value;\n    }\n}\n\n// Top function name: binary_encoding\n"
      }
    ],
    "code_length": 481,
    "token_count": 131,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/binary_full_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_full_adder",
    "ResourceMetric": 2.09983e-05,
    "design_id": "project",
    "algo_name": "binary_full_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "binary_full_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid binary_full_adder(ap_uint<4> A[ARRAY_SIZE], ap_uint<4> B[ARRAY_SIZE], ap_uint<1> Cin[ARRAY_SIZE], ap_uint<4> Sum[ARRAY_SIZE], ap_uint<1> Cout[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<5> temp = A[i] + B[i] + Cin[i];\n        Sum[i] = temp.range(3, 0);\n        Cout[i] = temp[4];\n    }\n}\n\n// Top function name: binary_full_adder\n"
      }
    ],
    "code_length": 410,
    "token_count": 140,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/binary_rate_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 79,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_rate_multiplier",
    "ResourceMetric": 1.75465e-05,
    "design_id": "project",
    "algo_name": "binary_rate_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "binary_rate_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid binary_rate_multiplier(ap_uint<1> input[N], ap_uint<1> rate[N], ap_uint<1> output[N]) {\n    for (int i = 0; i < N; i++) {\n        output[i] = input[i] & rate[i];\n    }\n}\n\n// Top function name: binary_rate_multiplier\n"
      }
    ],
    "code_length": 258,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/binary_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5,
    "Worst-caseLatency": 2054.0,
    "BRAM_18K": 0,
    "LUT": 557,
    "DSP": 0,
    "FF": 228,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "binary_search",
    "ResourceMetric": 0.0001286742,
    "design_id": "project",
    "algo_name": "binary_search",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "binary_search.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid binary_search(ap_int<32> array[ARRAY_SIZE], ap_int<32> key, ap_int<32> &index) {\n    ap_int<32> low = 0;\n    ap_int<32> high = ARRAY_SIZE - 1;\n    ap_int<32> mid;\n\n    index = -1; // Default value if key is not found\n\n    for (ap_int<32> i = 0; i < ARRAY_SIZE; i++) {\n        if (low <= high) {\n            mid = (low + high) / 2;\n            if (array[mid] == key) {\n                index = mid;\n                break;\n            } else if (array[mid] < key) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n}\n\n// Top function name: binary_search\n"
      }
    ],
    "code_length": 667,
    "token_count": 196,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit64_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 148,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit64_comparator",
    "ResourceMetric": 3.07783e-05,
    "design_id": "project",
    "algo_name": "bit64_comparator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit64_comparator.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid bit64_comparator(uint64_t input1[ARRAY_SIZE], uint64_t input2[ARRAY_SIZE], bool output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input1[i] > input2[i]);\n    }\n}\n\n// Top function name: bit64_comparator\n"
      }
    ],
    "code_length": 288,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_adder_2bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 96,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_adder_2bit",
    "ResourceMetric": 2.08065e-05,
    "design_id": "project",
    "algo_name": "bit_adder_2bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_adder_2bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bit_adder_2bit(ap_uint<2> A[ARRAY_SIZE], ap_uint<2> B[ARRAY_SIZE], ap_uint<2> Sum[ARRAY_SIZE], ap_uint<1> Carry[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<3> temp = A[i] + B[i];\n        Sum[i] = temp.range(1, 0);\n        Carry[i] = temp[2];\n    }\n}\n\n// Top function name: bit_adder_2bit\n"
      }
    ],
    "code_length": 369,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 86,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_comparator",
    "ResourceMetric": 1.88888e-05,
    "design_id": "project",
    "algo_name": "bit_comparator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid bit_comparator(ap_uint<2> A[SIZE], ap_uint<2> B[SIZE], bool result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        result[i] = (A[i] == B[i]);\n    }\n}\n\n// Top function name: bit_comparator\n"
      }
    ],
    "code_length": 240,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_comparator_4bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 89,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_comparator_4bit",
    "ResourceMetric": 1.94641e-05,
    "design_id": "project",
    "algo_name": "bit_comparator_4bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_comparator_4bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bit_comparator_4bit(ap_uint<4> A[ARRAY_SIZE], ap_uint<4> B[ARRAY_SIZE], bool result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result[i] = (A[i] > B[i]);\n    }\n}\n\n// Top function name: bit_comparator_4bit\n"
      }
    ],
    "code_length": 279,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 89,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_counter",
    "ResourceMetric": 1.94641e-05,
    "design_id": "project",
    "algo_name": "bit_counter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define MAX_COUNT 1024\n\nvoid bit_counter(ap_uint<4> input[MAX_COUNT], ap_uint<4> output[MAX_COUNT]) {\n    for (int i = 0; i < MAX_COUNT; i++) {\n        output[i] = input[i] + 1;\n    }\n}\n\n// Top function name: bit_counter\n"
      }
    ],
    "code_length": 242,
    "token_count": 75,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_counter_2bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 273,
    "DSP": 0,
    "FF": 94,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_counter_2bit",
    "ResourceMetric": 6.13648e-05,
    "design_id": "project",
    "algo_name": "bit_counter_2bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_counter_2bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bit_counter_2bit(ap_uint<2> input_array[ARRAY_SIZE], ap_uint<10> &count_0, ap_uint<10> &count_1, ap_uint<10> &count_2, ap_uint<10> &count_3) {\n    count_0 = 0;\n    count_1 = 0;\n    count_2 = 0;\n    count_3 = 0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (input_array[i]) {\n            case 0:\n                count_0++;\n                break;\n            case 1:\n                count_1++;\n                break;\n            case 2:\n                count_2++;\n                break;\n            case 3:\n                count_3++;\n                break;\n        }\n    }\n}\n\n// Top function name: bit_counter_2bit\n"
      }
    ],
    "code_length": 678,
    "token_count": 196,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 215,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_divider",
    "ResourceMetric": 4.36265e-05,
    "design_id": "project",
    "algo_name": "bit_divider",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bit_divider(ap_uint<4> dividend[ARRAY_SIZE], ap_uint<4> divisor[ARRAY_SIZE], ap_uint<4> quotient[ARRAY_SIZE], ap_uint<4> remainder[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<4> temp_dividend = dividend[i];\n        ap_uint<4> temp_divisor = divisor[i];\n        ap_uint<4> temp_quotient = 0;\n        ap_uint<4> temp_remainder = 0;\n\n        for (int j = 3; j >= 0; j--) {\n            temp_remainder = (temp_remainder << 1) | ((temp_dividend >> j) & 1);\n            if (temp_remainder >= temp_divisor) {\n                temp_remainder -= temp_divisor;\n                temp_quotient |= (1 << j);\n            }\n        }\n\n        quotient[i] = temp_quotient;\n        remainder[i] = temp_remainder;\n    }\n}\n\n// Top function name: bit_divider\n"
      }
    ],
    "code_length": 817,
    "token_count": 237,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bit_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 88,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bit_multiplier",
    "ResourceMetric": 1.92724e-05,
    "design_id": "project",
    "algo_name": "bit_multiplier",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bit_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bit_multiplier(ap_uint<4> A[ARRAY_SIZE], ap_uint<4> B[ARRAY_SIZE], ap_uint<8> C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: bit_multiplier\n"
      }
    ],
    "code_length": 263,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/black_scholes/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1185,
    "Worst-caseLatency": 1185.0,
    "BRAM_18K": 0,
    "LUT": 95171,
    "DSP": 1275,
    "FF": 97215,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "black_scholes",
    "ResourceMetric": 0.0628941359,
    "design_id": "project",
    "algo_name": "black_scholes",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "black_scholes.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid black_scholes(\n    double S[ARRAY_SIZE], // Stock price\n    double X[ARRAY_SIZE], // Strike price\n    double T[ARRAY_SIZE], // Time to maturity\n    double r,             // Risk-free rate\n    double v,             // Volatility\n    double call[ARRAY_SIZE], // Call option price\n    double put[ARRAY_SIZE]   // Put option price\n) {\n    const double PI = 3.14159265358979323846;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        double d1 = (log(S[i] / X[i]) + (r + 0.5 * v * v) * T[i]) / (v * sqrt(T[i]));\n        double d2 = d1 - v * sqrt(T[i]);\n\n        double cdf_d1 = 0.5 * (1.0 + erf(d1 / sqrt(2.0)));\n        double cdf_d2 = 0.5 * (1.0 + erf(d2 / sqrt(2.0)));\n\n        call[i] = S[i] * cdf_d1 - X[i] * exp(-r * T[i]) * cdf_d2;\n        put[i] = X[i] * exp(-r * T[i]) * (1.0 - cdf_d2) - S[i] * (1.0 - cdf_d1);\n    }\n}\n\n// Top function name: black_scholes\n"
      }
    ],
    "code_length": 907,
    "token_count": 323,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/bluetooth_module/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 85,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bluetooth_module",
    "ResourceMetric": 1.86971e-05,
    "design_id": "project",
    "algo_name": "bluetooth_module",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "bluetooth_module.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bluetooth_module(uint8_t input_data[ARRAY_SIZE], uint8_t output_data[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Simple processing: invert the bits of each byte\n        output_data[i] = ~input_data[i];\n    }\n}\n\n// Top function name: bluetooth_module\n"
      }
    ],
    "code_length": 326,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/boosting/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3096,
    "Worst-caseLatency": 3096.0,
    "BRAM_18K": 0,
    "LUT": 1010,
    "DSP": 7,
    "FF": 972,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "boosting",
    "ResourceMetric": 0.0004808075,
    "design_id": "project",
    "algo_name": "boosting",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "boosting.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid boosting(float input[N], float output[N], float weights[N], float alpha) {\n    float weighted_sum = 0.0;\n    float sum_weights = 0.0;\n\n    // Calculate weighted sum and sum of weights\n    for (int i = 0; i < N; i++) {\n        weighted_sum += input[i] * weights[i];\n        sum_weights += weights[i];\n    }\n\n    // Calculate the weighted average\n    float weighted_avg = weighted_sum / sum_weights;\n\n    // Boosting step\n    for (int i = 0; i < N; i++) {\n        output[i] = input[i] + alpha * (input[i] - weighted_avg);\n    }\n}\n\n// Top function name: boosting\n"
      }
    ],
    "code_length": 599,
    "token_count": 163,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/booth_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 34,
    "Worst-caseLatency": 34.0,
    "BRAM_18K": 0,
    "LUT": 191,
    "DSP": 0,
    "FF": 72,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "booth_multiplier",
    "ResourceMetric": 4.35306e-05,
    "design_id": "project",
    "algo_name": "booth_multiplier",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "booth_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid booth_multiplier(ap_int<32> x, ap_int<32> y, ap_int<64> &product) {\n    ap_int<64> A = x;\n    ap_int<64> S = -x;\n    ap_int<64> P = 0;\n    P.range(63, 32) = y;\n    \n    for (int i = 0; i < 32; i++) {\n        ap_int<2> last_two_bits = P.range(1, 0);\n        if (last_two_bits == 1) {\n            P.range(63, 32) = P.range(63, 32) + A;\n        } else if (last_two_bits == 2) {\n            P.range(63, 32) = P.range(63, 32) + S;\n        }\n        P = P >> 1;\n    }\n    \n    product = P;\n}\n\n// Top function name: booth_multiplier\n"
      }
    ],
    "code_length": 568,
    "token_count": 211,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bootstrap_sampling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 38,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bootstrap_sampling",
    "ResourceMetric": 1.84094e-05,
    "design_id": "project",
    "algo_name": "bootstrap_sampling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bootstrap_sampling.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024  // Large scale array size\n\nvoid bootstrap_sampling(ap_int<32> input[N], ap_int<32> output[N], ap_int<32> indices[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_int<32> index = indices[i];\n        output[i] = input[index];\n    }\n}\n\n// Top function name: bootstrap_sampling\n"
      }
    ],
    "code_length": 313,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/box_cox_transformation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1061,
    "Worst-caseLatency": 1061.0,
    "BRAM_18K": 5,
    "LUT": 13450,
    "DSP": 138,
    "FF": 8938,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "box_cox_transformation",
    "ResourceMetric": 0.0075693925,
    "design_id": "project",
    "algo_name": "box_cox_transformation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "box_cox_transformation.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid box_cox_transformation(double input[N], double output[N], double lambda) {\n    for (int i = 0; i < N; i++) {\n        if (lambda == 0) {\n            output[i] = log(input[i]);\n        } else {\n            output[i] = (pow(input[i], lambda) - 1) / lambda;\n        }\n    }\n}\n\n// Top function name: box_cox_transformation\n"
      }
    ],
    "code_length": 357,
    "token_count": 101,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/branch_prediction/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 258,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "branch_prediction",
    "ResourceMetric": 5.18724e-05,
    "design_id": "project",
    "algo_name": "branch_prediction",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "branch_prediction.cpp",
        "file_content": "#include <stdint.h>\n\n#define N 1024\n\nvoid branch_prediction(int32_t input[N], int32_t output[N]) {\n    int32_t threshold = 500;\n    for (int i = 0; i < N; i++) {\n        if (input[i] > threshold) {\n            output[i] = input[i] * 2;\n        } else {\n            output[i] = input[i] / 2;\n        }\n    }\n}\n\n// Top function name: branch_prediction\n"
      }
    ],
    "code_length": 350,
    "token_count": 103,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/brent_kung_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3084,
    "Worst-caseLatency": 3084.0,
    "BRAM_18K": 1,
    "LUT": 520,
    "DSP": 0,
    "FF": 1102,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "brent_kung_adder",
    "ResourceMetric": 0.0002673841,
    "design_id": "project",
    "algo_name": "brent_kung_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "brent_kung_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid brent_kung_adder(ap_uint<N> A, ap_uint<N> B, ap_uint<N>& Sum) {\n    ap_uint<N> G[N], P[N], C[N+1];\n    ap_uint<N> temp_sum;\n\n    // Generate\n    for (int i = 0; i < N; i++) {\n        G[i] = A[i] & B[i];\n        P[i] = A[i] ^ B[i];\n    }\n\n    // Propagate\n    C[0] = 0;\n    for (int i = 1; i <= N; i++) {\n        C[i] = G[i-1] | (P[i-1] & C[i-1]);\n    }\n\n    // Sum\n    for (int i = 0; i < N; i++) {\n        temp_sum[i] = P[i] ^ C[i];\n    }\n\n    Sum = temp_sum;\n}\n\n// Top function name: brent_kung_adder\n"
      }
    ],
    "code_length": 545,
    "token_count": 217,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/brier_score/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2060,
    "Worst-caseLatency": 2060.0,
    "BRAM_18K": 0,
    "LUT": 556,
    "DSP": 5,
    "FF": 557,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "brier_score",
    "ResourceMetric": 0.0002985473,
    "design_id": "project",
    "algo_name": "brier_score",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "brier_score.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid brier_score(float predictions[ARRAY_SIZE], float actuals[ARRAY_SIZE], float &score) {\n    score = 0.0f;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float diff = predictions[i] - actuals[i];\n        score += diff * diff;\n    }\n    score /= ARRAY_SIZE;\n}\n\n// Top function name: brier_score\n"
      }
    ],
    "code_length": 343,
    "token_count": 96,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/bst_operations/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 64,
    "DSP": 0,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bst_operations",
    "ResourceMetric": 1.35194e-05,
    "design_id": "project",
    "algo_name": "bst_operations",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "bst_operations.cpp",
        "file_content": "#include <iostream>\n\n#define NODES 1024\n\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n};\n\nvoid insert(Node* tree, int key) {\n    Node* newNode = new Node;\n    newNode->key = key;\n    newNode->left = nullptr;\n    newNode->right = nullptr;\n\n    Node* parent = nullptr;\n    Node* current = tree;\n\n    while (current != nullptr) {\n        parent = current;\n        if (key < current->key) {\n            current = current->left;\n        } else {\n            current = current->right;\n        }\n    }\n\n    if (parent == nullptr) {\n        tree = newNode;\n    } else if (key < parent->key) {\n        parent->left = newNode;\n    } else {\n        parent->right = newNode;\n    }\n}\n\nbool search(Node* tree, int key) {\n    Node* current = tree;\n    while (current != nullptr) {\n        if (key == current->key) {\n            return true;\n        } else if (key < current->key) {\n            current = current->left;\n        } else {\n            current = current->right;\n        }\n    }\n    return false;\n}\n\nvoid inorder(Node* tree, int* result, int& index) {\n    if (tree != nullptr) {\n        inorder(tree->left, result, index);\n        result[index++] = tree->key;\n        inorder(tree->right, result, index);\n    }\n}\n\nvoid bst_operations(int keys[NODES], int search_keys[NODES], bool search_results[NODES], int inorder_result[NODES]) {\n    Node* tree = nullptr;\n\n    for (int i = 0; i < NODES; i++) {\n        insert(tree, keys[i]);\n    }\n\n    for (int i = 0; i < NODES; i++) {\n        search_results[i] = search(tree, search_keys[i]);\n    }\n\n    int index = 0;\n    inorder(tree, inorder_result, index);\n}\n\n// Top function name: bst_operations\n"
      }
    ],
    "code_length": 1650,
    "token_count": 427,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/bubble_sort/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6139,
    "Worst-caseLatency": 2097151.0,
    "BRAM_18K": 0,
    "LUT": 231,
    "DSP": 0,
    "FF": 77,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bubble_sort",
    "ResourceMetric": 5.16806e-05,
    "design_id": "project",
    "algo_name": "bubble_sort",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "bubble_sort.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid bubble_sort(ap_int<32> array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE - 1; i++) {\n        for (int j = 0; j < ARRAY_SIZE - i - 1; j++) {\n            if (array[j] > array[j + 1]) {\n                ap_int<32> temp = array[j];\n                array[j] = array[j + 1];\n                array[j + 1] = temp;\n            }\n        }\n    }\n}\n\n// Top function name: bubble_sort\n"
      }
    ],
    "code_length": 429,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/bundle_methods/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 210233355,
    "Worst-caseLatency": 210233355.0,
    "BRAM_18K": 16,
    "LUT": 2070,
    "DSP": 8,
    "FF": 1495,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bundle_methods",
    "ResourceMetric": 0.0017539922,
    "design_id": "project",
    "algo_name": "bundle_methods",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "bundle_methods.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid bundle_methods(float x[N], float g[N], float H[N][N], float alpha, float beta, float result[N]) {\n    float y[N];\n    float s[N];\n    float q[N];\n    float r[N];\n    float z[N];\n    float temp1[N];\n    float temp2[N];\n    float temp3[N];\n\n    // Initialize y and s\n    for (int i = 0; i < N; i++) {\n        y[i] = x[i];\n        s[i] = 0.0f;\n    }\n\n    // Main loop\n    for (int iter = 0; iter < 100; iter++) {\n        // Compute q = H * y\n        for (int i = 0; i < N; i++) {\n            q[i] = 0.0f;\n            for (int j = 0; j < N; j++) {\n                q[i] += H[i][j] * y[j];\n            }\n        }\n\n        // Compute r = q + g\n        for (int i = 0; i < N; i++) {\n            r[i] = q[i] + g[i];\n        }\n\n        // Compute z = alpha * r\n        for (int i = 0; i < N; i++) {\n            z[i] = alpha * r[i];\n        }\n\n        // Compute temp1 = beta * s\n        for (int i = 0; i < N; i++) {\n            temp1[i] = beta * s[i];\n        }\n\n        // Compute temp2 = y - z\n        for (int i = 0; i < N; i++) {\n            temp2[i] = y[i] - z[i];\n        }\n\n        // Compute temp3 = temp1 + temp2\n        for (int i = 0; i < N; i++) {\n            temp3[i] = temp1[i] + temp2[i];\n        }\n\n        // Update s and y\n        for (int i = 0; i < N; i++) {\n            s[i] = temp3[i];\n            y[i] = s[i];\n        }\n    }\n\n    // Copy result to output\n    for (int i = 0; i < N; i++) {\n        result[i] = y[i];\n    }\n}\n\n// Top function name: bundle_methods\n"
      }
    ],
    "code_length": 1516,
    "token_count": 504,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/burst_rw/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3,
    "Worst-caseLatency": 50689.0,
    "BRAM_18K": 3,
    "LUT": 1898,
    "DSP": 0,
    "FF": 1439,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vadd",
    "ResourceMetric": 0.0006879564,
    "design_id": "project",
    "algo_name": "burst_rw",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n/*******************************************************************************\nDescription:\n    HLS Example using AXI4-master interface for burst read and write\n*******************************************************************************/\n\n// Includes\n// Missing include: #include <stdio.h>\n// Missing include: #include <string.h>\n#define DATA_SIZE 2048\n#define INCR_VALUE 10\n// define internal buffer max size\n#define BURSTBUFFERSIZE 256\n\nvoid vadd(int* a, int size, int inc_value);\n// TRIPCOUNT identifiers\nconst unsigned int c_size_min = 1;\nconst unsigned int c_size_max = BURSTBUFFERSIZE;\nconst unsigned int c_chunk_sz = DATA_SIZE;\n\nvoid vadd(int* a, int size, int inc_value) {\n// Map pointer a to AXI4-master interface for global memory access\n#pragma HLS INTERFACE m_axi port = a offset = slave bundle = gmem max_read_burst_length = 256 max_write_burst_length = 256 depth = 2048\n// We also need to map a and return to a bundled axilite slave interface\n#pragma HLS INTERFACE s_axilite port = a\n#pragma HLS INTERFACE s_axilite port = size\n#pragma HLS INTERFACE s_axilite port = inc_value\n#pragma HLS INTERFACE s_axilite port = return\n\n    int burstbuffer[BURSTBUFFERSIZE];\n\nread_buf:\n    // Per iteration of this loop perform BURSTBUFFERSIZE vector addition\n    for (int i = 0; i < size; i += BURSTBUFFERSIZE) {\n#pragma HLS LOOP_TRIPCOUNT min = c_size_min* c_size_min max = c_chunk_sz * c_chunk_sz / (c_size_max * c_size_max)\n        int chunk_size = BURSTBUFFERSIZE;\n        // boundary checks\n        if ((i + BURSTBUFFERSIZE) > size) chunk_size = size - i;\n        // burst read\n        // Auto-pipeline is going to apply pipeline to these loops\n        for (int j = 0; j < chunk_size; j++) {\n// As the outer loop is not a perfect loop\n#pragma HLS loop_flatten off\n#pragma HLS LOOP_TRIPCOUNT min = c_size_min max = c_size_max\n            burstbuffer[j] = a[i + j];\n        }\n\n    // calculate and write results to global memory, the sequential write in a for\n    // loop can be inferred to a memory burst access\n    calc_write:\n        for (int j = 0; j < chunk_size; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_size_max max = c_chunk_sz\n            burstbuffer[j] = burstbuffer[j] + inc_value;\n            a[i + j] = burstbuffer[j];\n        }\n    }\n}\n"
      },
      {
        "file_name": "xvadd_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xvadd.h\"\n\nextern XVadd_Config XVadd_ConfigTable[];\n\n#ifdef SDT\nXVadd_Config *XVadd_LookupConfig(UINTPTR BaseAddress) {\n\tXVadd_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XVadd_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XVadd_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XVadd_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, UINTPTR BaseAddress) {\n\tXVadd_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XVadd_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XVadd_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXVadd_Config *XVadd_LookupConfig(u16 DeviceId) {\n\tXVadd_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XVADD_NUM_INSTANCES; Index++) {\n\t\tif (XVadd_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XVadd_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, u16 DeviceId) {\n\tXVadd_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XVadd_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XVadd_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xvadd_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : Control signals\n//        bit 0  - ap_start (Read/Write/COH)\n//        bit 1  - ap_done (Read/COR)\n//        bit 2  - ap_idle (Read)\n//        bit 3  - ap_ready (Read/COR)\n//        bit 7  - auto_restart (Read/Write)\n//        bit 9  - interrupt (Read)\n//        others - reserved\n// 0x04 : Global Interrupt Enable Register\n//        bit 0  - Global Interrupt Enable (Read/Write)\n//        others - reserved\n// 0x08 : IP Interrupt Enable Register (Read/Write)\n//        bit 0 - enable ap_done interrupt (Read/Write)\n//        bit 1 - enable ap_ready interrupt (Read/Write)\n//        others - reserved\n// 0x0c : IP Interrupt Status Register (Read/TOW)\n//        bit 0 - ap_done (Read/TOW)\n//        bit 1 - ap_ready (Read/TOW)\n//        others - reserved\n// 0x10 : Data signal of a\n//        bit 31~0 - a[31:0] (Read/Write)\n// 0x14 : Data signal of a\n//        bit 31~0 - a[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of size\n//        bit 31~0 - size[31:0] (Read/Write)\n// 0x20 : reserved\n// 0x24 : Data signal of inc_value\n//        bit 31~0 - inc_value[31:0] (Read/Write)\n// 0x28 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XVADD_CONTROL_ADDR_AP_CTRL        0x00\n#define XVADD_CONTROL_ADDR_GIE            0x04\n#define XVADD_CONTROL_ADDR_IER            0x08\n#define XVADD_CONTROL_ADDR_ISR            0x0c\n#define XVADD_CONTROL_ADDR_A_DATA         0x10\n#define XVADD_CONTROL_BITS_A_DATA         64\n#define XVADD_CONTROL_ADDR_SIZE_DATA      0x1c\n#define XVADD_CONTROL_BITS_SIZE_DATA      32\n#define XVADD_CONTROL_ADDR_INC_VALUE_DATA 0x24\n#define XVADD_CONTROL_BITS_INC_VALUE_DATA 32\n\n"
      },
      {
        "file_name": "xvadd.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xvadd.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XVadd_CfgInitialize(XVadd *InstancePtr, XVadd_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XVadd_Start(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL) & 0x80;\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL, Data | 0x01);\n}\n\nu32 XVadd_IsDone(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL);\n    return (Data >> 1) & 0x1;\n}\n\nu32 XVadd_IsIdle(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL);\n    return (Data >> 2) & 0x1;\n}\n\nu32 XVadd_IsReady(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL);\n    // check ap_start to see if the pcore is ready for next input\n    return !(Data & 0x1);\n}\n\nvoid XVadd_EnableAutoRestart(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL, 0x80);\n}\n\nvoid XVadd_DisableAutoRestart(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_AP_CTRL, 0);\n}\n\nvoid XVadd_Set_a(XVadd *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA, (u32)(Data));\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XVadd_Get_a(XVadd *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA);\n    Data += (u64)XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_A_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XVadd_Set_size(XVadd *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_SIZE_DATA, Data);\n}\n\nu32 XVadd_Get_size(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_SIZE_DATA);\n    return Data;\n}\n\nvoid XVadd_Set_inc_value(XVadd *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_INC_VALUE_DATA, Data);\n}\n\nu32 XVadd_Get_inc_value(XVadd *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_INC_VALUE_DATA);\n    return Data;\n}\n\nvoid XVadd_InterruptGlobalEnable(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_GIE, 1);\n}\n\nvoid XVadd_InterruptGlobalDisable(XVadd *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_GIE, 0);\n}\n\nvoid XVadd_InterruptEnable(XVadd *InstancePtr, u32 Mask) {\n    u32 Register;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Register =  XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER);\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER, Register | Mask);\n}\n\nvoid XVadd_InterruptDisable(XVadd *InstancePtr, u32 Mask) {\n    u32 Register;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Register =  XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER);\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER, Register & (~Mask));\n}\n\nvoid XVadd_InterruptClear(XVadd *InstancePtr, u32 Mask) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_ISR, Mask);\n}\n\nu32 XVadd_InterruptGetEnabled(XVadd *InstancePtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    return XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IER);\n}\n\nu32 XVadd_InterruptGetStatus(XVadd *InstancePtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    return XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_ISR);\n}\n\n"
      },
      {
        "file_name": "xvadd.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XVADD_H\n#define XVADD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xvadd_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XVadd_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XVadd;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XVadd_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XVadd_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XVadd_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XVadd_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XVadd_Initialize(XVadd *InstancePtr, UINTPTR BaseAddress);\nXVadd_Config* XVadd_LookupConfig(UINTPTR BaseAddress);\n#else\nint XVadd_Initialize(XVadd *InstancePtr, u16 DeviceId);\nXVadd_Config* XVadd_LookupConfig(u16 DeviceId);\n#endif\nint XVadd_CfgInitialize(XVadd *InstancePtr, XVadd_Config *ConfigPtr);\n#else\nint XVadd_Initialize(XVadd *InstancePtr, const char* InstanceName);\nint XVadd_Release(XVadd *InstancePtr);\n#endif\n\nvoid XVadd_Start(XVadd *InstancePtr);\nu32 XVadd_IsDone(XVadd *InstancePtr);\nu32 XVadd_IsIdle(XVadd *InstancePtr);\nu32 XVadd_IsReady(XVadd *InstancePtr);\nvoid XVadd_EnableAutoRestart(XVadd *InstancePtr);\nvoid XVadd_DisableAutoRestart(XVadd *InstancePtr);\n\nvoid XVadd_Set_a(XVadd *InstancePtr, u64 Data);\nu64 XVadd_Get_a(XVadd *InstancePtr);\nvoid XVadd_Set_size(XVadd *InstancePtr, u32 Data);\nu32 XVadd_Get_size(XVadd *InstancePtr);\nvoid XVadd_Set_inc_value(XVadd *InstancePtr, u32 Data);\nu32 XVadd_Get_inc_value(XVadd *InstancePtr);\n\nvoid XVadd_InterruptGlobalEnable(XVadd *InstancePtr);\nvoid XVadd_InterruptGlobalDisable(XVadd *InstancePtr);\nvoid XVadd_InterruptEnable(XVadd *InstancePtr, u32 Mask);\nvoid XVadd_InterruptDisable(XVadd *InstancePtr, u32 Mask);\nvoid XVadd_InterruptClear(XVadd *InstancePtr, u32 Mask);\nu32 XVadd_InterruptGetEnabled(XVadd *InstancePtr);\nu32 XVadd_InterruptGetStatus(XVadd *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xvadd_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xvadd.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XVadd_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XVadd_uio_map maps[ MAX_UIO_MAPS ];\n} XVadd_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XVadd_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XVadd_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XVadd_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XVadd_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XVadd_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, const char* InstanceName) {\n\tXVadd_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XVadd_Release(XVadd *InstancePtr) {\n\tXVadd_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      }
    ],
    "code_length": 15803,
    "token_count": 4315,
    "pragma_number": 9,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/bus_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 2,
    "LUT": 251,
    "DSP": 0,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bus_controller",
    "ResourceMetric": 0.0001775103,
    "design_id": "project",
    "algo_name": "bus_controller",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "bus_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define BUS_SIZE 1024\n\nvoid bus_controller(ap_uint<32> input_bus[BUS_SIZE], ap_uint<32> output_bus[BUS_SIZE]) {\n    ap_uint<32> temp[BUS_SIZE];\n\n    // Process the input bus data\n    for (int i = 0; i < BUS_SIZE; i++) {\n        temp[i] = input_bus[i] + 1; // Example operation: increment each element\n    }\n\n    // Generate output bus data\n    for (int i = 0; i < BUS_SIZE; i++) {\n        output_bus[i] = temp[i] * 2; // Example operation: multiply each element by 2\n    }\n}\n\n// Top function name: bus_controller\n"
      }
    ],
    "code_length": 534,
    "token_count": 157,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/butterworth_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8209,
    "Worst-caseLatency": 8209.0,
    "BRAM_18K": 0,
    "LUT": 663,
    "DSP": 5,
    "FF": 1019,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "butterworth_filter",
    "ResourceMetric": 0.0003633638,
    "design_id": "project",
    "algo_name": "butterworth_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "butterworth_filter.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid butterworth_filter(const float input[N], float output[N], const float a[3], const float b[3]) {\n    float w[3] = {0.0, 0.0, 0.0};\n\n    for (int i = 0; i < N; i++) {\n        float new_w = input[i] - a[1] * w[1] - a[2] * w[2];\n        output[i] = b[0] * new_w + b[1] * w[1] + b[2] * w[2];\n        w[2] = w[1];\n        w[1] = new_w;\n    }\n}\n\n// Top function name: butterworth_filter\n"
      }
    ],
    "code_length": 438,
    "token_count": 169,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/butterworth_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 10251,
    "Worst-caseLatency": 10251.0,
    "BRAM_18K": 0,
    "LUT": 1162,
    "DSP": 11,
    "FF": 1619,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "butterworth_filter",
    "ResourceMetric": 0.0006828073,
    "design_id": "project",
    "algo_name": "butterworth_filter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "butterworth_filter.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid butterworth_filter(const double input[N], double output[N], const double a[3], const double b[3]) {\n    double w[3] = {0.0, 0.0, 0.0};\n    \n    for (int i = 0; i < N; i++) {\n        double x = input[i];\n        double y = b[0] * x + w[0];\n        w[0] = b[1] * x + w[1] - a[1] * y;\n        w[1] = b[2] * x + w[2] - a[2] * y;\n        w[2] = 0.0;\n        output[i] = y;\n    }\n}\n\n// Top function name: butterworth_filter\n"
      }
    ],
    "code_length": 457,
    "token_count": 177,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/hls_algorithms/cache_replacement_lru_fifo/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16385,
    "Worst-caseLatency": 6318081.0,
    "BRAM_18K": 1,
    "LUT": 487,
    "DSP": 0,
    "FF": 227,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cache_replacement_lru_fifo",
    "ResourceMetric": 0.0001771588,
    "design_id": "project",
    "algo_name": "cache_replacement_lru_fifo",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "cache_replacement_lru_fifo.cpp",
        "file_content": "#include <ap_int.h>\n\n#define CACHE_SIZE 1024\n#define ADDR_SIZE 2048\n\nvoid cache_replacement_lru_fifo(ap_uint<32> addresses[ADDR_SIZE], ap_uint<32> cache[CACHE_SIZE], bool is_lru) {\n    ap_uint<32> lru_tracker[CACHE_SIZE];\n    ap_uint<32> fifo_tracker = 0;\n    ap_uint<32> time = 0;\n\n    for (int i = 0; i < ADDR_SIZE; i++) {\n        ap_uint<32> addr = addresses[i];\n        bool hit = false;\n\n        for (int j = 0; j < CACHE_SIZE; j++) {\n            if (cache[j] == addr) {\n                hit = true;\n                if (is_lru) {\n                    lru_tracker[j] = time;\n                }\n                break;\n            }\n        }\n\n        if (!hit) {\n            ap_uint<32> replace_index = 0;\n            if (is_lru) {\n                ap_uint<32> min_time = time;\n                for (int j = 0; j < CACHE_SIZE; j++) {\n                    if (lru_tracker[j] < min_time) {\n                        min_time = lru_tracker[j];\n                        replace_index = j;\n                    }\n                }\n            } else {\n                replace_index = fifo_tracker;\n                fifo_tracker = (fifo_tracker + 1) % CACHE_SIZE;\n            }\n\n            cache[replace_index] = addr;\n            if (is_lru) {\n                lru_tracker[replace_index] = time;\n            }\n        }\n\n        time++;\n    }\n}\n\n// Top function name: cache_replacement_lru_fifo\n"
      }
    ],
    "code_length": 1382,
    "token_count": 345,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/camera_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048581,
    "Worst-caseLatency": 1048581.0,
    "BRAM_18K": 0,
    "LUT": 340,
    "DSP": 1,
    "FF": 216,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "camera_controller",
    "ResourceMetric": 0.0001136146,
    "design_id": "project",
    "algo_name": "camera_controller",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "camera_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid camera_controller(ap_uint<8> input_image[IMG_HEIGHT][IMG_WIDTH], ap_uint<8> output_image[IMG_HEIGHT][IMG_WIDTH], ap_uint<8> brightness, ap_uint<8> contrast) {\n    for (int i = 0; i < IMG_HEIGHT; i++) {\n        for (int j = 0; j < IMG_WIDTH; j++) {\n            ap_uint<8> pixel = input_image[i][j];\n            ap_int<16> temp = pixel * contrast + brightness;\n            if (temp > 255) temp = 255;\n            if (temp < 0) temp = 0;\n            output_image[i][j] = (ap_uint<8>)temp;\n        }\n    }\n}\n\n// Top function name: camera_controller\n"
      }
    ],
    "code_length": 619,
    "token_count": 183,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/canny_edge_detection/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 70019224,
    "Worst-caseLatency": 184912464.0,
    "BRAM_18K": 8200,
    "LUT": 14132,
    "DSP": 25,
    "FF": 8489,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "canny_edge_detection",
    "ResourceMetric": 0.512649104,
    "design_id": "project",
    "algo_name": "canny_edge_detection",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "canny_edge_detection.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid canny_edge_detection(uint8_t input_image[IMG_HEIGHT][IMG_WIDTH], uint8_t output_image[IMG_HEIGHT][IMG_WIDTH]) {\n    // Gaussian kernel for smoothing\n    const float gaussian_kernel[5][5] = {\n        {2, 4, 5, 4, 2},\n        {4, 9, 12, 9, 4},\n        {5, 12, 15, 12, 5},\n        {4, 9, 12, 9, 4},\n        {2, 4, 5, 4, 2}\n    };\n\n    // Sobel kernels for gradient calculation\n    const int8_t sobel_kernel_x[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n\n    const int8_t sobel_kernel_y[3][3] = {\n        {-1, -2, -1},\n        {0, 0, 0},\n        {1, 2, 1}\n    };\n\n    // Step 1: Gaussian smoothing\n    float smoothed_image[IMG_HEIGHT][IMG_WIDTH] = {0};\n    for (int i = 2; i < IMG_HEIGHT - 2; i++) {\n        for (int j = 2; j < IMG_WIDTH - 2; j++) {\n            float sum = 0;\n            for (int ki = -2; ki <= 2; ki++) {\n                for (int kj = -2; kj <= 2; kj++) {\n                    sum += input_image[i + ki][j + kj] * gaussian_kernel[ki + 2][kj + 2];\n                }\n            }\n            smoothed_image[i][j] = sum / 159.0f;\n        }\n    }\n\n    // Step 2: Gradient calculation\n    float gradient_x[IMG_HEIGHT][IMG_WIDTH] = {0};\n    float gradient_y[IMG_HEIGHT][IMG_WIDTH] = {0};\n    float gradient_magnitude[IMG_HEIGHT][IMG_WIDTH] = {0};\n    float gradient_direction[IMG_HEIGHT][IMG_WIDTH] = {0};\n\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            float gx = 0;\n            float gy = 0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++) {\n                    gx += smoothed_image[i + ki][j + kj] * sobel_kernel_x[ki + 1][kj + 1];\n                    gy += smoothed_image[i + ki][j + kj] * sobel_kernel_y[ki + 1][kj + 1];\n                }\n            }\n            gradient_x[i][j] = gx;\n            gradient_y[i][j] = gy;\n            gradient_magnitude[i][j] = sqrt(gx * gx + gy * gy);\n            gradient_direction[i][j] = atan2(gy, gx);\n        }\n    }\n\n    // Step 3: Non-maximum suppression\n    float non_max_suppressed[IMG_HEIGHT][IMG_WIDTH] = {0};\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            float direction = gradient_direction[i][j];\n            float magnitude = gradient_magnitude[i][j];\n            float q = 255, r = 255;\n\n            if ((direction >= -M_PI / 8 && direction < M_PI / 8) || (direction >= 7 * M_PI / 8 || direction < -7 * M_PI / 8)) {\n                q = gradient_magnitude[i][j + 1];\n                r = gradient_magnitude[i][j - 1];\n            } else if ((direction >= M_PI / 8 && direction < 3 * M_PI / 8) || (direction >= -7 * M_PI / 8 && direction < -5 * M_PI / 8)) {\n                q = gradient_magnitude[i + 1][j - 1];\n                r = gradient_magnitude[i - 1][j + 1];\n            } else if ((direction >= 3 * M_PI / 8 && direction < 5 * M_PI / 8) || (direction >= -5 * M_PI / 8 && direction < -3 * M_PI / 8)) {\n                q = gradient_magnitude[i + 1][j];\n                r = gradient_magnitude[i - 1][j];\n            } else if ((direction >= 5 * M_PI / 8 && direction < 7 * M_PI / 8) || (direction >= -3 * M_PI / 8 && direction < -M_PI / 8)) {\n                q = gradient_magnitude[i + 1][j + 1];\n                r = gradient_magnitude[i - 1][j - 1];\n            }\n\n            if (magnitude >= q && magnitude >= r) {\n                non_max_suppressed[i][j] = magnitude;\n            } else {\n                non_max_suppressed[i][j] = 0;\n            }\n        }\n    }\n\n    // Step 4: Double threshold and edge tracking by hysteresis\n    const float high_threshold = 100.0f;\n    const float low_threshold = 50.0f;\n\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            if (non_max_suppressed[i][j] >= high_threshold) {\n                output_image[i][j] = 255;\n            } else if (non_max_suppressed[i][j] >= low_threshold) {\n                output_image[i][j] = 128;\n            } else {\n                output_image[i][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            if (output_image[i][j] == 128) {\n                if (output_image[i + 1][j] == 255 || output_image[i - 1][j] == 255 ||\n                    output_image[i][j + 1] == 255 || output_image[i][j - 1] == 255 ||\n                    output_image[i + 1][j + 1] == 255 || output_image[i - 1][j - 1] == 255 ||\n                    output_image[i + 1][j - 1] == 255 || output_image[i - 1][j + 1] == 255) {\n                    output_image[i][j] = 255;\n                } else {\n                    output_image[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n\n// Top function name: canny_edge_detection\n"
      }
    ],
    "code_length": 4891,
    "token_count": 1534,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/carradio_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1032,
    "Worst-caseLatency": 1032.0,
    "BRAM_18K": 0,
    "LUT": 521,
    "DSP": 8,
    "FF": 726,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "carradio_signal_processor",
    "ResourceMetric": 0.0003911513,
    "design_id": "project",
    "algo_name": "carradio_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "carradio_signal_processor.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid carradio_signal_processor(float input_signal[N], float output_signal[N], float gain, float offset) {\n    for (int i = 0; i < N; i++) {\n        // Apply gain\n        float amplified_signal = input_signal[i] * gain;\n\n        // Apply offset\n        float shifted_signal = amplified_signal + offset;\n\n        // Apply a simple non-linear transformation (e.g., squaring)\n        float processed_signal = shifted_signal * shifted_signal;\n\n        // Store the result\n        output_signal[i] = processed_signal;\n    }\n}\n\n// Top function name: carradio_signal_processor\n"
      }
    ],
    "code_length": 603,
    "token_count": 134,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/carry_lookahead_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3083,
    "Worst-caseLatency": 3083.0,
    "BRAM_18K": 0,
    "LUT": 2330,
    "DSP": 0,
    "FF": 4147,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "carry_lookahead_adder",
    "ResourceMetric": 0.0008444365,
    "design_id": "project",
    "algo_name": "carry_lookahead_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "carry_lookahead_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid carry_lookahead_adder(ap_uint<SIZE> a, ap_uint<SIZE> b, ap_uint<SIZE>& sum, ap_uint<1>& carry_out) {\n    ap_uint<SIZE> p, g, c;\n    ap_uint<1> carry_in = 0;\n\n    // Generate propagate and generate signals\n    for (int i = 0; i < SIZE; i++) {\n        p[i] = a[i] ^ b[i];\n        g[i] = a[i] & b[i];\n    }\n\n    // Calculate carry signals\n    c[0] = carry_in;\n    for (int i = 1; i < SIZE; i++) {\n        c[i] = g[i-1] | (p[i-1] & c[i-1]);\n    }\n\n    // Calculate sum and final carry out\n    for (int i = 0; i < SIZE; i++) {\n        sum[i] = p[i] ^ c[i];\n    }\n    carry_out = g[SIZE-1] | (p[SIZE-1] & c[SIZE-1]);\n}\n\n// Top function name: carry_lookahead_adder\n"
      }
    ],
    "code_length": 703,
    "token_count": 254,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/carry_save_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 269,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "carry_save_adder",
    "ResourceMetric": 5.39818e-05,
    "design_id": "project",
    "algo_name": "carry_save_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "carry_save_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid carry_save_adder(ap_int<32> A[N], ap_int<32> B[N], ap_int<32> C[N], ap_int<32> Sum[N], ap_int<32> Carry[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_int<32> a = A[i];\n        ap_int<32> b = B[i];\n        ap_int<32> c = C[i];\n        Sum[i] = a ^ b ^ c;\n        Carry[i] = (a & b) | (b & c) | (c & a);\n    }\n}\n\n// Top function name: carry_save_adder\n"
      }
    ],
    "code_length": 397,
    "token_count": 153,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/carry_skip_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 278,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "carry_skip_adder",
    "ResourceMetric": 5.87759e-05,
    "design_id": "project",
    "algo_name": "carry_skip_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "carry_skip_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid carry_skip_adder(ap_uint<32> A[N], ap_uint<32> B[N], ap_uint<32> C[N]) {\n    ap_uint<32> carry = 0;\n    for (int i = 0; i < N; i++) {\n        ap_uint<32> sum = A[i] + B[i] + carry;\n        C[i] = sum;\n        carry = (A[i] & B[i]) | ((A[i] ^ B[i]) & carry);\n    }\n}\n\n// Top function name: carry_skip_adder\n"
      }
    ],
    "code_length": 348,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/catboost/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2098191,
    "Worst-caseLatency": 2098191.0,
    "BRAM_18K": 2,
    "LUT": 914,
    "DSP": 5,
    "FF": 759,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "catboost",
    "ResourceMetric": 0.0005105753,
    "design_id": "project",
    "algo_name": "catboost",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "catboost.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid catboost(float data[N][N], float weights[N], float biases[N], float output[N]) {\n    float temp[N];\n    for (int i = 0; i < N; ++i) {\n        temp[i] = 0.0;\n        for (int j = 0; j < N; ++j) {\n            temp[i] += data[i][j] * weights[j];\n        }\n        temp[i] += biases[i];\n        temp[i] = std::max(0.0f, temp[i]); // ReLU activation\n    }\n\n    for (int i = 0; i < N; ++i) {\n        output[i] = temp[i];\n    }\n}\n\n// Top function name: catboost\n"
      }
    ],
    "code_length": 515,
    "token_count": 169,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/categorical_cross_entropy/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6161,
    "Worst-caseLatency": 6161.0,
    "BRAM_18K": 0,
    "LUT": 2180,
    "DSP": 68,
    "FF": 2616,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "categorical_cross_entropy",
    "ResourceMetric": 0.002552741,
    "design_id": "project",
    "algo_name": "categorical_cross_entropy",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "categorical_cross_entropy.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid categorical_cross_entropy(float predictions[ARRAY_SIZE], float labels[ARRAY_SIZE], float &loss) {\n    loss = 0.0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        loss += -labels[i] * log(predictions[i]);\n    }\n}\n\n// Top function name: categorical_cross_entropy\n"
      }
    ],
    "code_length": 312,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/ccd_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 169,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ccd_signal_processor",
    "ResourceMetric": 3.48053e-05,
    "design_id": "project",
    "algo_name": "ccd_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "ccd_signal_processor.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid ccd_signal_processor(fixed_point_t input_signal[SIZE], fixed_point_t output_signal[SIZE]) {\n    fixed_point_t gain = 1.5;\n    fixed_point_t offset = 0.25;\n    fixed_point_t noise_threshold = 0.1;\n\n    for (int i = 0; i < SIZE; i++) {\n        // Amplify the signal\n        fixed_point_t amplified_signal = input_signal[i] * gain;\n\n        // Offset correction\n        fixed_point_t corrected_signal = amplified_signal + offset;\n\n        // Noise reduction\n        if (corrected_signal < noise_threshold) {\n            output_signal[i] = 0;\n        } else {\n            output_signal[i] = corrected_signal;\n        }\n    }\n}\n\n// Top function name: ccd_signal_processor\n"
      }
    ],
    "code_length": 754,
    "token_count": 189,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/center_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 524299,
    "Worst-caseLatency": 524299.0,
    "BRAM_18K": 0,
    "LUT": 783,
    "DSP": 5,
    "FF": 763,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "center_loss",
    "ResourceMetric": 0.0003618297,
    "design_id": "project",
    "algo_name": "center_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "center_loss.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define D 256\n\nvoid center_loss(float features[N][D], float centers[D][D], int labels[N], float loss[N]) {\n    float diff[D];\n    float dist_sq;\n    \n    for (int i = 0; i < N; i++) {\n        dist_sq = 0.0;\n        for (int j = 0; j < D; j++) {\n            diff[j] = features[i][j] - centers[labels[i]][j];\n            dist_sq += diff[j] * diff[j];\n        }\n        loss[i] = dist_sq;\n    }\n}\n\n// Top function name: center_loss\n"
      }
    ],
    "code_length": 462,
    "token_count": 141,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/chacha20/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 533,
    "Worst-caseLatency": 533.0,
    "BRAM_18K": 0,
    "LUT": 24956,
    "DSP": 0,
    "FF": 9640,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "chacha20",
    "ResourceMetric": 0.0057099902,
    "design_id": "project",
    "algo_name": "chacha20",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "chacha20.cpp",
        "file_content": "#include <stdint.h>\n\n#define ROUNDS 20\n#define ARRAY_SIZE 1024\n\nvoid chacha20_block(uint32_t output[16], const uint32_t input[16]) {\n    uint32_t x[16];\n    for (int i = 0; i < 16; i++) {\n        x[i] = input[i];\n    }\n\n    for (int i = 0; i < ROUNDS; i += 2) {\n        // Column round\n        x[0] += x[4]; x[12] ^= x[0]; x[12] = (x[12] << 16) | (x[12] >> 16);\n        x[8] += x[12]; x[4] ^= x[8]; x[4] = (x[4] << 12) | (x[4] >> 20);\n        x[0] += x[4]; x[12] ^= x[0]; x[12] = (x[12] << 8) | (x[12] >> 24);\n        x[8] += x[12]; x[4] ^= x[8]; x[4] = (x[4] << 7) | (x[4] >> 25);\n\n        x[1] += x[5]; x[13] ^= x[1]; x[13] = (x[13] << 16) | (x[13] >> 16);\n        x[9] += x[13]; x[5] ^= x[9]; x[5] = (x[5] << 12) | (x[5] >> 20);\n        x[1] += x[5]; x[13] ^= x[1]; x[13] = (x[13] << 8) | (x[13] >> 24);\n        x[9] += x[13]; x[5] ^= x[9]; x[5] = (x[5] << 7) | (x[5] >> 25);\n\n        x[2] += x[6]; x[14] ^= x[2]; x[14] = (x[14] << 16) | (x[14] >> 16);\n        x[10] += x[14]; x[6] ^= x[10]; x[6] = (x[6] << 12) | (x[6] >> 20);\n        x[2] += x[6]; x[14] ^= x[2]; x[14] = (x[14] << 8) | (x[14] >> 24);\n        x[10] += x[14]; x[6] ^= x[10]; x[6] = (x[6] << 7) | (x[6] >> 25);\n\n        x[3] += x[7]; x[15] ^= x[3]; x[15] = (x[15] << 16) | (x[15] >> 16);\n        x[11] += x[15]; x[7] ^= x[11]; x[7] = (x[7] << 12) | (x[7] >> 20);\n        x[3] += x[7]; x[15] ^= x[3]; x[15] = (x[15] << 8) | (x[15] >> 24);\n        x[11] += x[15]; x[7] ^= x[11]; x[7] = (x[7] << 7) | (x[7] >> 25);\n\n        // Diagonal round\n        x[0] += x[5]; x[15] ^= x[0]; x[15] = (x[15] << 16) | (x[15] >> 16);\n        x[10] += x[15]; x[5] ^= x[10]; x[5] = (x[5] << 12) | (x[5] >> 20);\n        x[0] += x[5]; x[15] ^= x[0]; x[15] = (x[15] << 8) | (x[15] >> 24);\n        x[10] += x[15]; x[5] ^= x[10]; x[5] = (x[5] << 7) | (x[5] >> 25);\n\n        x[1] += x[6]; x[12] ^= x[1]; x[12] = (x[12] << 16) | (x[12] >> 16);\n        x[11] += x[12]; x[6] ^= x[11]; x[6] = (x[6] << 12) | (x[6] >> 20);\n        x[1] += x[6]; x[12] ^= x[1]; x[12] = (x[12] << 8) | (x[12] >> 24);\n        x[11] += x[12]; x[6] ^= x[11]; x[6] = (x[6] << 7) | (x[6] >> 25);\n\n        x[2] += x[7]; x[13] ^= x[2]; x[13] = (x[13] << 16) | (x[13] >> 16);\n        x[8] += x[13]; x[7] ^= x[8]; x[7] = (x[7] << 12) | (x[7] >> 20);\n        x[2] += x[7]; x[13] ^= x[2]; x[13] = (x[13] << 8) | (x[13] >> 24);\n        x[8] += x[13]; x[7] ^= x[8]; x[7] = (x[7] << 7) | (x[7] >> 25);\n\n        x[3] += x[4]; x[14] ^= x[3]; x[14] = (x[14] << 16) | (x[14] >> 16);\n        x[9] += x[14]; x[4] ^= x[9]; x[4] = (x[4] << 12) | (x[4] >> 20);\n        x[3] += x[4]; x[14] ^= x[3]; x[14] = (x[14] << 8) | (x[14] >> 24);\n        x[9] += x[14]; x[4] ^= x[9]; x[4] = (x[4] << 7) | (x[4] >> 25);\n    }\n\n    for (int i = 0; i < 16; i++) {\n        output[i] = x[i] + input[i];\n    }\n}\n\nvoid chacha20(uint32_t output[ARRAY_SIZE], const uint32_t input[ARRAY_SIZE], const uint32_t key[8], const uint32_t nonce[3]) {\n    uint32_t block[16];\n    uint32_t counter = 1;\n\n    for (int i = 0; i < ARRAY_SIZE; i += 16) {\n        // Setup the block\n        block[0] = 0x61707865;\n        block[1] = 0x3320646e;\n        block[2] = 0x79622d32;\n        block[3] = 0x6b206574;\n\n        for (int j = 0; j < 8; j++) {\n            block[4 + j] = key[j];\n        }\n\n        block[12] = counter++;\n        block[13] = nonce[0];\n        block[14] = nonce[1];\n        block[15] = nonce[2];\n\n        uint32_t keystream[16];\n        chacha20_block(keystream, block);\n\n        for (int j = 0; j < 16; j++) {\n            output[i + j] = input[i + j] ^ keystream[j];\n        }\n    }\n}\n\n// Top function name: chacha20\n"
      }
    ],
    "code_length": 3595,
    "token_count": 1788,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/channel_photo_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "channel_photo_multiplier",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "channel_photo_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "channel_photo_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid channel_photo_multiplier(ap_uint<16> input[N], ap_uint<16> output[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<16> temp = input[i];\n        ap_uint<16> result = 0;\n        for (int j = 0; j < 16; j++) {\n            result += (temp & 1) * (1 << j);\n            temp >>= 1;\n        }\n        output[i] = result;\n    }\n}\n\n// Top function name: channel_photo_multiplier\n"
      }
    ],
    "code_length": 419,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/chebyshev_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13339,
    "Worst-caseLatency": 13339.0,
    "BRAM_18K": 0,
    "LUT": 1719,
    "DSP": 11,
    "FF": 1917,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "chebyshev_filter",
    "ResourceMetric": 0.0008181933,
    "design_id": "project",
    "algo_name": "chebyshev_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "chebyshev_filter.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid chebyshev_filter(double input[N], double output[N], double coeffs[5]) {\n    double x[N + 4] = {0}; // Extended array to handle boundary conditions\n    double y[N + 4] = {0}; // Extended array to handle boundary conditions\n\n    // Copy input to extended array\n    for (int i = 0; i < N; i++) {\n        x[i + 2] = input[i];\n    }\n\n    // Apply Chebyshev filter\n    for (int i = 2; i < N + 2; i++) {\n        y[i] = coeffs[0] * x[i] + coeffs[1] * x[i - 1] + coeffs[2] * x[i - 2]\n             - coeffs[3] * y[i - 1] - coeffs[4] * y[i - 2];\n    }\n\n    // Copy result to output array\n    for (int i = 0; i < N; i++) {\n        output[i] = y[i + 2];\n    }\n}\n\n// Top function name: chebyshev_filter\n"
      }
    ],
    "code_length": 728,
    "token_count": 248,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/chebyshev_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 12299,
    "Worst-caseLatency": 12299.0,
    "BRAM_18K": 8,
    "LUT": 1776,
    "DSP": 19,
    "FF": 2292,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "chebyshev_filter",
    "ResourceMetric": 0.0015827428,
    "design_id": "project",
    "algo_name": "chebyshev_filter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "chebyshev_filter.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid chebyshev_filter(double input[N], double output[N], double coeffs[5]) {\n    double x[N];\n    double y[N];\n    double a0 = coeffs[0];\n    double a1 = coeffs[1];\n    double a2 = coeffs[2];\n    double b1 = coeffs[3];\n    double b2 = coeffs[4];\n\n    for (int i = 0; i < N; i++) {\n        x[i] = input[i];\n    }\n\n    y[0] = a0 * x[0];\n    y[1] = a0 * x[1] + a1 * x[0] - b1 * y[0];\n\n    for (int i = 2; i < N; i++) {\n        y[i] = a0 * x[i] + a1 * x[i-1] + a2 * x[i-2] - b1 * y[i-1] - b2 * y[i-2];\n    }\n\n    for (int i = 0; i < N; i++) {\n        output[i] = y[i];\n    }\n}\n\n// Top function name: chebyshev_filter\n"
      }
    ],
    "code_length": 647,
    "token_count": 256,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/chi_squared_test/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3097,
    "Worst-caseLatency": 3097.0,
    "BRAM_18K": 0,
    "LUT": 1069,
    "DSP": 11,
    "FF": 1258,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "chi_squared_test",
    "ResourceMetric": 0.0006303596,
    "design_id": "project",
    "algo_name": "chi_squared_test",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "chi_squared_test.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define SIZE 1024\n\nvoid chi_squared_test(const uint32_t observed[SIZE], const uint32_t expected[SIZE], double result[1]) {\n    double chi_squared = 0.0;\n    for (int i = 0; i < SIZE; i++) {\n        double diff = static_cast<double>(observed[i]) - static_cast<double>(expected[i]);\n        chi_squared += (diff * diff) / static_cast<double>(expected[i]);\n    }\n    result[0] = chi_squared;\n}\n\n// Top function name: chi_squared_test\n"
      }
    ],
    "code_length": 468,
    "token_count": 124,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/cholesky/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 32001,
    "Worst-caseLatency": 56012028001.0,
    "BRAM_18K": 0,
    "LUT": 3207,
    "DSP": 22,
    "FF": 2825,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_cholesky",
    "ResourceMetric": 0.0014953435,
    "design_id": "project",
    "algo_name": "cholesky",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "cholesky.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* cholesky.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"cholesky.h\"\n\n\n\n\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\nstatic\nvoid print_array(int n,\n\t\t DATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n\n{\n  int i, j;\n\n  POLYBENCH_DUMP_START;\n  POLYBENCH_DUMP_BEGIN(\"A\");\n  for (i = 0; i < n; i++)\n    for (j = 0; j <= i; j++) {\n    if ((i * n + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, \"\\n\");\n    fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);\n  }\n  POLYBENCH_DUMP_END(\"A\");\n  POLYBENCH_DUMP_FINISH;\n}\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_cholesky(int n,\n\t\t     DATA_TYPE POLYBENCH_2D(A,N,N,n,n))\n{\n  int i, j, k;\n\n\n#pragma scop\n  for (i = 0; i < _PB_N; i++) {\n     //j<i\n     for (j = 0; j < i; j++) {\n        for (k = 0; k < j; k++) {\n           A[i][j] -= A[i][k] * A[j][k];\n        }\n        A[i][j] /= A[j][j];\n     }\n     // i==j case\n     for (k = 0; k < i; k++) {\n        A[i][i] -= A[i][k] * A[i][k];\n     }\n     A[i][i] = SQRT_FUN(A[i][i]);\n  }\n#pragma endscop\n\n}\n"
      },
      {
        "file_name": "cholesky.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _CHOLESKY_H\n# define _CHOLESKY_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define N 40\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define N 120\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define N 400\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define N 2000\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define N 4000\n#  endif\n\n\n#endif /* !(N) */\n\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_CHOLESKY_H */\n"
      }
    ],
    "code_length": 1518,
    "token_count": 512,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/cholesky_decomposition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 23553,
    "Worst-caseLatency": 3246393345.0,
    "BRAM_18K": 0,
    "LUT": 1535,
    "DSP": 11,
    "FF": 1514,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cholesky_decomposition",
    "ResourceMetric": 0.0007442679,
    "design_id": "project",
    "algo_name": "cholesky_decomposition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "cholesky_decomposition.cpp",
        "file_content": "#include <cmath>\n\n#define MATRIX_SIZE 1024\n\nvoid cholesky_decomposition(double A[MATRIX_SIZE][MATRIX_SIZE], double L[MATRIX_SIZE][MATRIX_SIZE]) {\n    for (int i = 0; i < MATRIX_SIZE; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < j; k++) {\n                sum += L[i][k] * L[j][k];\n            }\n            if (i == j) {\n                L[i][j] = sqrt(A[i][i] - sum);\n            } else {\n                L[i][j] = (A[i][j] - sum) / L[j][j];\n            }\n        }\n    }\n}\n\n// Top function name: cholesky_decomposition\n"
      }
    ],
    "code_length": 582,
    "token_count": 178,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/cis_analog_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1039,
    "Worst-caseLatency": 1039.0,
    "BRAM_18K": 0,
    "LUT": 2076,
    "DSP": 35,
    "FF": 1621,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cis_analog_signal_processor",
    "ResourceMetric": 0.0015231658,
    "design_id": "project",
    "algo_name": "cis_analog_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "cis_analog_signal_processor.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid cis_analog_signal_processor(float input_signal[ARRAY_SIZE], float output_signal[ARRAY_SIZE], float gain, float offset) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Apply gain and offset\n        float processed_signal = input_signal[i] * gain + offset;\n        \n        // Apply a simple non-linear transformation\n        if (processed_signal > 0) {\n            processed_signal = std::log(1 + processed_signal);\n        } else {\n            processed_signal = -std::log(1 - processed_signal);\n        }\n        \n        // Store the processed signal\n        output_signal[i] = processed_signal;\n    }\n}\n\n// Top function name: cis_analog_signal_processor\n"
      }
    ],
    "code_length": 713,
    "token_count": 160,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/client_selection/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 118,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "client_selection",
    "ResourceMetric": 2.80936e-05,
    "design_id": "project",
    "algo_name": "client_selection",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "client_selection.cpp",
        "file_content": "#include <iostream>\n\n#define NUM_CLIENTS 1024\n\nvoid client_selection(int client_scores[NUM_CLIENTS], int selected_clients[NUM_CLIENTS], int threshold) {\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        if (client_scores[i] >= threshold) {\n            selected_clients[i] = 1;\n        } else {\n            selected_clients[i] = 0;\n        }\n    }\n}\n\n// Top function name: client_selection\n"
      }
    ],
    "code_length": 391,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/clock_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1061,
    "Worst-caseLatency": 1061.0,
    "BRAM_18K": 0,
    "LUT": 1847,
    "DSP": 0,
    "FF": 2474,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "clock_divider",
    "ResourceMetric": 0.0005914028,
    "design_id": "project",
    "algo_name": "clock_divider",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "clock_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nvoid clock_divider(ap_uint<32> input_clock[LARGE_SCALE], ap_uint<32> output_clock[LARGE_SCALE], ap_uint<32> divisor) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        output_clock[i] = input_clock[i] / divisor;\n    }\n}\n\n// Top function name: clock_divider\n"
      }
    ],
    "code_length": 307,
    "token_count": 89,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/clock_gating/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 148,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "clock_gating",
    "ResourceMetric": 3.38465e-05,
    "design_id": "project",
    "algo_name": "clock_gating",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "clock_gating.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid clock_gating(uint32_t input[ARRAY_SIZE], uint32_t output[ARRAY_SIZE], uint32_t threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] > threshold) {\n            output[i] = input[i];\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: clock_gating\n"
      }
    ],
    "code_length": 354,
    "token_count": 99,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/clock_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 3,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "clock_multiplier",
    "ResourceMetric": 0.0001071782,
    "design_id": "project",
    "algo_name": "clock_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "clock_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid clock_multiplier(ap_uint<32> input[SIZE], ap_uint<32> factor, ap_uint<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] * factor;\n    }\n}\n\n// Top function name: clock_multiplier\n"
      }
    ],
    "code_length": 259,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/cmos_alu/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 230,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cmos_alu",
    "ResourceMetric": 4.65989e-05,
    "design_id": "project",
    "algo_name": "cmos_alu",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "cmos_alu.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid cmos_alu(ap_uint<4> A[SIZE], ap_uint<4> B[SIZE], ap_uint<3> ALU_Sel[SIZE], ap_uint<4> ALU_Result[SIZE], ap_uint<1> CarryOut[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<4> a = A[i];\n        ap_uint<4> b = B[i];\n        ap_uint<3> sel = ALU_Sel[i];\n        ap_uint<4> result = 0;\n        ap_uint<1> carry = 0;\n\n        switch (sel) {\n            case 0: // Addition\n                result = a + b;\n                carry = (a + b) >> 4;\n                break;\n            case 1: // Subtraction\n                result = a - b;\n                carry = (a < b);\n                break;\n            case 2: // AND\n                result = a & b;\n                break;\n            case 3: // OR\n                result = a | b;\n                break;\n            case 4: // XOR\n                result = a ^ b;\n                break;\n            case 5: // NAND\n                result = ~(a & b);\n                break;\n            case 6: // NOR\n                result = ~(a | b);\n                break;\n            case 7: // XNOR\n                result = ~(a ^ b);\n                break;\n            default:\n                result = 0;\n                carry = 0;\n                break;\n        }\n\n        ALU_Result[i] = result;\n        CarryOut[i] = carry;\n    }\n}\n\n// Top function name: cmos_alu\n"
      }
    ],
    "code_length": 1356,
    "token_count": 369,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/cmos_bcd_rata_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 136,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cmos_bcd_rata_multiplier",
    "ResourceMetric": 2.84771e-05,
    "design_id": "project",
    "algo_name": "cmos_bcd_rata_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "cmos_bcd_rata_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid cmos_bcd_rata_multiplier(ap_uint<4> A[SIZE], ap_uint<4> B[SIZE], ap_uint<8> C[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<8> temp = 0;\n        for (int j = 0; j < 4; j++) {\n            if (B[i][j] == 1) {\n                temp += (A[i] << j);\n            }\n        }\n        C[i] = temp;\n    }\n}\n\n// Top function name: cmos_bcd_rata_multiplier\n"
      }
    ],
    "code_length": 406,
    "token_count": 142,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/cmos_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 157,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cmos_counter",
    "ResourceMetric": 3.55724e-05,
    "design_id": "project",
    "algo_name": "cmos_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "cmos_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid cmos_counter(ap_uint<32> input_array[ARRAY_SIZE], ap_uint<32> output_array[ARRAY_SIZE]) {\n    ap_uint<32> counter = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_array[i] % 2 == 0) {\n            counter++;\n        }\n        output_array[i] = counter;\n    }\n}\n\n// Top function name: cmos_counter\n"
      }
    ],
    "code_length": 364,
    "token_count": 108,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/cmos_fpu/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1037,
    "Worst-caseLatency": 1037.0,
    "BRAM_18K": 0,
    "LUT": 973,
    "DSP": 12,
    "FF": 1218,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cmos_fpu",
    "ResourceMetric": 0.0006358188,
    "design_id": "project",
    "algo_name": "cmos_fpu",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "cmos_fpu.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid cmos_fpu(const float input1[ARRAY_SIZE], const float input2[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float a = input1[i];\n        float b = input2[i];\n        float result = (a + b) * (a - b) + std::sqrt(a * b);\n        output[i] = result;\n    }\n}\n\n// Top function name: cmos_fpu\n"
      }
    ],
    "code_length": 398,
    "token_count": 119,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/codec/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 85,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "codec",
    "ResourceMetric": 1.86971e-05,
    "design_id": "project",
    "algo_name": "codec",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "codec.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid codec(ap_uint<8> input[SIZE], ap_uint<8> output[SIZE]) {\n    ap_uint<8> key = 0xAB; // Example fixed key for encoding/decoding\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] ^ key; // Simple XOR encoding/decoding\n    }\n}\n\n// Top function name: codec\n"
      }
    ],
    "code_length": 314,
    "token_count": 100,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/codirectional_digital_data_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 1,
    "LUT": 236,
    "DSP": 0,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "codirectional_digital_data_processor",
    "ResourceMetric": 0.0001126299,
    "design_id": "project",
    "algo_name": "codirectional_digital_data_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "codirectional_digital_data_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid codirectional_digital_data_processor(ap_int<16> input_data[ARRAY_SIZE], ap_int<16> output_data[ARRAY_SIZE]) {\n    ap_int<16> temp[ARRAY_SIZE];\n\n    // Initial processing step\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp[i] = input_data[i] * 2;\n    }\n\n    // Further processing step\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = temp[i] + 5;\n    }\n}\n\n// Top function name: codirectional_digital_data_processor\n"
      }
    ],
    "code_length": 493,
    "token_count": 143,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/collaborative_filtering/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 33554597,
    "Worst-caseLatency": 33554597.0,
    "BRAM_18K": 0,
    "LUT": 5968,
    "DSP": 10,
    "FF": 6019,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "collaborative_filtering",
    "ResourceMetric": 0.001998608,
    "design_id": "project",
    "algo_name": "collaborative_filtering",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "collaborative_filtering.cpp",
        "file_content": "#include <cmath>\n\n#define NUM_USERS 1024\n#define NUM_ITEMS 1024\n#define NUM_FEATURES 64\n\nvoid collaborative_filtering(float user_features[NUM_USERS][NUM_FEATURES], \n                             float item_features[NUM_ITEMS][NUM_FEATURES], \n                             float ratings[NUM_USERS][NUM_ITEMS]) {\n    for (int u = 0; u < NUM_USERS; u++) {\n        for (int i = 0; i < NUM_ITEMS; i++) {\n            float rating = 0.0;\n            for (int f = 0; f < NUM_FEATURES; f++) {\n                rating += user_features[u][f] * item_features[i][f];\n            }\n            ratings[u][i] = rating;\n        }\n    }\n}\n\n// Top function name: collaborative_filtering\n"
      }
    ],
    "code_length": 666,
    "token_count": 164,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_ip/color_space_converter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097169,
    "Worst-caseLatency": 2097169.0,
    "BRAM_18K": 0,
    "LUT": 5487,
    "DSP": 52,
    "FF": 4526,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "color_space_converter",
    "ResourceMetric": 0.0029267804,
    "design_id": "project",
    "algo_name": "color_space_converter",
    "source_name": "rtl_ip",
    "source_code": [
      {
        "file_name": "color_space_converter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid color_space_converter(ap_uint<8> input_image[HEIGHT][WIDTH][3], ap_uint<8> output_image[HEIGHT][WIDTH][3]) {\n    int i, j;\n    for (i = 0; i < HEIGHT; i++) {\n        for (j = 0; j < WIDTH; j++) {\n            ap_uint<8> r = input_image[i][j][0];\n            ap_uint<8> g = input_image[i][j][1];\n            ap_uint<8> b = input_image[i][j][2];\n\n            ap_uint<8> y = (ap_uint<8>)(0.299 * r + 0.587 * g + 0.114 * b);\n            ap_uint<8> u = (ap_uint<8>)(-0.14713 * r - 0.28886 * g + 0.436 * b + 128);\n            ap_uint<8> v = (ap_uint<8>)(0.615 * r - 0.51499 * g - 0.10001 * b + 128);\n\n            output_image[i][j][0] = y;\n            output_image[i][j][1] = u;\n            output_image[i][j][2] = v;\n        }\n    }\n}\n\n// Top function name: color_space_converter\n"
      }
    ],
    "code_length": 840,
    "token_count": 301,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/communications_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4182,
    "Worst-caseLatency": 4182.0,
    "BRAM_18K": 2,
    "LUT": 4313,
    "DSP": 0,
    "FF": 5248,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "communications_processor",
    "ResourceMetric": 0.0014542807,
    "design_id": "project",
    "algo_name": "communications_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "communications_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid communications_processor(ap_int<32> input_data[ARRAY_SIZE], ap_int<32> output_data[ARRAY_SIZE]) {\n    ap_int<32> temp_buffer[ARRAY_SIZE];\n\n    // Step 1: Data Transformation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp_buffer[i] = input_data[i] * 2 + 1;\n    }\n\n    // Step 2: Data Filtering\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (temp_buffer[i] % 3 == 0) {\n            output_data[i] = temp_buffer[i];\n        } else {\n            output_data[i] = 0;\n        }\n    }\n\n    // Step 3: Data Aggregation\n    ap_int<32> sum = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += output_data[i];\n    }\n\n    // Step 4: Normalize Output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = output_data[i] / (sum + 1);\n    }\n}\n\n// Top function name: communications_processor\n"
      }
    ],
    "code_length": 867,
    "token_count": 265,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/comparator_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "comparator_16bit",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "comparator_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "comparator_16bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid comparator_16bit(ap_uint<16> input1[ARRAY_SIZE], ap_uint<16> input2[ARRAY_SIZE], bool result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result[i] = (input1[i] > input2[i]);\n    }\n}\n\n// Top function name: comparator_16bit\n"
      }
    ],
    "code_length": 295,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/completeness_score/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 234,
    "DSP": 6,
    "FF": 70,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "completeness_score",
    "ResourceMetric": 0.0002178081,
    "design_id": "project",
    "algo_name": "completeness_score",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "completeness_score.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid completeness_score(int input1[SIZE], int input2[SIZE], int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        int sum = input1[i] + input2[i];\n        int diff = input1[i] - input2[i];\n        output[i] = sum * sum + diff * diff;\n    }\n}\n\n// Top function name: completeness_score\n"
      }
    ],
    "code_length": 335,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/complex_accumulator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 201,
    "DSP": 0,
    "FF": 78,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "complex_accumulator",
    "ResourceMetric": 4.60236e-05,
    "design_id": "project",
    "algo_name": "complex_accumulator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "complex_accumulator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid complex_accumulator(ap_int<32> input_real[ARRAY_SIZE], ap_int<32> input_imag[ARRAY_SIZE], ap_int<32> &output_real, ap_int<32> &output_imag) {\n    ap_int<32> sum_real = 0;\n    ap_int<32> sum_imag = 0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum_real += input_real[i];\n        sum_imag += input_imag[i];\n    }\n\n    output_real = sum_real;\n    output_imag = sum_imag;\n}\n\n// Top function name: complex_accumulator\n"
      }
    ],
    "code_length": 473,
    "token_count": 141,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/component_interface_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "component_interface_processor",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "component_interface_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "component_interface_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid component_interface_processor(ap_int<16> input_array[ARRAY_SIZE], ap_int<16> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> temp = input_array[i] * 2;\n        output_array[i] = temp + 5;\n    }\n}\n\n// Top function name: component_interface_processor\n"
      }
    ],
    "code_length": 342,
    "token_count": 96,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/contrastive_divergence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 7441424,
    "Worst-caseLatency": 7441424.0,
    "BRAM_18K": 0,
    "LUT": 6215,
    "DSP": 56,
    "FF": 4604,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "contrastive_divergence",
    "ResourceMetric": 0.0031846797,
    "design_id": "project",
    "algo_name": "contrastive_divergence",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "contrastive_divergence.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid contrastive_divergence(float v0[N], float h0[N], float v1[N], float h1[N], float W[N][N], float b[N], float c[N], float learning_rate) {\n    // Positive phase\n    for (int i = 0; i < N; i++) {\n        float activation = b[i];\n        for (int j = 0; j < N; j++) {\n            activation += W[i][j] * v0[j];\n        }\n        h0[i] = 1.0 / (1.0 + exp(-activation));\n    }\n\n    // Negative phase\n    for (int i = 0; i < N; i++) {\n        float activation = c[i];\n        for (int j = 0; j < N; j++) {\n            activation += W[j][i] * h0[j];\n        }\n        v1[i] = 1.0 / (1.0 + exp(-activation));\n    }\n\n    for (int i = 0; i < N; i++) {\n        float activation = b[i];\n        for (int j = 0; j < N; j++) {\n            activation += W[i][j] * v1[j];\n        }\n        h1[i] = 1.0 / (1.0 + exp(-activation));\n    }\n\n    // Update weights and biases\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            W[i][j] += learning_rate * (v0[i] * h0[j] - v1[i] * h1[j]);\n        }\n        b[i] += learning_rate * (v0[i] - v1[i]);\n        c[i] += learning_rate * (h0[i] - h1[i]);\n    }\n}\n\n// Top function name: contrastive_divergence\n"
      }
    ],
    "code_length": 1198,
    "token_count": 414,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/contrastive_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1033,
    "Worst-caseLatency": 1033.0,
    "BRAM_18K": 0,
    "LUT": 638,
    "DSP": 5,
    "FF": 794,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "contrastive_learning",
    "ResourceMetric": 0.0003369961,
    "design_id": "project",
    "algo_name": "contrastive_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "contrastive_learning.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid contrastive_learning(float input1[ARRAY_SIZE], float input2[ARRAY_SIZE], float output[ARRAY_SIZE], float margin) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float diff = input1[i] - input2[i];\n        float dist_sq = diff * diff;\n        if (dist_sq < margin) {\n            output[i] = dist_sq;\n        } else {\n            output[i] = margin;\n        }\n    }\n}\n\n// Top function name: contrastive_learning\n"
      }
    ],
    "code_length": 463,
    "token_count": 120,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/contrastive_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2073,
    "Worst-caseLatency": 2073.0,
    "BRAM_18K": 0,
    "LUT": 1142,
    "DSP": 7,
    "FF": 971,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "contrastive_loss",
    "ResourceMetric": 0.0005060246,
    "design_id": "project",
    "algo_name": "contrastive_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "contrastive_loss.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid contrastive_loss(float anchor[ARRAY_SIZE], float positive[ARRAY_SIZE], float negative[ARRAY_SIZE], float margin, float &loss) {\n    float pos_dist = 0.0f;\n    float neg_dist = 0.0f;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float diff_pos = anchor[i] - positive[i];\n        float diff_neg = anchor[i] - negative[i];\n        pos_dist += diff_pos * diff_pos;\n        neg_dist += diff_neg * diff_neg;\n    }\n\n    pos_dist = sqrt(pos_dist);\n    neg_dist = sqrt(neg_dist);\n\n    loss = fmaxf(0.0f, pos_dist - neg_dist + margin);\n}\n\n// Top function name: contrastive_loss\n"
      }
    ],
    "code_length": 622,
    "token_count": 173,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/conv_layer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5253085,
    "Worst-caseLatency": 5253085.0,
    "BRAM_18K": 0,
    "LUT": 1575,
    "DSP": 10,
    "FF": 2368,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "conv_layer",
    "ResourceMetric": 0.0008061182,
    "design_id": "project",
    "algo_name": "conv_layer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "conv_layer.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_SIZE 1024\n#define KERNEL_SIZE 3\n#define OUTPUT_SIZE (INPUT_SIZE - KERNEL_SIZE + 1)\n\nvoid conv_layer(float input[INPUT_SIZE][INPUT_SIZE], \n                float kernel[KERNEL_SIZE][KERNEL_SIZE], \n                float output[OUTPUT_SIZE][OUTPUT_SIZE]) \n{\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            float sum = 0.0;\n            for (int ki = 0; ki < KERNEL_SIZE; ki++) {\n                for (int kj = 0; kj < KERNEL_SIZE; kj++) {\n                    sum += input[i + ki][j + kj] * kernel[ki][kj];\n                }\n            }\n            output[i][j] = sum;\n        }\n    }\n}\n\n// Top function name: conv_layer\n"
      }
    ],
    "code_length": 707,
    "token_count": 188,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/convolutional_encoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 0,
    "FF": 27,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "convolutional_encoder",
    "ResourceMetric": 2.119e-05,
    "design_id": "project",
    "algo_name": "convolutional_encoder",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "convolutional_encoder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid convolutional_encoder(ap_uint<1> input[N], ap_uint<2> output[2*N]) {\n    const ap_uint<3> G1 = 0b111; // Generator polynomial 1\n    const ap_uint<3> G2 = 0b101; // Generator polynomial 2\n\n    ap_uint<3> shift_reg = 0;\n\n    for (int i = 0; i < N; i++) {\n        shift_reg = (shift_reg << 1) | input[i];\n\n        ap_uint<1> out1 = (shift_reg & G1).xor_reduce();\n        ap_uint<1> out2 = (shift_reg & G2).xor_reduce();\n\n        output[2*i] = out1;\n        output[2*i + 1] = out2;\n    }\n}\n\n// Top function name: convolutional_encoder\n"
      }
    ],
    "code_length": 573,
    "token_count": 193,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/cordic/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 2549,
    "DSP": 2,
    "FF": 211,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cordic",
    "ResourceMetric": 0.0005644476,
    "design_id": "project",
    "algo_name": "cordic",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "cordic.cpp",
        "file_content": "#include <cmath>\n#include <ap_fixed.h>\n\n#define NUM_ITER 16\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 4> fixed_point_t;\n\nvoid cordic(fixed_point_t x_in[ARRAY_SIZE], fixed_point_t y_in[ARRAY_SIZE], fixed_point_t theta_in[ARRAY_SIZE], fixed_point_t x_out[ARRAY_SIZE], fixed_point_t y_out[ARRAY_SIZE]) {\n    const fixed_point_t K = 0.6072529350088812561694; // Scaling factor\n    const fixed_point_t angles[NUM_ITER] = {\n        0.7853981633974483, 0.4636476090008061, 0.24497866312686414, 0.12435499454676144,\n        0.06241880999595735, 0.031239833430268277, 0.015623728620476831, 0.007812341060101111,\n        0.0039062301319669718, 0.0019531225164788188, 0.0009765621895593195, 0.0004882812111948983,\n        0.00024414062014936177, 0.00012207031189367021, 6.103515617420877e-05, 3.0517578115526096e-05\n    };\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        fixed_point_t x = x_in[i];\n        fixed_point_t y = y_in[i];\n        fixed_point_t theta = theta_in[i];\n\n        fixed_point_t current_x = x * K;\n        fixed_point_t current_y = y * K;\n        fixed_point_t current_theta = theta;\n\n        for (int j = 0; j < NUM_ITER; j++) {\n            fixed_point_t x_shift = current_x >> j;\n            fixed_point_t y_shift = current_y >> j;\n\n            if (current_theta < 0) {\n                current_x += y_shift;\n                current_y -= x_shift;\n                current_theta += angles[j];\n            } else {\n                current_x -= y_shift;\n                current_y += x_shift;\n                current_theta -= angles[j];\n            }\n        }\n\n        x_out[i] = current_x;\n        y_out[i] = current_y;\n    }\n}\n\n// Top function name: cordic\n"
      }
    ],
    "code_length": 1673,
    "token_count": 505,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/correlation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 20212041,
    "Worst-caseLatency": 8064063241.0,
    "BRAM_18K": 0,
    "LUT": 3251,
    "DSP": 16,
    "FF": 3103,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_correlation",
    "ResourceMetric": 0.0013642131,
    "design_id": "project",
    "algo_name": "correlation",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "correlation.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* correlation.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"correlation.h\"\n\n\n\n\n/* DCE code. Must scan the entire live-out data.\n   Can be used also to check the correctness of the output. */\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_correlation(int m, int n,\n\t\t\tDATA_TYPE float_n,\n\t\t\tDATA_TYPE POLYBENCH_2D(data,N,M,n,m),\n\t\t\tDATA_TYPE POLYBENCH_2D(corr,M,M,m,m),\n\t\t\tDATA_TYPE POLYBENCH_1D(mean,M,m),\n\t\t\tDATA_TYPE POLYBENCH_1D(stddev,M,m))\n{\n  int i, j, k;\n\n  DATA_TYPE eps = SCALAR_VAL(0.1);\n\n\n#pragma scop\n  for (j = 0; j < _PB_M; j++)\n    {\n      mean[j] = SCALAR_VAL(0.0);\n      for (i = 0; i < _PB_N; i++)\n\tmean[j] += data[i][j];\n      mean[j] /= float_n;\n    }\n\n\n   for (j = 0; j < _PB_M; j++)\n    {\n      stddev[j] = SCALAR_VAL(0.0);\n      for (i = 0; i < _PB_N; i++)\n        stddev[j] += (data[i][j] - mean[j]) * (data[i][j] - mean[j]);\n      stddev[j] /= float_n;\n      stddev[j] = SQRT_FUN(stddev[j]);\n      /* The following in an inelegant but usual way to handle\n         near-zero std. dev. values, which below would cause a zero-\n         divide. */\n      stddev[j] = stddev[j] <= eps ? SCALAR_VAL(1.0) : stddev[j];\n    }\n\n  /* Center and reduce the column vectors. */\n  for (i = 0; i < _PB_N; i++)\n    for (j = 0; j < _PB_M; j++)\n      {\n        data[i][j] -= mean[j];\n        data[i][j] /= SQRT_FUN(float_n) * stddev[j];\n      }\n\n  /* Calculate the m * m correlation matrix. */\n  for (i = 0; i < _PB_M-1; i++)\n    {\n      corr[i][i] = SCALAR_VAL(1.0);\n      for (j = i+1; j < _PB_M; j++)\n        {\n          corr[i][j] = SCALAR_VAL(0.0);\n          for (k = 0; k < _PB_N; k++)\n            corr[i][j] += (data[k][i] * data[k][j]);\n          corr[j][i] = corr[i][j];\n        }\n    }\n  corr[_PB_M-1][_PB_M-1] = SCALAR_VAL(1.0);\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "correlation.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _CORRELATION_H\n# define _CORRELATION_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(M) && !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define M 28\n#   define N 32\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define M 80\n#   define N 100\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define M 240\n#   define N 260\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define M 1200\n#   define N 1400\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define M 2600\n#   define N 3000\n#  endif\n\n\n#endif /* !(M N) */\n\n# define _PB_M POLYBENCH_LOOP_BOUND(M,m)\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_CORRELATION_H */\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 2224,
    "token_count": 733,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cosine_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2072,
    "Worst-caseLatency": 2072.0,
    "BRAM_18K": 0,
    "LUT": 1026,
    "DSP": 10,
    "FF": 1004,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cosine_loss",
    "ResourceMetric": 0.0005700557,
    "design_id": "project",
    "algo_name": "cosine_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cosine_loss.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid cosine_loss(float input1[ARRAY_SIZE], float input2[ARRAY_SIZE], float &loss) {\n    float dot_product = 0.0;\n    float norm1 = 0.0;\n    float norm2 = 0.0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        dot_product += input1[i] * input2[i];\n        norm1 += input1[i] * input1[i];\n        norm2 += input2[i] * input2[i];\n    }\n\n    norm1 = sqrt(norm1);\n    norm2 = sqrt(norm2);\n\n    loss = 1.0 - (dot_product / (norm1 * norm2));\n}\n\n// Top function name: cosine_loss\n"
      }
    ],
    "code_length": 517,
    "token_count": 165,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cosine_similarity/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2069,
    "Worst-caseLatency": 2069.0,
    "BRAM_18K": 0,
    "LUT": 959,
    "DSP": 10,
    "FF": 969,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cosine_similarity",
    "ResourceMetric": 0.0005538516,
    "design_id": "project",
    "algo_name": "cosine_similarity",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cosine_similarity.cpp",
        "file_content": "#include <cmath>\n\n#define VECTOR_SIZE 1024\n\nvoid cosine_similarity(float A[VECTOR_SIZE], float B[VECTOR_SIZE], float &result) {\n    float dot_product = 0.0;\n    float normA = 0.0;\n    float normB = 0.0;\n\n    for (int i = 0; i < VECTOR_SIZE; i++) {\n        dot_product += A[i] * B[i];\n        normA += A[i] * A[i];\n        normB += B[i] * B[i];\n    }\n\n    normA = sqrt(normA);\n    normB = sqrt(normB);\n\n    result = dot_product / (normA * normB);\n}\n\n// Top function name: cosine_similarity\n"
      }
    ],
    "code_length": 489,
    "token_count": 151,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/counter_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "counter_16bit",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "counter_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "counter_16bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid counter_16bit(ap_uint<16> input_array[ARRAY_SIZE], ap_uint<16> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_array[i] = input_array[i] + 1;\n    }\n}\n\n// Top function name: counter_16bit\n"
      }
    ],
    "code_length": 276,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/counter_64bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 148,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "counter_64bit",
    "ResourceMetric": 3.07783e-05,
    "design_id": "project",
    "algo_name": "counter_64bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "counter_64bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define COUNTER_SIZE 1024\n\nvoid counter_64bit(ap_uint<64> input_array[COUNTER_SIZE], ap_uint<64> output_array[COUNTER_SIZE]) {\n    for (int i = 0; i < COUNTER_SIZE; i++) {\n        output_array[i] = input_array[i] + 1;\n    }\n}\n\n// Top function name: counter_64bit\n"
      }
    ],
    "code_length": 284,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/crc16/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 591,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "crc16",
    "ResourceMetric": 0.0001157301,
    "design_id": "project",
    "algo_name": "crc16",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "crc16.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid crc16(uint16_t data[ARRAY_SIZE], uint16_t crc[ARRAY_SIZE]) {\n    uint16_t polynomial = 0x1021;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint16_t current_crc = 0xFFFF;\n        for (int j = 0; j < 16; j++) {\n            bool bit = ((data[i] >> (15 - j) & 1) == 1);\n            bool c15 = ((current_crc >> 15 & 1) == 1);\n            current_crc <<= 1;\n            if (c15 ^ bit) {\n                current_crc ^= polynomial;\n            }\n        }\n        crc[i] = current_crc;\n    }\n}\n\n// Top function name: crc16\n"
      }
    ],
    "code_length": 573,
    "token_count": 175,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/crc32/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 678,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "crc32",
    "ResourceMetric": 0.0001344272,
    "design_id": "project",
    "algo_name": "crc32",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "crc32.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid crc32(uint32_t data[DATA_SIZE], uint32_t &crc) {\n    uint32_t polynomial = 0xEDB88320;\n    crc = 0xFFFFFFFF;\n\n    for (int i = 0; i < DATA_SIZE; i++) {\n        uint32_t current_byte = data[i];\n        crc ^= current_byte;\n        for (int j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc = (crc >> 1) ^ polynomial;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc ^= 0xFFFFFFFF;\n}\n\n// Top function name: crc32\n"
      }
    ],
    "code_length": 521,
    "token_count": 155,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/crc32/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 2062,
    "DSP": 0,
    "FF": 134,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "crc32",
    "ResourceMetric": 0.0004082674,
    "design_id": "project",
    "algo_name": "crc32",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "crc32.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid crc32(uint32_t data[DATA_SIZE], uint32_t crc[DATA_SIZE]) {\n    uint32_t polynomial = 0xEDB88320;\n    for (int i = 0; i < DATA_SIZE; i++) {\n        uint32_t crc_value = 0xFFFFFFFF;\n        for (int j = 0; j < 32; j++) {\n            uint32_t bit = (data[i] >> j) & 1;\n            uint32_t c = (crc_value & 1) ^ bit;\n            crc_value = (crc_value >> 1) ^ (c ? polynomial : 0);\n        }\n        crc[i] = crc_value ^ 0xFFFFFFFF;\n    }\n}\n\n// Top function name: crc32\n"
      }
    ],
    "code_length": 517,
    "token_count": 168,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/operators/crc8/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 236,
    "DSP": 0,
    "FF": 22,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "crc8",
    "ResourceMetric": 4.73659e-05,
    "design_id": "project",
    "algo_name": "crc8",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "crc8.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid crc8(uint8_t data[DATA_SIZE], uint8_t* crc_out) {\n    uint8_t crc = 0x00;\n    uint8_t polynomial = 0x07;\n\n    for (int i = 0; i < DATA_SIZE; i++) {\n        crc ^= data[i];\n        for (int j = 0; j < 8; j++) {\n            if (crc & 0x80) {\n                crc = (crc << 1) ^ polynomial;\n            } else {\n                crc <<= 1;\n            }\n        }\n    }\n    *crc_out = crc;\n}\n\n// Top function name: crc8\n"
      }
    ],
    "code_length": 465,
    "token_count": 148,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cross_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 101711949,
    "Worst-caseLatency": 101711949.0,
    "BRAM_18K": 1025,
    "LUT": 5610,
    "DSP": 65,
    "FF": 3939,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cross_attention",
    "ResourceMetric": 0.0668083027,
    "design_id": "project",
    "algo_name": "cross_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cross_attention.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define N 1024\n#define D 64\n\ntypedef ap_fixed<16, 6> fixed_t;\n\nvoid cross_attention(fixed_t query[N][D], fixed_t key[N][D], fixed_t value[N][D], fixed_t output[N][D]) {\n    fixed_t attention_weights[N][N];\n    fixed_t sum_weights[N];\n\n    // Compute attention weights\n    for (int i = 0; i < N; i++) {\n        sum_weights[i] = 0;\n        for (int j = 0; j < N; j++) {\n            fixed_t dot_product = 0;\n            for (int d = 0; d < D; d++) {\n                dot_product += query[i][d] * key[j][d];\n            }\n            attention_weights[i][j] = dot_product;\n            sum_weights[i] += dot_product;\n        }\n    }\n\n    // Normalize attention weights\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            attention_weights[i][j] /= sum_weights[i];\n        }\n    }\n\n    // Compute output\n    for (int i = 0; i < N; i++) {\n        for (int d = 0; d < D; d++) {\n            output[i][d] = 0;\n            for (int j = 0; j < N; j++) {\n                output[i][d] += attention_weights[i][j] * value[j][d];\n            }\n        }\n    }\n}\n\n// Top function name: cross_attention\n"
      }
    ],
    "code_length": 1138,
    "token_count": 342,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cross_device_federated_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 412,
    "DSP": 5,
    "FF": 532,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cross_device_federated_learning",
    "ResourceMetric": 0.0002685361,
    "design_id": "project",
    "algo_name": "cross_device_federated_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cross_device_federated_learning.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid cross_device_federated_learning(float local_updates[DATA_SIZE], float global_model[DATA_SIZE], float learning_rate, float updated_model[DATA_SIZE]) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        updated_model[i] = global_model[i] - learning_rate * local_updates[i];\n    }\n}\n// Top function name: cross_device_federated_learning\n"
      }
    ],
    "code_length": 380,
    "token_count": 94,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cross_modal_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3146777,
    "Worst-caseLatency": 3146777.0,
    "BRAM_18K": 2050,
    "LUT": 1472,
    "DSP": 5,
    "FF": 1735,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cross_modal_attention",
    "ResourceMetric": 0.1276952883,
    "design_id": "project",
    "algo_name": "cross_modal_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cross_modal_attention.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid cross_modal_attention(float input1[SIZE][SIZE], float input2[SIZE][SIZE], float output[SIZE][SIZE]) {\n    float attention_weights[SIZE][SIZE];\n    float sum_weights[SIZE];\n\n    // Initialize sum_weights to zero\n    for (int i = 0; i < SIZE; i++) {\n        sum_weights[i] = 0.0;\n    }\n\n    // Compute attention weights\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            attention_weights[i][j] = input1[i][j] * input2[i][j];\n            sum_weights[i] += attention_weights[i][j];\n        }\n    }\n\n    // Normalize attention weights and compute output\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (sum_weights[i] != 0) {\n                attention_weights[i][j] /= sum_weights[i];\n            } else {\n                attention_weights[i][j] = 0;\n            }\n            output[i][j] = attention_weights[i][j] * input1[i][j];\n        }\n    }\n}\n\n// Top function name: cross_modal_attention\n"
      }
    ],
    "code_length": 1020,
    "token_count": 282,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cross_silo_federated_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 262672,
    "Worst-caseLatency": 262672.0,
    "BRAM_18K": 1,
    "LUT": 785,
    "DSP": 5,
    "FF": 567,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cross_silo_federated_learning",
    "ResourceMetric": 0.0004054242,
    "design_id": "project",
    "algo_name": "cross_silo_federated_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cross_silo_federated_learning.cpp",
        "file_content": "#include <iostream>\n\n#define NUM_CLIENTS 1024\n#define FEATURE_SIZE 256\n\nvoid cross_silo_federated_learning(\n    float global_model[FEATURE_SIZE],\n    float client_models[NUM_CLIENTS][FEATURE_SIZE],\n    float client_weights[NUM_CLIENTS])\n{\n    float aggregated_model[FEATURE_SIZE] = {0};\n\n    // Aggregate client models\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        for (int j = 0; j < FEATURE_SIZE; j++) {\n            aggregated_model[j] += client_models[i][j] * client_weights[i];\n        }\n    }\n\n    // Update global model\n    for (int j = 0; j < FEATURE_SIZE; j++) {\n        global_model[j] = aggregated_model[j];\n    }\n}\n\n// Top function name: cross_silo_federated_learning\n"
      }
    ],
    "code_length": 685,
    "token_count": 178,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/cryptographic_rng/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 178,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cryptographic_rng",
    "ResourceMetric": 3.84489e-05,
    "design_id": "project",
    "algo_name": "cryptographic_rng",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "cryptographic_rng.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid cryptographic_rng(ap_uint<32> seed, ap_uint<32> output[ARRAY_SIZE]) {\n    ap_uint<32> state = seed;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        state = state ^ (state << 13);\n        state = state ^ (state >> 17);\n        state = state ^ (state << 5);\n        output[i] = state;\n    }\n}\n\n// Top function name: cryptographic_rng\n"
      }
    ],
    "code_length": 386,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/crystal_oscillator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9232,
    "Worst-caseLatency": 9232.0,
    "BRAM_18K": 0,
    "LUT": 7698,
    "DSP": 104,
    "FF": 3145,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "crystal_oscillator",
    "ResourceMetric": 0.0046589617,
    "design_id": "project",
    "algo_name": "crystal_oscillator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "crystal_oscillator.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid crystal_oscillator(float input[N], float output[N], float frequency, float amplitude) {\n    float phase = 0.0f;\n    float phase_increment = 2.0f * M_PI * frequency / N;\n\n    for (int i = 0; i < N; i++) {\n        output[i] = amplitude * sin(phase);\n        phase += phase_increment;\n        if (phase >= 2.0f * M_PI) {\n            phase -= 2.0f * M_PI;\n        }\n    }\n}\n\n// Top function name: crystal_oscillator\n"
      }
    ],
    "code_length": 451,
    "token_count": 132,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/csprng/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 141,
    "DSP": 2,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "csprng",
    "ResourceMetric": 8.67614e-05,
    "design_id": "project",
    "algo_name": "csprng",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "csprng.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid csprng(ap_uint<32> seed, ap_uint<32> output[SIZE]) {\n    ap_uint<32> state = seed;\n    ap_uint<32> multiplier = 1664525;\n    ap_uint<32> increment = 1013904223;\n\n    for (int i = 0; i < SIZE; i++) {\n        state = state * multiplier + increment;\n        output[i] = state;\n    }\n}\n\n// Top function name: csprng\n"
      }
    ],
    "code_length": 357,
    "token_count": 114,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/current_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "current_multiplier",
    "ResourceMetric": 4.73598e-05,
    "design_id": "project",
    "algo_name": "current_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "current_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid current_multiplier(ap_int<16> input_current[ARRAY_SIZE], ap_int<16> multiplier, ap_int<16> output_current[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_current[i] = input_current[i] * multiplier;\n    }\n}\n\n// Top function name: current_multiplier\n"
      }
    ],
    "code_length": 324,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/current_sensor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1045,
    "Worst-caseLatency": 1045.0,
    "BRAM_18K": 0,
    "LUT": 566,
    "DSP": 0,
    "FF": 762,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "current_sensor",
    "ResourceMetric": 0.0001816013,
    "design_id": "project",
    "algo_name": "current_sensor",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "current_sensor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid current_sensor(ap_int<16> voltage[ARRAY_SIZE], ap_int<16> resistance[ARRAY_SIZE], ap_int<16> current[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        current[i] = voltage[i] / resistance[i];\n    }\n}\n\n// Top function name: current_sensor\n"
      }
    ],
    "code_length": 305,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/curriculum_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "curriculum_learning",
    "ResourceMetric": 2.90524e-05,
    "design_id": "project",
    "algo_name": "curriculum_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "curriculum_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid curriculum_learning(ap_int<16> input[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    ap_int<16> threshold = 100;\n    ap_int<16> increment = 5;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] < threshold) {\n            output[i] = input[i] + increment;\n        } else {\n            output[i] = input[i];\n        }\n    }\n}\n\n// Top function name: curriculum_learning\n"
      }
    ],
    "code_length": 434,
    "token_count": 122,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cutmix/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048579,
    "Worst-caseLatency": 1048579.0,
    "BRAM_18K": 0,
    "LUT": 767,
    "DSP": 0,
    "FF": 200,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cutmix",
    "ResourceMetric": 0.0001662601,
    "design_id": "project",
    "algo_name": "cutmix",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cutmix.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define IMG_SIZE 1024\n#define BBOX_SIZE 256\n\nvoid cutmix(float img1[IMG_SIZE][IMG_SIZE], float img2[IMG_SIZE][IMG_SIZE], float output[IMG_SIZE][IMG_SIZE], int x, int y, int w, int h, float lambda) {\n    int i, j;\n\n    // Ensure the bounding box is within the image boundaries\n    int x1 = std::max(0, x);\n    int y1 = std::max(0, y);\n    int x2 = std::min(IMG_SIZE, x + w);\n    int y2 = std::min(IMG_SIZE, y + h);\n\n    // Apply CutMix\n    for (i = 0; i < IMG_SIZE; i++) {\n        for (j = 0; j < IMG_SIZE; j++) {\n            if (i >= y1 && i < y2 && j >= x1 && j < x2) {\n                output[i][j] = img2[i][j];\n            } else {\n                output[i][j] = img1[i][j];\n            }\n        }\n    }\n}\n// Top function name: cutmix\n"
      }
    ],
    "code_length": 778,
    "token_count": 253,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cutout/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048579,
    "Worst-caseLatency": 1048579.0,
    "BRAM_18K": 0,
    "LUT": 495,
    "DSP": 0,
    "FF": 152,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cutout",
    "ResourceMetric": 0.0001094977,
    "design_id": "project",
    "algo_name": "cutout",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cutout.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid cutout(ap_uint<8> input_image[SIZE][SIZE], ap_uint<8> output_image[SIZE][SIZE], int x, int y, int cutout_width, int cutout_height) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (i >= y && i < y + cutout_height && j >= x && j < x + cutout_width) {\n                output_image[i][j] = 0; // Cutout region set to zero\n            } else {\n                output_image[i][j] = input_image[i][j];\n            }\n        }\n    }\n}\n\n// Top function name: cutout\n"
      }
    ],
    "code_length": 549,
    "token_count": 168,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/cutting_plane_method/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 4198442045.0,
    "BRAM_18K": 4,
    "LUT": 2046,
    "DSP": 11,
    "FF": 1851,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cutting_plane_method",
    "ResourceMetric": 0.001122588,
    "design_id": "project",
    "algo_name": "cutting_plane_method",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "cutting_plane_method.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid cutting_plane_method(double A[N][N], double b[N], double x[N], double epsilon) {\n    double r[N];\n    double alpha = 0.01;\n    double norm_r = 0.0;\n\n    for (int i = 0; i < N; i++) {\n        x[i] = 0.0;\n    }\n\n    for (int iter = 0; iter < 1000; iter++) {\n        for (int i = 0; i < N; i++) {\n            r[i] = b[i];\n            for (int j = 0; j < N; j++) {\n                r[i] -= A[i][j] * x[j];\n            }\n        }\n\n        norm_r = 0.0;\n        for (int i = 0; i < N; i++) {\n            norm_r += r[i] * r[i];\n        }\n        norm_r = sqrt(norm_r);\n\n        if (norm_r < epsilon) {\n            break;\n        }\n\n        for (int i = 0; i < N; i++) {\n            x[i] += alpha * r[i];\n        }\n    }\n}\n\n// Top function name: cutting_plane_method\n"
      }
    ],
    "code_length": 798,
    "token_count": 260,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/d_flip_flop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "d_flip_flop",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "d_flip_flop",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "d_flip_flop.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid d_flip_flop(ap_uint<1> D[SIZE], ap_uint<1> Q[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        Q[i] = D[i];\n    }\n}\n\n// Top function name: d_flip_flop\n"
      }
    ],
    "code_length": 200,
    "token_count": 73,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/d_latch/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 39,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "d_latch",
    "ResourceMetric": 1.85053e-05,
    "design_id": "project",
    "algo_name": "d_latch",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "d_latch.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid d_latch(ap_uint<1> D[SIZE], ap_uint<1> E[SIZE], ap_uint<1> Q[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (E[i] == 1) {\n            Q[i] = D[i];\n        }\n    }\n}\n\n// Top function name: d_latch\n"
      }
    ],
    "code_length": 251,
    "token_count": 93,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dac_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dac_16bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "dac_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dac_16bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dac_16bit(ap_uint<16> input[ARRAY_SIZE], ap_uint<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: dac_16bit\n"
      }
    ],
    "code_length": 240,
    "token_count": 77,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dac_24bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 125,
    "DSP": 1,
    "FF": 95,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dac_24bit",
    "ResourceMetric": 6.07833e-05,
    "design_id": "project",
    "algo_name": "dac_24bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dac_24bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dac_24bit(uint32_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t value = input[i];\n        uint8_t msb = (value >> 16) & 0xFF; // Extract the most significant byte\n        uint8_t mid = (value >> 8) & 0xFF;  // Extract the middle byte\n        uint8_t lsb = value & 0xFF;         // Extract the least significant byte\n        output[i] = (msb + mid + lsb) / 3;  // Simple averaging for DAC output\n    }\n}\n\n// Top function name: dac_24bit\n"
      }
    ],
    "code_length": 551,
    "token_count": 169,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dac_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dac_8bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "dac_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dac_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid dac_8bit(uint8_t input[SIZE], uint16_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (uint16_t)input[i] * 256;\n    }\n}\n\n// Top function name: dac_8bit\n"
      }
    ],
    "code_length": 223,
    "token_count": 77,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/data_augmentation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1041,
    "Worst-caseLatency": 1041.0,
    "BRAM_18K": 0,
    "LUT": 7240,
    "DSP": 97,
    "FF": 2977,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_augmentation",
    "ResourceMetric": 0.0043610979,
    "design_id": "project",
    "algo_name": "data_augmentation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "data_augmentation.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid data_augmentation(float input[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        // Example augmentation: scaling\n        output[i] = input[i] * 1.5f;\n        \n        // Example augmentation: adding noise\n        output[i] += sin(input[i]);\n        \n        // Example augmentation: clipping\n        if (output[i] > 1.0f) {\n            output[i] = 1.0f;\n        } else if (output[i] < -1.0f) {\n            output[i] = -1.0f;\n        }\n    }\n}\n\n// Top function name: data_augmentation\n"
      }
    ],
    "code_length": 550,
    "token_count": 155,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/data_bus_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_bus_16bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "data_bus_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "data_bus_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid data_bus_16bit(uint16_t input[SIZE], uint16_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: data_bus_16bit\n"
      }
    ],
    "code_length": 220,
    "token_count": 70,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/data_bus_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_bus_32bit",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "data_bus_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "data_bus_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid data_bus_32bit(uint32_t input[SIZE], uint32_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] + 1;\n    }\n}\n\n// Top function name: data_bus_32bit\n"
      }
    ],
    "code_length": 224,
    "token_count": 74,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/data_bus_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_bus_8bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "data_bus_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "data_bus_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid data_bus_8bit(uint8_t input[DATA_SIZE], uint8_t output[DATA_SIZE]) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: data_bus_8bit\n"
      }
    ],
    "code_length": 236,
    "token_count": 74,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/data_forwarding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_forwarding",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "data_forwarding",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "data_forwarding.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid data_forwarding(ap_int<32> input[SIZE], ap_int<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: data_forwarding\n"
      }
    ],
    "code_length": 226,
    "token_count": 71,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/data_integrity_with_checksum/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "data_integrity_with_checksum",
    "ResourceMetric": 3.10659e-05,
    "design_id": "project",
    "algo_name": "data_integrity_with_checksum",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "data_integrity_with_checksum.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid data_integrity_with_checksum(uint32_t input_data[ARRAY_SIZE], uint32_t *checksum) {\n    uint32_t sum = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += input_data[i];\n    }\n    *checksum = sum;\n}\n\n// Top function name: data_integrity_with_checksum\n"
      }
    ],
    "code_length": 311,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dct/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3184641,
    "Worst-caseLatency": 3184641.0,
    "BRAM_18K": 0,
    "LUT": 9567,
    "DSP": 110,
    "FF": 3791,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dct",
    "ResourceMetric": 0.0052455337,
    "design_id": "project",
    "algo_name": "dct",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dct.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid dct(int16_t input[N], int16_t output[N]) {\n    const double PI = 3.14159265358979323846;\n    double factor = sqrt(2.0 / N);\n    double sum;\n    int i, j;\n\n    for (i = 0; i < N; i++) {\n        sum = 0.0;\n        for (j = 0; j < N; j++) {\n            sum += input[j] * cos(PI * (j + 0.5) * i / N);\n        }\n        if (i == 0) {\n            output[i] = (int16_t)(sum * sqrt(1.0 / N));\n        } else {\n            output[i] = (int16_t)(sum * factor);\n        }\n    }\n}\n\n// Top function name: dct\n"
      }
    ],
    "code_length": 554,
    "token_count": 190,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/deadbeat_control/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9217,
    "Worst-caseLatency": 1056769.0,
    "BRAM_18K": 0,
    "LUT": 240,
    "DSP": 1,
    "FF": 192,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "deadbeat_control",
    "ResourceMetric": 9.21369e-05,
    "design_id": "project",
    "algo_name": "deadbeat_control",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "deadbeat_control.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid deadbeat_control(ap_int<16> input[N], ap_int<16> output[N], ap_int<16> coefficients[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_int<32> acc = 0;\n        for (int j = 0; j <= i; j++) {\n            acc += input[j] * coefficients[i - j];\n        }\n        output[i] = acc;\n    }\n}\n\n// Top function name: deadbeat_control\n"
      }
    ],
    "code_length": 367,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/decade_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 117,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decade_counter",
    "ResourceMetric": 2.48335e-05,
    "design_id": "project",
    "algo_name": "decade_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "decade_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid decade_counter(ap_uint<4> input[SIZE], ap_uint<4> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (input[i] + 1) % 10;\n    }\n}\n\n// Top function name: decade_counter\n"
      }
    ],
    "code_length": 235,
    "token_count": 78,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/decision_tree_classifier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6,
    "Worst-caseLatency": 4102.0,
    "BRAM_18K": 0,
    "LUT": 316,
    "DSP": 0,
    "FF": 341,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decision_tree_classifier",
    "ResourceMetric": 9.32936e-05,
    "design_id": "project",
    "algo_name": "decision_tree_classifier",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "decision_tree_classifier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_FEATURES 10\n#define NUM_NODES 1024\n#define NUM_CLASSES 3\n\nstruct Node {\n    ap_int<16> feature_index;\n    float threshold;\n    ap_int<16> left_child;\n    ap_int<16> right_child;\n    ap_int<16> class_label;\n};\n\nvoid decision_tree_classifier(float features[NUM_FEATURES], Node nodes[NUM_NODES], ap_int<16>& predicted_class) {\n    ap_int<16> node_index = 0;\n    for (int i = 0; i < NUM_NODES; i++) {\n        Node current_node = nodes[node_index];\n        if (current_node.left_child == -1 && current_node.right_child == -1) {\n            predicted_class = current_node.class_label;\n            return;\n        }\n        if (features[current_node.feature_index] <= current_node.threshold) {\n            node_index = current_node.left_child;\n        } else {\n            node_index = current_node.right_child;\n        }\n    }\n    predicted_class = -1; // Default class if no prediction is made\n}\n\n// Top function name: decision_tree_classifier\n"
      }
    ],
    "code_length": 972,
    "token_count": 233,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/decision_tree_inference/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6,
    "Worst-caseLatency": 4102.0,
    "BRAM_18K": 0,
    "LUT": 348,
    "DSP": 0,
    "FF": 469,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decision_tree_inference",
    "ResourceMetric": 0.000111703,
    "design_id": "project",
    "algo_name": "decision_tree_inference",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "decision_tree_inference.cpp",
        "file_content": "#include <stdint.h>\n\n#define N_FEATURES 10\n#define N_NODES 1024\n\nstruct Node {\n    int feature_index;\n    float threshold;\n    int left;\n    int right;\n    float value;\n};\n\nvoid decision_tree_inference(float features[N_FEATURES], Node nodes[N_NODES], float *result) {\n    int node_index = 0;\n    for (int i = 0; i < N_NODES; i++) {\n        Node node = nodes[node_index];\n        if (node.left == -1 && node.right == -1) {\n            *result = node.value;\n            return;\n        }\n        if (features[node.feature_index] <= node.threshold) {\n            node_index = node.left;\n        } else {\n            node_index = node.right;\n        }\n    }\n    *result = 0.0f; // Default value if no leaf node is reached\n}\n\n// Top function name: decision_tree_inference\n"
      }
    ],
    "code_length": 767,
    "token_count": 192,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/decoder_2to4/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 105,
    "DSP": 0,
    "FF": 24,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decoder_2to4",
    "ResourceMetric": 2.24365e-05,
    "design_id": "project",
    "algo_name": "decoder_2to4",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "decoder_2to4.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_SIZE 1024\n\nvoid decoder_2to4(ap_uint<2> input[INPUT_SIZE], ap_uint<4> output[INPUT_SIZE]) {\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        switch (input[i]) {\n            case 0:\n                output[i] = 1; // 0001\n                break;\n            case 1:\n                output[i] = 2; // 0010\n                break;\n            case 2:\n                output[i] = 4; // 0100\n                break;\n            case 3:\n                output[i] = 8; // 1000\n                break;\n            default:\n                output[i] = 0; // Should never happen\n                break;\n        }\n    }\n}\n\n// Top function name: decoder_2to4\n"
      }
    ],
    "code_length": 678,
    "token_count": 183,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/decoder_3to8/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 207,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decoder_3to8",
    "ResourceMetric": 4.20924e-05,
    "design_id": "project",
    "algo_name": "decoder_3to8",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "decoder_3to8.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_SIZE 1024\n\nvoid decoder_3to8(ap_uint<3> input[INPUT_SIZE], ap_uint<8> output[INPUT_SIZE]) {\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        ap_uint<3> in = input[i];\n        ap_uint<8> out = 0;\n\n        for (int j = 0; j < 8; j++) {\n            if (in == j) {\n                out = 1 << j;\n            }\n        }\n        output[i] = out;\n    }\n}\n\n// Top function name: decoder_3to8\n"
      }
    ],
    "code_length": 421,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/decoder_4_to_16/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 433,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decoder_4_to_16",
    "ResourceMetric": 8.54312e-05,
    "design_id": "project",
    "algo_name": "decoder_4_to_16",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "decoder_4_to_16.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_WIDTH 4\n#define OUTPUT_WIDTH 16\n#define LARGE_SCALE 1024\n\nvoid decoder_4_to_16(ap_uint<INPUT_WIDTH> input[LARGE_SCALE], ap_uint<OUTPUT_WIDTH> output[LARGE_SCALE]) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        ap_uint<OUTPUT_WIDTH> decoded_value = 0;\n        for (int j = 0; j < OUTPUT_WIDTH; j++) {\n            if (j == input[i]) {\n                decoded_value = 1 << j;\n            }\n        }\n        output[i] = decoded_value;\n    }\n}\n\n// Top function name: decoder_4_to_16\n"
      }
    ],
    "code_length": 521,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/decoder_5to32/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 34,
    "Worst-caseLatency": 34.0,
    "BRAM_18K": 0,
    "LUT": 218,
    "DSP": 0,
    "FF": 40,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "decoder_5to32",
    "ResourceMetric": 4.564e-05,
    "design_id": "project",
    "algo_name": "decoder_5to32",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "decoder_5to32.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_WIDTH 5\n#define OUTPUT_WIDTH 32\n#define NUM_INPUTS (1 << INPUT_WIDTH)\n\nvoid decoder_5to32(ap_uint<INPUT_WIDTH> input, ap_uint<OUTPUT_WIDTH> &output) {\n    output = 0;\n    for (int i = 0; i < NUM_INPUTS; i++) {\n        if (input == i) {\n            output = 1 << i;\n        }\n    }\n}\n\n// Top function name: decoder_5to32\n"
      }
    ],
    "code_length": 355,
    "token_count": 108,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/deepwalk/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 66561,
    "Worst-caseLatency": 18950145.0,
    "BRAM_18K": 0,
    "LUT": 380,
    "DSP": 0,
    "FF": 125,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "deepwalk",
    "ResourceMetric": 8.48559e-05,
    "design_id": "project",
    "algo_name": "deepwalk",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "deepwalk.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NODES 1024\n#define WALK_LENGTH 10\n\nvoid deepwalk(ap_uint<16> graph[NODES][NODES], ap_uint<16> walks[NODES][WALK_LENGTH]) {\n    for (int node = 0; node < NODES; node++) {\n        walks[node][0] = node;\n        for (int step = 1; step < WALK_LENGTH; step++) {\n            ap_uint<16> current_node = walks[node][step - 1];\n            ap_uint<16> next_node = 0;\n            for (int neighbor = 0; neighbor < NODES; neighbor++) {\n                if (graph[current_node][neighbor] != 0) {\n                    next_node = neighbor;\n                    break;\n                }\n            }\n            walks[node][step] = next_node;\n        }\n    }\n}\n\n// Top function name: deepwalk\n"
      }
    ],
    "code_length": 707,
    "token_count": 191,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dense_block/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097161,
    "Worst-caseLatency": 2097161.0,
    "BRAM_18K": 0,
    "LUT": 728,
    "DSP": 5,
    "FF": 694,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dense_block",
    "ResourceMetric": 0.0003446667,
    "design_id": "project",
    "algo_name": "dense_block",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dense_block.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid dense_block(float input[N], float weights[N][N], float bias[N], float output[N]) {\n    for (int i = 0; i < N; i++) {\n        float sum = 0;\n        for (int j = 0; j < N; j++) {\n            sum += input[j] * weights[j][i];\n        }\n        output[i] = sum + bias[i];\n    }\n}\n\n// Top function name: dense_block\n"
      }
    ],
    "code_length": 350,
    "token_count": 106,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/depthwise_separable_conv/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2552362,
    "Worst-caseLatency": 2552362.0,
    "BRAM_18K": 128,
    "LUT": 8013,
    "DSP": 10,
    "FF": 8610,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "depthwise_separable_conv",
    "ResourceMetric": 0.0105757064,
    "design_id": "project",
    "algo_name": "depthwise_separable_conv",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "depthwise_separable_conv.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_CHANNELS 64\n#define OUTPUT_CHANNELS 64\n#define HEIGHT 32\n#define WIDTH 32\n#define KERNEL_SIZE 3\n\nvoid depthwise_separable_conv(\n    float input[INPUT_CHANNELS][HEIGHT][WIDTH],\n    float depthwise_kernel[INPUT_CHANNELS][KERNEL_SIZE][KERNEL_SIZE],\n    float pointwise_kernel[OUTPUT_CHANNELS][INPUT_CHANNELS],\n    float output[OUTPUT_CHANNELS][HEIGHT][WIDTH])\n{\n    int h, w, c, kh, kw, oc;\n\n    // Depthwise Convolution\n    float depthwise_output[INPUT_CHANNELS][HEIGHT][WIDTH] = {0};\n    for (c = 0; c < INPUT_CHANNELS; c++) {\n        for (h = 0; h < HEIGHT; h++) {\n            for (w = 0; w < WIDTH; w++) {\n                float sum = 0.0;\n                for (kh = 0; kh < KERNEL_SIZE; kh++) {\n                    for (kw = 0; kw < KERNEL_SIZE; kw++) {\n                        int ih = h + kh - KERNEL_SIZE / 2;\n                        int iw = w + kw - KERNEL_SIZE / 2;\n                        if (ih >= 0 && ih < HEIGHT && iw >= 0 && iw < WIDTH) {\n                            sum += input[c][ih][iw] * depthwise_kernel[c][kh][kw];\n                        }\n                    }\n                }\n                depthwise_output[c][h][w] = sum;\n            }\n        }\n    }\n\n    // Pointwise Convolution\n    for (oc = 0; oc < OUTPUT_CHANNELS; oc++) {\n        for (h = 0; h < HEIGHT; h++) {\n            for (w = 0; w < WIDTH; w++) {\n                float sum = 0.0;\n                for (c = 0; c < INPUT_CHANNELS; c++) {\n                    sum += depthwise_output[c][h][w] * pointwise_kernel[oc][c];\n                }\n                output[oc][h][w] = sum;\n            }\n        }\n    }\n}\n\n// Top function name: depthwise_separable_conv\n"
      }
    ],
    "code_length": 1678,
    "token_count": 440,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/deriche/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 300810321,
    "Worst-caseLatency": 300810321.0,
    "BRAM_18K": 1,
    "LUT": 7418,
    "DSP": 29,
    "FF": 3994,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_deriche",
    "ResourceMetric": 0.0026708832,
    "design_id": "project",
    "algo_name": "deriche",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "deriche.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* deriche.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"deriche.h\"\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Original code provided by Gael Deest */\nvoid kernel_deriche(int w, int h, DATA_TYPE alpha,\n       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h),\n       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h),\n       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h),\n       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h)) {\n    int i,j;\n    DATA_TYPE xm1, tm1, ym1, ym2;\n    DATA_TYPE xp1, xp2;\n    DATA_TYPE tp1, tp2;\n    DATA_TYPE yp1, yp2;\n\n    DATA_TYPE k;\n    DATA_TYPE a1, a2, a3, a4, a5, a6, a7, a8;\n    DATA_TYPE b1, b2, c1, c2;\n\n#pragma scop\n   k = (SCALAR_VAL(1.0)-EXP_FUN(-alpha))*(SCALAR_VAL(1.0)-EXP_FUN(-alpha))/(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*alpha*EXP_FUN(-alpha)-EXP_FUN(SCALAR_VAL(2.0)*alpha));\n   a1 = a5 = k;\n   a2 = a6 = k*EXP_FUN(-alpha)*(alpha-SCALAR_VAL(1.0));\n   a3 = a7 = k*EXP_FUN(-alpha)*(alpha+SCALAR_VAL(1.0));\n   a4 = a8 = -k*EXP_FUN(SCALAR_VAL(-2.0)*alpha);\n   b1 =  POW_FUN(SCALAR_VAL(2.0),-alpha);\n   b2 = -EXP_FUN(SCALAR_VAL(-2.0)*alpha);\n   c1 = c2 = 1;\n\n   for (i=0; i<_PB_W; i++) {\n        ym1 = SCALAR_VAL(0.0);\n        ym2 = SCALAR_VAL(0.0);\n        xm1 = SCALAR_VAL(0.0);\n        for (j=0; j<_PB_H; j++) {\n            y1[i][j] = a1*imgIn[i][j] + a2*xm1 + b1*ym1 + b2*ym2;\n            xm1 = imgIn[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    for (i=0; i<_PB_W; i++) {\n        yp1 = SCALAR_VAL(0.0);\n        yp2 = SCALAR_VAL(0.0);\n        xp1 = SCALAR_VAL(0.0);\n        xp2 = SCALAR_VAL(0.0);\n        for (j=_PB_H-1; j>=0; j--) {\n            y2[i][j] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2;\n            xp2 = xp1;\n            xp1 = imgIn[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (i=0; i<_PB_W; i++)\n        for (j=0; j<_PB_H; j++) {\n            imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);\n        }\n\n    for (j=0; j<_PB_H; j++) {\n        tm1 = SCALAR_VAL(0.0);\n        ym1 = SCALAR_VAL(0.0);\n        ym2 = SCALAR_VAL(0.0);\n        for (i=0; i<_PB_W; i++) {\n            y1[i][j] = a5*imgOut[i][j] + a6*tm1 + b1*ym1 + b2*ym2;\n            tm1 = imgOut[i][j];\n            ym2 = ym1;\n            ym1 = y1 [i][j];\n        }\n    }\n\n\n    for (j=0; j<_PB_H; j++) {\n        tp1 = SCALAR_VAL(0.0);\n        tp2 = SCALAR_VAL(0.0);\n        yp1 = SCALAR_VAL(0.0);\n        yp2 = SCALAR_VAL(0.0);\n        for (i=_PB_W-1; i>=0; i--) {\n            y2[i][j] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2;\n            tp2 = tp1;\n            tp1 = imgOut[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (i=0; i<_PB_W; i++)\n        for (j=0; j<_PB_H; j++)\n            imgOut[i][j] = c2*(y1[i][j] + y2[i][j]);\n\n#pragma endscop\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "deriche.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _DERICHE_H\n# define _DERICHE_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(W) && !defined(H)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define W 64\n#   define H 64\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define W 192\n#   define H 128\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define W 720\n#   define H 480\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define W 4096\n#   define H 2160\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define W 7680\n#   define H 4320\n#  endif\n\n\n#endif /* !(W H) */\n\n# define _PB_W POLYBENCH_LOOP_BOUND(W,w)\n# define _PB_H POLYBENCH_LOOP_BOUND(H,h)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_FLOAT\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_DERICHE_H */\n"
      }
    ],
    "code_length": 3171,
    "token_count": 1235,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/des_encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 2941,
    "DSP": 0,
    "FF": 2079,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "des_encrypt",
    "ResourceMetric": 0.00076332,
    "design_id": "project",
    "algo_name": "des_encrypt",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "des_encrypt.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid des_encrypt(uint64_t input[DATA_SIZE], uint64_t output[DATA_SIZE], uint64_t key) {\n    uint64_t subkeys[16];\n    int i, j;\n\n    // Key schedule\n    for (i = 0; i < 16; i++) {\n        subkeys[i] = key; // Simplified key schedule for demonstration\n    }\n\n    // Initial permutation (simplified)\n    for (i = 0; i < DATA_SIZE; i++) {\n        uint64_t data = input[i];\n        uint64_t left = data >> 32;\n        uint64_t right = data & 0xFFFFFFFF;\n\n        // 16 rounds of DES\n        for (j = 0; j < 16; j++) {\n            uint64_t temp = right;\n            right = left ^ (right + subkeys[j]); // Simplified round function\n            left = temp;\n        }\n\n        // Final permutation (simplified)\n        output[i] = (right << 32) | left;\n    }\n}\n\n// Top function name: des_encrypt\n"
      }
    ],
    "code_length": 835,
    "token_count": 237,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/deserializer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2050,
    "Worst-caseLatency": 2050.0,
    "BRAM_18K": 0,
    "LUT": 201,
    "DSP": 0,
    "FF": 53,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "deserializer",
    "ResourceMetric": 4.36265e-05,
    "design_id": "project",
    "algo_name": "deserializer",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "deserializer.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid deserializer(uint32_t input_stream[DATA_SIZE], uint8_t output_stream[DATA_SIZE * 4]) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        uint32_t data = input_stream[i];\n        output_stream[i * 4 + 0] = (data >> 24) & 0xFF;\n        output_stream[i * 4 + 1] = (data >> 16) & 0xFF;\n        output_stream[i * 4 + 2] = (data >> 8) & 0xFF;\n        output_stream[i * 4 + 3] = data & 0xFF;\n    }\n}\n\n// Top function name: deserializer\n"
      }
    ],
    "code_length": 479,
    "token_count": 162,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/dfadd/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2,
    "Worst-caseLatency": 4.0,
    "BRAM_18K": 0,
    "LUT": 10388,
    "DSP": 0,
    "FF": 1788,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "float64_add",
    "ResourceMetric": 0.002163491,
    "design_id": "project",
    "algo_name": "dfadd",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "softfloat.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point types.\n*----------------------------------------------------------------------------*/\ntypedef unsigned int float32;\ntypedef unsigned long long float64;\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point underflow tininess-detection mode.\n*----------------------------------------------------------------------------*/\n#define float_tininess_after_rounding   0\n#define float_tininess_before_rounding  1\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point rounding mode.\n*----------------------------------------------------------------------------*/\n#define float_round_nearest_even  0\n#define float_round_to_zero       1\n#define float_round_up            2\n#define float_round_down          3\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point exception flags.\n*----------------------------------------------------------------------------*/\n#define float_flag_inexact     1\n#define float_flag_divbyzero   2\n#define float_flag_underflow   4\n#define float_flag_overflow    8\n#define float_flag_invalid    16\n"
      },
      {
        "file_name": "softfloat.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C source file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n#include \"milieu.h\"\n#include \"softfloat.h\"\n\n/*----------------------------------------------------------------------------\n| Floating-point rounding mode, extended double-precision rounding precision,\n| and exception flags.\n*----------------------------------------------------------------------------*/\nint8 float_rounding_mode = float_round_nearest_even;\nint8 float_exception_flags = 0;\n\n/*----------------------------------------------------------------------------\n| Primitive arithmetic functions, including multi-word arithmetic, and\n| division and square root approximations.  (Can be specialized to target if\n| desired.)\n*----------------------------------------------------------------------------*/\nINLINE void\nshift64RightJamming (bits64 a, int16 count, bits64 * zPtr)\n{\n  bits64 z;\n\n  if (count == 0)\n    {\n      z = a;\n    }\n  else if (count < 64)\n    {\n      z = (a >> count) | ((a << ((-count) & 63)) != 0);\n    }\n  else\n    {\n      z = (a != 0);\n    }\n  *zPtr = z;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the number of leading 0 bits before the most-significant 1 bit of\n| `a'.  If `a' is zero, 32 is returned.\n*----------------------------------------------------------------------------*/\n\nstatic int8\ncountLeadingZeros32 (bits32 a)\n{\n  static const int8 countLeadingZerosHigh[256] = {\n    8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n  };\n  int8 shiftCount;\n\n  shiftCount = 0;\n  if (a < 0x10000)\n    {\n      shiftCount += 16;\n      a <<= 16;\n    }\n  if (a < 0x1000000)\n    {\n      shiftCount += 8;\n      a <<= 8;\n    }\n  shiftCount += countLeadingZerosHigh[a >> 24];\n  return shiftCount;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the number of leading 0 bits before the most-significant 1 bit of\n| `a'.  If `a' is zero, 64 is returned.\n*----------------------------------------------------------------------------*/\n\nstatic int8\ncountLeadingZeros64 (bits64 a)\n{\n  int8 shiftCount;\n\n  shiftCount = 0;\n  if (a < ((bits64) 1) << 32)\n    {\n      shiftCount += 32;\n    }\n  else\n    {\n      a >>= 32;\n    }\n  shiftCount += countLeadingZeros32 (a);\n  return shiftCount;\n\n}\n\n\n/*----------------------------------------------------------------------------\n| Functions and definitions to determine:  (1) whether tininess for underflow\n| is detected before or after rounding by default, (2) what (if anything)\n| happens when exceptions are raised, (3) how signaling NaNs are distinguished\n| from quiet NaNs, (4) the default generated quiet NaNs, and (5) how NaNs\n| are propagated from function inputs to output.  These details are target-\n| specific.\n*----------------------------------------------------------------------------*/\n/*----------------------------------------------------------------------------\n| Underflow tininess-detection mode, statically initialized to default value.\n| (The declaration in `softfloat.h' must match the `int8' type here.)\n*----------------------------------------------------------------------------*/\n#define float_detect_tininess float_tininess_before_rounding\n\n/*----------------------------------------------------------------------------\n| Raises the exceptions specified by `flags'.  Floating-point traps can be\n| defined here if desired.  It is currently not possible for such a trap\n| to substitute a result value.  If traps are not implemented, this routine\n| should be simply `float_exception_flags |= flags;'.\n*----------------------------------------------------------------------------*/\n\nvoid\nfloat_raise (int8 flags)\n{\n  float_exception_flags |= flags;\n\n}\n\n\n/*----------------------------------------------------------------------------\n| The pattern for a default generated double-precision NaN.\n*----------------------------------------------------------------------------*/\n#define float64_default_nan LIT64( 0x7FFFFFFFFFFFFFFF )\n\n/*----------------------------------------------------------------------------\n| Returns 1 if the double-precision floating-point value `a' is a NaN;\n| otherwise returns 0.\n*----------------------------------------------------------------------------*/\n\nflag\nfloat64_is_nan (float64 a)\n{\n\n  return (LIT64 (0xFFE0000000000000) < (bits64) (a << 1));\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns 1 if the double-precision floating-point value `a' is a signaling\n| NaN; otherwise returns 0.\n*----------------------------------------------------------------------------*/\n\nflag\nfloat64_is_signaling_nan (float64 a)\n{\n\n  return (((a >> 51) & 0xFFF) == 0xFFE) && (a & LIT64 (0x0007FFFFFFFFFFFF));\n\n}\n\n/*----------------------------------------------------------------------------\n| Takes two double-precision floating-point values `a' and `b', one of which\n| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a\n| signaling NaN, the invalid exception is raised.\n*----------------------------------------------------------------------------*/\n\nstatic float64\npropagateFloat64NaN (float64 a, float64 b)\n{\n  flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;\n\n  aIsNaN = float64_is_nan (a);\n  aIsSignalingNaN = float64_is_signaling_nan (a);\n  bIsNaN = float64_is_nan (b);\n  bIsSignalingNaN = float64_is_signaling_nan (b);\n  a |= LIT64 (0x0008000000000000);\n  b |= LIT64 (0x0008000000000000);\n  if (aIsSignalingNaN | bIsSignalingNaN)\n    float_raise (float_flag_invalid);\n  return bIsSignalingNaN ? b : aIsSignalingNaN ? a : bIsNaN ? b : a;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the fraction bits of the double-precision floating-point value `a'.\n*----------------------------------------------------------------------------*/\n\nINLINE bits64\nextractFloat64Frac (float64 a)\n{\n\n  return a & LIT64 (0x000FFFFFFFFFFFFF);\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the exponent bits of the double-precision floating-point value `a'.\n*----------------------------------------------------------------------------*/\n\nINLINE int16\nextractFloat64Exp (float64 a)\n{\n\n  return (a >> 52) & 0x7FF;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the sign bit of the double-precision floating-point value `a'.\n*----------------------------------------------------------------------------*/\n\nINLINE flag\nextractFloat64Sign (float64 a)\n{\n\n  return a >> 63;\n\n}\n\n/*----------------------------------------------------------------------------\n| Packs the sign `zSign', exponent `zExp', and significand `zSig' into a\n| double-precision floating-point value, returning the result.  After being\n| shifted into the proper positions, the three fields are simply added\n| together to form the result.  This means that any integer portion of `zSig'\n| will be added into the exponent.  Since a properly normalized significand\n| will have an integer portion equal to 1, the `zExp' input should be 1 less\n| than the desired result exponent whenever `zSig' is a complete, normalized\n| significand.\n*----------------------------------------------------------------------------*/\n\nINLINE float64\npackFloat64 (flag zSign, int16 zExp, bits64 zSig)\n{\n\n  return (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;\n\n}\n\n/*----------------------------------------------------------------------------\n| Takes an abstract floating-point value having sign `zSign', exponent `zExp',\n| and significand `zSig', and returns the proper double-precision floating-\n| point value corresponding to the abstract input.  Ordinarily, the abstract\n| value is simply rounded and packed into the double-precision format, with\n| the inexact exception raised if the abstract input cannot be represented\n| exactly.  However, if the abstract value is too large, the overflow and\n| inexact exceptions are raised and an infinity or maximal finite value is\n| returned.  If the abstract value is too small, the input value is rounded\n| to a subnormal number, and the underflow and inexact exceptions are raised\n| if the abstract input cannot be represented exactly as a subnormal double-\n| precision floating-point number.\n|     The input significand `zSig' has its binary point between bits 62\n| and 61, which is 10 bits to the left of the usual location.  This shifted\n| significand must be normalized or smaller.  If `zSig' is not normalized,\n| `zExp' must be 0; in that case, the result returned is a subnormal number,\n| and it must not require rounding.  In the usual case that `zSig' is\n| normalized, `zExp' must be 1 less than the ``true'' floating-point exponent.\n| The handling of underflow and overflow follows the IEC/IEEE Standard for\n| Binary Floating-Point Arithmetic.\n*----------------------------------------------------------------------------*/\n\nstatic float64\nroundAndPackFloat64 (flag zSign, int16 zExp, bits64 zSig)\n{\n  int8 roundingMode;\n  flag roundNearestEven, isTiny;\n  int16 roundIncrement, roundBits;\n\n  roundingMode = float_rounding_mode;\n  roundNearestEven = (roundingMode == float_round_nearest_even);\n  roundIncrement = 0x200;\n  if (!roundNearestEven)\n    {\n      if (roundingMode == float_round_to_zero)\n\t{\n\t  roundIncrement = 0;\n\t}\n      else\n\t{\n\t  roundIncrement = 0x3FF;\n\t  if (zSign)\n\t    {\n\t      if (roundingMode == float_round_up)\n\t\troundIncrement = 0;\n\t    }\n\t  else\n\t    {\n\t      if (roundingMode == float_round_down)\n\t\troundIncrement = 0;\n\t    }\n\t}\n    }\n  roundBits = zSig & 0x3FF;\n  if (0x7FD <= (bits16) zExp)\n    {\n      if ((0x7FD < zExp)\n\t  || ((zExp == 0x7FD) && ((sbits64) (zSig + roundIncrement) < 0)))\n\t{\n\t  float_raise (float_flag_overflow | float_flag_inexact);\n\t  return packFloat64 (zSign, 0x7FF, 0) - (roundIncrement == 0);\n\t}\n      if (zExp < 0)\n\t{\n\t  isTiny = (float_detect_tininess == float_tininess_before_rounding)\n\t    || (zExp < -1)\n\t    || (zSig + roundIncrement < LIT64 (0x8000000000000000));\n\t  shift64RightJamming (zSig, -zExp, &zSig);\n\t  zExp = 0;\n\t  roundBits = zSig & 0x3FF;\n\t  if (isTiny && roundBits)\n\t    float_raise (float_flag_underflow);\n\t}\n    }\n  if (roundBits)\n    float_exception_flags |= float_flag_inexact;\n  zSig = (zSig + roundIncrement) >> 10;\n  zSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);\n  if (zSig == 0)\n    zExp = 0;\n  return packFloat64 (zSign, zExp, zSig);\n\n}\n\n/*----------------------------------------------------------------------------\n| Takes an abstract floating-point value having sign `zSign', exponent `zExp',\n| and significand `zSig', and returns the proper double-precision floating-\n| point value corresponding to the abstract input.  This routine is just like\n| `roundAndPackFloat64' except that `zSig' does not have to be normalized.\n| Bit 63 of `zSig' must be zero, and `zExp' must be 1 less than the ``true''\n| floating-point exponent.\n*----------------------------------------------------------------------------*/\n\nstatic float64\nnormalizeRoundAndPackFloat64 (flag zSign, int16 zExp, bits64 zSig)\n{\n  int8 shiftCount;\n\n  shiftCount = countLeadingZeros64 (zSig) - 1;\n  return roundAndPackFloat64 (zSign, zExp - shiftCount, zSig << shiftCount);\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the result of adding the absolute values of the double-precision\n| floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated\n| before being returned.  `zSign' is ignored if the result is a NaN.\n| The addition is performed according to the IEC/IEEE Standard for Binary\n| Floating-Point Arithmetic.\n*----------------------------------------------------------------------------*/\n\nstatic float64\naddFloat64Sigs (float64 a, float64 b, flag zSign)\n{\n  int16 aExp, bExp, zExp;\n  bits64 aSig, bSig, zSig;\n  int16 expDiff;\n\n  aSig = extractFloat64Frac (a);\n  aExp = extractFloat64Exp (a);\n  bSig = extractFloat64Frac (b);\n  bExp = extractFloat64Exp (b);\n  expDiff = aExp - bExp;\n  aSig <<= 9;\n  bSig <<= 9;\n  if (0 < expDiff)\n    {\n      if (aExp == 0x7FF)\n\t{\n\t  if (aSig)\n\t    return propagateFloat64NaN (a, b);\n\t  return a;\n\t}\n      if (bExp == 0)\n\t--expDiff;\n      else\n\tbSig |= LIT64 (0x2000000000000000);\n      shift64RightJamming (bSig, expDiff, &bSig);\n      zExp = aExp;\n    }\n  else if (expDiff < 0)\n    {\n      if (bExp == 0x7FF)\n\t{\n\t  if (bSig)\n\t    return propagateFloat64NaN (a, b);\n\t  return packFloat64 (zSign, 0x7FF, 0);\n\t}\n      if (aExp == 0)\n\t++expDiff;\n      else\n\t{\n\t  aSig |= LIT64 (0x2000000000000000);\n\t}\n      shift64RightJamming (aSig, -expDiff, &aSig);\n      zExp = bExp;\n    }\n  else\n    {\n      if (aExp == 0x7FF)\n\t{\n\t  if (aSig | bSig)\n\t    return propagateFloat64NaN (a, b);\n\t  return a;\n\t}\n      if (aExp == 0)\n\treturn packFloat64 (zSign, 0, (aSig + bSig) >> 9);\n      zSig = LIT64 (0x4000000000000000) + aSig + bSig;\n      zExp = aExp;\n      goto roundAndPack;\n    }\n  aSig |= LIT64 (0x2000000000000000);\n  zSig = (aSig + bSig) << 1;\n  --zExp;\n  if ((sbits64) zSig < 0)\n    {\n      zSig = aSig + bSig;\n      ++zExp;\n    }\nroundAndPack:\n  return roundAndPackFloat64 (zSign, zExp, zSig);\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the result of subtracting the absolute values of the double-\n| precision floating-point values `a' and `b'.  If `zSign' is 1, the\n| difference is negated before being returned.  `zSign' is ignored if the\n| result is a NaN.  The subtraction is performed according to the IEC/IEEE\n| Standard for Binary Floating-Point Arithmetic.\n*----------------------------------------------------------------------------*/\n\nstatic float64\nsubFloat64Sigs (float64 a, float64 b, flag zSign)\n{\n  int16 aExp, bExp, zExp;\n  bits64 aSig, bSig, zSig;\n  int16 expDiff;\n\n  aSig = extractFloat64Frac (a);\n  aExp = extractFloat64Exp (a);\n  bSig = extractFloat64Frac (b);\n  bExp = extractFloat64Exp (b);\n  expDiff = aExp - bExp;\n  aSig <<= 10;\n  bSig <<= 10;\n  if (0 < expDiff)\n    goto aExpBigger;\n  if (expDiff < 0)\n    goto bExpBigger;\n  if (aExp == 0x7FF)\n    {\n      if (aSig | bSig)\n\treturn propagateFloat64NaN (a, b);\n      float_raise (float_flag_invalid);\n      return float64_default_nan;\n    }\n  if (aExp == 0)\n    {\n      aExp = 1;\n      bExp = 1;\n    }\n  if (bSig < aSig)\n    goto aBigger;\n  if (aSig < bSig)\n    goto bBigger;\n  return packFloat64 (float_rounding_mode == float_round_down, 0, 0);\nbExpBigger:\n  if (bExp == 0x7FF)\n    {\n      if (bSig)\n\treturn propagateFloat64NaN (a, b);\n      return packFloat64 (zSign ^ 1, 0x7FF, 0);\n    }\n  if (aExp == 0)\n    ++expDiff;\n  else\n    aSig |= LIT64 (0x4000000000000000);\n  shift64RightJamming (aSig, -expDiff, &aSig);\n  bSig |= LIT64 (0x4000000000000000);\nbBigger:\n  zSig = bSig - aSig;\n  zExp = bExp;\n  zSign ^= 1;\n  goto normalizeRoundAndPack;\naExpBigger:\n  if (aExp == 0x7FF)\n    {\n      if (aSig)\n\treturn propagateFloat64NaN (a, b);\n      return a;\n    }\n  if (bExp == 0)\n    --expDiff;\n  else\n    bSig |= LIT64 (0x4000000000000000);\n  shift64RightJamming (bSig, expDiff, &bSig);\n  aSig |= LIT64 (0x4000000000000000);\naBigger:\n  zSig = aSig - bSig;\n  zExp = aExp;\nnormalizeRoundAndPack:\n  --zExp;\n  return normalizeRoundAndPackFloat64 (zSign, zExp, zSig);\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the result of adding the double-precision floating-point values `a'\n| and `b'.  The operation is performed according to the IEC/IEEE Standard for\n| Binary Floating-Point Arithmetic.\n*----------------------------------------------------------------------------*/\n\nfloat64\nfloat64_add (float64 a, float64 b)\n{\n  flag aSign, bSign;\n\n  aSign = extractFloat64Sign (a);\n  bSign = extractFloat64Sign (b);\n  if (aSign == bSign)\n    return addFloat64Sigs (a, b, aSign);\n  else\n    return subFloat64Sigs (a, b, aSign);\n\n}\n"
      },
      {
        "file_name": "SPARC-GCC.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n/*----------------------------------------------------------------------------\n| Each of the following `typedef's defines the most convenient type that holds\n| integers of at least as many bits as specified.  For example, `uint8' should\n| be the most convenient type that can hold unsigned integers of as many as\n| 8 bits.  The `flag' type must be able to hold either a 0 or 1.  For most\n| implementations of C, `flag', `uint8', and `int8' should all be `typedef'ed\n| to the same as `int'.\n*----------------------------------------------------------------------------*/\ntypedef int flag;\ntypedef int int8;\ntypedef int int16;\n\n/*----------------------------------------------------------------------------\n| Each of the following `typedef's defines a type that holds integers\n| of _exactly_ the number of bits specified.  For instance, for most\n| implementation of C, `bits16' and `sbits16' should be `typedef'ed to\n| `unsigned short int' and `signed short int' (or `short int'), respectively.\n*----------------------------------------------------------------------------*/\ntypedef unsigned short int bits16;\ntypedef unsigned int bits32;\ntypedef unsigned long long int bits64;\ntypedef signed long long int sbits64;\n\n/*----------------------------------------------------------------------------\n| The `LIT64' macro takes as its argument a textual integer literal and\n| if necessary ``marks'' the literal as having a 64-bit integer type.\n| For example, the GNU C Compiler (`gcc') requires that 64-bit literals be\n| appended with the letters `LL' standing for `long long', which is `gcc's\n| name for the 64-bit integer type.  Some compilers may allow `LIT64' to be\n| defined as the identity macro:  `#define LIT64( a ) a'.\n*----------------------------------------------------------------------------*/\n#define LIT64( a ) a##LL\n\n/*----------------------------------------------------------------------------\n| The macro `INLINE' can be used before functions that should be inlined.  If\n| a compiler does not support explicit inlining, this macro should be defined\n| to be `static'.\n*----------------------------------------------------------------------------*/\n#define INLINE\n"
      },
      {
        "file_name": "milieu.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n/*----------------------------------------------------------------------------\n| Include common integer types and flags.\n*----------------------------------------------------------------------------*/\n#include \"SPARC-GCC.h\"\n"
      }
    ],
    "code_length": 19540,
    "token_count": 5346,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/dfmul/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 4.0,
    "BRAM_18K": 0,
    "LUT": 4657,
    "DSP": 16,
    "FF": 1174,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "float64_mul",
    "ResourceMetric": 0.0014488773,
    "design_id": "project",
    "algo_name": "dfmul",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "softfloat.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point types.\n*----------------------------------------------------------------------------*/\ntypedef unsigned int float32;\ntypedef unsigned long long float64;\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point underflow tininess-detection mode.\n*----------------------------------------------------------------------------*/\n#define float_tininess_after_rounding   0\n#define float_tininess_before_rounding  1\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point rounding mode.\n*----------------------------------------------------------------------------*/\n#define float_round_nearest_even  0\n#define float_round_to_zero       1\n#define float_round_up            2\n#define float_round_down          3\n\n/*----------------------------------------------------------------------------\n| Software IEC/IEEE floating-point exception flags.\n*----------------------------------------------------------------------------*/\n#define float_flag_inexact     1\n#define float_flag_divbyzero   2\n#define float_flag_underflow   4\n#define float_flag_overflow    8\n#define float_flag_invalid    16\n"
      },
      {
        "file_name": "softfloat.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C source file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n#include \"milieu.h\"\n#include \"softfloat.h\"\n\n/*----------------------------------------------------------------------------\n| Floating-point rounding mode, extended double-precision rounding precision,\n| and exception flags.\n*----------------------------------------------------------------------------*/\nint8 float_rounding_mode = float_round_nearest_even;\nint8 float_exception_flags = 0;\n\n/*----------------------------------------------------------------------------\n| Primitive arithmetic functions, including multi-word arithmetic, and\n| division and square root approximations.  (Can be specialized to target if\n| desired.)\n*----------------------------------------------------------------------------*/\nINLINE void\nshift64RightJamming (bits64 a, int16 count, bits64 * zPtr)\n{\n  bits64 z;\n\n  if (count == 0)\n    {\n      z = a;\n    }\n  else if (count < 64)\n    {\n      z = (a >> count) | ((a << ((-count) & 63)) != 0);\n    }\n  else\n    {\n      z = (a != 0);\n    }\n  *zPtr = z;\n\n}\n\n/*----------------------------------------------------------------------------\n| Multiplies `a' by `b' to obtain a 128-bit product.  The product is broken\n| into two 64-bit pieces which are stored at the locations pointed to by\n| `z0Ptr' and `z1Ptr'.\n*----------------------------------------------------------------------------*/\n\nINLINE void\nmul64To128 (bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr)\n{\n  bits32 aHigh, aLow, bHigh, bLow;\n  bits64 z0, zMiddleA, zMiddleB, z1;\n\n  aLow = a;\n  aHigh = a >> 32;\n  bLow = b;\n  bHigh = b >> 32;\n  z1 = ((bits64) aLow) * bLow;\n  zMiddleA = ((bits64) aLow) * bHigh;\n  zMiddleB = ((bits64) aHigh) * bLow;\n  z0 = ((bits64) aHigh) * bHigh;\n  zMiddleA += zMiddleB;\n  z0 += (((bits64) (zMiddleA < zMiddleB)) << 32) + (zMiddleA >> 32);\n  zMiddleA <<= 32;\n  z1 += zMiddleA;\n  z0 += (z1 < zMiddleA);\n  *z1Ptr = z1;\n  *z0Ptr = z0;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the number of leading 0 bits before the most-significant 1 bit of\n| `a'.  If `a' is zero, 32 is returned.\n*----------------------------------------------------------------------------*/\n\nstatic int8\ncountLeadingZeros32 (bits32 a)\n{\n  static const int8 countLeadingZerosHigh[256] = {\n    8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\n    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n  };\n  int8 shiftCount;\n\n  shiftCount = 0;\n  if (a < 0x10000)\n    {\n      shiftCount += 16;\n      a <<= 16;\n    }\n  if (a < 0x1000000)\n    {\n      shiftCount += 8;\n      a <<= 8;\n    }\n  shiftCount += countLeadingZerosHigh[a >> 24];\n  return shiftCount;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the number of leading 0 bits before the most-significant 1 bit of\n| `a'.  If `a' is zero, 64 is returned.\n*----------------------------------------------------------------------------*/\n\nstatic int8\ncountLeadingZeros64 (bits64 a)\n{\n  int8 shiftCount;\n\n  shiftCount = 0;\n  if (a < ((bits64) 1) << 32)\n    {\n      shiftCount += 32;\n    }\n  else\n    {\n      a >>= 32;\n    }\n  shiftCount += countLeadingZeros32 (a);\n  return shiftCount;\n\n}\n\n/*----------------------------------------------------------------------------\n| Functions and definitions to determine:  (1) whether tininess for underflow\n| is detected before or after rounding by default, (2) what (if anything)\n| happens when exceptions are raised, (3) how signaling NaNs are distinguished\n| from quiet NaNs, (4) the default generated quiet NaNs, and (5) how NaNs\n| are propagated from function inputs to output.  These details are target-\n| specific.\n*----------------------------------------------------------------------------*/\n/*----------------------------------------------------------------------------\n| Underflow tininess-detection mode, statically initialized to default value.\n| (The declaration in `softfloat.h' must match the `int8' type here.)\n*----------------------------------------------------------------------------*/\n#define float_detect_tininess float_tininess_before_rounding\n\n/*----------------------------------------------------------------------------\n| Raises the exceptions specified by `flags'.  Floating-point traps can be\n| defined here if desired.  It is currently not possible for such a trap\n| to substitute a result value.  If traps are not implemented, this routine\n| should be simply `float_exception_flags |= flags;'.\n*----------------------------------------------------------------------------*/\n\nvoid\nfloat_raise (int8 flags)\n{\n  float_exception_flags |= flags;\n\n}\n\n/*----------------------------------------------------------------------------\n| The pattern for a default generated double-precision NaN.\n*----------------------------------------------------------------------------*/\n#define float64_default_nan LIT64( 0x7FFFFFFFFFFFFFFF )\n\n/*----------------------------------------------------------------------------\n| Returns 1 if the double-precision floating-point value `a' is a NaN;\n| otherwise returns 0.\n*----------------------------------------------------------------------------*/\n\nflag\nfloat64_is_nan (float64 a)\n{\n\n  return (LIT64 (0xFFE0000000000000) < (bits64) (a << 1));\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns 1 if the double-precision floating-point value `a' is a signaling\n| NaN; otherwise returns 0.\n*----------------------------------------------------------------------------*/\n\nflag\nfloat64_is_signaling_nan (float64 a)\n{\n\n  return (((a >> 51) & 0xFFF) == 0xFFE) && (a & LIT64 (0x0007FFFFFFFFFFFF));\n\n}\n\n/*----------------------------------------------------------------------------\n| Takes two double-precision floating-point values `a' and `b', one of which\n| is a NaN, and returns the appropriate NaN result.  If either `a' or `b' is a\n| signaling NaN, the invalid exception is raised.\n*----------------------------------------------------------------------------*/\n\nstatic float64\npropagateFloat64NaN (float64 a, float64 b)\n{\n  flag aIsNaN, aIsSignalingNaN, bIsNaN, bIsSignalingNaN;\n\n  aIsNaN = float64_is_nan (a);\n  aIsSignalingNaN = float64_is_signaling_nan (a);\n  bIsNaN = float64_is_nan (b);\n  bIsSignalingNaN = float64_is_signaling_nan (b);\n  a |= LIT64 (0x0008000000000000);\n  b |= LIT64 (0x0008000000000000);\n  if (aIsSignalingNaN | bIsSignalingNaN)\n    float_raise (float_flag_invalid);\n  return bIsSignalingNaN ? b : aIsSignalingNaN ? a : bIsNaN ? b : a;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the fraction bits of the double-precision floating-point value `a'.\n*----------------------------------------------------------------------------*/\n\nINLINE bits64\nextractFloat64Frac (float64 a)\n{\n\n  return a & LIT64 (0x000FFFFFFFFFFFFF);\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the exponent bits of the double-precision floating-point value `a'.\n*----------------------------------------------------------------------------*/\n\nINLINE int16\nextractFloat64Exp (float64 a)\n{\n\n  return (a >> 52) & 0x7FF;\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the sign bit of the double-precision floating-point value `a'.\n*----------------------------------------------------------------------------*/\n\nINLINE flag\nextractFloat64Sign (float64 a)\n{\n\n  return a >> 63;\n\n}\n\n/*----------------------------------------------------------------------------\n| Normalizes the subnormal double-precision floating-point value represented\n| by the denormalized significand `aSig'.  The normalized exponent and\n| significand are stored at the locations pointed to by `zExpPtr' and\n| `zSigPtr', respectively.\n*----------------------------------------------------------------------------*/\n\nstatic void\nnormalizeFloat64Subnormal (bits64 aSig, int16 * zExpPtr, bits64 * zSigPtr)\n{\n  int8 shiftCount;\n\n  shiftCount = countLeadingZeros64 (aSig) - 11;\n  *zSigPtr = aSig << shiftCount;\n  *zExpPtr = 1 - shiftCount;\n\n}\n\n/*----------------------------------------------------------------------------\n| Packs the sign `zSign', exponent `zExp', and significand `zSig' into a\n| double-precision floating-point value, returning the result.  After being\n| shifted into the proper positions, the three fields are simply added\n| together to form the result.  This means that any integer portion of `zSig'\n| will be added into the exponent.  Since a properly normalized significand\n| will have an integer portion equal to 1, the `zExp' input should be 1 less\n| than the desired result exponent whenever `zSig' is a complete, normalized\n| significand.\n*----------------------------------------------------------------------------*/\n\nINLINE float64\npackFloat64 (flag zSign, int16 zExp, bits64 zSig)\n{\n\n  return (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;\n\n}\n\n/*----------------------------------------------------------------------------\n| Takes an abstract floating-point value having sign `zSign', exponent `zExp',\n| and significand `zSig', and returns the proper double-precision floating-\n| point value corresponding to the abstract input.  Ordinarily, the abstract\n| value is simply rounded and packed into the double-precision format, with\n| the inexact exception raised if the abstract input cannot be represented\n| exactly.  However, if the abstract value is too large, the overflow and\n| inexact exceptions are raised and an infinity or maximal finite value is\n| returned.  If the abstract value is too small, the input value is rounded\n| to a subnormal number, and the underflow and inexact exceptions are raised\n| if the abstract input cannot be represented exactly as a subnormal double-\n| precision floating-point number.\n|     The input significand `zSig' has its binary point between bits 62\n| and 61, which is 10 bits to the left of the usual location.  This shifted\n| significand must be normalized or smaller.  If `zSig' is not normalized,\n| `zExp' must be 0; in that case, the result returned is a subnormal number,\n| and it must not require rounding.  In the usual case that `zSig' is\n| normalized, `zExp' must be 1 less than the ``true'' floating-point exponent.\n| The handling of underflow and overflow follows the IEC/IEEE Standard for\n| Binary Floating-Point Arithmetic.\n*----------------------------------------------------------------------------*/\n\nstatic float64\nroundAndPackFloat64 (flag zSign, int16 zExp, bits64 zSig)\n{\n  int8 roundingMode;\n  flag roundNearestEven, isTiny;\n  int16 roundIncrement, roundBits;\n\n  roundingMode = float_rounding_mode;\n  roundNearestEven = (roundingMode == float_round_nearest_even);\n  roundIncrement = 0x200;\n  if (!roundNearestEven)\n    {\n      if (roundingMode == float_round_to_zero)\n\t{\n\t  roundIncrement = 0;\n\t}\n      else\n\t{\n\t  roundIncrement = 0x3FF;\n\t  if (zSign)\n\t    {\n\t      if (roundingMode == float_round_up)\n\t\troundIncrement = 0;\n\t    }\n\t  else\n\t    {\n\t      if (roundingMode == float_round_down)\n\t\troundIncrement = 0;\n\t    }\n\t}\n    }\n  roundBits = zSig & 0x3FF;\n  if (0x7FD <= (bits16) zExp)\n    {\n      if ((0x7FD < zExp)\n\t  || ((zExp == 0x7FD) && ((sbits64) (zSig + roundIncrement) < 0)))\n\t{\n\t  float_raise (float_flag_overflow | float_flag_inexact);\n\t  return packFloat64 (zSign, 0x7FF, 0) - (roundIncrement == 0);\n\t}\n      if (zExp < 0)\n\t{\n\t  isTiny = (float_detect_tininess == float_tininess_before_rounding)\n\t    || (zExp < -1)\n\t    || (zSig + roundIncrement < LIT64 (0x8000000000000000));\n\t  shift64RightJamming (zSig, -zExp, &zSig);\n\t  zExp = 0;\n\t  roundBits = zSig & 0x3FF;\n\t  if (isTiny && roundBits)\n\t    float_raise (float_flag_underflow);\n\t}\n    }\n  if (roundBits)\n    float_exception_flags |= float_flag_inexact;\n  zSig = (zSig + roundIncrement) >> 10;\n  zSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);\n  if (zSig == 0)\n    zExp = 0;\n  return packFloat64 (zSign, zExp, zSig);\n\n}\n\n/*----------------------------------------------------------------------------\n| Returns the result of multiplying the double-precision floating-point values\n| `a' and `b'.  The operation is performed according to the IEC/IEEE Standard\n| for Binary Floating-Point Arithmetic.\n*----------------------------------------------------------------------------*/\n\nfloat64\nfloat64_mul (float64 a, float64 b)\n{\n  flag aSign, bSign, zSign;\n  int16 aExp, bExp, zExp;\n  bits64 aSig, bSig, zSig0, zSig1;\n\n  aSig = extractFloat64Frac (a);\n  aExp = extractFloat64Exp (a);\n  aSign = extractFloat64Sign (a);\n  bSig = extractFloat64Frac (b);\n  bExp = extractFloat64Exp (b);\n  bSign = extractFloat64Sign (b);\n  zSign = aSign ^ bSign;\n  if (aExp == 0x7FF)\n    {\n      if (aSig || ((bExp == 0x7FF) && bSig))\n\treturn propagateFloat64NaN (a, b);\n      if ((bExp | bSig) == 0)\n\t{\n\t  float_raise (float_flag_invalid);\n\t  return float64_default_nan;\n\t}\n      return packFloat64 (zSign, 0x7FF, 0);\n    }\n  if (bExp == 0x7FF)\n    {\n      if (bSig)\n\treturn propagateFloat64NaN (a, b);\n      if ((aExp | aSig) == 0)\n\t{\n\t  float_raise (float_flag_invalid);\n\t  return float64_default_nan;\n\t}\n      return packFloat64 (zSign, 0x7FF, 0);\n    }\n  if (aExp == 0)\n    {\n      if (aSig == 0)\n\treturn packFloat64 (zSign, 0, 0);\n      normalizeFloat64Subnormal (aSig, &aExp, &aSig);\n    }\n  if (bExp == 0)\n    {\n      if (bSig == 0)\n\treturn packFloat64 (zSign, 0, 0);\n      normalizeFloat64Subnormal (bSig, &bExp, &bSig);\n    }\n  zExp = aExp + bExp - 0x3FF;\n  aSig = (aSig | LIT64 (0x0010000000000000)) << 10;\n  bSig = (bSig | LIT64 (0x0010000000000000)) << 11;\n  mul64To128 (aSig, bSig, &zSig0, &zSig1);\n  zSig0 |= (zSig1 != 0);\n  if (0 <= (sbits64) (zSig0 << 1))\n    {\n      zSig0 <<= 1;\n      --zExp;\n    }\n  return roundAndPackFloat64 (zSign, zExp, zSig0);\n\n}\n"
      },
      {
        "file_name": "SPARC-GCC.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n/*----------------------------------------------------------------------------\n| Each of the following `typedef's defines the most convenient type that holds\n| integers of at least as many bits as specified.  For example, `uint8' should\n| be the most convenient type that can hold unsigned integers of as many as\n| 8 bits.  The `flag' type must be able to hold either a 0 or 1.  For most\n| implementations of C, `flag', `uint8', and `int8' should all be `typedef'ed\n| to the same as `int'.\n*----------------------------------------------------------------------------*/\ntypedef int flag;\ntypedef int int8;\ntypedef int int16;\n\n/*----------------------------------------------------------------------------\n| Each of the following `typedef's defines a type that holds integers\n| of _exactly_ the number of bits specified.  For instance, for most\n| implementation of C, `bits16' and `sbits16' should be `typedef'ed to\n| `unsigned short int' and `signed short int' (or `short int'), respectively.\n*----------------------------------------------------------------------------*/\ntypedef unsigned short int bits16;\ntypedef unsigned int bits32;\ntypedef unsigned long long int bits64;\ntypedef signed long long int sbits64;\n\n/*----------------------------------------------------------------------------\n| The `LIT64' macro takes as its argument a textual integer literal and\n| if necessary ``marks'' the literal as having a 64-bit integer type.\n| For example, the GNU C Compiler (`gcc') requires that 64-bit literals be\n| appended with the letters `LL' standing for `long long', which is `gcc's\n| name for the 64-bit integer type.  Some compilers may allow `LIT64' to be\n| defined as the identity macro:  `#define LIT64( a ) a'.\n*----------------------------------------------------------------------------*/\n#define LIT64( a ) a##LL\n\n/*----------------------------------------------------------------------------\n| The macro `INLINE' can be used before functions that should be inlined.  If\n| a compiler does not support explicit inlining, this macro should be defined\n| to be `static'.\n*----------------------------------------------------------------------------*/\n#define INLINE\n"
      },
      {
        "file_name": "milieu.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*============================================================================\n\nThis C header file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic\nPackage, Release 2b.\n\nWritten by John R. Hauser.  This work was made possible in part by the\nInternational Computer Science Institute, located at Suite 600, 1947 Center\nStreet, Berkeley, California 94704.  Funding was partially provided by the\nNational Science Foundation under grant MIP-9311980.  The original version\nof this code was written as part of a project to build a fixed-point vector\nprocessor in collaboration with the University of California at Berkeley,\noverseen by Profs. Nelson Morgan and John Wawrzynek.  More information\nis available through the Web page `http://www.cs.berkeley.edu/~jhauser/\narithmetic/SoftFloat.html'.\n\nTHIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has\nbeen made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES\nRESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS\nAND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ALL LOSSES,\nCOSTS, OR OTHER PROBLEMS THEY INCUR DUE TO THE SOFTWARE, AND WHO FURTHERMORE\nEFFECTIVELY INDEMNIFY JOHN HAUSER AND THE INTERNATIONAL COMPUTER SCIENCE\nINSTITUTE (possibly via similar legal warning) AGAINST ALL LOSSES, COSTS, OR\nOTHER PROBLEMS INCURRED BY THEIR CUSTOMERS AND CLIENTS DUE TO THE SOFTWARE.\n\nDerivative works are acceptable, even for commercial purposes, so long as\n(1) the source code for the derivative work includes prominent notice that\nthe work is derivative, and (2) the source code includes prominent notice with\nthese four paragraphs for those parts of this code that are retained.\n\n=============================================================================*/\n\n/*----------------------------------------------------------------------------\n| Include common integer types and flags.\n*----------------------------------------------------------------------------*/\n#include \"SPARC-GCC.h\"\n"
      }
    ],
    "code_length": 17452,
    "token_count": 4745,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dice_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2075,
    "Worst-caseLatency": 2075.0,
    "BRAM_18K": 0,
    "LUT": 1694,
    "DSP": 18,
    "FF": 1624,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dice_loss",
    "ResourceMetric": 0.0009792329,
    "design_id": "project",
    "algo_name": "dice_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dice_loss.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid dice_loss(float pred[SIZE], float target[SIZE], float &loss) {\n    float intersection = 0.0;\n    float sum_pred = 0.0;\n    float sum_target = 0.0;\n\n    for (int i = 0; i < SIZE; i++) {\n        intersection += pred[i] * target[i];\n        sum_pred += pred[i];\n        sum_target += target[i];\n    }\n\n    loss = 1.0 - (2.0 * intersection) / (sum_pred + sum_target);\n}\n\n// Top function name: dice_loss\n"
      }
    ],
    "code_length": 441,
    "token_count": 131,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/differential_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 162,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "differential_comparator",
    "ResourceMetric": 3.3463e-05,
    "design_id": "project",
    "algo_name": "differential_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "differential_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid differential_comparator(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input1[i] > input2[i]) {\n            output[i] = input1[i] - input2[i];\n        } else {\n            output[i] = input2[i] - input1[i];\n        }\n    }\n}\n\n// Top function name: differential_comparator\n"
      }
    ],
    "code_length": 426,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/digit-recognition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9004,
    "Worst-caseLatency": 9540397007.0,
    "BRAM_18K": 251,
    "LUT": 9629,
    "DSP": 1,
    "FF": 13225,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "DigitRec",
    "ResourceMetric": 0.0187052487,
    "design_id": "project",
    "algo_name": "digit-recognition",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "digitrec.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          digitrec.h                           */\n/*                                                               */\n/*             Hardware function for digit recognition           */\n/*                                                               */\n/*===============================================================*/\n\n#include \"typedefs.h\"\n\n#pragma SDS data mem_attribute(global_training_set:PHYSICAL_CONTIGUOUS, global_test_set:PHYSICAL_CONTIGUOUS, global_results:PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(global_training_set:AXIDMA_SIMPLE, global_test_set:AXIDMA_SIMPLE, global_results:AXIDMA_SIMPLE)\nvoid DigitRec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run);\n\n"
      },
      {
        "file_name": "digitrec.cpp",
        "file_content": "// #ifndef __TYPEDEFS_H__\n// #define __TYPEDEFS_H__\n\n// // dataset information\n// #define NUM_TRAINING 18000\n// #define CLASS_SIZE 1800\n// #define NUM_TEST 2000\n// #define DIGIT_WIDTH 4\n\n// // typedefs\n// typedef unsigned long long DigitType;\n// typedef unsigned char      LabelType;\n\n// #ifdef OCL\n//   #include <string>\n//   // target device\n//   // change here to map to a different device\n//   const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n// #endif\n\n// #ifdef SDSOC\n//   #include \"ap_int.h\"\n//   // sdsoc wide vector type\n//   typedef ap_uint<256>  WholeDigitType;\n// #endif\n\n// // parameters\n// #define K_CONST 3\n// #define PAR_FACTOR 40\n\n// #endif\n\n\n/*===============================================================*/\n/*                                                               */\n/*                          digitrec.cpp                         */\n/*                                                               */\n/*             Hardware function for digit recognition           */\n/*                                                               */\n/*===============================================================*/\n\n#define SDSOC\n#include \"typedefs.h\"\n\n// popcount function\nint popcount(WholeDigitType x)\n{\n  // most straightforward implementation\n  // actually not bad on FPGA\n  int cnt = 0;\n  for (int i = 0; i < 256; i ++ )\n    cnt = cnt + x[i];\n\n  return cnt;\n}\n\n// Given the test instance and a (new) training instance, this\n// function maintains/updates an array of K minimum\n// distances per training set.\nvoid update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] ) \n{\n  #pragma HLS inline\n\n  // Compute the difference using XOR\n  WholeDigitType diff = test_inst ^ train_inst;\n\n  int dist = 0;\n\n  dist = popcount(diff);\n\n  int max_dist = 0;\n  int max_dist_id = K_CONST+1;\n  int k = 0;\n\n  // Find the max distance\n  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k ) \n  {\n    if ( min_distances[k] > max_dist ) \n    {\n      max_dist = min_distances[k];\n      max_dist_id = k;\n    }\n  }\n\n  // Replace the entry with the max distance\n  if ( dist < max_dist )\n    min_distances[max_dist_id] = dist;\n\n  return;\n}\n\n// Given 10xK minimum distance values, this function\n// finds the actual K nearest neighbors and determines the\n// final output based on the most common int represented by\n// these nearest neighbors (i.e., a vote among KNNs).\nLabelType knn_vote( int knn_set[PAR_FACTOR * K_CONST] ) \n{\n  #pragma HLS inline\n\n  // local buffers\n\n  // final K nearest neighbors\n  int min_distance_list[K_CONST];\n  #pragma HLS array_partition variable=min_distance_list complete dim=0\n  // labels for the K nearest neighbors\n  int label_list[K_CONST];\n  #pragma HLS array_partition variable=label_list complete dim=0\n  // voting boxes\n  int vote_list[10];\n  #pragma HLS array_partition variable=vote_list complete dim=0\n\n  int pos = 1000;\n\n  // initialize\n  INIT_1: for (int i = 0;i < K_CONST; i ++ )\n  {\n    \n    min_distance_list[i] = 256;\n    label_list[i] = 9;\n  }\n\n  INIT_2: for (int i = 0;i < 10; i ++ )\n  {\n    \n    vote_list[i] = 0;\n  }\n\n  // go through all the lanes\n  // do an insertion sort to keep a sorted neighbor list\n  LANES: for (int i = 0; i < PAR_FACTOR; i ++ )\n  {\n    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )\n    {\n      \n      pos = 1000;\n      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )\n      {\n        \n        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;\n      }\n\n      INSERT: for (int r = K_CONST ;r > 0; r -- )\n      {\n        \n        if(r-1 > pos)\n        {\n          min_distance_list[r-1] = min_distance_list[r-2];\n          label_list[r-1] = label_list[r-2];\n        }\n        else if (r-1 == pos)\n        {\n          min_distance_list[r-1] = knn_set[i*K_CONST+j];\n          label_list[r-1] = i / (PAR_FACTOR / 10);\n        }\n      }\n    }\n  }\n\n  // vote\n  INCREMENT: for (int i = 0;i < K_CONST; i ++ )\n  {\n    \n    vote_list[label_list[i]] += 1;\n  }\n\n  LabelType max_vote;\n  max_vote = 0;\n\n  // find the maximum value\n  VOTE: for (int i = 0;i < 10; i ++ )\n  {\n    \n    if(vote_list[i] >= vote_list[max_vote])\n    {\n      max_vote = i;\n    }\n  }\n\n  return max_vote;\n\n}\n\n// top-level hardware function\n// since AXIDMA_SIMPLE interface does not support arrays with size more than 16384 on interface\n// we call this function twice to transfer data\nvoid DigitRec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run) \n{\n\n  // This array stores K minimum distances per training set\n  int knn_set[PAR_FACTOR * K_CONST];\n  #pragma HLS array_partition variable=knn_set complete dim=0\n\n  static WholeDigitType training_set [NUM_TRAINING];\n  // to be used in a pragma\n  const int unroll_factor = PAR_FACTOR;\n\n\n  static WholeDigitType test_set     [NUM_TEST];\n  static LabelType results           [NUM_TEST];\n\n  // the first time, just do data transfer and return\n  if (run == 0)\n  {\n    // copy the training set for the first time\n    for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n      \n      training_set[i] = global_training_set[i];\n    return;\n  }\n\n  // for the second time\n  for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n    \n    training_set[i + NUM_TRAINING / 2] = global_training_set[i];\n  // copy the test set\n  for (int i = 0; i < NUM_TEST; i ++ )\n    \n    test_set[i] = global_test_set[i];\n\n  // loop through test set\n  TEST_LOOP: for (int t = 0; t < NUM_TEST; ++t) \n  {\n    // fetch one instance\n    WholeDigitType test_instance = test_set[t];\n\n    // Initialize the knn set\n    SET_KNN_SET: for ( int i = 0; i < K_CONST * PAR_FACTOR ; ++i ) \n    {\n      \n      // Note that the max distance is 256\n      knn_set[i] = 256;\n    }\n\n    TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i ) \n    {\n\n      LANES : for ( int j = 0; j < PAR_FACTOR; j++ ) \n      {\n\n        // Read a new instance from the training set\n        WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];\n\n        // Update the KNN set\n        update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );\n      }\n    }\n    // Compute the final output\n    LabelType max_vote = knn_vote(knn_set);\n    results[t] = max_vote;\n\n  }\n\n  // copy the results out\n  for (int i = 0; i < NUM_TEST; i ++ )\n    \n    global_results[i] = results[i];\n\n}\n\n"
      },
      {
        "file_name": "typedefs.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          typedefs.h                           */\n/*                                                               */\n/*           Constant definitions and typedefs for host.         */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\n\n// dataset information\n#define NUM_TRAINING 18000\n#define CLASS_SIZE 1800\n#define NUM_TEST 2000\n#define DIGIT_WIDTH 4\n\n// typedefs\ntypedef unsigned long long DigitType;\ntypedef unsigned char      LabelType;\n\n#ifdef OCL\n  #include <string>\n  // target device\n  // change here to map to a different device\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n#ifdef SDSOC\n  #include \"ap_int.h\"\n  // sdsoc wide vector type\n  typedef ap_uint<256>  WholeDigitType;\n#endif\n\n// parameters\n#define K_CONST 3\n#define PAR_FACTOR 40\n\n#endif\n"
      }
    ],
    "code_length": 6437,
    "token_count": 1773,
    "pragma_number": 8,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/digital_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 159,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "digital_comparator",
    "ResourceMetric": 3.28877e-05,
    "design_id": "project",
    "algo_name": "digital_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "digital_comparator.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid digital_comparator(int32_t input1[ARRAY_SIZE], int32_t input2[ARRAY_SIZE], int32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input1[i] > input2[i]) {\n            output[i] = 1;\n        } else if (input1[i] < input2[i]) {\n            output[i] = -1;\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: digital_comparator\n"
      }
    ],
    "code_length": 439,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/digital_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "digital_counter",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "digital_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "digital_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid digital_counter(ap_uint<32> input_array[SIZE], ap_uint<32> output_array[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output_array[i] = input_array[i] + 1;\n    }\n}\n\n// Top function name: digital_counter\n"
      }
    ],
    "code_length": 256,
    "token_count": 77,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/digital_image_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5222425,
    "Worst-caseLatency": 5222425.0,
    "BRAM_18K": 0,
    "LUT": 488,
    "DSP": 1,
    "FF": 193,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "digital_image_processor",
    "ResourceMetric": 0.0001397905,
    "design_id": "project",
    "algo_name": "digital_image_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "digital_image_processor.cpp",
        "file_content": "#include <stdint.h>\n\n#define IMG_SIZE 1024\n\nvoid digital_image_processor(uint8_t input_image[IMG_SIZE][IMG_SIZE], uint8_t output_image[IMG_SIZE][IMG_SIZE]) {\n    int i, j;\n    for (i = 1; i < IMG_SIZE - 1; i++) {\n        for (j = 1; j < IMG_SIZE - 1; j++) {\n            uint16_t pixel_sum = 0;\n            pixel_sum += input_image[i-1][j-1];\n            pixel_sum += input_image[i-1][j];\n            pixel_sum += input_image[i-1][j+1];\n            pixel_sum += input_image[i][j-1];\n            pixel_sum += input_image[i][j];\n            pixel_sum += input_image[i][j+1];\n            pixel_sum += input_image[i+1][j-1];\n            pixel_sum += input_image[i+1][j];\n            pixel_sum += input_image[i+1][j+1];\n            output_image[i][j] = pixel_sum / 9;\n        }\n    }\n}\n\n// Top function name: digital_image_processor\n"
      }
    ],
    "code_length": 827,
    "token_count": 237,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/digital_lcd_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 144,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "digital_lcd_counter",
    "ResourceMetric": 3.01071e-05,
    "design_id": "project",
    "algo_name": "digital_lcd_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "digital_lcd_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define COUNTER_SIZE 1024\n\nvoid digital_lcd_counter(ap_uint<8> input[COUNTER_SIZE], ap_uint<8> output[COUNTER_SIZE]) {\n    for (int i = 0; i < COUNTER_SIZE; i++) {\n        ap_uint<8> digit = input[i];\n        ap_uint<8> lcd_representation = 0;\n\n        switch (digit) {\n            case 0: lcd_representation = 0b00111111; break; // 0\n            case 1: lcd_representation = 0b00000110; break; // 1\n            case 2: lcd_representation = 0b01011011; break; // 2\n            case 3: lcd_representation = 0b01001111; break; // 3\n            case 4: lcd_representation = 0b01100110; break; // 4\n            case 5: lcd_representation = 0b01101101; break; // 5\n            case 6: lcd_representation = 0b01111101; break; // 6\n            case 7: lcd_representation = 0b00000111; break; // 7\n            case 8: lcd_representation = 0b01111111; break; // 8\n            case 9: lcd_representation = 0b01101111; break; // 9\n            default: lcd_representation = 0b00000000; break; // Invalid input\n        }\n\n        output[i] = lcd_representation;\n    }\n}\n\n// Top function name: digital_lcd_counter\n"
      }
    ],
    "code_length": 1121,
    "token_count": 337,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/digital_phase_shifter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1069,
    "Worst-caseLatency": 1073.0,
    "BRAM_18K": 0,
    "LUT": 15055,
    "DSP": 180,
    "FF": 5989,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "digital_phase_shifter",
    "ResourceMetric": 0.0084479618,
    "design_id": "project",
    "algo_name": "digital_phase_shifter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "digital_phase_shifter.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid digital_phase_shifter(int16_t input_real[N], int16_t input_imag[N], int16_t output_real[N], int16_t output_imag[N], float phase_shift) {\n    float cos_val = cos(phase_shift);\n    float sin_val = sin(phase_shift);\n\n    for (int i = 0; i < N; i++) {\n        output_real[i] = static_cast<int16_t>(input_real[i] * cos_val - input_imag[i] * sin_val);\n        output_imag[i] = static_cast<int16_t>(input_real[i] * sin_val + input_imag[i] * cos_val);\n    }\n}\n\n// Top function name: digital_phase_shifter\n"
      }
    ],
    "code_length": 555,
    "token_count": 155,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dijkstra/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4201467,
    "Worst-caseLatency": 4201467.0,
    "BRAM_18K": 0,
    "LUT": 942,
    "DSP": 0,
    "FF": 313,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dijkstra",
    "ResourceMetric": 0.0002106537,
    "design_id": "project",
    "algo_name": "dijkstra",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dijkstra.cpp",
        "file_content": "#include <limits.h>\n\n#define N 1024\n\nvoid dijkstra(int graph[N][N], int src, int dist[N]) {\n    bool sptSet[N]; // sptSet[i] will be true if vertex i is included in shortest path tree\n    int i, count, v, u, min;\n\n    // Initialize all distances as INFINITE and stpSet[] as false\n    for (i = 0; i < N; i++) {\n        dist[i] = INT_MAX;\n        sptSet[i] = false;\n    }\n\n    // Distance of source vertex from itself is always 0\n    dist[src] = 0;\n\n    // Find shortest path for all vertices\n    for (count = 0; count < N - 1; count++) {\n        // Pick the minimum distance vertex from the set of vertices not yet processed.\n        min = INT_MAX;\n        for (v = 0; v < N; v++)\n            if (sptSet[v] == false && dist[v] <= min)\n                min = dist[v], u = v;\n\n        // Mark the picked vertex as processed\n        sptSet[u] = true;\n\n        // Update dist value of the adjacent vertices of the picked vertex.\n        for (v = 0; v < N; v++)\n            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])\n                dist[v] = dist[u] + graph[u][v];\n    }\n}\n\n// Top function name: dijkstra\n"
      }
    ],
    "code_length": 1144,
    "token_count": 335,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dilated_convolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 0,
    "LUT": 1027,
    "DSP": 10,
    "FF": 1237,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dilated_convolution",
    "ResourceMetric": 0.0005925881,
    "design_id": "project",
    "algo_name": "dilated_convolution",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dilated_convolution.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_SIZE 1024\n#define KERNEL_SIZE 3\n#define DILATION 2\n#define OUTPUT_SIZE (INPUT_SIZE - (KERNEL_SIZE - 1) * DILATION)\n\nvoid dilated_convolution(const float input[INPUT_SIZE], const float kernel[KERNEL_SIZE], float output[OUTPUT_SIZE]) {\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output[i] = 0;\n        for (int k = 0; k < KERNEL_SIZE; k++) {\n            int input_index = i + k * DILATION;\n            if (input_index < INPUT_SIZE) {\n                output[i] += input[input_index] * kernel[k];\n            }\n        }\n    }\n}\n\n// Top function name: dilated_convolution\n"
      }
    ],
    "code_length": 612,
    "token_count": 164,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dimensionality_reduction/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16777222,
    "Worst-caseLatency": 16777222.0,
    "BRAM_18K": 0,
    "LUT": 890,
    "DSP": 5,
    "FF": 648,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dimensionality_reduction",
    "ResourceMetric": 0.000371322,
    "design_id": "project",
    "algo_name": "dimensionality_reduction",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dimensionality_reduction.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define D 128\n#define K 64\n\nvoid dimensionality_reduction(float input[N][D], float output[N][K], float transformation_matrix[D][K]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < K; j++) {\n            output[i][j] = 0;\n            for (int k = 0; k < D; k++) {\n                output[i][j] += input[i][k] * transformation_matrix[k][j];\n            }\n        }\n    }\n}\n\n// Top function name: dimensionality_reduction\n"
      }
    ],
    "code_length": 466,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/disaggregation_of_axis_port/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13,
    "Worst-caseLatency": 13.0,
    "BRAM_18K": 0,
    "LUT": 110,
    "DSP": 0,
    "FF": 49,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 2.57924e-05,
    "design_id": "project",
    "algo_name": "disaggregation_of_axis_port",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define N 10\n\nstruct A {\n    char c;\n    int i;\n};\n\n// Top function\nvoid dut(A in[N], A out[N]);\n\nvoid dut(A in[N], A out[N]) {\n#pragma HLS interface axis port = in\n#pragma HLS interface axis port = out\n#pragma HLS disaggregate variable = in\n#pragma HLS disaggregate variable = out\n    int sum = 0;\n    for (unsigned i = 0; i < N; i++) {\n        out[i].c = in[i].c;\n        out[i].i = in[i].i;\n    }\n}\n"
      }
    ],
    "code_length": 1790,
    "token_count": 436,
    "pragma_number": 4,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/disentangled_representation_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6205,
    "Worst-caseLatency": 6205.0,
    "BRAM_18K": 0,
    "LUT": 1270,
    "DSP": 5,
    "FF": 1299,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "disentangled_representation_learning",
    "ResourceMetric": 0.0005066121,
    "design_id": "project",
    "algo_name": "disentangled_representation_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "disentangled_representation_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid disentangled_representation_learning(float input[LARGE_SCALE], float output[LARGE_SCALE]) {\n    float mean = 0.0;\n    float variance = 0.0;\n    float epsilon = 1e-8;\n\n    // Calculate mean\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        mean += input[i];\n    }\n    mean /= LARGE_SCALE;\n\n    // Calculate variance\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        variance += (input[i] - mean) * (input[i] - mean);\n    }\n    variance /= LARGE_SCALE;\n\n    // Normalize input\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        output[i] = (input[i] - mean) / sqrt(variance + epsilon);\n    }\n\n    // Apply non-linear transformation (ReLU)\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        if (output[i] < 0) {\n            output[i] = 0;\n        }\n    }\n}\n// Top function name: disentangled_representation_learning\n"
      }
    ],
    "code_length": 868,
    "token_count": 246,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/distributed_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3095,
    "Worst-caseLatency": 3095.0,
    "BRAM_18K": 2,
    "LUT": 968,
    "DSP": 8,
    "FF": 871,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "distributed_training",
    "ResourceMetric": 0.0006147811,
    "design_id": "project",
    "algo_name": "distributed_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "distributed_training.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid distributed_training(float input[ARRAY_SIZE], float weights[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float learning_rate = 0.01;\n    float gradient[ARRAY_SIZE];\n\n    // Compute gradient\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        gradient[i] = 2 * (input[i] * weights[i] - output[i]);\n    }\n\n    // Update weights\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        weights[i] -= learning_rate * gradient[i];\n    }\n\n    // Compute output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * weights[i];\n    }\n}\n\n// Top function name: distributed_training\n"
      }
    ],
    "code_length": 634,
    "token_count": 174,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/divide_by_2/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "divide_by_2",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "divide_by_2",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "divide_by_2.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid divide_by_2(ap_int<32> input_array[ARRAY_SIZE], ap_int<32> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_array[i] = input_array[i] >> 1;\n    }\n}\n\n// Top function name: divide_by_2\n"
      }
    ],
    "code_length": 271,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/divide_by_4/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "divide_by_4",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "divide_by_4",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "divide_by_4.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid divide_by_4(ap_int<32> input[ARRAY_SIZE], ap_int<32> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] >> 2;\n    }\n}\n\n// Top function name: divide_by_4\n"
      }
    ],
    "code_length": 247,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/divide_by_twelve_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 99,
    "DSP": 4,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "divide_by_twelve_counter",
    "ResourceMetric": 0.0001321974,
    "design_id": "project",
    "algo_name": "divide_by_twelve_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "divide_by_twelve_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid divide_by_twelve_counter(ap_uint<32> input_array[ARRAY_SIZE], ap_uint<32> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_array[i] = input_array[i] / 12;\n    }\n}\n\n// Top function name: divide_by_twelve_counter\n"
      }
    ],
    "code_length": 299,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 494,
    "DSP": 0,
    "FF": 68,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "divider",
    "ResourceMetric": 0.0001012518,
    "design_id": "project",
    "algo_name": "divider",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "divider.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid divider(uint8_t dividend[ARRAY_SIZE], uint8_t divisor[ARRAY_SIZE], uint8_t quotient[ARRAY_SIZE], uint8_t remainder[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t temp_dividend = dividend[i];\n        uint8_t temp_divisor = divisor[i];\n        uint8_t temp_quotient = 0;\n        uint8_t temp_remainder = 0;\n\n        for (int j = 7; j >= 0; j--) {\n            temp_remainder = (temp_remainder << 1) | ((temp_dividend >> j) & 1);\n            if (temp_remainder >= temp_divisor) {\n                temp_remainder -= temp_divisor;\n                temp_quotient |= (1 << j);\n            }\n        }\n        quotient[i] = temp_quotient;\n        remainder[i] = temp_remainder;\n    }\n}\n\n// Top function name: divider\n"
      }
    ],
    "code_length": 784,
    "token_count": 216,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dma/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dma",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "dma",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dma.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid dma(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: dma\n"
      }
    ],
    "code_length": 204,
    "token_count": 67,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dma_control/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dma_control",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "dma_control",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dma_control.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid dma_control(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] + 1;\n    }\n}\n\n// Top function name: dma_control\n"
      }
    ],
    "code_length": 224,
    "token_count": 73,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dma_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8194,
    "Worst-caseLatency": 8194.0,
    "BRAM_18K": 0,
    "LUT": 203,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dma_controller",
    "ResourceMetric": 4.3243e-05,
    "design_id": "project",
    "algo_name": "dma_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dma_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid dma_controller(uint32_t input[8][SIZE], uint32_t output[8][SIZE]) {\n    for (int channel = 0; channel < 8; channel++) {\n        for (int i = 0; i < SIZE; i++) {\n            output[channel][i] = input[channel][i];\n        }\n    }\n}\n\n// Top function name: dma_controller\n"
      }
    ],
    "code_length": 314,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/doitgen/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2154096001,
    "Worst-caseLatency": 2154096001.0,
    "BRAM_18K": 0,
    "LUT": 1650,
    "DSP": 12,
    "FF": 1268,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_doitgen",
    "ResourceMetric": 0.0007704377,
    "design_id": "project",
    "algo_name": "doitgen",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "doitgen.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* doitgen.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"doitgen.h\"\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_doitgen(int nr, int nq, int np,\n\t\t    DATA_TYPE POLYBENCH_3D(A,NR,NQ,NP,nr,nq,np),\n\t\t    DATA_TYPE POLYBENCH_2D(C4,NP,NP,np,np),\n\t\t    DATA_TYPE POLYBENCH_1D(sum,NP,np))\n{\n  int r, q, p, s;\n\n#pragma scop\n  for (r = 0; r < _PB_NR; r++)\n    for (q = 0; q < _PB_NQ; q++)  {\n      for (p = 0; p < _PB_NP; p++)  {\n\tsum[p] = SCALAR_VAL(0.0);\n\tfor (s = 0; s < _PB_NP; s++)\n\t  sum[p] += A[r][q][s] * C4[s][p];\n      }\n      for (p = 0; p < _PB_NP; p++)\n\tA[r][q][p] = sum[p];\n    }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "doitgen.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _DOITGEN_H\n# define _DOITGEN_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(NQ) && !defined(NR) && !defined(NP)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define NQ 8\n#   define NR 10\n#   define NP 12\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define NQ 20\n#   define NR 25\n#   define NP 30\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define NQ 40\n#   define NR 50\n#   define NP 60\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define NQ 140\n#   define NR 150\n#   define NP 160\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define NQ 220\n#   define NR 250\n#   define NP 270\n#  endif\n\n\n#endif /* !(NQ NR NP) */\n\n# define _PB_NQ POLYBENCH_LOOP_BOUND(NQ,nq)\n# define _PB_NR POLYBENCH_LOOP_BOUND(NR,nr)\n# define _PB_NP POLYBENCH_LOOP_BOUND(NP,np)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_DOITGEN_H */\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 1067,
    "token_count": 373,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/dolby_b_noise_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1039,
    "Worst-caseLatency": 1039.0,
    "BRAM_18K": 0,
    "LUT": 869,
    "DSP": 4,
    "FF": 1469,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dolby_b_noise_processor",
    "ResourceMetric": 0.0004183105,
    "design_id": "project",
    "algo_name": "dolby_b_noise_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "dolby_b_noise_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid dolby_b_noise_processor(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float threshold, float compression_ratio) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float sample = input[i];\n        if (std::abs(sample) > threshold) {\n            if (sample > 0) {\n                sample = threshold + (sample - threshold) / compression_ratio;\n            } else {\n                sample = -threshold + (sample + threshold) / compression_ratio;\n            }\n        }\n        output[i] = sample;\n    }\n}\n\n// Top function name: dolby_b_noise_processor\n"
      }
    ],
    "code_length": 623,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dot_product/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 191,
    "DSP": 4,
    "FF": 78,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dot_product",
    "ResourceMetric": 0.0001549215,
    "design_id": "project",
    "algo_name": "dot_product",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dot_product.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dot_product(const int32_t A[ARRAY_SIZE], const int32_t B[ARRAY_SIZE], int64_t &result) {\n    result = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result += (int64_t)A[i] * (int64_t)B[i];\n    }\n}\n\n// Top function name: dot_product\n"
      }
    ],
    "code_length": 291,
    "token_count": 94,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/down_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 103,
    "DSP": 0,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "down_counter",
    "ResourceMetric": 2.09983e-05,
    "design_id": "project",
    "algo_name": "down_counter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "down_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid down_counter(ap_int<32> start_value, ap_int<32> result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        result[i] = start_value - i;\n    }\n}\n\n// Top function name: down_counter\n"
      }
    ],
    "code_length": 227,
    "token_count": 70,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dram_cell/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dram_cell",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "dram_cell",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dram_cell.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid dram_cell(uint8_t input[SIZE], uint8_t output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i];\n    }\n}\n\n// Top function name: dram_cell\n"
      }
    ],
    "code_length": 208,
    "token_count": 64,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dram_cell_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 93,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dram_cell_16bit",
    "ResourceMetric": 2.02312e-05,
    "design_id": "project",
    "algo_name": "dram_cell_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dram_cell_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dram_cell_16bit(uint16_t input_array[ARRAY_SIZE], uint16_t output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint16_t temp = input_array[i];\n        // Simulate some processing on the DRAM cell\n        temp = (temp << 1) | (temp >> 15); // Rotate left by 1 bit\n        temp ^= 0xAAAA; // XOR with a pattern\n        output_array[i] = temp;\n    }\n}\n\n// Top function name: dram_cell_16bit\n"
      }
    ],
    "code_length": 466,
    "token_count": 136,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/dram_cell_4bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dram_cell_4bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "dram_cell_4bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "dram_cell_4bit.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid dram_cell_4bit(uint8_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t cell = input[i] & 0x0F; // Extract 4-bit cell\n        output[i] = cell;\n    }\n}\n\n// Top function name: dram_cell_4bit\n"
      }
    ],
    "code_length": 299,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dropout/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1034,
    "Worst-caseLatency": 1034.0,
    "BRAM_18K": 0,
    "LUT": 225,
    "DSP": 0,
    "FF": 693,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dropout",
    "ResourceMetric": 0.0001095936,
    "design_id": "project",
    "algo_name": "dropout",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dropout.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid dropout(ap_uint<1> mask[SIZE], float input[SIZE], float output[SIZE], float dropout_rate) {\n    for (int i = 0; i < SIZE; i++) {\n        if (mask[i] == 1) {\n            output[i] = input[i] / dropout_rate;\n        } else {\n            output[i] = 0.0f;\n        }\n    }\n}\n\n// Top function name: dropout\n"
      }
    ],
    "code_length": 347,
    "token_count": 104,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_2bit_subtractor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 87,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_2bit_subtractor",
    "ResourceMetric": 1.90806e-05,
    "design_id": "project",
    "algo_name": "dual_2bit_subtractor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_2bit_subtractor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dual_2bit_subtractor(ap_uint<2> A[ARRAY_SIZE], ap_uint<2> B[ARRAY_SIZE], ap_int<3> result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result[i] = A[i] - B[i];\n    }\n}\n\n// Top function name: dual_2bit_subtractor\n"
      }
    ],
    "code_length": 284,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dual_averaging/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3094,
    "Worst-caseLatency": 3094.0,
    "BRAM_18K": 0,
    "LUT": 1090,
    "DSP": 10,
    "FF": 1033,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_averaging",
    "ResourceMetric": 0.0005851092,
    "design_id": "project",
    "algo_name": "dual_averaging",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dual_averaging.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid dual_averaging(float alpha, float beta, float gamma, float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float sum1 = 0.0f;\n    float sum2 = 0.0f;\n    float avg1 = 0.0f;\n    float avg2 = 0.0f;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum1 += input[i];\n        sum2 += input[ARRAY_SIZE - 1 - i];\n    }\n\n    avg1 = sum1 / ARRAY_SIZE;\n    avg2 = sum2 / ARRAY_SIZE;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = alpha * input[i] + beta * avg1 + gamma * avg2;\n    }\n}\n\n// Top function name: dual_averaging\n"
      }
    ],
    "code_length": 583,
    "token_count": 193,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_comparator",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "dual_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid dual_comparator(ap_int<16> input1[SIZE], ap_int<16> input2[SIZE], ap_int<1> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (input1[i] > input2[i]) {\n            output[i] = 1;\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: dual_comparator\n"
      }
    ],
    "code_length": 339,
    "token_count": 109,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_differential_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 162,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_differential_comparator",
    "ResourceMetric": 3.3463e-05,
    "design_id": "project",
    "algo_name": "dual_differential_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_differential_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dual_differential_comparator(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> diff1 = input1[i] - input2[i];\n        ap_int<16> diff2 = input2[i] - input1[i];\n        if (diff1 > diff2) {\n            output[i] = diff1;\n        } else {\n            output[i] = diff2;\n        }\n    }\n}\n\n// Top function name: dual_differential_comparator\n"
      }
    ],
    "code_length": 496,
    "token_count": 151,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_mux_demux/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 141,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_mux_demux",
    "ResourceMetric": 2.95318e-05,
    "design_id": "project",
    "algo_name": "dual_mux_demux",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_mux_demux.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid dual_mux_demux(ap_uint<32> input1[SIZE], ap_uint<32> input2[SIZE], ap_uint<32> output1[SIZE], ap_uint<32> output2[SIZE], bool select) {\n    for (int i = 0; i < SIZE; i++) {\n        if (select) {\n            output1[i] = input1[i];\n            output2[i] = input2[i];\n        } else {\n            output1[i] = input2[i];\n            output2[i] = input1[i];\n        }\n    }\n}\n\n// Top function name: dual_mux_demux\n"
      }
    ],
    "code_length": 457,
    "token_count": 142,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_supply_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2054,
    "Worst-caseLatency": 2054.0,
    "BRAM_18K": 1,
    "LUT": 239,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_supply_shift_register",
    "ResourceMetric": 0.0001121505,
    "design_id": "project",
    "algo_name": "dual_supply_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_supply_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid dual_supply_shift_register(ap_uint<8> serial_in, ap_uint<1> load, ap_uint<8> parallel_in[SIZE], ap_uint<8> &serial_out, ap_uint<8> parallel_out[SIZE]) {\n    static ap_uint<8> shift_register[SIZE];\n\n    for (int i = 0; i < SIZE; i++) {\n        if (load) {\n            shift_register[i] = parallel_in[i];\n        } else {\n            if (i == 0) {\n                shift_register[i] = serial_in;\n            } else {\n                shift_register[i] = shift_register[i-1];\n            }\n        }\n        parallel_out[i] = shift_register[i];\n    }\n\n    serial_out = shift_register[SIZE-1];\n}\n\n// Top function name: dual_supply_shift_register\n"
      }
    ],
    "code_length": 685,
    "token_count": 182,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_temperature_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_temperature_comparator",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "dual_temperature_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_temperature_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dual_temperature_comparator(ap_int<16> temp1[ARRAY_SIZE], ap_int<16> temp2[ARRAY_SIZE], ap_int<1> result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (temp1[i] > temp2[i]) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n}\n\n// Top function name: dual_temperature_comparator\n"
      }
    ],
    "code_length": 389,
    "token_count": 116,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/dual_voltage_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dual_voltage_comparator",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "dual_voltage_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "dual_voltage_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid dual_voltage_comparator(ap_int<16> voltage1[ARRAY_SIZE], ap_int<16> voltage2[ARRAY_SIZE], ap_int<1> result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (voltage1[i] > voltage2[i]) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n}\n\n// Top function name: dual_voltage_comparator\n"
      }
    ],
    "code_length": 393,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/durbin/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 99952,
    "Worst-caseLatency": 20069962.0,
    "BRAM_18K": 0,
    "LUT": 1996,
    "DSP": 19,
    "FF": 1950,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_durbin",
    "ResourceMetric": 0.0010961075,
    "design_id": "project",
    "algo_name": "durbin",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "durbin.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* durbin.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"durbin.h\"\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_durbin(int n,\n\t\t   DATA_TYPE POLYBENCH_1D(r,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(y,N,n))\n{\n DATA_TYPE z[N];\n DATA_TYPE alpha;\n DATA_TYPE beta;\n DATA_TYPE sum;\n\n int i,k;\n\n#pragma scop\n y[0] = -r[0];\n beta = SCALAR_VAL(1.0);\n alpha = -r[0];\n\n for (k = 1; k < _PB_N; k++) {\n   beta = (1-alpha*alpha)*beta;\n   sum = SCALAR_VAL(0.0);\n   for (i=0; i<k; i++) {\n      sum += r[k-i-1]*y[i];\n   }\n   alpha = - (r[k] + sum)/beta;\n\n   for (i=0; i<k; i++) {\n      z[i] = y[i] + alpha*y[k-i-1];\n   }\n   for (i=0; i<k; i++) {\n     y[i] = z[i];\n   }\n   y[k] = alpha;\n }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "durbin.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _DURBIN_H\n# define _DURBIN_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define N 40\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define N 120\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define N 400\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define N 2000\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define N 4000\n#  endif\n\n\n#endif /* !(N) */\n\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_DURBIN_H */\n"
      }
    ],
    "code_length": 1143,
    "token_count": 380,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dvfs/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1036,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 295,
    "DSP": 6,
    "FF": 557,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dvfs",
    "ResourceMetric": 0.0002762005,
    "design_id": "project",
    "algo_name": "dvfs",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dvfs.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid dvfs(float voltage[ARRAY_SIZE], float frequency[ARRAY_SIZE], float power[ARRAY_SIZE], float energy[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        power[i] = voltage[i] * voltage[i] * frequency[i];\n        energy[i] = power[i] / frequency[i];\n    }\n}\n\n// Top function name: dvfs\n"
      }
    ],
    "code_length": 348,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dwt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1560,
    "Worst-caseLatency": 1560.0,
    "BRAM_18K": 2,
    "LUT": 734,
    "DSP": 4,
    "FF": 890,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dwt",
    "ResourceMetric": 0.0004609143,
    "design_id": "project",
    "algo_name": "dwt",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dwt.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid dwt(float input[N], float output[N]) {\n    float temp[N];\n    int half = N / 2;\n\n    for (int i = 0; i < half; i++) {\n        temp[i] = (input[2 * i] + input[2 * i + 1]) / sqrt(2.0);\n        temp[half + i] = (input[2 * i] - input[2 * i + 1]) / sqrt(2.0);\n    }\n\n    for (int i = 0; i < N; i++) {\n        output[i] = temp[i];\n    }\n}\n\n// Top function name: dwt\n"
      }
    ],
    "code_length": 399,
    "token_count": 150,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dynamic_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3113,
    "Worst-caseLatency": 3113.0,
    "BRAM_18K": 0,
    "LUT": 1555,
    "DSP": 2,
    "FF": 1790,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dynamic_attention",
    "ResourceMetric": 0.0005252317,
    "design_id": "project",
    "algo_name": "dynamic_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dynamic_attention.cpp",
        "file_content": "#include <cmath>\n#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid dynamic_attention(fixed_point_t input[ARRAY_SIZE], fixed_point_t weights[ARRAY_SIZE], fixed_point_t output[ARRAY_SIZE]) {\n    fixed_point_t sum = 0;\n    fixed_point_t weighted_sum = 0;\n\n    // Compute the sum of the input array\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += input[i];\n    }\n\n    // Compute the weighted sum\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        weighted_sum += input[i] * weights[i];\n    }\n\n    // Compute the attention output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] / sum) * weighted_sum;\n    }\n}\n\n// Top function name: dynamic_attention\n"
      }
    ],
    "code_length": 723,
    "token_count": 201,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/dynamic_range_compression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1039,
    "Worst-caseLatency": 1039.0,
    "BRAM_18K": 0,
    "LUT": 932,
    "DSP": 4,
    "FF": 1564,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dynamic_range_compression",
    "ResourceMetric": 0.0004395006,
    "design_id": "project",
    "algo_name": "dynamic_range_compression",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "dynamic_range_compression.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define ARRAY_SIZE 1024\n\nvoid dynamic_range_compression(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float threshold, float compression_ratio) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] > threshold) {\n            output[i] = threshold + (input[i] - threshold) / compression_ratio;\n        } else if (input[i] < -threshold) {\n            output[i] = -threshold + (input[i] + threshold) / compression_ratio;\n        } else {\n            output[i] = input[i];\n        }\n    }\n}\n\n// Top function name: dynamic_range_compression\n"
      }
    ],
    "code_length": 592,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/dynamic_routing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2107396,
    "Worst-caseLatency": 2107396.0,
    "BRAM_18K": 1,
    "LUT": 460,
    "DSP": 1,
    "FF": 119,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dynamic_routing",
    "ResourceMetric": 0.0001893297,
    "design_id": "project",
    "algo_name": "dynamic_routing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "dynamic_routing.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NODES 1024\n\nvoid dynamic_routing(ap_int<16> weights[NODES][NODES], ap_int<16> inputs[NODES], ap_int<16> outputs[NODES]) {\n    ap_int<16> temp[NODES];\n\n    // Initialize outputs to zero\n    for (int i = 0; i < NODES; i++) {\n        outputs[i] = 0;\n    }\n\n    // Perform dynamic routing\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < NODES; j++) {\n            temp[j] = weights[i][j] * inputs[i];\n        }\n        for (int j = 0; j < NODES; j++) {\n            outputs[j] += temp[j];\n        }\n    }\n}\n\n// Top function name: dynamic_routing\n"
      }
    ],
    "code_length": 587,
    "token_count": 189,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/e_com/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "e_com",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "e_com",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "e_com.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid e_com(int input1[SIZE], int input2[SIZE], int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] + input2[i];\n    }\n}\n\n// Top function name: e_com\n"
      }
    ],
    "code_length": 224,
    "token_count": 72,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/ecc_flags/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 111,
    "Worst-caseLatency": 111.0,
    "BRAM_18K": 0,
    "LUT": 4785,
    "DSP": 3,
    "FF": 4931,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ecc_flags",
    "ResourceMetric": 0.0014735027,
    "design_id": "project",
    "algo_name": "ecc_flags",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define N 10\n\nusing din_t = int;\n\nvoid ecc_flags(din_t in1[N], din_t in2[N], const din_t Iter, din_t output[N]);\nvoid sfunc2(din_t vec1[N], const din_t sIter, din_t ovec[N]) {\n    for (int i = 0; i < N; ++i)\n        ovec[i] = vec1[i] / sIter;\n}\n\nvoid sfunc1(const din_t cIter, din_t a[N], din_t b[N], din_t res[N]) {\n    int i;\n    din_t res1[N];\n#pragma HLS ARRAY_RESHAPE variable = res1 dim = 1 factor = 2 block\n#pragma HLS BIND_STORAGE variable = res1 type = ram_s2p impl = uram_ecc\n    for (i = 0; i < N; i++) {\n        res1[i] = b[i] + a[i];\n    }\n    sfunc2(res1, cIter, res);\n}\n\nvoid sfunc3(din_t inrun[N], din_t oval[N]) {\n    int i;\n    din_t calc = 0;\n    for (i = 0; i < N; ++i) {\n        calc = (inrun[i] * inrun[i]) / (i + 1);\n        oval[i] = calc;\n    }\n}\n\nvoid ecc_flags(din_t in1[N], din_t in2[N], const din_t Iter, din_t output[N]) {\n    din_t auxbuffer1[N];\n\n    sfunc1(Iter, in1, in2, auxbuffer1);\n    sfunc3(auxbuffer1, output);\n\n    return;\n}"
      }
    ],
    "code_length": 2353,
    "token_count": 668,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/echo_cancellation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097164,
    "Worst-caseLatency": 2097164.0,
    "BRAM_18K": 0,
    "LUT": 1109,
    "DSP": 7,
    "FF": 1111,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "echo_cancellation",
    "ResourceMetric": 0.0005131199,
    "design_id": "project",
    "algo_name": "echo_cancellation",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "echo_cancellation.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n\nvoid echo_cancellation(float input_signal[N], float echo_signal[N], float output_signal[N], float filter_coeff[N]) {\n    for (int i = 0; i < N; i++) {\n        float estimated_echo = 0.0;\n        for (int j = 0; j < N; j++) {\n            if (i - j >= 0) {\n                estimated_echo += filter_coeff[j] * input_signal[i - j];\n            }\n        }\n        output_signal[i] = input_signal[i] - estimated_echo + echo_signal[i];\n    }\n}\n\n// Top function name: echo_cancellation\n"
      }
    ],
    "code_length": 533,
    "token_count": 141,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/edge_detector/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4200420,
    "Worst-caseLatency": 4200420.0,
    "BRAM_18K": 0,
    "LUT": 1899,
    "DSP": 3,
    "FF": 825,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "edge_detector",
    "ResourceMetric": 0.0005263762,
    "design_id": "project",
    "algo_name": "edge_detector",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "edge_detector.cpp",
        "file_content": "#include <cmath>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid edge_detector(int input_image[IMG_HEIGHT][IMG_WIDTH], int output_image[IMG_HEIGHT][IMG_WIDTH]) {\n    int gx, gy;\n    int sobel_x[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    int sobel_y[3][3] = {\n        {-1, -2, -1},\n        {0, 0, 0},\n        {1, 2, 1}\n    };\n\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            gx = 0;\n            gy = 0;\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    gx += input_image[i + k][j + l] * sobel_x[k + 1][l + 1];\n                    gy += input_image[i + k][j + l] * sobel_y[k + 1][l + 1];\n                }\n            }\n            output_image[i][j] = (int)sqrt((float)(gx * gx + gy * gy));\n        }\n    }\n}\n\n// Top function name: edge_detector\n"
      }
    ],
    "code_length": 911,
    "token_count": 316,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/edge_triggered_d_flip_flop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 90,
    "DSP": 0,
    "FF": 42,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "edge_triggered_d_flip_flop",
    "ResourceMetric": 2.12859e-05,
    "design_id": "project",
    "algo_name": "edge_triggered_d_flip_flop",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "edge_triggered_d_flip_flop.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid edge_triggered_d_flip_flop(ap_uint<1> D[SIZE], ap_uint<1> CLK[SIZE], ap_uint<1> Q[SIZE]) {\n    ap_uint<1> prev_clk = 0;\n    for (int i = 0; i < SIZE; i++) {\n        if (CLK[i] == 1 && prev_clk == 0) {\n            Q[i] = D[i];\n        }\n        prev_clk = CLK[i];\n    }\n}\n\n// Top function name: edge_triggered_d_flip_flop\n"
      }
    ],
    "code_length": 366,
    "token_count": 124,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/edit_distance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": null,
    "BRAM_18K": 0,
    "LUT": 905,
    "DSP": 0,
    "FF": 493,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "edit_distance",
    "ResourceMetric": 0.0002208172,
    "design_id": "project",
    "algo_name": "edit_distance",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "edit_distance.cpp",
        "file_content": "#include <cstdint>\n#include <algorithm>\n\n#define MAX_LEN 1024\n\nvoid edit_distance(const char str1[MAX_LEN], const char str2[MAX_LEN], int len1, int len2, int result[MAX_LEN][MAX_LEN]) {\n    int i, j;\n\n    for (i = 0; i <= len1; i++) {\n        for (j = 0; j <= len2; j++) {\n            if (i == 0) {\n                result[i][j] = j;\n            } else if (j == 0) {\n                result[i][j] = i;\n            } else if (str1[i - 1] == str2[j - 1]) {\n                result[i][j] = result[i - 1][j - 1];\n            } else {\n                result[i][j] = 1 + std::min({result[i - 1][j], result[i][j - 1], result[i - 1][j - 1]});\n            }\n        }\n    }\n}\n\n// Top function name: edit_distance\n"
      }
    ],
    "code_length": 701,
    "token_count": 224,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/eeprom_cell/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 198,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "eeprom_cell",
    "ResourceMetric": 4.03665e-05,
    "design_id": "project",
    "algo_name": "eeprom_cell",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "eeprom_cell.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid eeprom_cell(uint8_t input_array[ARRAY_SIZE], uint8_t output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t cell_value = input_array[i];\n        uint8_t new_value = 0;\n\n        // Simulate some EEPROM cell behavior\n        for (int j = 0; j < 8; j++) {\n            if (cell_value & (1 << j)) {\n                new_value |= (1 << (7 - j));\n            }\n        }\n\n        output_array[i] = new_value;\n    }\n}\n\n// Top function name: eeprom_cell\n"
      }
    ],
    "code_length": 527,
    "token_count": 148,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/efficient_attention_mechanisms/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4316987418,
    "Worst-caseLatency": 4316987418.0,
    "BRAM_18K": 2050,
    "LUT": 4201,
    "DSP": 33,
    "FF": 2430,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "efficient_attention_mechanisms",
    "ResourceMetric": 0.1290609621,
    "design_id": "project",
    "algo_name": "efficient_attention_mechanisms",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "efficient_attention_mechanisms.cpp",
        "file_content": "#include <cmath>\n#include <iostream>\n\n#define SIZE 1024\n\nvoid efficient_attention_mechanisms(float query[SIZE][SIZE], float key[SIZE][SIZE], float value[SIZE][SIZE], float output[SIZE][SIZE]) {\n    float attention_weights[SIZE][SIZE];\n    float sum_attention[SIZE];\n\n    // Compute attention weights\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            attention_weights[i][j] = 0.0;\n            for (int k = 0; k < SIZE; k++) {\n                attention_weights[i][j] += query[i][k] * key[j][k];\n            }\n            attention_weights[i][j] = exp(attention_weights[i][j]);\n        }\n    }\n\n    // Normalize attention weights\n    for (int i = 0; i < SIZE; i++) {\n        sum_attention[i] = 0.0;\n        for (int j = 0; j < SIZE; j++) {\n            sum_attention[i] += attention_weights[i][j];\n        }\n    }\n\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            attention_weights[i][j] /= sum_attention[i];\n        }\n    }\n\n    // Compute output\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            output[i][j] = 0.0;\n            for (int k = 0; k < SIZE; k++) {\n                output[i][j] += attention_weights[i][k] * value[k][j];\n            }\n        }\n    }\n}\n\n// Top function name: efficient_attention_mechanisms\n"
      }
    ],
    "code_length": 1338,
    "token_count": 390,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/eight_bit_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 145,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "eight_bit_counter",
    "ResourceMetric": 3.0203e-05,
    "design_id": "project",
    "algo_name": "eight_bit_counter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "eight_bit_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid eight_bit_counter(ap_uint<8> input_array[ARRAY_SIZE], ap_uint<8> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<8> count = 0;\n        for (int j = 0; j < 8; j++) {\n            count += (input_array[i] >> j) & 0x1;\n        }\n        output_array[i] = count;\n    }\n}\n\n// Top function name: eight_bit_counter\n"
      }
    ],
    "code_length": 397,
    "token_count": 124,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/elastic_weight_consolidation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1039,
    "Worst-caseLatency": 1039.0,
    "BRAM_18K": 0,
    "LUT": 965,
    "DSP": 16,
    "FF": 1461,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "elastic_weight_consolidation",
    "ResourceMetric": 0.0007683997,
    "design_id": "project",
    "algo_name": "elastic_weight_consolidation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "elastic_weight_consolidation.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid elastic_weight_consolidation(\n    float weights[ARRAY_SIZE],\n    float fisher_information[ARRAY_SIZE],\n    float old_weights[ARRAY_SIZE],\n    float importance[ARRAY_SIZE],\n    float new_weights[ARRAY_SIZE],\n    float lambda)\n{\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float fisher = fisher_information[i];\n        float old_weight = old_weights[i];\n        float weight = weights[i];\n        float imp = importance[i];\n\n        float penalty = lambda * fisher * (weight - old_weight) * (weight - old_weight);\n        new_weights[i] = weight - imp * penalty;\n    }\n}\n\n// Top function name: elastic_weight_consolidation\n"
      }
    ],
    "code_length": 676,
    "token_count": 160,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/electron_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "electron_multiplier",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "electron_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "electron_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid electron_multiplier(ap_int<16> input1[N], ap_int<16> input2[N], ap_int<32> output[N]) {\n    for (int i = 0; i < N; i++) {\n        output[i] = input1[i] * input2[i];\n    }\n}\n\n// Top function name: electron_multiplier\n"
      }
    ],
    "code_length": 258,
    "token_count": 83,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/embedded_microprocessor_fpu/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1038,
    "Worst-caseLatency": 1038.0,
    "BRAM_18K": 0,
    "LUT": 1381,
    "DSP": 22,
    "FF": 1274,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "embedded_microprocessor_fpu",
    "ResourceMetric": 0.0009964673,
    "design_id": "project",
    "algo_name": "embedded_microprocessor_fpu",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "embedded_microprocessor_fpu.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid embedded_microprocessor_fpu(float input1[ARRAY_SIZE], float input2[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float temp1 = input1[i];\n        float temp2 = input2[i];\n        float result = temp1 * temp2 + std::sqrt(temp1) - std::log(temp2 + 1.0f);\n        output[i] = result;\n    }\n}\n\n// Top function name: embedded_microprocessor_fpu\n"
      }
    ],
    "code_length": 453,
    "token_count": 127,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/encoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 85,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "encoder",
    "ResourceMetric": 1.86971e-05,
    "design_id": "project",
    "algo_name": "encoder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "encoder.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid encoder(uint8_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE]) {\n    uint8_t key = 0xAA; // Example fixed key for encoding\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] ^ key; // Simple XOR encoding\n    }\n}\n\n// Top function name: encoder\n"
      }
    ],
    "code_length": 315,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/encoder_16to4/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 188,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "encoder_16to4",
    "ResourceMetric": 3.85447e-05,
    "design_id": "project",
    "algo_name": "encoder_16to4",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "encoder_16to4.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_SIZE 1024\n\nvoid encoder_16to4(ap_uint<16> input[INPUT_SIZE], ap_uint<4> output[INPUT_SIZE]) {\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        ap_uint<16> in = input[i];\n        ap_uint<4> out = 0;\n        for (int j = 0; j < 16; j++) {\n            if (in[j] == 1) {\n                out = j;\n                break;\n            }\n        }\n        output[i] = out;\n    }\n}\n\n// Top function name: encoder_16to4\n"
      }
    ],
    "code_length": 446,
    "token_count": 140,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/entropy_based_methods/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4907,
    "Worst-caseLatency": 4907.0,
    "BRAM_18K": 1,
    "LUT": 8723,
    "DSP": 46,
    "FF": 5640,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "entropy_based_methods",
    "ResourceMetric": 0.0035499251,
    "design_id": "project",
    "algo_name": "entropy_based_methods",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "entropy_based_methods.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid entropy_based_methods(const float input[ARRAY_SIZE], float &entropy) {\n    float histogram[256] = {0};\n    float total = 0;\n\n    // Calculate histogram\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t value = static_cast<uint8_t>(input[i]);\n        histogram[value]++;\n        total++;\n    }\n\n    // Calculate entropy\n    entropy = 0;\n    for (int i = 0; i < 256; i++) {\n        if (histogram[i] > 0) {\n            float probability = histogram[i] / total;\n            entropy -= probability * log2(probability);\n        }\n    }\n}\n\n// Top function name: entropy_based_methods\n"
      }
    ],
    "code_length": 653,
    "token_count": 168,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/equality_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "equality_comparator",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "equality_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "equality_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid equality_comparator(ap_int<32> A[SIZE], ap_int<32> B[SIZE], bool result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        result[i] = (A[i] == B[i]);\n    }\n}\n\n// Top function name: equality_comparator\n"
      }
    ],
    "code_length": 250,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/error_correction_with_arq/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "error_correction_with_arq",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "error_correction_with_arq",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "error_correction_with_arq.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid error_correction_with_arq(ap_uint<8> input_data[ARRAY_SIZE], ap_uint<8> corrected_data[ARRAY_SIZE], ap_uint<1> ack[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Simulate error detection and correction\n        ap_uint<8> received_data = input_data[i];\n        ap_uint<8> corrected_byte = received_data; // Assume no error for simplicity\n\n        // Simulate ARQ mechanism\n        if (ack[i] == 1) {\n            corrected_data[i] = corrected_byte;\n        } else {\n            // If not acknowledged, retransmit (for simplicity, just copy the input data)\n            corrected_data[i] = input_data[i];\n        }\n    }\n}\n\n// Top function name: error_correction_with_arq\n"
      }
    ],
    "code_length": 741,
    "token_count": 187,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/ethernet_mac_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5,
    "Worst-caseLatency": 65540.0,
    "BRAM_18K": 0,
    "LUT": 315,
    "DSP": 0,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ethernet_mac_controller",
    "ResourceMetric": 6.57753e-05,
    "design_id": "project",
    "algo_name": "ethernet_mac_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "ethernet_mac_controller.cpp",
        "file_content": "#include <cstdint>\n\n#define PACKET_SIZE 1024\n\nvoid ethernet_mac_controller(uint8_t input_buffer[PACKET_SIZE], uint8_t output_buffer[PACKET_SIZE], uint16_t &frame_length) {\n    // Preamble and SFD (Start Frame Delimiter)\n    const uint8_t preamble_sfd[8] = {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0xD5};\n    \n    // MAC addresses (6 bytes each)\n    uint8_t dest_mac[6];\n    uint8_t src_mac[6];\n    \n    // Type/Length field (2 bytes)\n    uint16_t type_length;\n    \n    // Extract MAC addresses and Type/Length field\n    for (int i = 0; i < 6; i++) {\n        dest_mac[i] = input_buffer[8 + i];\n        src_mac[i] = input_buffer[14 + i];\n    }\n    type_length = (input_buffer[20] << 8) | input_buffer[21];\n    \n    // Extract payload\n    uint16_t payload_length = frame_length - 22; // Subtracting preamble, SFD, MAC addresses, and Type/Length field\n    for (int i = 0; i < payload_length; i++) {\n        output_buffer[i] = input_buffer[22 + i];\n    }\n    \n    // Add CRC (Cyclic Redundancy Check) - Dummy CRC for example\n    uint32_t crc = 0xDEADBEEF;\n    output_buffer[payload_length] = (crc >> 24) & 0xFF;\n    output_buffer[payload_length + 1] = (crc >> 16) & 0xFF;\n    output_buffer[payload_length + 2] = (crc >> 8) & 0xFF;\n    output_buffer[payload_length + 3] = crc & 0xFF;\n    \n    // Update frame length to include CRC\n    frame_length = payload_length + 4;\n}\n\n// Top function name: ethernet_mac_controller\n"
      }
    ],
    "code_length": 1415,
    "token_count": 441,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/ethernet_mac_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2056,
    "Worst-caseLatency": 2056.0,
    "BRAM_18K": 0,
    "LUT": 457,
    "DSP": 0,
    "FF": 55,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ethernet_mac_controller",
    "ResourceMetric": 9.29101e-05,
    "design_id": "project",
    "algo_name": "ethernet_mac_controller",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "ethernet_mac_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define PACKET_SIZE 1024\n\nvoid ethernet_mac_controller(uint8_t input_packet[PACKET_SIZE], uint8_t output_packet[PACKET_SIZE]) {\n    uint16_t crc = 0xFFFF;\n    uint8_t polynomial = 0x07;\n\n    // Calculate CRC for input packet\n    for (int i = 0; i < PACKET_SIZE; i++) {\n        crc ^= input_packet[i];\n        for (int j = 0; j < 8; j++) {\n            if (crc & 1) {\n                crc = (crc >> 1) ^ polynomial;\n            } else {\n                crc >>= 1;\n            }\n        }\n    }\n\n    // Append CRC to the output packet\n    for (int i = 0; i < PACKET_SIZE; i++) {\n        output_packet[i] = input_packet[i];\n    }\n    output_packet[PACKET_SIZE - 2] = crc & 0xFF;\n    output_packet[PACKET_SIZE - 1] = (crc >> 8) & 0xFF;\n}\n\n// Top function name: ethernet_mac_controller\n"
      }
    ],
    "code_length": 800,
    "token_count": 233,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/euclidean_distance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2062,
    "Worst-caseLatency": 2062.0,
    "BRAM_18K": 0,
    "LUT": 474,
    "DSP": 5,
    "FF": 490,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "euclidean_distance",
    "ResourceMetric": 0.0002763984,
    "design_id": "project",
    "algo_name": "euclidean_distance",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "euclidean_distance.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid euclidean_distance(float A[SIZE], float B[SIZE], float &distance) {\n    float sum = 0.0;\n    for (int i = 0; i < SIZE; i++) {\n        float diff = A[i] - B[i];\n        sum += diff * diff;\n    }\n    distance = sqrt(sum);\n}\n\n// Top function name: euclidean_distance\n"
      }
    ],
    "code_length": 306,
    "token_count": 90,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/even_parity_generator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 64,
    "DSP": 0,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "even_parity_generator",
    "ResourceMetric": 1.35194e-05,
    "design_id": "project",
    "algo_name": "even_parity_generator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "even_parity_generator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid even_parity_generator(ap_uint<1> input[ARRAY_SIZE], ap_uint<1> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<1> parity = 0;\n        for (int j = 0; j < 8; j++) {\n            parity ^= input[i].range(j, j);\n        }\n        output[i] = parity;\n    }\n}\n\n// Top function name: even_parity_generator\n"
      }
    ],
    "code_length": 383,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/f1_score/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1045,
    "Worst-caseLatency": 1045.0,
    "BRAM_18K": 0,
    "LUT": 892,
    "DSP": 5,
    "FF": 660,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "f1_score",
    "ResourceMetric": 0.0003728562,
    "design_id": "project",
    "algo_name": "f1_score",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "f1_score.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid f1_score(ap_uint<1> y_true[SIZE], ap_uint<1> y_pred[SIZE], float &f1) {\n    int tp = 0; // True Positives\n    int fp = 0; // False Positives\n    int fn = 0; // False Negatives\n\n    for (int i = 0; i < SIZE; i++) {\n        if (y_true[i] == 1 && y_pred[i] == 1) {\n            tp++;\n        } else if (y_true[i] == 0 && y_pred[i] == 1) {\n            fp++;\n        } else if (y_true[i] == 1 && y_pred[i] == 0) {\n            fn++;\n        }\n    }\n\n    float precision = tp / float(tp + fp);\n    float recall = tp / float(tp + fn);\n    f1 = 2 * (precision * recall) / (precision + recall);\n}\n\n// Top function name: f1_score\n"
      }
    ],
    "code_length": 663,
    "token_count": 221,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/factorization_machines/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 100396,
    "Worst-caseLatency": 325676.0,
    "BRAM_18K": 4,
    "LUT": 2498,
    "DSP": 10,
    "FF": 3111,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "factorization_machines",
    "ResourceMetric": 0.0013023737,
    "design_id": "project",
    "algo_name": "factorization_machines",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "factorization_machines.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define K 10\n\nvoid factorization_machines(float X[N][K], float V[K][K], float W[K], float b, float y[N]) {\n    float linear_terms[N];\n    float interaction_terms[N];\n\n    for (int i = 0; i < N; i++) {\n        linear_terms[i] = b;\n        for (int j = 0; j < K; j++) {\n            linear_terms[i] += W[j] * X[i][j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        interaction_terms[i] = 0.0f;\n        for (int j = 0; j < K; j++) {\n            for (int k = j + 1; k < K; k++) {\n                interaction_terms[i] += V[j][k] * X[i][j] * X[i][k];\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        y[i] = linear_terms[i] + interaction_terms[i];\n    }\n}\n\n// Top function name: factorization_machines\n"
      }
    ],
    "code_length": 763,
    "token_count": 249,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/fairness_aware_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3095,
    "Worst-caseLatency": 3095.0,
    "BRAM_18K": 0,
    "LUT": 999,
    "DSP": 5,
    "FF": 831,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fairness_aware_learning",
    "ResourceMetric": 0.0004097709,
    "design_id": "project",
    "algo_name": "fairness_aware_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "fairness_aware_learning.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define ARRAY_SIZE 1024\n\nvoid fairness_aware_learning(float input_data[ARRAY_SIZE], float output_data[ARRAY_SIZE], float fairness_factor) {\n    float sum = 0.0;\n    float max_val = -INFINITY;\n    float min_val = INFINITY;\n\n    // Calculate sum, max, and min\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += input_data[i];\n        if (input_data[i] > max_val) {\n            max_val = input_data[i];\n        }\n        if (input_data[i] < min_val) {\n            min_val = input_data[i];\n        }\n    }\n\n    float mean = sum / ARRAY_SIZE;\n    float range = max_val - min_val;\n\n    // Apply fairness-aware transformation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float normalized = (input_data[i] - mean) / range;\n        output_data[i] = normalized * fairness_factor;\n    }\n}\n\n// Top function name: fairness_aware_learning\n"
      }
    ],
    "code_length": 877,
    "token_count": 227,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/fan_speed_control/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 213,
    "DSP": 2,
    "FF": 53,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fan_speed_control",
    "ResourceMetric": 0.0001013355,
    "design_id": "project",
    "algo_name": "fan_speed_control",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "fan_speed_control.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid fan_speed_control(ap_int<16> temperature[ARRAY_SIZE], ap_int<16> fan_speed[ARRAY_SIZE]) {\n    ap_int<16> threshold_low = 30;\n    ap_int<16> threshold_high = 70;\n    ap_int<16> speed_low = 1000;\n    ap_int<16> speed_high = 3000;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (temperature[i] < threshold_low) {\n            fan_speed[i] = speed_low;\n        } else if (temperature[i] > threshold_high) {\n            fan_speed[i] = speed_high;\n        } else {\n            fan_speed[i] = speed_low + ((temperature[i] - threshold_low) * (speed_high - speed_low)) / (threshold_high - threshold_low);\n        }\n    }\n}\n\n// Top function name: fan_speed_control\n"
      }
    ],
    "code_length": 713,
    "token_count": 199,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/fast_dual_dac_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fast_dual_dac_multiplier",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "fast_dual_dac_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "fast_dual_dac_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid fast_dual_dac_multiplier(ap_int<16> input1[SIZE], ap_int<16> input2[SIZE], ap_int<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] * input2[i];\n    }\n}\n\n// Top function name: fast_dual_dac_multiplier\n"
      }
    ],
    "code_length": 283,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/fc_series_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 125,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fc_series_adder",
    "ResourceMetric": 2.94359e-05,
    "design_id": "project",
    "algo_name": "fc_series_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "fc_series_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid fc_series_adder(ap_int<32> input_array[ARRAY_SIZE], ap_int<32> output_array[ARRAY_SIZE]) {\n    ap_int<32> sum = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += input_array[i];\n        output_array[i] = sum;\n    }\n}\n\n// Top function name: fc_series_adder\n"
      }
    ],
    "code_length": 318,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/fdr_control/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 17425,
    "Worst-caseLatency": 5244955.0,
    "BRAM_18K": 3,
    "LUT": 1437,
    "DSP": 3,
    "FF": 856,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fdr_control",
    "ResourceMetric": 0.0006267651,
    "design_id": "project",
    "algo_name": "fdr_control",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "fdr_control.cpp",
        "file_content": "#include <algorithm>\n\n#define N 1024\n\nvoid fdr_control(float p_values[N], float q_values[N], float alpha) {\n    int i, j;\n    float sorted_p_values[N];\n    int indices[N];\n\n    // Initialize indices\n    for (i = 0; i < N; i++) {\n        indices[i] = i;\n    }\n\n    // Sort p-values and keep track of indices\n    for (i = 0; i < N - 1; i++) {\n        for (j = 0; j < N - i - 1; j++) {\n            if (p_values[indices[j]] > p_values[indices[j + 1]]) {\n                int temp = indices[j];\n                indices[j] = indices[j + 1];\n                indices[j + 1] = temp;\n            }\n        }\n    }\n\n    // Apply FDR control\n    for (i = 0; i < N; i++) {\n        sorted_p_values[i] = p_values[indices[i]];\n    }\n\n    for (i = 0; i < N; i++) {\n        q_values[indices[i]] = sorted_p_values[i] * N / (i + 1);\n    }\n\n    for (i = 1; i < N; i++) {\n        if (q_values[indices[i]] < q_values[indices[i - 1]]) {\n            q_values[indices[i]] = q_values[indices[i - 1]];\n        }\n    }\n\n    for (i = 0; i < N; i++) {\n        if (q_values[i] > alpha) {\n            q_values[i] = alpha;\n        }\n    }\n}\n\n// Top function name: fdr_control\n"
      }
    ],
    "code_length": 1141,
    "token_count": 358,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/fdtd-2d/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1798430001,
    "Worst-caseLatency": 1798430001.0,
    "BRAM_18K": 0,
    "LUT": 4423,
    "DSP": 25,
    "FF": 3761,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_fdtd_2d",
    "ResourceMetric": 0.0019013873,
    "design_id": "project",
    "algo_name": "fdtd-2d",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "fdtd-2d.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _FDTD_2D_H\n# define _FDTD_2D_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(TMAX) && !defined(NX) && !defined(NY)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define TMAX 20\n#   define NX 20\n#   define NY 30\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define TMAX 40\n#   define NX 60\n#   define NY 80\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define TMAX 100\n#   define NX 200\n#   define NY 240\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define TMAX 500\n#   define NX 1000\n#   define NY 1200\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define TMAX 1000\n#   define NX 2000\n#   define NY 2600\n#  endif\n\n\n#endif /* !(TMAX NX NY) */\n\n# define _PB_TMAX POLYBENCH_LOOP_BOUND(TMAX,tmax)\n# define _PB_NX POLYBENCH_LOOP_BOUND(NX,nx)\n# define _PB_NY POLYBENCH_LOOP_BOUND(NY,ny)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_FDTD_2D_H */\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "fdtd-2d.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* fdtd-2d.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"fdtd-2d.h\"\n\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_fdtd_2d(int tmax,\n\t\t    int nx,\n\t\t    int ny,\n\t\t    DATA_TYPE POLYBENCH_2D(ex,NX,NY,nx,ny),\n\t\t    DATA_TYPE POLYBENCH_2D(ey,NX,NY,nx,ny),\n\t\t    DATA_TYPE POLYBENCH_2D(hz,NX,NY,nx,ny),\n\t\t    DATA_TYPE POLYBENCH_1D(_fict_,TMAX,tmax))\n{\n  int t, i, j;\n\n#pragma scop\n\n  for(t = 0; t < _PB_TMAX; t++)\n    {\n      for (j = 0; j < _PB_NY; j++)\n\tey[0][j] = _fict_[t];\n      for (i = 1; i < _PB_NX; i++)\n\tfor (j = 0; j < _PB_NY; j++)\n\t  ey[i][j] = ey[i][j] - SCALAR_VAL(0.5)*(hz[i][j]-hz[i-1][j]);\n      for (i = 0; i < _PB_NX; i++)\n\tfor (j = 1; j < _PB_NY; j++)\n\t  ex[i][j] = ex[i][j] - SCALAR_VAL(0.5)*(hz[i][j]-hz[i][j-1]);\n      for (i = 0; i < _PB_NX - 1; i++)\n\tfor (j = 0; j < _PB_NY - 1; j++)\n\t  hz[i][j] = hz[i][j] - SCALAR_VAL(0.7)*  (ex[i][j+1] - ex[i][j] +\n\t\t\t\t       ey[i+1][j] - ey[i][j]);\n    }\n\n#pragma endscop\n}\n\n"
      }
    ],
    "code_length": 1394,
    "token_count": 546,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/feature_engineering/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1041,
    "Worst-caseLatency": 1041.0,
    "BRAM_18K": 0,
    "LUT": 2341,
    "DSP": 31,
    "FF": 1629,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "feature_engineering",
    "ResourceMetric": 0.0014639349,
    "design_id": "project",
    "algo_name": "feature_engineering",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "feature_engineering.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid feature_engineering(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Feature 1: Square of the input\n        float feature1 = input[i] * input[i];\n        \n        // Feature 2: Square root of the input\n        float feature2 = sqrtf(input[i]);\n        \n        // Feature 3: Logarithm of the input (adding 1 to avoid log(0))\n        float feature3 = logf(input[i] + 1.0f);\n        \n        // Feature 4: Exponential of the input\n        float feature4 = expf(input[i]);\n        \n        // Combine features into the output\n        output[i] = feature1 + feature2 + feature3 + feature4;\n    }\n}\n\n// Top function name: feature_engineering\n"
      }
    ],
    "code_length": 743,
    "token_count": 192,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/feature_selection_rfe_selectkbest/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 10249,
    "Worst-caseLatency": 5237779.0,
    "BRAM_18K": 1,
    "LUT": 530,
    "DSP": 0,
    "FF": 204,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "feature_selection_rfe_selectkbest",
    "ResourceMetric": 0.0001831994,
    "design_id": "project",
    "algo_name": "feature_selection_rfe_selectkbest",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "feature_selection_rfe_selectkbest.cpp",
        "file_content": "#include <iostream>\n#include <algorithm>\n\n#define N 1024\n#define K 10\n\nvoid feature_selection_rfe_selectkbest(float data[N][N], float scores[N], float selected_features[K]) {\n    // Initialize indices\n    int indices[N];\n    for (int i = 0; i < N; i++) {\n        indices[i] = i;\n    }\n\n    // Sort indices based on scores\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = 0; j < N - i - 1; j++) {\n            if (scores[indices[j]] < scores[indices[j + 1]]) {\n                std::swap(indices[j], indices[j + 1]);\n            }\n        }\n    }\n\n    // Select top K features\n    for (int i = 0; i < K; i++) {\n        selected_features[i] = indices[i];\n    }\n}\n\n// Top function name: feature_selection_rfe_selectkbest\n"
      }
    ],
    "code_length": 726,
    "token_count": 211,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_active_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3093,
    "Worst-caseLatency": 3093.0,
    "BRAM_18K": 4,
    "LUT": 847,
    "DSP": 5,
    "FF": 793,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_active_learning",
    "ResourceMetric": 0.000624995,
    "design_id": "project",
    "algo_name": "federated_active_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_active_learning.cpp",
        "file_content": "#include <iostream>\n\n#define DATA_SIZE 1024\n\nvoid federated_active_learning(float input_data[DATA_SIZE], float output_data[DATA_SIZE], float model_weights[DATA_SIZE], float learning_rate) {\n    // Initialize variables\n    float gradients[DATA_SIZE];\n    float updated_weights[DATA_SIZE];\n\n    // Compute gradients\n    for (int i = 0; i < DATA_SIZE; i++) {\n        gradients[i] = input_data[i] * (input_data[i] - model_weights[i]);\n    }\n\n    // Update model weights\n    for (int i = 0; i < DATA_SIZE; i++) {\n        updated_weights[i] = model_weights[i] - learning_rate * gradients[i];\n    }\n\n    // Generate output data\n    for (int i = 0; i < DATA_SIZE; i++) {\n        output_data[i] = updated_weights[i];\n    }\n}\n\n// Top function name: federated_active_learning\n"
      }
    ],
    "code_length": 765,
    "token_count": 194,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_adversarial_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 7248,
    "Worst-caseLatency": 7248.0,
    "BRAM_18K": 0,
    "LUT": 3689,
    "DSP": 24,
    "FF": 4721,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_adversarial_learning",
    "ResourceMetric": 0.0018249751,
    "design_id": "project",
    "algo_name": "federated_adversarial_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_adversarial_learning.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_adversarial_learning(\n    float global_model[ARRAY_SIZE], \n    float local_models[ARRAY_SIZE][10], \n    float adversarial_examples[ARRAY_SIZE][10], \n    float updated_global_model[ARRAY_SIZE])\n{\n    float learning_rate = 0.01;\n    float adversarial_weight = 0.1;\n\n    // Initialize updated global model\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        updated_global_model[i] = global_model[i];\n    }\n\n    // Aggregate local models and adversarial examples\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        for (int j = 0; j < 10; j++) {\n            updated_global_model[i] += learning_rate * (local_models[i][j] - global_model[i]);\n            updated_global_model[i] += adversarial_weight * adversarial_examples[i][j];\n        }\n    }\n\n    // Normalize the updated global model\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        updated_global_model[i] /= 10.0;\n    }\n}\n\n// Top function name: federated_adversarial_learning\n"
      }
    ],
    "code_length": 987,
    "token_count": 259,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_anomaly_detection/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4226049,
    "Worst-caseLatency": 4226049.0,
    "BRAM_18K": 0,
    "LUT": 1037,
    "DSP": 5,
    "FF": 818,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_anomaly_detection",
    "ResourceMetric": 0.0004158115,
    "design_id": "project",
    "algo_name": "federated_anomaly_detection",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_anomaly_detection.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_anomaly_detection(float input_data[DATA_SIZE], float threshold, int anomaly_flags[DATA_SIZE]) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        float mean = 0.0;\n        float variance = 0.0;\n        \n        // Calculate mean\n        for (int j = 0; j < DATA_SIZE; j++) {\n            mean += input_data[j];\n        }\n        mean /= DATA_SIZE;\n        \n        // Calculate variance\n        for (int j = 0; j < DATA_SIZE; j++) {\n            variance += (input_data[j] - mean) * (input_data[j] - mean);\n        }\n        variance /= DATA_SIZE;\n        \n        // Calculate standard deviation\n        float stddev = std::sqrt(variance);\n        \n        // Detect anomaly\n        if (std::abs(input_data[i] - mean) > threshold * stddev) {\n            anomaly_flags[i] = 1;\n        } else {\n            anomaly_flags[i] = 0;\n        }\n    }\n}\n\n// Top function name: federated_anomaly_detection\n"
      }
    ],
    "code_length": 952,
    "token_count": 239,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_averaging/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 131338,
    "Worst-caseLatency": 131338.0,
    "BRAM_18K": 0,
    "LUT": 663,
    "DSP": 0,
    "FF": 118,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_averaging",
    "ResourceMetric": 0.0001384542,
    "design_id": "project",
    "algo_name": "federated_averaging",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_averaging.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_CLIENTS 1024\n#define NUM_FEATURES 128\n\nvoid federated_averaging(ap_int<32> local_weights[NUM_CLIENTS][NUM_FEATURES], ap_int<32> global_weights[NUM_FEATURES]) {\n    ap_int<32> temp_weights[NUM_FEATURES] = {0};\n\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            temp_weights[j] += local_weights[i][j];\n        }\n    }\n\n    for (int j = 0; j < NUM_FEATURES; j++) {\n        global_weights[j] = temp_weights[j] / NUM_CLIENTS;\n    }\n}\n\n// Top function name: federated_averaging\n"
      }
    ],
    "code_length": 560,
    "token_count": 169,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_blockchain_integration/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 264203,
    "Worst-caseLatency": 264203.0,
    "BRAM_18K": 15,
    "LUT": 2197,
    "DSP": 0,
    "FF": 378,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_blockchain_integration",
    "ResourceMetric": 0.0013876105,
    "design_id": "project",
    "algo_name": "federated_blockchain_integration",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_blockchain_integration.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_blockchain_integration(ap_uint<256> input_data[ARRAY_SIZE], ap_uint<256> output_data[ARRAY_SIZE]) {\n    ap_uint<256> local_data[ARRAY_SIZE];\n    \n    // Step 1: Data Aggregation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        local_data[i] = input_data[i];\n    }\n    \n    // Step 2: Blockchain Hash Calculation (Simplified)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<256> hash = 0;\n        for (int j = 0; j < 256; j++) {\n            hash ^= (local_data[i] >> j) & 1;\n        }\n        output_data[i] = hash;\n    }\n    \n    // Step 3: Federated Learning Model Update (Simplified)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] += local_data[i];\n    }\n}\n\n// Top function name: federated_blockchain_integration\n"
      }
    ],
    "code_length": 808,
    "token_count": 237,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_continual_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6183,
    "Worst-caseLatency": 6183.0,
    "BRAM_18K": 0,
    "LUT": 2092,
    "DSP": 14,
    "FF": 2638,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_continual_learning",
    "ResourceMetric": 0.0010419645,
    "design_id": "project",
    "algo_name": "federated_continual_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_continual_learning.cpp",
        "file_content": "#include <iostream>\n\n#define LARGE_SCALE 1024\n\nvoid federated_continual_learning(float global_model[LARGE_SCALE], float local_models[10][LARGE_SCALE], float updated_global_model[LARGE_SCALE]) {\n    float learning_rate = 0.01;\n    int i, j;\n\n    // Initialize updated global model with the current global model\n    for (i = 0; i < LARGE_SCALE; i++) {\n        updated_global_model[i] = global_model[i];\n    }\n\n    // Aggregate local models into the global model\n    for (i = 0; i < LARGE_SCALE; i++) {\n        for (j = 0; j < 10; j++) {\n            updated_global_model[i] += learning_rate * (local_models[j][i] - global_model[i]);\n        }\n    }\n}\n\n// Top function name: federated_continual_learning\n"
      }
    ],
    "code_length": 700,
    "token_count": 180,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_contrastive_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 425985,
    "Worst-caseLatency": 425985.0,
    "BRAM_18K": 0,
    "LUT": 1001,
    "DSP": 5,
    "FF": 1010,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_contrastive_learning",
    "ResourceMetric": 0.0004273174,
    "design_id": "project",
    "algo_name": "federated_contrastive_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_contrastive_learning.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nvoid federated_contrastive_learning(\n    float local_embeddings[LARGE_SCALE][128], \n    float global_embeddings[LARGE_SCALE][128], \n    float updated_global_embeddings[LARGE_SCALE][128], \n    float learning_rate)\n{\n    int i, j;\n    float diff[128];\n    float norm_diff;\n\n    for (i = 0; i < LARGE_SCALE; i++) {\n        norm_diff = 0.0;\n        for (j = 0; j < 128; j++) {\n            diff[j] = local_embeddings[i][j] - global_embeddings[i][j];\n            norm_diff += diff[j] * diff[j];\n        }\n        norm_diff = sqrt(norm_diff);\n\n        for (j = 0; j < 128; j++) {\n            updated_global_embeddings[i][j] = global_embeddings[i][j] + learning_rate * (diff[j] / norm_diff);\n        }\n    }\n}\n\n// Top function name: federated_contrastive_learning\n"
      }
    ],
    "code_length": 820,
    "token_count": 222,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_deep_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2627163,
    "Worst-caseLatency": 2627163.0,
    "BRAM_18K": 5,
    "LUT": 1046,
    "DSP": 1,
    "FF": 177,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_deep_learning",
    "ResourceMetric": 0.000555281,
    "design_id": "project",
    "algo_name": "federated_deep_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_deep_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n#define FEATURE_SIZE 256\n#define NUM_CLIENTS 10\n\ntypedef ap_int<16> data_t;\n\nvoid federated_deep_learning(data_t global_model[FEATURE_SIZE], data_t client_data[NUM_CLIENTS][DATA_SIZE][FEATURE_SIZE], data_t updated_model[FEATURE_SIZE]) {\n    data_t local_models[NUM_CLIENTS][FEATURE_SIZE];\n    data_t sum_model[FEATURE_SIZE];\n\n    // Initialize sum_model to zero\n    for (int i = 0; i < FEATURE_SIZE; i++) {\n        sum_model[i] = 0;\n    }\n\n    // Local training on each client\n    for (int client = 0; client < NUM_CLIENTS; client++) {\n        for (int i = 0; i < FEATURE_SIZE; i++) {\n            local_models[client][i] = global_model[i];\n        }\n\n        for (int data_idx = 0; data_idx < DATA_SIZE; data_idx++) {\n            for (int feature = 0; feature < FEATURE_SIZE; feature++) {\n                local_models[client][feature] += client_data[client][data_idx][feature];\n            }\n        }\n    }\n\n    // Aggregate local models to update the global model\n    for (int client = 0; client < NUM_CLIENTS; client++) {\n        for (int i = 0; i < FEATURE_SIZE; i++) {\n            sum_model[i] += local_models[client][i];\n        }\n    }\n\n    for (int i = 0; i < FEATURE_SIZE; i++) {\n        updated_model[i] = sum_model[i] / NUM_CLIENTS;\n    }\n}\n\n// Top function name: federated_deep_learning\n"
      }
    ],
    "code_length": 1343,
    "token_count": 356,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_differential_privacy/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1030,
    "Worst-caseLatency": 1030.0,
    "BRAM_18K": 0,
    "LUT": 817,
    "DSP": 3,
    "FF": 632,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_differential_privacy",
    "ResourceMetric": 0.0003003813,
    "design_id": "project",
    "algo_name": "federated_differential_privacy",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_differential_privacy.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n#define EPSILON 1.0\n#define DELTA 1e-5\n#define SENSITIVITY 1.0\n\nvoid federated_differential_privacy(\n    double input[ARRAY_SIZE],\n    double output[ARRAY_SIZE],\n    double noise[ARRAY_SIZE])\n{\n    double scale = SENSITIVITY / EPSILON;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] + noise[i] * scale;\n    }\n}\n\n// Top function name: federated_differential_privacy\n"
      }
    ],
    "code_length": 452,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_edge_computing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5148,
    "Worst-caseLatency": 5148.0,
    "BRAM_18K": 4,
    "LUT": 1035,
    "DSP": 5,
    "FF": 780,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_edge_computing",
    "ResourceMetric": 0.0006598003,
    "design_id": "project",
    "algo_name": "federated_edge_computing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_edge_computing.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_edge_computing(float input_data[DATA_SIZE], float output_data[DATA_SIZE], float model_weights[DATA_SIZE]) {\n    // Local variables\n    float local_update[DATA_SIZE];\n    float aggregated_update[DATA_SIZE];\n\n    // Initialize local update and aggregated update arrays\n    for (int i = 0; i < DATA_SIZE; i++) {\n        local_update[i] = 0.0f;\n        aggregated_update[i] = 0.0f;\n    }\n\n    // Simulate local computation at each edge device\n    for (int i = 0; i < DATA_SIZE; i++) {\n        local_update[i] = input_data[i] * model_weights[i];\n    }\n\n    // Simulate aggregation of updates from multiple edge devices\n    for (int i = 0; i < DATA_SIZE; i++) {\n        aggregated_update[i] += local_update[i];\n    }\n\n    // Apply aggregated update to the model weights\n    for (int i = 0; i < DATA_SIZE; i++) {\n        model_weights[i] += aggregated_update[i];\n    }\n\n    // Output the updated model weights\n    for (int i = 0; i < DATA_SIZE; i++) {\n        output_data[i] = model_weights[i];\n    }\n}\n\n// Top function name: federated_edge_computing\n"
      }
    ],
    "code_length": 1121,
    "token_count": 293,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_ensemble_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 40974,
    "Worst-caseLatency": 40974.0,
    "BRAM_18K": 20,
    "LUT": 1110,
    "DSP": 5,
    "FF": 519,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_ensemble_learning",
    "ResourceMetric": 0.0016412208,
    "design_id": "project",
    "algo_name": "federated_ensemble_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_ensemble_learning.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_ensemble_learning(float input_data[ARRAY_SIZE], float model_weights[10][ARRAY_SIZE], float output_data[10]) {\n    float intermediate_results[10][ARRAY_SIZE];\n    \n    // Initialize intermediate results\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < ARRAY_SIZE; j++) {\n            intermediate_results[i][j] = 0.0;\n        }\n    }\n\n    // Compute intermediate results for each model\n    for (int model = 0; model < 10; model++) {\n        for (int i = 0; i < ARRAY_SIZE; i++) {\n            intermediate_results[model][i] = input_data[i] * model_weights[model][i];\n        }\n    }\n\n    // Aggregate results from all models\n    for (int model = 0; model < 10; model++) {\n        output_data[model] = 0.0;\n        for (int i = 0; i < ARRAY_SIZE; i++) {\n            output_data[model] += intermediate_results[model][i];\n        }\n    }\n}\n\n// Top function name: federated_ensemble_learning\n"
      }
    ],
    "code_length": 960,
    "token_count": 255,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_few_shot_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13347,
    "Worst-caseLatency": 13347.0,
    "BRAM_18K": 2,
    "LUT": 1297,
    "DSP": 7,
    "FF": 1214,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_few_shot_learning",
    "ResourceMetric": 0.0006830555,
    "design_id": "project",
    "algo_name": "federated_few_shot_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_few_shot_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid federated_few_shot_learning(float global_model[LARGE_SCALE], float local_models[10][LARGE_SCALE], float updated_global_model[LARGE_SCALE], float learning_rate) {\n    int i, j;\n    float aggregated_model[LARGE_SCALE] = {0};\n\n    // Aggregate local models\n    for (i = 0; i < 10; i++) {\n        for (j = 0; j < LARGE_SCALE; j++) {\n            aggregated_model[j] += local_models[i][j];\n        }\n    }\n\n    // Average the aggregated model\n    for (j = 0; j < LARGE_SCALE; j++) {\n        aggregated_model[j] /= 10.0;\n    }\n\n    // Update the global model\n    for (j = 0; j < LARGE_SCALE; j++) {\n        updated_global_model[j] = global_model[j] + learning_rate * (aggregated_model[j] - global_model[j]);\n    }\n}\n\n// Top function name: federated_few_shot_learning\n"
      }
    ],
    "code_length": 809,
    "token_count": 220,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_financial_modeling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4194313,
    "Worst-caseLatency": 4194313.0,
    "BRAM_18K": 0,
    "LUT": 1276,
    "DSP": 11,
    "FF": 1185,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_financial_modeling",
    "ResourceMetric": 0.0006630555,
    "design_id": "project",
    "algo_name": "federated_financial_modeling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_financial_modeling.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid federated_financial_modeling(double input_data[N], double weights[N], double bias, double output_data[N]) {\n    for (int i = 0; i < N; i++) {\n        double weighted_sum = 0.0;\n        for (int j = 0; j < N; j++) {\n            weighted_sum += input_data[j] * weights[j];\n        }\n        output_data[i] = weighted_sum + bias;\n    }\n}\n\n// Top function name: federated_financial_modeling\n"
      }
    ],
    "code_length": 426,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_graph_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 67507426,
    "Worst-caseLatency": 67507426.0,
    "BRAM_18K": 160,
    "LUT": 15588,
    "DSP": 62,
    "FF": 13950,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_graph_learning",
    "ResourceMetric": 0.0159650671,
    "design_id": "project",
    "algo_name": "federated_graph_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_graph_learning.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define NODES 1024\n#define FEATURES 64\n#define CLASSES 10\n\nvoid federated_graph_learning(float node_features[NODES][FEATURES], \n                              int adjacency_matrix[NODES][NODES], \n                              float weights[FEATURES][CLASSES], \n                              float output[NODES][CLASSES]) \n{\n    float aggregated_features[NODES][FEATURES];\n    float node_class_scores[NODES][CLASSES];\n\n    // Initialize aggregated features to zero\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < FEATURES; j++) {\n            aggregated_features[i][j] = 0.0f;\n        }\n    }\n\n    // Aggregate features from neighbors\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < NODES; j++) {\n            if (adjacency_matrix[i][j] == 1) {\n                for (int k = 0; k < FEATURES; k++) {\n                    aggregated_features[i][k] += node_features[j][k];\n                }\n            }\n        }\n    }\n\n    // Apply weights to aggregated features to compute class scores\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < CLASSES; j++) {\n            node_class_scores[i][j] = 0.0f;\n            for (int k = 0; k < FEATURES; k++) {\n                node_class_scores[i][j] += aggregated_features[i][k] * weights[k][j];\n            }\n        }\n    }\n\n    // Apply softmax to compute output probabilities\n    for (int i = 0; i < NODES; i++) {\n        float sum_exp = 0.0f;\n        for (int j = 0; j < CLASSES; j++) {\n            node_class_scores[i][j] = exp(node_class_scores[i][j]);\n            sum_exp += node_class_scores[i][j];\n        }\n        for (int j = 0; j < CLASSES; j++) {\n            output[i][j] = node_class_scores[i][j] / sum_exp;\n        }\n    }\n}\n\n// Top function name: federated_graph_learning\n"
      }
    ],
    "code_length": 1809,
    "token_count": 491,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_healthcare_analytics/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3142,
    "Worst-caseLatency": 3142.0,
    "BRAM_18K": 3,
    "LUT": 4564,
    "DSP": 9,
    "FF": 4430,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_healthcare_analytics",
    "ResourceMetric": 0.0017353209,
    "design_id": "project",
    "algo_name": "federated_healthcare_analytics",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_healthcare_analytics.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid federated_healthcare_analytics(ap_int<32> input_data[DATA_SIZE], ap_int<32> output_data[DATA_SIZE]) {\n    ap_int<32> local_data[DATA_SIZE];\n    \n    // Step 1: Data normalization\n    ap_int<32> max_val = input_data[0];\n    ap_int<32> min_val = input_data[0];\n    for (int i = 1; i < DATA_SIZE; i++) {\n        if (input_data[i] > max_val) {\n            max_val = input_data[i];\n        }\n        if (input_data[i] < min_val) {\n            min_val = input_data[i];\n        }\n    }\n    \n    for (int i = 0; i < DATA_SIZE; i++) {\n        local_data[i] = (input_data[i] - min_val) * 100 / (max_val - min_val);\n    }\n    \n    // Step 2: Feature extraction (simple moving average)\n    for (int i = 1; i < DATA_SIZE - 1; i++) {\n        output_data[i] = (local_data[i-1] + local_data[i] + local_data[i+1]) / 3;\n    }\n    \n    // Handle boundary conditions\n    output_data[0] = (local_data[0] + local_data[1]) / 2;\n    output_data[DATA_SIZE - 1] = (local_data[DATA_SIZE - 2] + local_data[DATA_SIZE - 1]) / 2;\n}\n\n// Top function name: federated_healthcare_analytics\n"
      }
    ],
    "code_length": 1105,
    "token_count": 345,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_homomorphic_encryption/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 212,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_homomorphic_encryption",
    "ResourceMetric": 4.30512e-05,
    "design_id": "project",
    "algo_name": "federated_homomorphic_encryption",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_homomorphic_encryption.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_homomorphic_encryption(ap_uint<32> input1[ARRAY_SIZE], ap_uint<32> input2[ARRAY_SIZE], ap_uint<32> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<32> encrypted_value1 = input1[i] ^ 0x5A5A5A5A; // Simple XOR encryption\n        ap_uint<32> encrypted_value2 = input2[i] ^ 0xA5A5A5A5; // Simple XOR encryption\n        ap_uint<32> homomorphic_result = encrypted_value1 + encrypted_value2; // Homomorphic addition\n        output[i] = homomorphic_result ^ 0xFFFFFFFF; // Simple XOR decryption\n    }\n}\n\n// Top function name: federated_homomorphic_encryption\n"
      }
    ],
    "code_length": 645,
    "token_count": 189,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_knowledge_distillation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 253,
    "DSP": 0,
    "FF": 66,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_knowledge_distillation",
    "ResourceMetric": 5.48447e-05,
    "design_id": "project",
    "algo_name": "federated_knowledge_distillation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_knowledge_distillation.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nvoid federated_knowledge_distillation(\n    ap_uint<8> client_data[LARGE_SCALE][LARGE_SCALE],\n    ap_uint<8> server_data[LARGE_SCALE][LARGE_SCALE],\n    ap_uint<8> distilled_data[LARGE_SCALE][LARGE_SCALE])\n{\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            ap_uint<8> client_value = client_data[i][j];\n            ap_uint<8> server_value = server_data[i][j];\n            distilled_data[i][j] = (client_value + server_value) / 2;\n        }\n    }\n}\n\n// Top function name: federated_knowledge_distillation\n"
      }
    ],
    "code_length": 603,
    "token_count": 170,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_knowledge_graph_embedding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 262164,
    "Worst-caseLatency": 262164.0,
    "BRAM_18K": 0,
    "LUT": 1413,
    "DSP": 6,
    "FF": 1390,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_knowledge_graph_embedding",
    "ResourceMetric": 0.0005704637,
    "design_id": "project",
    "algo_name": "federated_knowledge_graph_embedding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_knowledge_graph_embedding.cpp",
        "file_content": "#include <cmath>\n\n#define NUM_ENTITIES 1024\n#define NUM_RELATIONS 256\n#define EMBEDDING_DIM 128\n\nvoid federated_knowledge_graph_embedding(\n    float entity_embeddings[NUM_ENTITIES][EMBEDDING_DIM],\n    float relation_embeddings[NUM_RELATIONS][EMBEDDING_DIM],\n    int triplets[NUM_ENTITIES][3],\n    float output_embeddings[NUM_ENTITIES][EMBEDDING_DIM])\n{\n    for (int i = 0; i < NUM_ENTITIES; i++) {\n        int head = triplets[i][0];\n        int relation = triplets[i][1];\n        int tail = triplets[i][2];\n\n        for (int j = 0; j < EMBEDDING_DIM; j++) {\n            float head_embedding = entity_embeddings[head][j];\n            float relation_embedding = relation_embeddings[relation][j];\n            float tail_embedding = entity_embeddings[tail][j];\n\n            output_embeddings[head][j] += head_embedding + relation_embedding - tail_embedding;\n            output_embeddings[tail][j] += tail_embedding + relation_embedding - head_embedding;\n        }\n    }\n}\n\n// Top function name: federated_knowledge_graph_embedding\n"
      }
    ],
    "code_length": 1027,
    "token_count": 246,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 525844,
    "Worst-caseLatency": 525844.0,
    "BRAM_18K": 1,
    "LUT": 917,
    "DSP": 5,
    "FF": 609,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_learning",
    "ResourceMetric": 0.0004347642,
    "design_id": "project",
    "algo_name": "federated_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_learning.cpp",
        "file_content": "#include <iostream>\n\n#define NUM_CLIENTS 1024\n#define FEATURE_SIZE 512\n\nvoid federated_learning(float global_model[FEATURE_SIZE], float client_models[NUM_CLIENTS][FEATURE_SIZE], float updated_global_model[FEATURE_SIZE]) {\n    float sum_model[FEATURE_SIZE] = {0};\n\n    // Aggregate client models\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        for (int j = 0; j < FEATURE_SIZE; j++) {\n            sum_model[j] += client_models[i][j];\n        }\n    }\n\n    // Average the aggregated model\n    for (int j = 0; j < FEATURE_SIZE; j++) {\n        updated_global_model[j] = sum_model[j] / NUM_CLIENTS;\n    }\n\n    // Update global model\n    for (int j = 0; j < FEATURE_SIZE; j++) {\n        global_model[j] = updated_global_model[j];\n    }\n}\n\n// Top function name: federated_learning\n"
      }
    ],
    "code_length": 777,
    "token_count": 205,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_lifelong_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2098195,
    "Worst-caseLatency": 2098195.0,
    "BRAM_18K": 0,
    "LUT": 979,
    "DSP": 5,
    "FF": 922,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_lifelong_learning",
    "ResourceMetric": 0.0004146609,
    "design_id": "project",
    "algo_name": "federated_lifelong_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_lifelong_learning.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_lifelong_learning(float global_model[ARRAY_SIZE], float local_models[ARRAY_SIZE][ARRAY_SIZE], float updated_global_model[ARRAY_SIZE]) {\n    float learning_rate = 0.01;\n    int num_clients = ARRAY_SIZE;\n\n    // Initialize updated global model\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        updated_global_model[i] = global_model[i];\n    }\n\n    // Aggregate local models\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        for (int j = 0; j < ARRAY_SIZE; j++) {\n            updated_global_model[i] += learning_rate * (local_models[j][i] - global_model[i]) / num_clients;\n        }\n    }\n}\n\n// Top function name: federated_lifelong_learning\n"
      }
    ],
    "code_length": 719,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_model_compression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 239,
    "DSP": 0,
    "FF": 258,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_model_compression",
    "ResourceMetric": 7.05695e-05,
    "design_id": "project",
    "algo_name": "federated_model_compression",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_model_compression.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_model_compression(float input_model[ARRAY_SIZE], float compressed_model[ARRAY_SIZE], float threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (std::abs(input_model[i]) < threshold) {\n            compressed_model[i] = 0.0f;\n        } else {\n            compressed_model[i] = input_model[i];\n        }\n    }\n}\n\n// Top function name: federated_model_compression\n"
      }
    ],
    "code_length": 452,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_multi_modal_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1047,
    "Worst-caseLatency": 1047.0,
    "BRAM_18K": 0,
    "LUT": 1708,
    "DSP": 19,
    "FF": 1314,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_multi_modal_learning",
    "ResourceMetric": 0.000979898,
    "design_id": "project",
    "algo_name": "federated_multi_modal_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_multi_modal_learning.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_multi_modal_learning(\n    float input1[DATA_SIZE], \n    float input2[DATA_SIZE], \n    float output[DATA_SIZE], \n    float weights1[DATA_SIZE], \n    float weights2[DATA_SIZE], \n    float bias[DATA_SIZE])\n{\n    for (int i = 0; i < DATA_SIZE; i++) {\n        float weighted_sum1 = input1[i] * weights1[i];\n        float weighted_sum2 = input2[i] * weights2[i];\n        float combined_sum = weighted_sum1 + weighted_sum2 + bias[i];\n        output[i] = 1.0f / (1.0f + expf(-combined_sum)); // Sigmoid activation\n    }\n}\n\n// Top function name: federated_multi_modal_learning\n"
      }
    ],
    "code_length": 625,
    "token_count": 175,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_multi_view_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2099220,
    "Worst-caseLatency": 2099220.0,
    "BRAM_18K": 4,
    "LUT": 1880,
    "DSP": 10,
    "FF": 1616,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_multi_view_learning",
    "ResourceMetric": 0.0010405188,
    "design_id": "project",
    "algo_name": "federated_multi_view_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_multi_view_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid federated_multi_view_learning(\n    float data_view1[LARGE_SCALE][LARGE_SCALE],\n    float data_view2[LARGE_SCALE][LARGE_SCALE],\n    float weights_view1[LARGE_SCALE],\n    float weights_view2[LARGE_SCALE],\n    float output[LARGE_SCALE])\n{\n    float intermediate1[LARGE_SCALE] = {0};\n    float intermediate2[LARGE_SCALE] = {0};\n\n    // Aggregating data from view 1\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            intermediate1[i] += data_view1[i][j] * weights_view1[j];\n        }\n    }\n\n    // Aggregating data from view 2\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            intermediate2[i] += data_view2[i][j] * weights_view2[j];\n        }\n    }\n\n    // Combining the results from both views\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        output[i] = (intermediate1[i] + intermediate2[i]) / 2.0f;\n    }\n}\n\n// Top function name: federated_multi_view_learning\n"
      }
    ],
    "code_length": 1018,
    "token_count": 294,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_neural_architecture_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048579,
    "Worst-caseLatency": 1048579.0,
    "BRAM_18K": 0,
    "LUT": 361,
    "DSP": 3,
    "FF": 158,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_neural_architecture_search",
    "ResourceMetric": 0.0001674882,
    "design_id": "project",
    "algo_name": "federated_neural_architecture_search",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_neural_architecture_search.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nvoid federated_neural_architecture_search(\n    ap_uint<32> input_data[LARGE_SCALE],\n    ap_uint<32> output_data[LARGE_SCALE],\n    ap_uint<32> weights[LARGE_SCALE],\n    ap_uint<32> biases[LARGE_SCALE])\n{\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        ap_uint<32> sum = 0;\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            sum += input_data[j] * weights[j];\n        }\n        output_data[i] = sum + biases[i];\n    }\n}\n\n// Top function name: federated_neural_architecture_search\n"
      }
    ],
    "code_length": 538,
    "token_count": 154,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_privacy_preserving_data_analytics/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1055,
    "Worst-caseLatency": 1055.0,
    "BRAM_18K": 0,
    "LUT": 2938,
    "DSP": 34,
    "FF": 1872,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_privacy_preserving_data_analytics",
    "ResourceMetric": 0.0016848297,
    "design_id": "project",
    "algo_name": "federated_privacy_preserving_data_analytics",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_privacy_preserving_data_analytics.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_privacy_preserving_data_analytics(\n    float input_data[DATA_SIZE], \n    float weights[DATA_SIZE], \n    float biases[DATA_SIZE], \n    float output_data[DATA_SIZE])\n{\n    for (int i = 0; i < DATA_SIZE; i++) {\n        float weighted_sum = input_data[i] * weights[i] + biases[i];\n        output_data[i] = 1.0f / (1.0f + exp(-weighted_sum)); // Sigmoid activation function\n    }\n}\n\n// Top function name: federated_privacy_preserving_data_analytics\n"
      }
    ],
    "code_length": 501,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_privacy_preserving_data_sharing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_privacy_preserving_data_sharing",
    "ResourceMetric": 2.63677e-05,
    "design_id": "project",
    "algo_name": "federated_privacy_preserving_data_sharing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_privacy_preserving_data_sharing.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid federated_privacy_preserving_data_sharing(ap_uint<32> data_in[DATA_SIZE], ap_uint<32> data_out[DATA_SIZE], ap_uint<32> key) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        // Simple XOR encryption for privacy-preserving\n        data_out[i] = data_in[i] ^ key;\n    }\n}\n\n// Top function name: federated_privacy_preserving_data_sharing\n"
      }
    ],
    "code_length": 387,
    "token_count": 111,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_reinforcement_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 0,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_reinforcement_learning",
    "ResourceMetric": 0.0,
    "design_id": "project",
    "algo_name": "federated_reinforcement_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_reinforcement_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_AGENTS 1024\n#define STATE_SIZE 128\n#define ACTION_SIZE 64\n\nvoid federated_reinforcement_learning(\n    ap_uint<32> state[NUM_AGENTS][STATE_SIZE],\n    ap_uint<32> action[NUM_AGENTS][ACTION_SIZE],\n    ap_uint<32> reward[NUM_AGENTS],\n    ap_uint<32> next_state[NUM_AGENTS][STATE_SIZE],\n    ap_uint<32> q_table[STATE_SIZE][ACTION_SIZE]\n) {\n    ap_uint<32> learning_rate = 0.1;\n    ap_uint<32> discount_factor = 0.9;\n\n    for (int agent = 0; agent < NUM_AGENTS; agent++) {\n        for (int s = 0; s < STATE_SIZE; s++) {\n            for (int a = 0; a < ACTION_SIZE; a++) {\n                ap_uint<32> max_q_next = 0;\n                for (int next_a = 0; next_a < ACTION_SIZE; next_a++) {\n                    if (q_table[next_state[agent][s]][next_a] > max_q_next) {\n                        max_q_next = q_table[next_state[agent][s]][next_a];\n                    }\n                }\n                q_table[state[agent][s]][a] = q_table[state[agent][s]][a] + learning_rate * (reward[agent] + discount_factor * max_q_next - q_table[state[agent][s]][a]);\n            }\n        }\n    }\n}\n\n// Top function name: federated_reinforcement_learning\n"
      }
    ],
    "code_length": 1166,
    "token_count": 328,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_aggregation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 262407,
    "Worst-caseLatency": 262407.0,
    "BRAM_18K": 0,
    "LUT": 395,
    "DSP": 0,
    "FF": 68,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_aggregation",
    "ResourceMetric": 8.22671e-05,
    "design_id": "project",
    "algo_name": "federated_secure_aggregation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_aggregation.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_CLIENTS 1024\n#define DATA_SIZE 256\n\nvoid federated_secure_aggregation(ap_uint<32> client_data[NUM_CLIENTS][DATA_SIZE], ap_uint<32> aggregated_data[DATA_SIZE]) {\n    // Initialize the aggregated data array to zero\n    for (int i = 0; i < DATA_SIZE; i++) {\n        aggregated_data[i] = 0;\n    }\n\n    // Aggregate data from each client\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        for (int j = 0; j < DATA_SIZE; j++) {\n            aggregated_data[j] += client_data[i][j];\n        }\n    }\n}\n\n// Top function name: federated_secure_aggregation\n"
      }
    ],
    "code_length": 579,
    "token_count": 161,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_data_sharing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4111,
    "Worst-caseLatency": 4111.0,
    "BRAM_18K": 4,
    "LUT": 555,
    "DSP": 0,
    "FF": 112,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_data_sharing",
    "ResourceMetric": 0.0003651842,
    "design_id": "project",
    "algo_name": "federated_secure_data_sharing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_data_sharing.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_secure_data_sharing(ap_uint<32> input_data[ARRAY_SIZE], ap_uint<32> output_data[ARRAY_SIZE], ap_uint<32> key) {\n    ap_uint<32> encrypted_data[ARRAY_SIZE];\n    ap_uint<32> decrypted_data[ARRAY_SIZE];\n\n    // Encryption phase\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        encrypted_data[i] = input_data[i] ^ key; // Simple XOR encryption\n    }\n\n    // Simulate data sharing (in a real scenario, this would involve network communication)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = encrypted_data[i];\n    }\n\n    // Decryption phase\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        decrypted_data[i] = output_data[i] ^ key; // Simple XOR decryption\n    }\n\n    // Output the decrypted data\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = decrypted_data[i];\n    }\n}\n\n// Top function name: federated_secure_data_sharing\n"
      }
    ],
    "code_length": 926,
    "token_count": 255,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_gradient_aggregation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 131339,
    "Worst-caseLatency": 131339.0,
    "BRAM_18K": 0,
    "LUT": 602,
    "DSP": 0,
    "FF": 85,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_gradient_aggregation",
    "ResourceMetric": 0.0001235924,
    "design_id": "project",
    "algo_name": "federated_secure_gradient_aggregation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_gradient_aggregation.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_CLIENTS 1024\n#define VECTOR_SIZE 128\n\nvoid federated_secure_gradient_aggregation(\n    ap_int<32> gradients[NUM_CLIENTS][VECTOR_SIZE],\n    ap_int<32> aggregated_gradient[VECTOR_SIZE])\n{\n    for (int i = 0; i < VECTOR_SIZE; i++) {\n        aggregated_gradient[i] = 0;\n    }\n\n    for (int client = 0; client < NUM_CLIENTS; client++) {\n        for (int i = 0; i < VECTOR_SIZE; i++) {\n            aggregated_gradient[i] += gradients[client][i];\n        }\n    }\n\n    for (int i = 0; i < VECTOR_SIZE; i++) {\n        aggregated_gradient[i] /= NUM_CLIENTS;\n    }\n}\n\n// Top function name: federated_secure_gradient_aggregation\n"
      }
    ],
    "code_length": 649,
    "token_count": 176,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_model_aggregation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 524815,
    "Worst-caseLatency": 524815.0,
    "BRAM_18K": 1,
    "LUT": 918,
    "DSP": 5,
    "FF": 726,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_model_aggregation",
    "ResourceMetric": 0.0004461742,
    "design_id": "project",
    "algo_name": "federated_secure_model_aggregation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_model_aggregation.cpp",
        "file_content": "#include <iostream>\n\n#define NUM_CLIENTS 1024\n#define MODEL_SIZE 256\n\nvoid federated_secure_model_aggregation(float global_model[MODEL_SIZE], float client_models[NUM_CLIENTS][MODEL_SIZE]) {\n    float aggregated_model[MODEL_SIZE] = {0};\n\n    for (int i = 0; i < MODEL_SIZE; i++) {\n        for (int j = 0; j < NUM_CLIENTS; j++) {\n            aggregated_model[i] += client_models[j][i];\n        }\n        aggregated_model[i] /= NUM_CLIENTS;\n    }\n\n    for (int i = 0; i < MODEL_SIZE; i++) {\n        global_model[i] = aggregated_model[i];\n    }\n}\n\n// Top function name: federated_secure_model_aggregation\n"
      }
    ],
    "code_length": 601,
    "token_count": 158,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_model_inference/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 346,
    "DSP": 3,
    "FF": 90,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_model_inference",
    "ResourceMetric": 0.0001580918,
    "design_id": "project",
    "algo_name": "federated_secure_model_inference",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_model_inference.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid federated_secure_model_inference(ap_uint<32> input_data[ARRAY_SIZE], ap_uint<32> model_weights[ARRAY_SIZE], ap_uint<32> output_data[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<32> result = 0;\n        for (int j = 0; j < ARRAY_SIZE; j++) {\n            result += input_data[j] * model_weights[(i + j) % ARRAY_SIZE];\n        }\n        output_data[i] = result;\n    }\n}\n\n// Top function name: federated_secure_model_inference\n"
      }
    ],
    "code_length": 502,
    "token_count": 143,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_model_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2099220,
    "Worst-caseLatency": 2099220.0,
    "BRAM_18K": 2,
    "LUT": 1094,
    "DSP": 5,
    "FF": 909,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_model_training",
    "ResourceMetric": 0.0005594753,
    "design_id": "project",
    "algo_name": "federated_secure_model_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_model_training.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_secure_model_training(float data[DATA_SIZE][DATA_SIZE], float model[DATA_SIZE], float updated_model[DATA_SIZE], float learning_rate) {\n    float gradient[DATA_SIZE];\n    \n    // Initialize gradient to zero\n    for (int i = 0; i < DATA_SIZE; i++) {\n        gradient[i] = 0.0f;\n    }\n\n    // Compute gradient\n    for (int i = 0; i < DATA_SIZE; i++) {\n        for (int j = 0; j < DATA_SIZE; j++) {\n            gradient[i] += data[i][j] * model[j];\n        }\n    }\n\n    // Update model\n    for (int i = 0; i < DATA_SIZE; i++) {\n        updated_model[i] = model[i] - learning_rate * gradient[i];\n    }\n}\n\n// Top function name: federated_secure_model_training\n"
      }
    ],
    "code_length": 711,
    "token_count": 198,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_secure_mpc/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_secure_mpc",
    "ResourceMetric": 2.32994e-05,
    "design_id": "project",
    "algo_name": "federated_secure_mpc",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_secure_mpc.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid federated_secure_mpc(ap_uint<32> input1[SIZE], ap_uint<32> input2[SIZE], ap_uint<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<32> temp1 = input1[i];\n        ap_uint<32> temp2 = input2[i];\n        ap_uint<32> result = temp1 ^ temp2; // Simple XOR operation for secure computation\n        output[i] = result;\n    }\n}\n\n// Top function name: federated_secure_mpc\n"
      }
    ],
    "code_length": 432,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_self_supervised_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4126,
    "Worst-caseLatency": 4126.0,
    "BRAM_18K": 6,
    "LUT": 1466,
    "DSP": 10,
    "FF": 1412,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_self_supervised_learning",
    "ResourceMetric": 0.0010655761,
    "design_id": "project",
    "algo_name": "federated_self_supervised_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_self_supervised_learning.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_self_supervised_learning(float input_data[DATA_SIZE], float output_data[DATA_SIZE], float weights[DATA_SIZE], float biases[DATA_SIZE], float learning_rate) {\n    // Initialize variables\n    float gradients[DATA_SIZE];\n    float predictions[DATA_SIZE];\n    float errors[DATA_SIZE];\n\n    // Forward pass: Compute predictions\n    for (int i = 0; i < DATA_SIZE; i++) {\n        predictions[i] = input_data[i] * weights[i] + biases[i];\n    }\n\n    // Compute errors\n    for (int i = 0; i < DATA_SIZE; i++) {\n        errors[i] = predictions[i] - output_data[i];\n    }\n\n    // Compute gradients\n    for (int i = 0; i < DATA_SIZE; i++) {\n        gradients[i] = errors[i] * input_data[i];\n    }\n\n    // Update weights and biases\n    for (int i = 0; i < DATA_SIZE; i++) {\n        weights[i] -= learning_rate * gradients[i];\n        biases[i] -= learning_rate * errors[i];\n    }\n}\n\n// Top function name: federated_self_supervised_learning\n"
      }
    ],
    "code_length": 983,
    "token_count": 254,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_semi_supervised_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4294969386,
    "Worst-caseLatency": 4294969386.0,
    "BRAM_18K": 2,
    "LUT": 2507,
    "DSP": 7,
    "FF": 1966,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_semi_supervised_learning",
    "ResourceMetric": 0.0009871946,
    "design_id": "project",
    "algo_name": "federated_semi_supervised_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_semi_supervised_learning.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_semi_supervised_learning(\n    float labeled_data[DATA_SIZE][DATA_SIZE], \n    float unlabeled_data[DATA_SIZE][DATA_SIZE], \n    float model_weights[DATA_SIZE], \n    float updated_weights[DATA_SIZE], \n    float learning_rate)\n{\n    float gradients[DATA_SIZE] = {0};\n\n    // Compute gradients from labeled data\n    for (int i = 0; i < DATA_SIZE; i++) {\n        for (int j = 0; j < DATA_SIZE; j++) {\n            float prediction = 0;\n            for (int k = 0; k < DATA_SIZE; k++) {\n                prediction += labeled_data[i][k] * model_weights[k];\n            }\n            float error = prediction - labeled_data[i][j];\n            gradients[j] += error * labeled_data[i][j];\n        }\n    }\n\n    // Compute gradients from unlabeled data\n    for (int i = 0; i < DATA_SIZE; i++) {\n        for (int j = 0; j < DATA_SIZE; j++) {\n            float prediction = 0;\n            for (int k = 0; k < DATA_SIZE; k++) {\n                prediction += unlabeled_data[i][k] * model_weights[k];\n            }\n            gradients[j] += prediction * unlabeled_data[i][j];\n        }\n    }\n\n    // Update model weights\n    for (int i = 0; i < DATA_SIZE; i++) {\n        updated_weights[i] = model_weights[i] - learning_rate * gradients[i];\n    }\n}\n\n// Top function name: federated_semi_supervised_learning\n"
      }
    ],
    "code_length": 1347,
    "token_count": 349,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_sgd/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 316725728,
    "Worst-caseLatency": 316725728.0,
    "BRAM_18K": 2,
    "LUT": 1373,
    "DSP": 8,
    "FF": 1094,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_sgd",
    "ResourceMetric": 0.0007138277,
    "design_id": "project",
    "algo_name": "federated_sgd",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_sgd.cpp",
        "file_content": "#include <cmath>\n\n#define NUM_FEATURES 1024\n#define NUM_SAMPLES 1024\n#define NUM_ITERATIONS 100\n\nvoid federated_sgd(float data[NUM_SAMPLES][NUM_FEATURES], float labels[NUM_SAMPLES], float weights[NUM_FEATURES], float learning_rate) {\n    float gradient[NUM_FEATURES] = {0};\n\n    for (int iter = 0; iter < NUM_ITERATIONS; iter++) {\n        // Initialize gradient to zero\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            gradient[j] = 0;\n        }\n\n        // Compute gradient\n        for (int i = 0; i < NUM_SAMPLES; i++) {\n            float prediction = 0;\n            for (int j = 0; j < NUM_FEATURES; j++) {\n                prediction += data[i][j] * weights[j];\n            }\n            float error = prediction - labels[i];\n            for (int j = 0; j < NUM_FEATURES; j++) {\n                gradient[j] += data[i][j] * error;\n            }\n        }\n\n        // Update weights\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            weights[j] -= learning_rate * gradient[j] / NUM_SAMPLES;\n        }\n    }\n}\n\n// Top function name: federated_sgd\n"
      }
    ],
    "code_length": 1069,
    "token_count": 278,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_transfer_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2099224,
    "Worst-caseLatency": 2099224.0,
    "BRAM_18K": 2,
    "LUT": 1324,
    "DSP": 7,
    "FF": 1221,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_transfer_learning",
    "ResourceMetric": 0.0006889043,
    "design_id": "project",
    "algo_name": "federated_transfer_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_transfer_learning.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_transfer_learning(float global_model[DATA_SIZE], float local_models[DATA_SIZE][DATA_SIZE], float updated_global_model[DATA_SIZE]) {\n    float learning_rate = 0.01;\n    float aggregated_model[DATA_SIZE] = {0};\n\n    // Aggregate local models\n    for (int i = 0; i < DATA_SIZE; i++) {\n        for (int j = 0; j < DATA_SIZE; j++) {\n            aggregated_model[i] += local_models[j][i];\n        }\n        aggregated_model[i] /= DATA_SIZE;\n    }\n\n    // Update global model\n    for (int i = 0; i < DATA_SIZE; i++) {\n        updated_global_model[i] = global_model[i] + learning_rate * (aggregated_model[i] - global_model[i]);\n    }\n}\n\n// Top function name: federated_transfer_learning\n"
      }
    ],
    "code_length": 736,
    "token_count": 191,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_unsupervised_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2100252,
    "Worst-caseLatency": 2100252.0,
    "BRAM_18K": 2,
    "LUT": 1258,
    "DSP": 5,
    "FF": 1099,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_unsupervised_learning",
    "ResourceMetric": 0.0006091424,
    "design_id": "project",
    "algo_name": "federated_unsupervised_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_unsupervised_learning.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid federated_unsupervised_learning(float input_data[DATA_SIZE], float output_data[DATA_SIZE], float weights[DATA_SIZE], float learning_rate) {\n    int i, j;\n    float gradient[DATA_SIZE];\n\n    // Initialize gradient to zero\n    for (i = 0; i < DATA_SIZE; i++) {\n        gradient[i] = 0.0f;\n    }\n\n    // Compute gradient\n    for (i = 0; i < DATA_SIZE; i++) {\n        for (j = 0; j < DATA_SIZE; j++) {\n            gradient[i] += (input_data[j] - weights[i]) * (input_data[j] - weights[i]);\n        }\n    }\n\n    // Update weights\n    for (i = 0; i < DATA_SIZE; i++) {\n        weights[i] -= learning_rate * gradient[i];\n    }\n\n    // Generate output data\n    for (i = 0; i < DATA_SIZE; i++) {\n        output_data[i] = weights[i];\n    }\n}\n\n// Top function name: federated_unsupervised_learning\n"
      }
    ],
    "code_length": 834,
    "token_count": 237,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_unsupervised_representation_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2149580815,
    "Worst-caseLatency": 2149580815.0,
    "BRAM_18K": 0,
    "LUT": 1692,
    "DSP": 5,
    "FF": 890,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_unsupervised_representation_learning",
    "ResourceMetric": 0.000548321,
    "design_id": "project",
    "algo_name": "federated_unsupervised_representation_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_unsupervised_representation_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid federated_unsupervised_representation_learning(\n    float input_data[LARGE_SCALE][LARGE_SCALE],\n    float output_data[LARGE_SCALE][LARGE_SCALE],\n    float weights[LARGE_SCALE][LARGE_SCALE],\n    float biases[LARGE_SCALE])\n{\n    // Initialize output_data with biases\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            output_data[i][j] = biases[j];\n        }\n    }\n\n    // Perform matrix multiplication and add biases\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            for (int k = 0; k < LARGE_SCALE; k++) {\n                output_data[i][j] += input_data[i][k] * weights[k][j];\n            }\n        }\n    }\n\n    // Apply activation function (ReLU)\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            output_data[i][j] = fmaxf(0, output_data[i][j]);\n        }\n    }\n}\n\n// Top function name: federated_unsupervised_representation_learning\n"
      }
    ],
    "code_length": 1045,
    "token_count": 286,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/federated_zero_shot_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2132993,
    "Worst-caseLatency": 2132993.0,
    "BRAM_18K": 0,
    "LUT": 3176,
    "DSP": 34,
    "FF": 1799,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "federated_zero_shot_learning",
    "ResourceMetric": 0.0017234703,
    "design_id": "project",
    "algo_name": "federated_zero_shot_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "federated_zero_shot_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid federated_zero_shot_learning(float input_data[LARGE_SCALE], float output_data[LARGE_SCALE], float weights[LARGE_SCALE], float bias) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        float activation = 0.0;\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            activation += input_data[j] * weights[j];\n        }\n        activation += bias;\n        output_data[i] = 1.0 / (1.0 + exp(-activation)); // Sigmoid activation function\n    }\n}\n\n// Top function name: federated_zero_shot_learning\n"
      }
    ],
    "code_length": 547,
    "token_count": 142,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/feed_forward_network/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1321474,
    "Worst-caseLatency": 1346818.0,
    "BRAM_18K": 6,
    "LUT": 5645,
    "DSP": 40,
    "FF": 3001,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "feed_forward_network",
    "ResourceMetric": 0.0028504356,
    "design_id": "project",
    "algo_name": "feed_forward_network",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "feed_forward_network.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 256\n\nvoid feed_forward_network(\n    float input[INPUT_SIZE], \n    float weights1[HIDDEN_SIZE][INPUT_SIZE], \n    float bias1[HIDDEN_SIZE], \n    float weights2[OUTPUT_SIZE][HIDDEN_SIZE], \n    float bias2[OUTPUT_SIZE], \n    float output[OUTPUT_SIZE]\n) {\n    float hidden_layer[HIDDEN_SIZE];\n\n    // Compute hidden layer activations\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        hidden_layer[i] = bias1[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            hidden_layer[i] += input[j] * weights1[i][j];\n        }\n        hidden_layer[i] = tanh(hidden_layer[i]); // Activation function\n    }\n\n    // Compute output layer activations\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output[i] = bias2[i];\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            output[i] += hidden_layer[j] * weights2[i][j];\n        }\n        output[i] = tanh(output[i]); // Activation function\n    }\n}\n\n// Top function name: feed_forward_network\n"
      }
    ],
    "code_length": 1032,
    "token_count": 280,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/few_shot_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2149580815,
    "Worst-caseLatency": 2149580815.0,
    "BRAM_18K": 0,
    "LUT": 1674,
    "DSP": 5,
    "FF": 878,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "few_shot_learning",
    "ResourceMetric": 0.0005437186,
    "design_id": "project",
    "algo_name": "few_shot_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "few_shot_learning.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define N 1024\n\nvoid few_shot_learning(float input[N][N], float weights[N][N], float output[N][N]) {\n    // Initialize output to zero\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            output[i][j] = 0.0f;\n        }\n    }\n\n    // Compute weighted sum\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                output[i][j] += input[i][k] * weights[k][j];\n            }\n        }\n    }\n\n    // Apply non-linear activation function (ReLU)\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            output[i][j] = fmaxf(0.0f, output[i][j]);\n        }\n    }\n}\n// Top function name: few_shot_learning\n"
      }
    ],
    "code_length": 762,
    "token_count": 248,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/fft_8_point/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2619,
    "Worst-caseLatency": 2619.0,
    "BRAM_18K": 4,
    "LUT": 20550,
    "DSP": 254,
    "FF": 14392,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fft_8_point",
    "ResourceMetric": 0.0126055142,
    "design_id": "project",
    "algo_name": "fft_8_point",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "fft_8_point.cpp",
        "file_content": "#include <cmath>\n#include <complex>\n\n#define N 1024\n\ntypedef std::complex<float> Complex;\n\nvoid fft_8_point(Complex input[N], Complex output[N]) {\n    const float PI = 3.14159265358979323846;\n    Complex W[N];\n    for (int i = 0; i < N; i++) {\n        float theta = -2 * PI * i / N;\n        W[i] = Complex(cos(theta), sin(theta));\n    }\n\n    for (int i = 0; i < N; i += 8) {\n        Complex temp[8];\n        for (int j = 0; j < 8; j++) {\n            temp[j] = input[i + j];\n        }\n\n        Complex stage1[8];\n        for (int j = 0; j < 4; j++) {\n            stage1[j] = temp[j] + temp[j + 4];\n            stage1[j + 4] = (temp[j] - temp[j + 4]) * W[j * N / 8];\n        }\n\n        Complex stage2[8];\n        for (int j = 0; j < 2; j++) {\n            stage2[j] = stage1[j] + stage1[j + 2];\n            stage2[j + 2] = (stage1[j] - stage1[j + 2]) * W[j * N / 4];\n            stage2[j + 4] = stage1[j + 4] + stage1[j + 6];\n            stage2[j + 6] = (stage1[j + 4] - stage1[j + 6]) * W[j * N / 4];\n        }\n\n        for (int j = 0; j < 8; j += 4) {\n            output[i + j] = stage2[j] + stage2[j + 1];\n            output[i + j + 1] = (stage2[j] - stage2[j + 1]) * W[j * N / 8];\n            output[i + j + 2] = stage2[j + 2] + stage2[j + 3];\n            output[i + j + 3] = (stage2[j + 2] - stage2[j + 3]) * W[j * N / 8];\n        }\n    }\n}\n\n// Top function name: fft_8_point\n"
      }
    ],
    "code_length": 1378,
    "token_count": 505,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/fft_strided/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 41,
    "Worst-caseLatency": 163881.0,
    "BRAM_18K": 0,
    "LUT": 2379,
    "DSP": 38,
    "FF": 3015,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fft",
    "ResourceMetric": 0.0017980423,
    "design_id": "project",
    "algo_name": "fft_strided",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "fft.h",
        "file_content": "#include <stdio.h>\n#include <stdlib.h>\n#include \"support.h\"\n\n#define FFT_SIZE 1024\n#define twoPI 6.28318530717959\n\nvoid fft(double real[FFT_SIZE], double img[FFT_SIZE], double real_twid[FFT_SIZE/2], double img_twid[FFT_SIZE/2]);\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n        double real[FFT_SIZE];\n        double img[FFT_SIZE];\n        double real_twid[FFT_SIZE/2];\n        double img_twid[FFT_SIZE/2];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "fft.c",
        "file_content": "#include \"fft.h\"\n\nvoid fft(double real[FFT_SIZE], double img[FFT_SIZE], double real_twid[FFT_SIZE/2], double img_twid[FFT_SIZE/2]){\n    int even, odd, span, log, rootindex;\n    double temp;\n    log = 0;\n\n    outer:for(span=FFT_SIZE>>1; span; span>>=1, log++){\n        #pragma HLS loop_tripcount min=10 max=10\n        inner:for(odd=span; odd<FFT_SIZE; odd++){\n            #pragma HLS loop_tripcount min=0 max=FFT_SIZE\n            odd |= span;\n            even = odd ^ span;\n\n            temp = real[even] + real[odd];\n            real[odd] = real[even] - real[odd];\n            real[even] = temp;\n\n            temp = img[even] + img[odd];\n            img[odd] = img[even] - img[odd];\n            img[even] = temp;\n\n            rootindex = (even<<log) & (FFT_SIZE - 1);\n            if(rootindex){\n                temp = real_twid[rootindex] * real[odd] -\n                    img_twid[rootindex]  * img[odd];\n                img[odd] = real_twid[rootindex]*img[odd] +\n                    img_twid[rootindex]*real[odd];\n                real[odd] = temp;\n            }\n        }\n    }\n}\n"
      }
    ],
    "code_length": 1082,
    "token_count": 302,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/fft_transpose/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16211,
    "Worst-caseLatency": 16211.0,
    "BRAM_18K": 16,
    "LUT": 47839,
    "DSP": 241,
    "FF": 32822,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fft1D_512",
    "ResourceMetric": 0.0199895952,
    "design_id": "project",
    "algo_name": "fft_transpose",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "fft.h",
        "file_content": "/*\nImplementations based on:\nV. Volkov and B. Kazian. Fitting fft onto the g80 architecture. 2008.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"support.h\"\n\n#define TYPE double\n\ntypedef struct complex_t {\n        TYPE x;\n        TYPE y;\n} complex;\n\n#define PI 3.1415926535\n#ifndef M_SQRT1_2\n#define M_SQRT1_2      0.70710678118654752440f\n#endif\nvoid fft1D_512(TYPE work_x[512], TYPE work_y[512]);\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n        TYPE work_x[512];\n        TYPE work_y[512];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "fft.c",
        "file_content": "/*\nImplementations based on:\nV. Volkov and B. Kazian. Fitting fft onto the g80 architecture. 2008.\n*/\n\n#include \"fft.h\"\n\n//////BEGIN TWIDDLES ////////\n#define THREADS 64\n#define cmplx_M_x(a_x, a_y, b_x, b_y) (a_x*b_x - a_y *b_y)\n#define cmplx_M_y(a_x, a_y, b_x, b_y) (a_x*b_y + a_y *b_x)\n#define cmplx_MUL_x(a_x, a_y, b_x, b_y ) (a_x*b_x - a_y*b_y)\n#define cmplx_MUL_y(a_x, a_y, b_x, b_y ) (a_x*b_y + a_y*b_x)\n#define cmplx_mul_x(a_x, a_y, b_x, b_y) (a_x*b_x - a_y*b_y)\n#define cmplx_mul_y(a_x, a_y, b_x, b_y) (a_x*b_y + a_y*b_x)\n#define cmplx_add_x(a_x, b_x) (a_x + b_x)\n#define cmplx_add_y(a_y, b_y) (a_y + b_y)\n#define cmplx_sub_x(a_x, b_x) (a_x - b_x)\n#define cmplx_sub_y(a_y, b_y) (a_y - b_y)\n#define cm_fl_mul_x(a_x, b) (b*a_x)\n#define cm_fl_mul_y(a_y, b) (b*a_y)\n\nvoid twiddles8(TYPE a_x[8], TYPE a_y[8], int i, int n){\n    int reversed8[8] = {0,4,2,6,1,5,3,7};\n    int j;\n    TYPE phi, tmp, phi_x, phi_y;\n\n    twiddles:for(j=1; j < 8; j++){\n        phi = ((-2*PI*reversed8[j]/n)*i);\n        phi_x = cos(phi);\n        phi_y = sin(phi);\n        tmp = a_x[j];\n        a_x[j] = cmplx_M_x(a_x[j], a_y[j], phi_x, phi_y);\n        a_y[j] = cmplx_M_y(tmp, a_y[j], phi_x, phi_y);\n    }\n}\n////END TWIDDLES ////\n\n#define FF2(a0_x, a0_y, a1_x, a1_y){\t\t\t\\\n    TYPE c0_x = *a0_x;\t\t\\\n    TYPE c0_y = *a0_y;\t\t\\\n    *a0_x = cmplx_add_x(c0_x, *a1_x);\t\\\n    *a0_y = cmplx_add_y(c0_y, *a1_y);\t\\\n    *a1_x = cmplx_sub_x(c0_x, *a1_x);\t\\\n    *a1_y = cmplx_sub_y(c0_y, *a1_y);\t\\\n}\n\n#define FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y){           \\\n    TYPE exp_1_44_x;\t\t\\\n    TYPE exp_1_44_y;\t\t\\\n    TYPE tmp;\t\t\t\\\n    exp_1_44_x =  0.0;\t\t\\\n    exp_1_44_y =  -1.0;\t\t\\\n    FF2( a0_x, a0_y, a2_x, a2_y);   \\\n    FF2( a1_x, a1_y, a3_x, a3_y);   \\\n    tmp = *a3_x;\t\t\t\\\n    *a3_x = *a3_x*exp_1_44_x-*a3_y*exp_1_44_y;     \t\\\n    *a3_y = tmp*exp_1_44_y - *a3_y*exp_1_44_x;    \t\\\n    FF2( a0_x, a0_y, a1_x, a1_y );                  \\\n    FF2( a2_x, a2_y, a3_x, a3_y );                  \\\n}\n\n#define FFT8(a_x, a_y)\t\t\t\\\n{                                               \\\n    TYPE exp_1_8_x, exp_1_4_x, exp_3_8_x;\t\\\n    TYPE exp_1_8_y, exp_1_4_y, exp_3_8_y;\t\\\n    TYPE tmp_1;\t\t\t\\\n    exp_1_8_x =  1;\t\t\t\t\\\n    exp_1_8_y = -1;\t\t\t\t\\\n    exp_1_4_x =  0;\t\t\t\t\\\n    exp_1_4_y = -1;\t\t\t\t\\\n    exp_3_8_x = -1;\t\t\t\t\\\n    exp_3_8_y = -1;\t\t\t\t\\\n    FF2( &a_x[0], &a_y[0], &a_x[4], &a_y[4]);\t\t\t\\\n    FF2( &a_x[1], &a_y[1], &a_x[5], &a_y[5]);\t\t\t\\\n    FF2( &a_x[2], &a_y[2], &a_x[6], &a_y[6]);\t\t\t\\\n    FF2( &a_x[3], &a_y[3], &a_x[7], &a_y[7]);\t\t\t\\\n    tmp_1 = a_x[5];\t\t\t\t\t\t\t\\\n    a_x[5] = cm_fl_mul_x( cmplx_mul_x(a_x[5], a_y[5], exp_1_8_x, exp_1_8_y),  M_SQRT1_2 );\t\\\n    a_y[5] = cm_fl_mul_y( cmplx_mul_y(tmp_1, a_y[5], exp_1_8_x, exp_1_8_y) , M_SQRT1_2 );\t\\\n    tmp_1 = a_x[6];\t\t\t\t\t\t\t\\\n    a_x[6] = cmplx_mul_x( a_x[6], a_y[6], exp_1_4_x , exp_1_4_y);\t\\\n    a_y[6] = cmplx_mul_y( tmp_1, a_y[6], exp_1_4_x , exp_1_4_y);\t\\\n    tmp_1 = a_x[7];\t\t\t\t\t\t\t\\\n    a_x[7] = cm_fl_mul_x( cmplx_mul_x(a_x[7], a_y[7], exp_3_8_x, exp_3_8_y), M_SQRT1_2 );\t\\\n    a_y[7] = cm_fl_mul_y( cmplx_mul_y(tmp_1, a_y[7], exp_3_8_x, exp_3_8_y) , M_SQRT1_2 );\t\\\n    FFT4( &a_x[0], &a_y[0], &a_x[1], &a_y[1], &a_x[2], &a_y[2], &a_x[3], &a_y[3] );\t\\\n    FFT4( &a_x[4], &a_y[4], &a_x[5], &a_y[5], &a_x[6], &a_y[6], &a_x[7], &a_y[7] );\t\\\n}\n\nvoid loadx8(TYPE a_x[], TYPE x[], int offset, int sx){\n    a_x[0] = x[0*sx+offset];\n    a_x[1] = x[1*sx+offset];\n    a_x[2] = x[2*sx+offset];\n    a_x[3] = x[3*sx+offset];\n    a_x[4] = x[4*sx+offset];\n    a_x[5] = x[5*sx+offset];\n    a_x[6] = x[6*sx+offset];\n    a_x[7] = x[7*sx+offset];\n}\n\nvoid loady8(TYPE a_y[], TYPE x[], int offset, int sx){\n    a_y[0] = x[0*sx+offset];\n    a_y[1] = x[1*sx+offset];\n    a_y[2] = x[2*sx+offset];\n    a_y[3] = x[3*sx+offset];\n    a_y[4] = x[4*sx+offset];\n    a_y[5] = x[5*sx+offset];\n    a_y[6] = x[6*sx+offset];\n    a_y[7] = x[7*sx+offset];\n}\n\nvoid fft1D_512(TYPE work_x[512], TYPE work_y[512]){\n    int tid, hi, lo, stride;\n    int reversed[] = {0,4,2,6,1,5,3,7};\n    TYPE DATA_x[THREADS*8];\n    TYPE DATA_y[THREADS*8];\n\n    TYPE data_x[ 8 ];\n    TYPE data_y[ 8 ];\n\n    TYPE smem[8*8*9];\n\n    stride = THREADS;\n\n    //Do it all at once...\nloop1 : for(tid = 0; tid < THREADS; tid++){\n            //GLOBAL_LOAD...\n            data_x[0] = work_x[0*stride+tid];\n            data_x[1] = work_x[1*stride+tid];\n            data_x[2] = work_x[2*stride+tid];\n            data_x[3] = work_x[3*stride+tid];\n            data_x[4] = work_x[4*stride+tid];\n            data_x[5] = work_x[5*stride+tid];\n            data_x[6] = work_x[6*stride+tid];\n            data_x[7] = work_x[7*stride+tid];\n\n            data_y[0] = work_y[0*stride+tid];\n            data_y[1] = work_y[1*stride+tid];\n            data_y[2] = work_y[2*stride+tid];\n            data_y[3] = work_y[3*stride+tid];\n            data_y[4] = work_y[4*stride+tid];\n            data_y[5] = work_y[5*stride+tid];\n            data_y[6] = work_y[6*stride+tid];\n            data_y[7] = work_y[7*stride+tid];\n\n            //First 8 point FFT...\n            FFT8(data_x, data_y);\n\n            //First Twiddle\n            twiddles8(data_x, data_y, tid, 512);\n\n            //save for fence\n            DATA_x[tid*8]     = data_x[0];\n            DATA_x[tid*8 + 1] = data_x[1];\n            DATA_x[tid*8 + 2] = data_x[2];\n            DATA_x[tid*8 + 3] = data_x[3];\n            DATA_x[tid*8 + 4] = data_x[4];\n            DATA_x[tid*8 + 5] = data_x[5];\n            DATA_x[tid*8 + 6] = data_x[6];\n            DATA_x[tid*8 + 7] = data_x[7];\n\n            DATA_y[tid*8]     = data_y[0];\n            DATA_y[tid*8 + 1] = data_y[1];\n            DATA_y[tid*8 + 2] = data_y[2];\n            DATA_y[tid*8 + 3] = data_y[3];\n            DATA_y[tid*8 + 4] = data_y[4];\n            DATA_y[tid*8 + 5] = data_y[5];\n            DATA_y[tid*8 + 6] = data_y[6];\n            DATA_y[tid*8 + 7] = data_y[7];\n        }\n        int sx, offset;\n        sx = 66;\nloop2 : for(tid = 0; tid < 64; tid++){\n            hi = tid>>3;\n            lo = tid&7;\n            offset = hi*8+lo;\n            smem[0*sx+offset] = DATA_x[tid*8 + 0];\n            smem[4*sx+offset] = DATA_x[tid*8 + 1];\n            smem[1*sx+offset] = DATA_x[tid*8 + 4];\n            smem[5*sx+offset] = DATA_x[tid*8 + 5];\n            smem[2*sx+offset] = DATA_x[tid*8 + 2];\n            smem[6*sx+offset] = DATA_x[tid*8 + 3];\n            smem[3*sx+offset] = DATA_x[tid*8 + 6];\n            smem[7*sx+offset] = DATA_x[tid*8 + 7];\n        }\n        sx = 8;\nloop3 : for(tid = 0; tid < 64; tid++){\n            hi = tid>>3;\n            lo = tid&7;\n            offset = lo*66+hi;\n\n            DATA_x[tid*8 +0] = smem[0*sx+offset];\n            DATA_x[tid*8 +4] = smem[4*sx+offset];\n            DATA_x[tid*8 +1] = smem[1*sx+offset];\n            DATA_x[tid*8 +5] = smem[5*sx+offset];\n            DATA_x[tid*8 +2] = smem[2*sx+offset];\n            DATA_x[tid*8 +6] = smem[6*sx+offset];\n            DATA_x[tid*8 +3] = smem[3*sx+offset];\n            DATA_x[tid*8 +7] = smem[7*sx+offset];\n        }\n\n        sx = 66;\nloop4 : for(tid = 0; tid < 64; tid++){\n            hi = tid>>3;\n            lo = tid&7;\n            offset = hi*8+lo;\n\n            smem[0*sx+offset] = DATA_y[tid*8 + 0];\n            smem[4*sx+offset] = DATA_y[tid*8 + 1];\n            smem[1*sx+offset] = DATA_y[tid*8 + 4];\n            smem[5*sx+offset] = DATA_y[tid*8 + 5];\n            smem[2*sx+offset] = DATA_y[tid*8 + 2];\n            smem[6*sx+offset] = DATA_y[tid*8 + 3];\n            smem[3*sx+offset] = DATA_y[tid*8 + 6];\n            smem[7*sx+offset] = DATA_y[tid*8 + 7];\n        }\n\nloop5 : for(tid = 0; tid < 64; tid++){\n            data_y[0] = DATA_y[tid*8 + 0];\n            data_y[1] = DATA_y[tid*8 + 1];\n            data_y[2] = DATA_y[tid*8 + 2];\n            data_y[3] = DATA_y[tid*8 + 3];\n            data_y[4] = DATA_y[tid*8 + 4];\n            data_y[5] = DATA_y[tid*8 + 5];\n            data_y[6] = DATA_y[tid*8 + 6];\n            data_y[7] = DATA_y[tid*8 + 7];\n\n            hi = tid>>3;\n            lo = tid&7;\n\n            loady8(data_y, smem, lo*66+hi, 8);\n\n            DATA_y[tid*8]     = data_y[0];\n            DATA_y[tid*8 + 1] = data_y[1];\n            DATA_y[tid*8 + 2] = data_y[2];\n            DATA_y[tid*8 + 3] = data_y[3];\n            DATA_y[tid*8 + 4] = data_y[4];\n            DATA_y[tid*8 + 5] = data_y[5];\n            DATA_y[tid*8 + 6] = data_y[6];\n            DATA_y[tid*8 + 7] = data_y[7];\n        }\n\nloop6 : for(tid = 0; tid < 64; tid++){\n            data_x[0] = DATA_x[tid*8 + 0];\n            data_x[1] = DATA_x[tid*8 + 1];\n            data_x[2] = DATA_x[tid*8 + 2];\n            data_x[3] = DATA_x[tid*8 + 3];\n            data_x[4] = DATA_x[tid*8 + 4];\n            data_x[5] = DATA_x[tid*8 + 5];\n            data_x[6] = DATA_x[tid*8 + 6];\n            data_x[7] = DATA_x[tid*8 + 7];\n\n            data_y[0] = DATA_y[tid*8 + 0];\n            data_y[1] = DATA_y[tid*8 + 1];\n            data_y[2] = DATA_y[tid*8 + 2];\n            data_y[3] = DATA_y[tid*8 + 3];\n            data_y[4] = DATA_y[tid*8 + 4];\n            data_y[5] = DATA_y[tid*8 + 5];\n            data_y[6] = DATA_y[tid*8 + 6];\n            data_y[7] = DATA_y[tid*8 + 7];\n\n            //Second FFT8...\n            FFT8(data_x, data_y);\n\n            //Calculate hi for second twiddle calculation...\n            hi = tid>>3;\n\n            //Second twiddles calc, use hi and 64 stride version as defined in G80/SHOC...\n            twiddles8(data_x, data_y, hi, 64);\n\n            //Save for final transpose...\n            DATA_x[tid*8]     = data_x[0];\n            DATA_x[tid*8 + 1] = data_x[1];\n            DATA_x[tid*8 + 2] = data_x[2];\n            DATA_x[tid*8 + 3] = data_x[3];\n            DATA_x[tid*8 + 4] = data_x[4];\n            DATA_x[tid*8 + 5] = data_x[5];\n            DATA_x[tid*8 + 6] = data_x[6];\n            DATA_x[tid*8 + 7] = data_x[7];\n\n            DATA_y[tid*8]     = data_y[0];\n            DATA_y[tid*8 + 1] = data_y[1];\n            DATA_y[tid*8 + 2] = data_y[2];\n            DATA_y[tid*8 + 3] = data_y[3];\n            DATA_y[tid*8 + 4] = data_y[4];\n            DATA_y[tid*8 + 5] = data_y[5];\n            DATA_y[tid*8 + 6] = data_y[6];\n            DATA_y[tid*8 + 7] = data_y[7];\n        }\n\n        //Transpose..\n        sx = 72;\nloop7 : for(tid = 0; tid < 64; tid++){\n            hi = tid>>3;\n            lo = tid&7;\n            offset = hi*8+lo;\n            smem[0*sx+offset] = DATA_x[tid*8 + 0];\n            smem[4*sx+offset] = DATA_x[tid*8 + 1];\n            smem[1*sx+offset] = DATA_x[tid*8 + 4];\n            smem[5*sx+offset] = DATA_x[tid*8 + 5];\n            smem[2*sx+offset] = DATA_x[tid*8 + 2];\n            smem[6*sx+offset] = DATA_x[tid*8 + 3];\n            smem[3*sx+offset] = DATA_x[tid*8 + 6];\n            smem[7*sx+offset] = DATA_x[tid*8 + 7];\n        }\n\n        sx = 8;\nloop8 : for(tid = 0; tid < 64; tid++){\n            hi = tid>>3;\n            lo = tid&7;\n            offset = hi*72+lo;\n\n            DATA_x[tid*8 +0] = smem[0*sx+offset];\n            DATA_x[tid*8 +4] = smem[4*sx+offset];\n            DATA_x[tid*8 +1] = smem[1*sx+offset];\n            DATA_x[tid*8 +5] = smem[5*sx+offset];\n            DATA_x[tid*8 +2] = smem[2*sx+offset];\n            DATA_x[tid*8 +6] = smem[6*sx+offset];\n            DATA_x[tid*8 +3] = smem[3*sx+offset];\n            DATA_x[tid*8 +7] = smem[7*sx+offset];\n        }\n\n        sx = 72;\nloop9 : for(tid = 0; tid < 64; tid++){\n            hi = tid>>3;\n            lo = tid&7;\n            offset = hi*8+lo;\n\n            smem[0*sx+offset] = DATA_y[tid*8 + 0];\n            smem[4*sx+offset] = DATA_y[tid*8 + 1];\n            smem[1*sx+offset] = DATA_y[tid*8 + 4];\n            smem[5*sx+offset] = DATA_y[tid*8 + 5];\n            smem[2*sx+offset] = DATA_y[tid*8 + 2];\n            smem[6*sx+offset] = DATA_y[tid*8 + 3];\n            smem[3*sx+offset] = DATA_y[tid*8 + 6];\n            smem[7*sx+offset] = DATA_y[tid*8 + 7];\n        }\n\nloop10 : for(tid = 0; tid < 64; tid++){\n             data_y[0] = DATA_y[tid*8 + 0];\n             data_y[1] = DATA_y[tid*8 + 1];\n             data_y[2] = DATA_y[tid*8 + 2];\n             data_y[3] = DATA_y[tid*8 + 3];\n             data_y[4] = DATA_y[tid*8 + 4];\n             data_y[5] = DATA_y[tid*8 + 5];\n             data_y[6] = DATA_y[tid*8 + 6];\n             data_y[7] = DATA_y[tid*8 + 7];\n\n             hi = tid>>3;\n             lo = tid&7;\n\n             loady8(data_y, smem, hi*72+lo, 8);\n\n             DATA_y[tid*8 + 0] = data_y[0];\n             DATA_y[tid*8 + 1] = data_y[1];\n             DATA_y[tid*8 + 2] = data_y[2];\n             DATA_y[tid*8 + 3] = data_y[3];\n             DATA_y[tid*8 + 4] = data_y[4];\n             DATA_y[tid*8 + 5] = data_y[5];\n             DATA_y[tid*8 + 6] = data_y[6];\n             DATA_y[tid*8 + 7] = data_y[7];\n         }\n\nloop11 : for(tid = 0; tid < 64; tid++){\n             //Load post-trans\n             data_y[0] = DATA_y[tid*8];\n             data_y[1] = DATA_y[tid*8 + 1];\n             data_y[2] = DATA_y[tid*8 + 2];\n             data_y[3] = DATA_y[tid*8 + 3];\n             data_y[4] = DATA_y[tid*8 + 4];\n             data_y[5] = DATA_y[tid*8 + 5];\n             data_y[6] = DATA_y[tid*8 + 6];\n             data_y[7] = DATA_y[tid*8 + 7];\n\n             data_x[0] = DATA_x[tid*8];\n             data_x[1] = DATA_x[tid*8 + 1];\n             data_x[2] = DATA_x[tid*8 + 2];\n             data_x[3] = DATA_x[tid*8 + 3];\n             data_x[4] = DATA_x[tid*8 + 4];\n             data_x[5] = DATA_x[tid*8 + 5];\n             data_x[6] = DATA_x[tid*8 + 6];\n             data_x[7] = DATA_x[tid*8 + 7];\n\n             //Final 8pt FFT...\n             FFT8(data_x, data_y);\n\n             //Global store\n             work_x[0*stride+tid] = data_x[reversed[0]];\n             work_x[1*stride+tid] = data_x[reversed[1]];\n             work_x[2*stride+tid] = data_x[reversed[2]];\n             work_x[3*stride+tid] = data_x[reversed[3]];\n             work_x[4*stride+tid] = data_x[reversed[4]];\n             work_x[5*stride+tid] = data_x[reversed[5]];\n             work_x[6*stride+tid] = data_x[reversed[6]];\n             work_x[7*stride+tid] = data_x[reversed[7]];\n\n             work_y[0*stride+tid] = data_y[reversed[0]];\n             work_y[1*stride+tid] = data_y[reversed[1]];\n             work_y[2*stride+tid] = data_y[reversed[2]];\n             work_y[3*stride+tid] = data_y[reversed[3]];\n             work_y[4*stride+tid] = data_y[reversed[4]];\n             work_y[5*stride+tid] = data_y[reversed[5]];\n             work_y[6*stride+tid] = data_y[reversed[6]];\n             work_y[7*stride+tid] = data_y[reversed[7]];\n         }\n}\n"
      }
    ],
    "code_length": 14438,
    "token_count": 5554,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/fibonacci/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 244,
    "DSP": 0,
    "FF": 61,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fibonacci",
    "ResourceMetric": 5.26395e-05,
    "design_id": "project",
    "algo_name": "fibonacci",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "fibonacci.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid fibonacci(ap_uint<32> fib[N]) {\n    fib[0] = 0;\n    fib[1] = 1;\n    for (int i = 2; i < N; i++) {\n        fib[i] = fib[i-1] + fib[i-2];\n    }\n}\n\n// Top function name: fibonacci\n"
      }
    ],
    "code_length": 219,
    "token_count": 83,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/fine_tuning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 3,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fine_tuning",
    "ResourceMetric": 0.0001071782,
    "design_id": "project",
    "algo_name": "fine_tuning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "fine_tuning.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid fine_tuning(int input[SIZE], int output[SIZE], int factor) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] * factor;\n    }\n}\n\n// Top function name: fine_tuning\n"
      }
    ],
    "code_length": 225,
    "token_count": 67,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/fir_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16486,
    "Worst-caseLatency": 16486.0,
    "BRAM_18K": 0,
    "LUT": 4831,
    "DSP": 10,
    "FF": 7673,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fir_filter",
    "ResourceMetric": 0.0019391608,
    "design_id": "project",
    "algo_name": "fir_filter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "fir_filter.cpp",
        "file_content": "#include <iostream>\n\n#define N 1024\n\nvoid fir_filter(const float input[N], const float coeffs[32], float output[N]) {\n    float acc;\n    for (int i = 0; i < N; i++) {\n        acc = 0.0;\n        for (int j = 0; j < 32; j++) {\n            if (i - j >= 0) {\n                acc += input[i - j] * coeffs[j];\n            }\n        }\n        output[i] = acc;\n    }\n}\n\n// Top function name: fir_filter\n"
      }
    ],
    "code_length": 395,
    "token_count": 119,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/fir_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 32837,
    "Worst-caseLatency": 32837.0,
    "BRAM_18K": 0,
    "LUT": 4246,
    "DSP": 64,
    "FF": 5857,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fir_filter",
    "ResourceMetric": 0.0031488666,
    "design_id": "project",
    "algo_name": "fir_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "fir_filter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid fir_filter(ap_int<16> input[N], ap_int<16> output[N], ap_int<16> coeffs[64]) {\n    ap_int<32> acc;\n    for (int i = 0; i < N; i++) {\n        acc = 0;\n        for (int j = 0; j < 64; j++) {\n            if (i - j >= 0) {\n                acc += input[i - j] * coeffs[j];\n            }\n        }\n        output[i] = acc >> 15; // Assuming fixed-point arithmetic with scaling\n    }\n}\n\n// Top function name: fir_filter\n"
      }
    ],
    "code_length": 455,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/hls_algorithms/fixed_point_addition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fixed_point_addition",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "fixed_point_addition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "fixed_point_addition.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid fixed_point_addition(fixed_point_t A[ARRAY_SIZE], fixed_point_t B[ARRAY_SIZE], fixed_point_t C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: fixed_point_addition\n"
      }
    ],
    "code_length": 326,
    "token_count": 99,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/fixed_point_multiplication/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fixed_point_multiplication",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "fixed_point_multiplication",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "fixed_point_multiplication.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid fixed_point_multiplication(fixed_point_t A[SIZE], fixed_point_t B[SIZE], fixed_point_t C[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: fixed_point_multiplication\n"
      }
    ],
    "code_length": 308,
    "token_count": 94,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/fixed_point_sqrt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 34,
    "Worst-caseLatency": 34.0,
    "BRAM_18K": 0,
    "LUT": 596,
    "DSP": 0,
    "FF": 124,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fxp_sqrt_top",
    "ResourceMetric": 0.0001261813,
    "design_id": "project",
    "algo_name": "fixed_point_sqrt",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FXP_SQRT_TOP_H_\n#define FXP_SQRT_TOP_H_\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef __FXP_SQRT_H__\n#define __FXP_SQRT_H__\n\n#include <ap_fixed.h>\n#include <cassert>\nusing namespace std;\n\n// Fixed point square-root template\n//\n// Basic usage: fxp_sqrt(root_var, radicand_var);\n//          or: fxp_sqrt<W2,IW2,W1,IW1>(root_var, radicand_var);\n// where root_var and radicand_var are ap_ufixed<> variables and W2 & IW2\n// are the total and iteger widths for root_var and W1/IW1 those for\n// radicand_var.\n//\n// Despcription:\n// This template function implements a non-restoring algorithm to calculate\n// the square-root of a fixed point variable (ap_ufixed<>) of arbitrary\n// format and assign it to another fixed point vaiable of arbitrary format.\n//\n// The template parameters specify the ap_ufixed<> width parameters to be used\n// for input and output formats (see documentation for ap_fixed<> for details).\n// These parameters do not need to be explicitly specified, as they will be\n// inferred by the types passed to the function call.\n//\n// As this function is only intended for use with real numbers, the input\n// and output variables are expected to be unsigned, i.e. ap_ufixed<>.  If\n// signed types are passed, it is the user's responsibility to ensure the\n// input variable does not go negative, as no checks are made for such;\n// also note that passing a signed variable may result in slighty sub-optimal\n// HLS due to a wider format than necessary.  Explicit casting is preferred.\n//\n// This function returns a precise (rounded to one ulp) result\n// as long as the output format has at least half (rounded up) as many\n// fractional bits as the input format.  The output format must have enough\n// whole (integer) bit to hold thd full range of the result (i.e. half\n// rounded up), otherwise an assertion failure will result at runtime (of SW\n// model and/or RTL co-simulation).\n//\n// Note that integer square-roots may be accomplished with this function by\n// use of ap_ufixed<> intermediate variables with no fractional portion, e.g.\n//    uint16_t a;\n//    uint8_t a_sqrt;\n//    ...\n//    ap_ufixed<16,16> a_fxp = ap_ufixed<16,16>(a);\n//    ap_ufixed<8,8> a_sqrt_fxp;\n//    fxp_sqrt(a_sqrt_fxp, a_fxp);\n//    a_sqrt = a_sqrt_fxp.toint();\n//\n// Which should result in no more hardware area than having an integer-\n// specific version of this function.\n\ntemplate <int W2, int IW2, int W1, int IW1>\nvoid fxp_sqrt(ap_ufixed<W2, IW2>& result, ap_ufixed<W1, IW1>& in_val) {\n    enum { QW = (IW1 + 1) / 2 + (W2 - IW2) + 1 }; // derive max root width\n    enum {\n        SCALE = (W2 - W1) - (IW2 - (IW1 + 1) / 2)\n    }; // scale (shift) to adj initial remainer value\n    enum { ROOT_PREC = QW - (IW1 % 2) };\n    assert((IW1 + 1) / 2 <=\n           IW2); // Check that output format can accommodate full result\n\n    ap_uint<QW> q = 0;      // partial sqrt\n    ap_uint<QW> q_star = 0; // diminished partial sqrt\n    ap_int<QW + 2> s; // scaled remainder initialized to extracted input bits\n    if (SCALE >= 0)\n        s = in_val.range(W1 - 1, 0) << (SCALE);\n    else\n        s = ((in_val.range(W1 - 1, 0) >> (0 - (SCALE + 1))) + 1) >> 1;\n\n    // Non-restoring square-root algorithm\n    for (int i = 0; i <= ROOT_PREC; i++) {\n        if (s >= 0) {\n            s = 2 * s - (((ap_int<QW + 2>(q) << 2) | 1) << (ROOT_PREC - i));\n            q_star = q << 1;\n            q = (q << 1) | 1;\n        } else {\n            s = 2 * s +\n                (((ap_int<QW + 2>(q_star) << 2) | 3) << (ROOT_PREC - i));\n            q = (q_star << 1) | 1;\n            q_star <<= 1;\n        }\n    }\n    // Round result by \"extra iteration\" method\n    if (s > 0)\n        q = q + 1;\n    // Truncate excess bit and assign to output format\n    result.range(W2 - 1, 0) = ap_uint<W2>(q >> 1);\n}\n\n#endif //__FXP_SQRT_H__ not defined\n#include <ap_int.h>\n\n#define IN_BW 24\n#define IN_IW 8\n#define OUT_BW 28\n#define OUT_IW 4 // ((IN_IW + 1) / 2)\n\n// typedefs for top-level input and output fixed-point formats\ntypedef ap_ufixed<IN_BW, IN_IW> in_data_t;\ntypedef ap_ufixed<OUT_BW, OUT_IW> out_data_t;\n\n// Top level wrapper function - calls the core template function w/ above types\nout_data_t fxp_sqrt_top(in_data_t& in_val);\n\n#endif // FXP_SQRT_TOP_H_ not defined\n\nout_data_t fxp_sqrt_top(in_data_t& in_val) {\n    out_data_t result;\n    fxp_sqrt(result, in_val);\n    return result;\n}\n"
      }
    ],
    "code_length": 6402,
    "token_count": 1766,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/flash_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 169869510,
    "Worst-caseLatency": 169869510.0,
    "BRAM_18K": 4100,
    "LUT": 8610,
    "DSP": 20,
    "FF": 8073,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "flash_attention",
    "ResourceMetric": 0.257195502,
    "design_id": "project",
    "algo_name": "flash_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "flash_attention.cpp",
        "file_content": "#include <hls_math.h>\n\n#define N 1024\n#define D 64\n\nvoid flash_attention(float query[N][D], float key[N][D], float value[N][D], float output[N][D]) {\n    float scale = 1.0f / hls::sqrt(float(D));\n    float scores[N][N];\n    float max_scores[N];\n    float exp_scores[N][N];\n    float sum_exp_scores[N];\n    \n    // Compute scaled dot-product attention scores\n    for (int i = 0; i < N; i++) {\n        max_scores[i] = -1e9;\n        for (int j = 0; j < N; j++) {\n            scores[i][j] = 0.0f;\n            for (int d = 0; d < D; d++) {\n                scores[i][j] += query[i][d] * key[j][d];\n            }\n            scores[i][j] *= scale;\n            if (scores[i][j] > max_scores[i]) {\n                max_scores[i] = scores[i][j];\n            }\n        }\n    }\n\n    // Compute exponentials and normalization\n    for (int i = 0; i < N; i++) {\n        sum_exp_scores[i] = 0.0f;\n        for (int j = 0; j < N; j++) {\n            exp_scores[i][j] = hls::exp(scores[i][j] - max_scores[i]);\n            sum_exp_scores[i] += exp_scores[i][j];\n        }\n    }\n\n    // Compute weighted sum of values\n    for (int i = 0; i < N; i++) {\n        for (int d = 0; d < D; d++) {\n            output[i][d] = 0.0f;\n            for (int j = 0; j < N; j++) {\n                output[i][d] += (exp_scores[i][j] / sum_exp_scores[i]) * value[j][d];\n            }\n        }\n    }\n}\n\n// Top function name: flash_attention\n"
      }
    ],
    "code_length": 1399,
    "token_count": 435,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/flash_memory_cell/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 93,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "flash_memory_cell",
    "ResourceMetric": 2.02312e-05,
    "design_id": "project",
    "algo_name": "flash_memory_cell",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "flash_memory_cell.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid flash_memory_cell(ap_uint<8> input[SIZE], ap_uint<8> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<8> cell = input[i];\n        ap_uint<8> processed_cell = 0;\n\n        // Simulate some processing on the flash memory cell\n        for (int j = 0; j < 8; j++) {\n            processed_cell[j] = cell[j] ^ 1; // Example operation: bitwise NOT\n        }\n\n        output[i] = processed_cell;\n    }\n}\n\n// Top function name: flash_memory_cell\n"
      }
    ],
    "code_length": 501,
    "token_count": 145,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/float_to_int_pipelined/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 704,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "float_to_int_pipelined",
    "ResourceMetric": 0.0001373995,
    "design_id": "project",
    "algo_name": "float_to_int_pipelined",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "float_to_int_pipelined.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define SIZE 1024\n\nvoid float_to_int_pipelined(float input[SIZE], int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = static_cast<int>(input[i]);\n    }\n}\n\n// Top function name: float_to_int_pipelined\n"
      }
    ],
    "code_length": 248,
    "token_count": 73,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/floating_point_addition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1030,
    "Worst-caseLatency": 1030.0,
    "BRAM_18K": 0,
    "LUT": 335,
    "DSP": 2,
    "FF": 370,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_addition",
    "ResourceMetric": 0.0001551255,
    "design_id": "project",
    "algo_name": "floating_point_addition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "floating_point_addition.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE (1 << 10)\n\nvoid floating_point_addition(float A[ARRAY_SIZE], float B[ARRAY_SIZE], float C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: floating_point_addition\n"
      }
    ],
    "code_length": 268,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_arithmetic_coprocessor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1030,
    "Worst-caseLatency": 1030.0,
    "BRAM_18K": 0,
    "LUT": 638,
    "DSP": 7,
    "FF": 707,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_arithmetic_coprocessor",
    "ResourceMetric": 0.0003840622,
    "design_id": "project",
    "algo_name": "floating_point_arithmetic_coprocessor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_arithmetic_coprocessor.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid floating_point_arithmetic_coprocessor(float A[ARRAY_SIZE], float B[ARRAY_SIZE], float C[ARRAY_SIZE], float D[ARRAY_SIZE], float E[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] + B[i];\n        D[i] = A[i] - B[i];\n        E[i] = A[i] * B[i];\n    }\n}\n// Top function name: floating_point_arithmetic_coprocessor\n"
      }
    ],
    "code_length": 388,
    "token_count": 121,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_arithmetic_coprocessor_double_precision/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1038,
    "Worst-caseLatency": 1038.0,
    "BRAM_18K": 0,
    "LUT": 1633,
    "DSP": 14,
    "FF": 1394,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_arithmetic_coprocessor_double_precision",
    "ResourceMetric": 0.0008346667,
    "design_id": "project",
    "algo_name": "floating_point_arithmetic_coprocessor_double_precision",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_arithmetic_coprocessor_double_precision.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid floating_point_arithmetic_coprocessor_double_precision(double input1[SIZE], double input2[SIZE], double output_add[SIZE], double output_sub[SIZE], double output_mul[SIZE], double output_div[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output_add[i] = input1[i] + input2[i];\n        output_sub[i] = input1[i] - input2[i];\n        output_mul[i] = input1[i] * input2[i];\n        output_div[i] = input1[i] / input2[i];\n    }\n}\n\n// Top function name: floating_point_arithmetic_coprocessor_double_precision\n"
      }
    ],
    "code_length": 552,
    "token_count": 153,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_comparator_unit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 648,
    "DSP": 2,
    "FF": 699,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_comparator_unit",
    "ResourceMetric": 0.0002466932,
    "design_id": "project",
    "algo_name": "floating_point_comparator_unit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_comparator_unit.cpp",
        "file_content": "#include <cmath>\n#include <cfloat>\n\n#define ARRAY_SIZE 1024\n\nvoid floating_point_comparator_unit(float A[ARRAY_SIZE], float B[ARRAY_SIZE], int result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (std::fabs(A[i] - B[i]) < FLT_EPSILON) {\n            result[i] = 0; // A[i] is equal to B[i]\n        } else if (A[i] > B[i]) {\n            result[i] = 1; // A[i] is greater than B[i]\n        } else {\n            result[i] = -1; // A[i] is less than B[i]\n        }\n    }\n}\n\n// Top function name: floating_point_comparator_unit\n"
      }
    ],
    "code_length": 545,
    "token_count": 164,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_coprocessor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1038,
    "Worst-caseLatency": 1038.0,
    "BRAM_18K": 0,
    "LUT": 1381,
    "DSP": 22,
    "FF": 1274,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_coprocessor",
    "ResourceMetric": 0.0009964673,
    "design_id": "project",
    "algo_name": "floating_point_coprocessor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_coprocessor.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid floating_point_coprocessor(float input1[SIZE], float input2[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] * input2[i] + std::sqrt(input1[i]) - std::log(input2[i] + 1.0f);\n    }\n}\n\n// Top function name: floating_point_coprocessor\n"
      }
    ],
    "code_length": 321,
    "token_count": 103,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_coprocessor_double_precision/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1039,
    "Worst-caseLatency": 1039.0,
    "BRAM_18K": 0,
    "LUT": 14427,
    "DSP": 196,
    "FF": 5853,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_coprocessor_double_precision",
    "ResourceMetric": 0.0087577559,
    "design_id": "project",
    "algo_name": "floating_point_coprocessor_double_precision",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_coprocessor_double_precision.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE (1 << 10)\n\nvoid floating_point_coprocessor_double_precision(double input1[ARRAY_SIZE], double input2[ARRAY_SIZE], double output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input1[i] * input2[i] + std::sin(input1[i]) - std::cos(input2[i]);\n    }\n}\n\n// Top function name: floating_point_coprocessor_double_precision\n"
      }
    ],
    "code_length": 385,
    "token_count": 107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_dsp/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1063,
    "Worst-caseLatency": 1063.0,
    "BRAM_18K": 0,
    "LUT": 9564,
    "DSP": 64,
    "FF": 3727,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_dsp",
    "ResourceMetric": 0.0039644425,
    "design_id": "project",
    "algo_name": "floating_point_dsp",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_dsp.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid floating_point_dsp(float input[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        float temp = input[i];\n        temp = std::sin(temp);\n        temp = std::cos(temp);\n        temp = std::tan(temp);\n        temp = std::log(temp + 1.0f); // Adding 1 to avoid log(0)\n        temp = std::exp(temp);\n        temp = std::sqrt(temp);\n        output[i] = temp;\n    }\n}\n\n// Top function name: floating_point_dsp\n"
      }
    ],
    "code_length": 468,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/floating_point_multiplication/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 154,
    "DSP": 3,
    "FF": 166,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_multiplication",
    "ResourceMetric": 0.00012856,
    "design_id": "project",
    "algo_name": "floating_point_multiplication",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "floating_point_multiplication.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\nvoid floating_point_multiplication(float A[ARRAY_SIZE], float B[ARRAY_SIZE], float C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: floating_point_multiplication\n"
      }
    ],
    "code_length": 280,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_pipelined_adder_unit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1030,
    "Worst-caseLatency": 1030.0,
    "BRAM_18K": 0,
    "LUT": 335,
    "DSP": 2,
    "FF": 370,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_pipelined_adder_unit",
    "ResourceMetric": 0.0001551255,
    "design_id": "project",
    "algo_name": "floating_point_pipelined_adder_unit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_pipelined_adder_unit.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\nvoid floating_point_pipelined_adder_unit(float input1[ARRAY_SIZE], float input2[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input1[i] + input2[i];\n    }\n}\n\n// Top function name: floating_point_pipelined_adder_unit\n"
      }
    ],
    "code_length": 322,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_pipelined_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1033,
    "Worst-caseLatency": 1033.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 199,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_pipelined_divider",
    "ResourceMetric": 3.9983e-05,
    "design_id": "project",
    "algo_name": "floating_point_pipelined_divider",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_pipelined_divider.cpp",
        "file_content": "#include <hls_math.h>\n\n#define ARRAY_SIZE 1024\n\nvoid floating_point_pipelined_divider(float A[ARRAY_SIZE], float B[ARRAY_SIZE], float C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] / B[i];\n    }\n}\n\n// Top function name: floating_point_pipelined_divider\n"
      }
    ],
    "code_length": 286,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/floating_point_pipelined_multiplier_unit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 154,
    "DSP": 3,
    "FF": 166,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floating_point_pipelined_multiplier_unit",
    "ResourceMetric": 0.00012856,
    "design_id": "project",
    "algo_name": "floating_point_pipelined_multiplier_unit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "floating_point_pipelined_multiplier_unit.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid floating_point_pipelined_multiplier_unit(float A[ARRAY_SIZE], float B[ARRAY_SIZE], float C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: floating_point_pipelined_multiplier_unit\n"
      }
    ],
    "code_length": 297,
    "token_count": 83,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/floyd_warshall/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3222274055,
    "Worst-caseLatency": 3222274055.0,
    "BRAM_18K": 0,
    "LUT": 878,
    "DSP": 0,
    "FF": 324,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "floyd_warshall",
    "ResourceMetric": 0.0001994354,
    "design_id": "project",
    "algo_name": "floyd_warshall",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "floyd_warshall.cpp",
        "file_content": "#define N 1024\n\nvoid floyd_warshall(int graph[N][N], int dist[N][N]) {\n    int i, j, k;\n\n    // Initialize the solution matrix same as input graph matrix\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            dist[i][j] = graph[i][j];\n        }\n    }\n\n    // Add all vertices one by one to the set of intermediate vertices\n    for (k = 0; k < N; k++) {\n        // Pick all vertices as source one by one\n        for (i = 0; i < N; i++) {\n            // Pick all vertices as destination for the above picked source\n            for (j = 0; j < N; j++) {\n                // If vertex k is on the shortest path from i to j, then update the value of dist[i][j]\n                if (dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\n// Top function name: floyd_warshall\n"
      }
    ],
    "code_length": 882,
    "token_count": 257,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/focal_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1054,
    "Worst-caseLatency": 1054.0,
    "BRAM_18K": 1,
    "LUT": 7049,
    "DSP": 58,
    "FF": 4619,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "focal_loss",
    "ResourceMetric": 0.0034634616,
    "design_id": "project",
    "algo_name": "focal_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "focal_loss.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid focal_loss(float gamma, float alpha, float y_true[N], float y_pred[N], float loss[N]) {\n    for (int i = 0; i < N; i++) {\n        float p_t = y_true[i] * y_pred[i] + (1 - y_true[i]) * (1 - y_pred[i]);\n        float alpha_t = y_true[i] * alpha + (1 - y_true[i]) * (1 - alpha);\n        loss[i] = -alpha_t * powf(1 - p_t, gamma) * logf(p_t);\n    }\n}\n\n// Top function name: focal_loss\n"
      }
    ],
    "code_length": 420,
    "token_count": 141,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/four_bit_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 89,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "four_bit_adder",
    "ResourceMetric": 1.94641e-05,
    "design_id": "project",
    "algo_name": "four_bit_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "four_bit_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid four_bit_adder(ap_uint<4> A[ARRAY_SIZE], ap_uint<4> B[ARRAY_SIZE], ap_uint<5> C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: four_bit_adder\n"
      }
    ],
    "code_length": 263,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/four_bit_full_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "four_bit_full_adder",
    "ResourceMetric": 2.09983e-05,
    "design_id": "project",
    "algo_name": "four_bit_full_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "four_bit_full_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid four_bit_full_adder(ap_uint<4> A[ARRAY_SIZE], ap_uint<4> B[ARRAY_SIZE], ap_uint<1> Cin[ARRAY_SIZE], ap_uint<4> Sum[ARRAY_SIZE], ap_uint<1> Cout[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<5> temp_sum = A[i] + B[i] + Cin[i];\n        Sum[i] = temp_sum.range(3, 0);\n        Cout[i] = temp_sum[4];\n    }\n}\n\n// Top function name: four_bit_full_adder\n"
      }
    ],
    "code_length": 426,
    "token_count": 145,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/fpn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 805306399,
    "Worst-caseLatency": 805306399.0,
    "BRAM_18K": 1572864,
    "LUT": 2835,
    "DSP": 9,
    "FF": 2272,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fpn",
    "ResourceMetric": 97.5248203571,
    "design_id": "project",
    "algo_name": "fpn",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "fpn.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 1024\n#define NUM_FEATURES 256\n\nvoid fpn(float input[INPUT_SIZE][INPUT_SIZE][NUM_FEATURES], \n         float output[OUTPUT_SIZE][OUTPUT_SIZE][NUM_FEATURES]) {\n    int i, j, k;\n    float temp[OUTPUT_SIZE][OUTPUT_SIZE][NUM_FEATURES];\n\n    // Downsample input to create a pyramid\n    for (i = 0; i < OUTPUT_SIZE; i++) {\n        for (j = 0; j < OUTPUT_SIZE; j++) {\n            for (k = 0; k < NUM_FEATURES; k++) {\n                temp[i][j][k] = 0.0f;\n                for (int di = 0; di < 2; di++) {\n                    for (int dj = 0; dj < 2; dj++) {\n                        temp[i][j][k] += input[2*i + di][2*j + dj][k];\n                    }\n                }\n                temp[i][j][k] /= 4.0f;\n            }\n        }\n    }\n\n    // Upsample and merge features\n    for (i = 0; i < OUTPUT_SIZE; i++) {\n        for (j = 0; j < OUTPUT_SIZE; j++) {\n            for (k = 0; k < NUM_FEATURES; k++) {\n                output[i][j][k] = temp[i][j][k];\n                if (i > 0 && j > 0) {\n                    output[i][j][k] += temp[i-1][j-1][k];\n                }\n                if (i > 0) {\n                    output[i][j][k] += temp[i-1][j][k];\n                }\n                if (j > 0) {\n                    output[i][j][k] += temp[i][j-1][k];\n                }\n                output[i][j][k] /= 4.0f;\n            }\n        }\n    }\n}\n\n// Top function name: fpn\n"
      }
    ],
    "code_length": 1428,
    "token_count": 432,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/fractional_n_pll/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1062,
    "Worst-caseLatency": 1062.0,
    "BRAM_18K": 0,
    "LUT": 521,
    "DSP": 0,
    "FF": 510,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fractional_n_pll",
    "ResourceMetric": 0.0001488095,
    "design_id": "project",
    "algo_name": "fractional_n_pll",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "fractional_n_pll.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid fractional_n_pll(ap_uint<32> ref_freq, ap_uint<32> div_ratio, ap_uint<32> phase_accum[N], ap_uint<32> output_freq[N]) {\n    ap_uint<32> phase = 0;\n    ap_uint<32> step = ref_freq / div_ratio;\n\n    for (int i = 0; i < N; i++) {\n        phase += step;\n        output_freq[i] = phase >> 16; // Simulate the fractional division\n        phase_accum[i] = phase;\n    }\n}\n\n// Top function name: fractional_n_pll\n"
      }
    ],
    "code_length": 446,
    "token_count": 135,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/free_running_kernel_remerge_ii4to1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 54,
    "Worst-caseLatency": 54.0,
    "BRAM_18K": 0,
    "LUT": 626,
    "DSP": 0,
    "FF": 167,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 0.0001360572,
    "design_id": "project",
    "algo_name": "free_running_kernel_remerge_ii4to1",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n//                    +--proc-->[ II=4 ]--+\n//                   /                     \\               \n// in -->[demux II=1]                       [mux II=1]---> out\n//                   \\                     /\n//                    +--proc-->[ II=4 ]--+\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_int.h\"\n#include <hls_stream.h>\nusing namespace hls;\n\n#include <iostream>\nusing namespace std;\n\n//--------------------------------------------\ntemplate <int ID> void proc(stream<int, 16>& in, stream<int, 16>& out) {\n    for (int i = 0; i < 25; i++) {\n#pragma HLS LATENCY min = 2 max = 2\n        int var;\n        in.read(var);\n        out.write(var);\n    }\n}\n\n//--------------------------------------------\nvoid mux(stream<int, 16> (&inter)[2], stream<int>& mux_output) {\n    int mux_sel = 0;\n    for (int i = 0; i < 50; i++) {\n        int var;\n        inter[mux_sel].read(var);\n        mux_output.write(var);\n        mux_sel = (mux_sel == 0) ? (1) : (0);\n    }\n}\n\n//--------------------------------------------\nvoid demux(stream<int>& in, stream<int, 16> (&inter)[2]) {\n    int demux_sel = 0;\n    for (int i = 0; i < 50; i++) {\n\n        int var;\n        in.read(var);\n        inter[demux_sel].write(var);\n        demux_sel = (demux_sel == 0) ? 1 : 0;\n    }\n}\n\nvoid example(stream<int>& in, stream<int>& out) {\n#pragma HLS INTERFACE mode = ap_ctrl_none port = return\n#pragma HLS DATAFLOW\n\n    stream<int, 16> inter[2];\n    stream<int, 16> mux_in[2];\n\n    demux(in, inter);\n    proc<0>(inter[0], mux_in[0]);\n    proc<1>(inter[1], mux_in[1]);\n    mux(mux_in, out);\n}\n"
      }
    ],
    "code_length": 2921,
    "token_count": 746,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/frequency_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8455,
    "Worst-caseLatency": 8455.0,
    "BRAM_18K": 0,
    "LUT": 372,
    "DSP": 0,
    "FF": 96,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "frequency_counter",
    "ResourceMetric": 8.05412e-05,
    "design_id": "project",
    "algo_name": "frequency_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "frequency_counter.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid frequency_counter(uint32_t input_array[ARRAY_SIZE], uint32_t frequency[256]) {\n    // Initialize frequency array\n    for (int i = 0; i < 256; i++) {\n        frequency[i] = 0;\n    }\n\n    // Count the frequency of each byte value\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t value = input_array[i];\n        for (int j = 0; j < 4; j++) {\n            uint8_t byte = (value >> (j * 8)) & 0xFF;\n            frequency[byte]++;\n        }\n    }\n}\n\n// Top function name: frequency_counter\n"
      }
    ],
    "code_length": 544,
    "token_count": 156,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/frequency_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1061,
    "Worst-caseLatency": 1061.0,
    "BRAM_18K": 0,
    "LUT": 1847,
    "DSP": 0,
    "FF": 2474,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "frequency_divider",
    "ResourceMetric": 0.0005914028,
    "design_id": "project",
    "algo_name": "frequency_divider",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "frequency_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid frequency_divider(ap_uint<32> input_freq[ARRAY_SIZE], ap_uint<32> divisor, ap_uint<32> output_freq[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_freq[i] = input_freq[i] / divisor;\n    }\n}\n\n// Top function name: frequency_divider\n"
      }
    ],
    "code_length": 307,
    "token_count": 89,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/frequency_encoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3084,
    "Worst-caseLatency": 3084.0,
    "BRAM_18K": 2,
    "LUT": 543,
    "DSP": 0,
    "FF": 183,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "frequency_encoding",
    "ResourceMetric": 0.0002456827,
    "design_id": "project",
    "algo_name": "frequency_encoding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "frequency_encoding.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid frequency_encoding(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    ap_uint<32> frequency[SIZE] = {0};\n\n    // Count frequencies\n    for (int i = 0; i < SIZE; i++) {\n        frequency[input[i]]++;\n    }\n\n    // Encode frequencies\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = frequency[input[i]];\n    }\n}\n\n// Top function name: frequency_encoding\n"
      }
    ],
    "code_length": 411,
    "token_count": 118,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/frequency_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 3,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "frequency_multiplier",
    "ResourceMetric": 0.0001071782,
    "design_id": "project",
    "algo_name": "frequency_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "frequency_multiplier.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid frequency_multiplier(int input[ARRAY_SIZE], int output[ARRAY_SIZE], int multiplier) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * multiplier;\n    }\n}\n\n// Top function name: frequency_multiplier\n"
      }
    ],
    "code_length": 275,
    "token_count": 69,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/fsm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 212,
    "DSP": 0,
    "FF": 18,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fsm",
    "ResourceMetric": 4.238e-05,
    "design_id": "project",
    "algo_name": "fsm",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "fsm.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nenum State { STATE_0, STATE_1, STATE_2, STATE_3 };\n\nvoid fsm(ap_uint<1> input[LARGE_SCALE], ap_uint<1> output[LARGE_SCALE]) {\n    State current_state = STATE_0;\n\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        switch (current_state) {\n            case STATE_0:\n                if (input[i] == 1) {\n                    current_state = STATE_1;\n                }\n                output[i] = 0;\n                break;\n            case STATE_1:\n                if (input[i] == 0) {\n                    current_state = STATE_2;\n                }\n                output[i] = 1;\n                break;\n            case STATE_2:\n                if (input[i] == 1) {\n                    current_state = STATE_3;\n                }\n                output[i] = 0;\n                break;\n            case STATE_3:\n                if (input[i] == 0) {\n                    current_state = STATE_0;\n                }\n                output[i] = 1;\n                break;\n        }\n    }\n}\n\n// Top function name: fsm\n"
      }
    ],
    "code_length": 1051,
    "token_count": 252,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/ftrl/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2109,
    "Worst-caseLatency": 2109.0,
    "BRAM_18K": 0,
    "LUT": 2127,
    "DSP": 14,
    "FF": 3469,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ftrl",
    "ResourceMetric": 0.0011283546,
    "design_id": "project",
    "algo_name": "ftrl",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "ftrl.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid ftrl(\n    float alpha, float beta, float lambda1, float lambda2,\n    float z[N], float n[N], float w[N], float g[N])\n{\n    for (int i = 0; i < N; i++) {\n        if (std::abs(z[i]) <= lambda1) {\n            w[i] = 0.0;\n        } else {\n            float sign = (z[i] > 0) ? 1.0 : -1.0;\n            w[i] = (sign * lambda1 - z[i]) / ((beta + std::sqrt(n[i])) / alpha + lambda2);\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        float sigma = (std::sqrt(n[i] + g[i] * g[i]) - std::sqrt(n[i])) / alpha;\n        z[i] += g[i] - sigma * w[i];\n        n[i] += g[i] * g[i];\n    }\n}\n\n// Top function name: ftrl\n"
      }
    ],
    "code_length": 649,
    "token_count": 230,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/fully_connected_layer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048582,
    "Worst-caseLatency": 1048582.0,
    "BRAM_18K": 0,
    "LUT": 727,
    "DSP": 5,
    "FF": 688,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fully_connected_layer",
    "ResourceMetric": 0.0003438997,
    "design_id": "project",
    "algo_name": "fully_connected_layer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "fully_connected_layer.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 512\n#define WEIGHT_SIZE (INPUT_SIZE * OUTPUT_SIZE)\n\nvoid fully_connected_layer(float input[INPUT_SIZE], float output[OUTPUT_SIZE], float weights[WEIGHT_SIZE], float bias[OUTPUT_SIZE]) {\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output[i] = bias[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            output[i] += input[j] * weights[i * INPUT_SIZE + j];\n        }\n    }\n}\n\n// Top function name: fully_connected_layer\n"
      }
    ],
    "code_length": 499,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/function_instantiate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 30,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "top",
    "ResourceMetric": 5.7529e-06,
    "design_id": "project",
    "algo_name": "function_instantiate",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nchar foo(char inval, char incr) {\n#pragma HLS INLINE OFF\n#pragma HLS FUNCTION_INSTANTIATE variable = incr\n    return inval + incr;\n}\n\nvoid top(char inval1, char inval2, char inval3, char* outval1, char* outval2,\n         char* outval3) {\n    *outval1 = foo(inval1, 0);\n    *outval2 = foo(inval2, 1);\n    *outval3 = foo(inval3, 100);\n}\n"
      }
    ],
    "code_length": 1029,
    "token_count": 265,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/gaussian_blur/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13601700,
    "Worst-caseLatency": 13601700.0,
    "BRAM_18K": 0,
    "LUT": 2046,
    "DSP": 10,
    "FF": 3150,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gaussian_blur",
    "ResourceMetric": 0.0009714195,
    "design_id": "project",
    "algo_name": "gaussian_blur",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "gaussian_blur.cpp",
        "file_content": "#include <cmath>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid gaussian_blur(const float input[HEIGHT][WIDTH], float output[HEIGHT][WIDTH]) {\n    const float kernel[5][5] = {\n        {1, 4, 7, 4, 1},\n        {4, 16, 26, 16, 4},\n        {7, 26, 41, 26, 7},\n        {4, 16, 26, 16, 4},\n        {1, 4, 7, 4, 1}\n    };\n    const float kernel_sum = 273.0;\n\n    for (int y = 2; y < HEIGHT - 2; y++) {\n        for (int x = 2; x < WIDTH - 2; x++) {\n            float sum = 0.0;\n            for (int ky = 0; ky < 5; ky++) {\n                for (int kx = 0; kx < 5; kx++) {\n                    sum += input[y + ky - 2][x + kx - 2] * kernel[ky][kx];\n                }\n            }\n            output[y][x] = sum / kernel_sum;\n        }\n    }\n}\n\n// Top function name: gaussian_blur\n"
      }
    ],
    "code_length": 771,
    "token_count": 281,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/gemm_blocked/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048582,
    "Worst-caseLatency": 1048582.0,
    "BRAM_18K": 0,
    "LUT": 1625,
    "DSP": 11,
    "FF": 1136,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "bbgemm",
    "ResourceMetric": 0.0007252832,
    "design_id": "project",
    "algo_name": "gemm_blocked",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "gemm.h",
        "file_content": "/*\nImplementation based on algorithm described in:\nThe cache performance and optimizations of blocked algorithms\nM. D. Lam, E. E. Rothberg, and M. E. Wolf\nASPLOS 1991\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"support.h\"\n\n//Data Type\n#define TYPE double\n\n//Algorithm Parameters\n#define row_size 64\n#define col_size 64\n#define N row_size*col_size\n#define block_size 8\n#define NUMOFBLOCKS N/block_size/block_size\n\n//Define the input range to operate over\n#define MIN 0.\n#define MAX 1.0\n\n//Set number of iterations to execute\n#define MAX_ITERATION 1\n\nvoid bbgemm(TYPE m1[N], TYPE m2[N], TYPE prod[N]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE m1[N];\n  TYPE m2[N];\n  TYPE prod[N];\n};\n"
      },
      {
        "file_name": "gemm.c",
        "file_content": "/*\nImplementation based on algorithm described in:\nThe cache performance and optimizations of blocked algorithms\nM. D. Lam, E. E. Rothberg, and M. E. Wolf\nASPLOS 1991\n*/\n\n#include \"gemm.h\"\n\nvoid bbgemm(TYPE m1[N], TYPE m2[N], TYPE prod[N]){\n    int i, k, j, jj, kk;\n    int i_row, k_row;\n    TYPE temp_x, mul;\n\n    loopjj:for (jj = 0; jj < row_size; jj += block_size){\n        loopkk:for (kk = 0; kk < row_size; kk += block_size){\n            loopi:for ( i = 0; i < row_size; ++i){\n                loopk:for (k = 0; k < block_size; ++k){\n                    i_row = i * row_size;\n                    k_row = (k  + kk) * row_size;\n                    temp_x = m1[i_row + k + kk];\n                    loopj:for (j = 0; j < block_size; ++j){\n                        mul = temp_x * m2[k_row + j + jj];\n                        prod[i_row + j + jj] += mul;\n                    }\n                }\n            }\n        }\n    }\n}\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      }
    ],
    "code_length": 923,
    "token_count": 268,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/gemm_ncubed/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 131239,
    "Worst-caseLatency": 131239.0,
    "BRAM_18K": 0,
    "LUT": 5972,
    "DSP": 22,
    "FF": 9427,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gemm",
    "ResourceMetric": 0.0026585891,
    "design_id": "project",
    "algo_name": "gemm_ncubed",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "gemm.h",
        "file_content": "//Standard Libraries\n#include <stdio.h>\n#include <stdlib.h>\n#include \"support.h\"\n\n//Define compute data type\n#define TYPE double\n\n//Specify row/column sizes\n#define row_size 64\n#define col_size 64\n#define N row_size*col_size\n\n//Define the input range to operate over\n#define MIN 0.\n#define MAX 1.0\n\n//Set number of iterations to execute\n#define MAX_ITERATION 1\n\nvoid gemm(TYPE m1[N], TYPE m2[N], TYPE prod[N]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE m1[N];\n  TYPE m2[N];\n  TYPE prod[N];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "gemm2.c",
        "file_content": "#include \"gemm.h\"\n\nvoid gemm( TYPE m1[N], TYPE m2[N], TYPE prod[N] ){\n    int i, j, k;\n    int k_col, i_col;\n    TYPE mult;\n\n    outer:for(i=0;i<row_size;i++) {\n        middle:for(j=0;j<col_size;j++) {\n            i_col = i * col_size;\n            TYPE sum = 0;\n            inner:for(k=0;k<row_size;k++) {\n                k_col = k * col_size;\n                mult = m1[i_col + k] * m2[k_col + j];\n                sum += mult;\n            }\n            prod[i_col + j]  = sum;\n        }\n    }\n}\n"
      }
    ],
    "code_length": 495,
    "token_count": 153,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/gemver/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 36002052,
    "Worst-caseLatency": 36002052.0,
    "BRAM_18K": 0,
    "LUT": 3232,
    "DSP": 25,
    "FF": 3694,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_gemver",
    "ResourceMetric": 0.0016665712,
    "design_id": "project",
    "algo_name": "gemver",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      },
      {
        "file_name": "gemver.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _GEMVER_H\n# define _GEMVER_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define N 40\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define N 120\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define N 400\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define N 2000\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define N 4000\n#  endif\n\n\n#endif /* !(N) */\n\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_DOUBLE\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_GEMVER_H */\n"
      },
      {
        "file_name": "gemver.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* gemver.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"gemver.h\"\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_gemver(int n,\n\t\t   DATA_TYPE alpha,\n\t\t   DATA_TYPE beta,\n\t\t   DATA_TYPE POLYBENCH_2D(A,N,N,n,n),\n\t\t   DATA_TYPE POLYBENCH_1D(u1,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(v1,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(u2,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(v2,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(w,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(x,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(y,N,n),\n\t\t   DATA_TYPE POLYBENCH_1D(z,N,n))\n{\n  int i, j;\n\n#pragma scop\n\n  for (i = 0; i < _PB_N; i++)\n    for (j = 0; j < _PB_N; j++)\n      A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];\n\n  for (i = 0; i < _PB_N; i++)\n    for (j = 0; j < _PB_N; j++)\n      x[i] = x[i] + beta * A[j][i] * y[j];\n\n  for (i = 0; i < _PB_N; i++)\n    x[i] = x[i] + z[i];\n\n  for (i = 0; i < _PB_N; i++)\n    for (j = 0; j < _PB_N; j++)\n      w[i] = w[i] +  alpha * A[i][j] * x[j];\n\n#pragma endscop\n}\n"
      }
    ],
    "code_length": 1396,
    "token_count": 509,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/gini_impurity/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3082,
    "Worst-caseLatency": null,
    "BRAM_18K": 0,
    "LUT": 1003,
    "DSP": 5,
    "FF": 725,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gini_impurity",
    "ResourceMetric": 0.0004003744,
    "design_id": "project",
    "algo_name": "gini_impurity",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "gini_impurity.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid gini_impurity(int num_classes, int data[ARRAY_SIZE], int class_counts[ARRAY_SIZE], float &gini) {\n    int total_count = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        class_counts[i] = 0;\n    }\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (data[i] < num_classes) {\n            class_counts[data[i]]++;\n            total_count++;\n        }\n    }\n\n    gini = 1.0f;\n    for (int i = 0; i < num_classes; i++) {\n        float prob = (float)class_counts[i] / (float)total_count;\n        gini -= prob * prob;\n    }\n}\n\n// Top function name: gini_impurity\n"
      }
    ],
    "code_length": 615,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/global_array_RAM/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 1,
    "LUT": 169,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 9.88228e-05,
    "design_id": "project",
    "algo_name": "global_array_RAM",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <ap_int.h>\n\nint test(int i);\n\nap_int<10> A[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nap_int<10> B[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\nap_int<10> C[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\nint test(int i) {\n#pragma HLS BIND_STORAGE variable = A type = RAM_2P impl = BRAM\n#pragma HLS BIND_STORAGE variable = B type = RAM_2P impl = LUTRAM\n    // URAM is not a supported implementation type for global arrays\n    // #pragma HLS BIND_STORAGE variable=C type=RAM_2P impl=URAM\n    A[i] += B[i] + C[i];\n    B[i] += 5;\n    C[i] += 10;\n\n    int result = (A[i] + B[i] + C[i]).to_int();\n    return result;\n}\n"
      }
    ],
    "code_length": 1986,
    "token_count": 574,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/global_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4135,
    "Worst-caseLatency": 4135.0,
    "BRAM_18K": 2,
    "LUT": 2886,
    "DSP": 31,
    "FF": 1912,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "global_attention",
    "ResourceMetric": 0.0017195894,
    "design_id": "project",
    "algo_name": "global_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "global_attention.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid global_attention(float query[N], float key[N], float value[N], float output[N]) {\n    float scores[N];\n    float max_score = -INFINITY;\n    float sum_exp_scores = 0.0;\n\n    // Compute the attention scores\n    for (int i = 0; i < N; i++) {\n        scores[i] = query[i] * key[i];\n        if (scores[i] > max_score) {\n            max_score = scores[i];\n        }\n    }\n\n    // Compute the exponentials of the scores and their sum\n    for (int i = 0; i < N; i++) {\n        scores[i] = exp(scores[i] - max_score);\n        sum_exp_scores += scores[i];\n    }\n\n    // Normalize the scores and compute the weighted sum of values\n    for (int i = 0; i < N; i++) {\n        scores[i] /= sum_exp_scores;\n        output[i] = scores[i] * value[i];\n    }\n}\n\n// Top function name: global_attention\n"
      }
    ],
    "code_length": 841,
    "token_count": 229,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/glu/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1054,
    "Worst-caseLatency": 1054.0,
    "BRAM_18K": 0,
    "LUT": 2743,
    "DSP": 37,
    "FF": 1872,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "glu",
    "ResourceMetric": 0.0017305472,
    "design_id": "project",
    "algo_name": "glu",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "glu.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid glu(float input1[SIZE], float input2[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] * (1 / (1 + exp(-input2[i])));\n    }\n}\n\n// Top function name: glu\n"
      }
    ],
    "code_length": 241,
    "token_count": 78,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/gpio_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 85,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gpio_controller",
    "ResourceMetric": 1.8793e-05,
    "design_id": "project",
    "algo_name": "gpio_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "gpio_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define GPIO_SIZE 1024\n\nvoid gpio_controller(uint8_t input_pins[GPIO_SIZE], uint8_t output_pins[GPIO_SIZE], uint8_t control_signal) {\n    for (int i = 0; i < GPIO_SIZE; i++) {\n        if (control_signal & 0x01) {\n            output_pins[i] = input_pins[i];\n        } else {\n            output_pins[i] = 0;\n        }\n    }\n}\n\n// Top function name: gpio_controller\n"
      }
    ],
    "code_length": 384,
    "token_count": 105,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/gps_baseband_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9251,
    "Worst-caseLatency": 9251.0,
    "BRAM_18K": 0,
    "LUT": 8051,
    "DSP": 107,
    "FF": 3917,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gps_baseband_processor",
    "ResourceMetric": 0.0048837876,
    "design_id": "project",
    "algo_name": "gps_baseband_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "gps_baseband_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid gps_baseband_processor(float input_signal[N], float output_signal[N], float carrier_frequency, float sampling_frequency) {\n    float phase = 0.0f;\n    float phase_increment = 2.0f * M_PI * carrier_frequency / sampling_frequency;\n\n    for (int i = 0; i < N; i++) {\n        float in_phase = input_signal[i] * cos(phase);\n        float quadrature = input_signal[i] * sin(phase);\n        output_signal[i] = sqrt(in_phase * in_phase + quadrature * quadrature);\n        phase += phase_increment;\n        if (phase >= 2.0f * M_PI) {\n            phase -= 2.0f * M_PI;\n        }\n    }\n}\n\n// Top function name: gps_baseband_processor\n"
      }
    ],
    "code_length": 682,
    "token_count": 177,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/gps_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1043,
    "Worst-caseLatency": 1043.0,
    "BRAM_18K": 0,
    "LUT": 1095,
    "DSP": 18,
    "FF": 1422,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gps_processor",
    "ResourceMetric": 0.0008449975,
    "design_id": "project",
    "algo_name": "gps_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "gps_processor.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid gps_processor(float latitude[ARRAY_SIZE], float longitude[ARRAY_SIZE], float altitude[ARRAY_SIZE], \n                   float velocity[ARRAY_SIZE], float time[ARRAY_SIZE], float processed_data[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float lat = latitude[i];\n        float lon = longitude[i];\n        float alt = altitude[i];\n        float vel = velocity[i];\n        float t = time[i];\n        \n        // Example processing: calculate distance from a fixed point (lat0, lon0, alt0)\n        float lat0 = 0.0f;\n        float lon0 = 0.0f;\n        float alt0 = 0.0f;\n        \n        float dlat = lat - lat0;\n        float dlon = lon - lon0;\n        float dalt = alt - alt0;\n        \n        float distance = sqrt(dlat * dlat + dlon * dlon + dalt * dalt);\n        \n        // Example processing: calculate some function of velocity and time\n        float velocity_time_product = vel * t;\n        \n        // Combine the results into the processed data\n        processed_data[i] = distance + velocity_time_product;\n    }\n}\n\n// Top function name: gps_processor\n"
      }
    ],
    "code_length": 1128,
    "token_count": 274,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/gradient_accumulation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 24,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gradient_accumulation",
    "ResourceMetric": 2.14777e-05,
    "design_id": "project",
    "algo_name": "gradient_accumulation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "gradient_accumulation.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid gradient_accumulation(ap_int<16> gradients[SIZE], ap_int<16> accumulated_gradients[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        accumulated_gradients[i] += gradients[i];\n    }\n}\n\n// Top function name: gradient_accumulation\n"
      }
    ],
    "code_length": 277,
    "token_count": 73,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/gradient_clipping/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 226,
    "DSP": 0,
    "FF": 158,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gradient_clipping",
    "ResourceMetric": 5.84883e-05,
    "design_id": "project",
    "algo_name": "gradient_clipping",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "gradient_clipping.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n#define CLIP_THRESHOLD 1.0\n\nvoid gradient_clipping(float gradients[ARRAY_SIZE], float clipped_gradients[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (gradients[i] > CLIP_THRESHOLD) {\n            clipped_gradients[i] = CLIP_THRESHOLD;\n        } else if (gradients[i] < -CLIP_THRESHOLD) {\n            clipped_gradients[i] = -CLIP_THRESHOLD;\n        } else {\n            clipped_gradients[i] = gradients[i];\n        }\n    }\n}\n\n// Top function name: gradient_clipping\n"
      }
    ],
    "code_length": 530,
    "token_count": 132,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/graphSAGE/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 655363,
    "Worst-caseLatency": 655363.0,
    "BRAM_18K": 0,
    "LUT": 988,
    "DSP": 1,
    "FF": 263,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "graphSAGE",
    "ResourceMetric": 0.0002423847,
    "design_id": "project",
    "algo_name": "graphSAGE",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "graphSAGE.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define NODES 1024\n#define FEATURES 128\n#define NEIGHBORS 10\n\nvoid graphSAGE(ap_int<16> nodes[NODES][FEATURES], ap_int<16> neighbors[NODES][NEIGHBORS][FEATURES], ap_int<16> output[NODES][FEATURES]) {\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < FEATURES; j++) {\n            ap_int<16> sum = 0;\n            for (int k = 0; k < NEIGHBORS; k++) {\n                sum += neighbors[i][k][j];\n            }\n            output[i][j] = (nodes[i][j] + sum) / (NEIGHBORS + 1);\n        }\n    }\n}\n\n// Top function name: graphSAGE\n"
      }
    ],
    "code_length": 577,
    "token_count": 194,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/graph_embeddings/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3407879,
    "Worst-caseLatency": 139722759.0,
    "BRAM_18K": 128,
    "LUT": 1141,
    "DSP": 0,
    "FF": 321,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "graph_embeddings",
    "ResourceMetric": 0.0081860899,
    "design_id": "project",
    "algo_name": "graph_embeddings",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "graph_embeddings.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define NODES 1024\n#define FEATURES 128\n\nvoid graph_embeddings(ap_int<16> adjacency_matrix[NODES][NODES], ap_int<16> node_features[NODES][FEATURES], ap_int<16> embeddings[NODES][FEATURES]) {\n    ap_int<16> temp_embeddings[NODES][FEATURES];\n\n    // Initialize embeddings with node features\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < FEATURES; j++) {\n            embeddings[i][j] = node_features[i][j];\n        }\n    }\n\n    // Perform one iteration of message passing\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < FEATURES; j++) {\n            temp_embeddings[i][j] = 0;\n        }\n    }\n\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < NODES; j++) {\n            if (adjacency_matrix[i][j] != 0) {\n                for (int k = 0; k < FEATURES; k++) {\n                    temp_embeddings[i][k] += node_features[j][k];\n                }\n            }\n        }\n    }\n\n    // Update embeddings\n    for (int i = 0; i < NODES; i++) {\n        for (int j = 0; j < FEATURES; j++) {\n            embeddings[i][j] = temp_embeddings[i][j];\n        }\n    }\n}\n\n// Top function name: graph_embeddings\n"
      }
    ],
    "code_length": 1181,
    "token_count": 348,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/graphic_display_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 245,
    "DSP": 0,
    "FF": 66,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "graphic_display_processor",
    "ResourceMetric": 5.33106e-05,
    "design_id": "project",
    "algo_name": "graphic_display_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "graphic_display_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid graphic_display_processor(uint8_t input_image[HEIGHT][WIDTH], uint8_t output_image[HEIGHT][WIDTH]) {\n    for (int y = 0; y < HEIGHT; y++) {\n        for (int x = 0; x < WIDTH; x++) {\n            uint8_t pixel = input_image[y][x];\n            // Example processing: Invert the pixel value\n            output_image[y][x] = 255 - pixel;\n        }\n    }\n}\n\n// Top function name: graphic_display_processor\n"
      }
    ],
    "code_length": 465,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/greedy_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 331,
    "DSP": 0,
    "FF": 142,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "greedy_search",
    "ResourceMetric": 7.70895e-05,
    "design_id": "project",
    "algo_name": "greedy_search",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "greedy_search.cpp",
        "file_content": "#include <limits.h>\n\n#define N 1024\n\nvoid greedy_search(int weights[N], int values[N], int capacity, int &max_value) {\n    int current_weight = 0;\n    max_value = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (current_weight + weights[i] <= capacity) {\n            current_weight += weights[i];\n            max_value += values[i];\n        }\n    }\n}\n\n// Top function name: greedy_search\n"
      }
    ],
    "code_length": 389,
    "token_count": 102,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/group_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 503316543,
    "Worst-caseLatency": 503316543.0,
    "BRAM_18K": 32768,
    "LUT": 5427,
    "DSP": 17,
    "FF": 4666,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "group_normalization",
    "ResourceMetric": 2.0337050933,
    "design_id": "project",
    "algo_name": "group_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "group_normalization.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n#define C 64\n#define G 8\n#define H 32\n#define W 32\n\nvoid group_normalization(float input[N][C][H][W], float output[N][C][H][W], float gamma[C], float beta[C]) {\n    float mean[N][G][H][W] = {0};\n    float variance[N][G][H][W] = {0};\n    float epsilon = 1e-5;\n\n    // Calculate mean\n    for (int n = 0; n < N; n++) {\n        for (int g = 0; g < G; g++) {\n            for (int h = 0; h < H; h++) {\n                for (int w = 0; w < W; w++) {\n                    float sum = 0.0;\n                    for (int c = 0; c < C / G; c++) {\n                        sum += input[n][g * (C / G) + c][h][w];\n                    }\n                    mean[n][g][h][w] = sum / (C / G);\n                }\n            }\n        }\n    }\n\n    // Calculate variance\n    for (int n = 0; n < N; n++) {\n        for (int g = 0; g < G; g++) {\n            for (int h = 0; h < H; h++) {\n                for (int w = 0; w < W; w++) {\n                    float sum = 0.0;\n                    for (int c = 0; c < C / G; c++) {\n                        float diff = input[n][g * (C / G) + c][h][w] - mean[n][g][h][w];\n                        sum += diff * diff;\n                    }\n                    variance[n][g][h][w] = sum / (C / G);\n                }\n            }\n        }\n    }\n\n    // Normalize and scale\n    for (int n = 0; n < N; n++) {\n        for (int g = 0; g < G; g++) {\n            for (int h = 0; h < H; h++) {\n                for (int w = 0; w < W; w++) {\n                    for (int c = 0; c < C / G; c++) {\n                        int channel = g * (C / G) + c;\n                        float norm = (input[n][channel][h][w] - mean[n][g][h][w]) / sqrt(variance[n][g][h][w] + epsilon);\n                        output[n][channel][h][w] = norm * gamma[channel] + beta[channel];\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Top function name: group_normalization\n"
      }
    ],
    "code_length": 1936,
    "token_count": 594,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/gru/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4761107,
    "Worst-caseLatency": 4775443.0,
    "BRAM_18K": 9,
    "LUT": 7824,
    "DSP": 44,
    "FF": 4014,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "gru",
    "ResourceMetric": 0.0036622476,
    "design_id": "project",
    "algo_name": "gru",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "gru.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n\nvoid gru(float input[INPUT_SIZE], float hidden_state[HIDDEN_SIZE], \n         float weight_z[HIDDEN_SIZE][INPUT_SIZE], float weight_r[HIDDEN_SIZE][INPUT_SIZE], \n         float weight_h[HIDDEN_SIZE][INPUT_SIZE], float weight_hh[HIDDEN_SIZE][HIDDEN_SIZE], \n         float bias_z[HIDDEN_SIZE], float bias_r[HIDDEN_SIZE], float bias_h[HIDDEN_SIZE], \n         float output[HIDDEN_SIZE]) \n{\n    float z[HIDDEN_SIZE];\n    float r[HIDDEN_SIZE];\n    float h_tilde[HIDDEN_SIZE];\n    float h_new[HIDDEN_SIZE];\n\n    // Compute update gate z\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        z[i] = bias_z[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            z[i] += weight_z[i][j] * input[j];\n        }\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            z[i] += weight_hh[i][j] * hidden_state[j];\n        }\n        z[i] = 1.0f / (1.0f + expf(-z[i])); // Sigmoid function\n    }\n\n    // Compute reset gate r\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        r[i] = bias_r[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            r[i] += weight_r[i][j] * input[j];\n        }\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            r[i] += weight_hh[i][j] * hidden_state[j];\n        }\n        r[i] = 1.0f / (1.0f + expf(-r[i])); // Sigmoid function\n    }\n\n    // Compute candidate hidden state h_tilde\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        h_tilde[i] = bias_h[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            h_tilde[i] += weight_h[i][j] * input[j];\n        }\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            h_tilde[i] += weight_hh[i][j] * hidden_state[j] * r[i];\n        }\n        h_tilde[i] = tanhf(h_tilde[i]); // Tanh function\n    }\n\n    // Compute new hidden state h_new\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        h_new[i] = (1 - z[i]) * h_tilde[i] + z[i] * hidden_state[i];\n    }\n\n    // Update output\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        output[i] = h_new[i];\n    }\n}\n\n// Top function name: gru\n"
      }
    ],
    "code_length": 2070,
    "token_count": 656,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/gsm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1005,
    "Worst-caseLatency": 1678.0,
    "BRAM_18K": 0,
    "LUT": 8477,
    "DSP": 45,
    "FF": 3345,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "Gsm_LPC_Analysis",
    "ResourceMetric": 0.0031929929,
    "design_id": "project",
    "algo_name": "gsm",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "lpc.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*\n * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische\n * Universitaet Berlin.  See the accompanying file \"COPYRIGHT\" for\n * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.\n */\n\n/* $Header: /home/kbs/jutta/src/gsm/gsm-1.0/src/RCS/lpc.c,v 1.5 1994/12/30 23:14:54 jutta Exp $ */\n\n#include \"private.h\"\n\n/*\n *  4.2.4 .. 4.2.7 LPC ANALYSIS SECTION\n */\n\n/* 4.2.4 */\n\n\n#define\tsaturate(x) \t\\\n\t((x) < MIN_WORD ? MIN_WORD : (x) > MAX_WORD ? MAX_WORD: (x))\n\nword\ngsm_add (word a, word b)\n{\n  longword sum;\n  sum = (longword) a + (longword) b;\n  return saturate (sum);\n}\n\nword\ngsm_mult (word a, word b)\n{\n  if (a == MIN_WORD && b == MIN_WORD)\n    return MAX_WORD;\n  else\n    return SASR ((longword) a * (longword) b, 15);\n}\n\nword\ngsm_mult_r (word a, word b)\n{\n  longword prod;\n  if (b == MIN_WORD && a == MIN_WORD)\n    return MAX_WORD;\n  else\n    {\n      prod = (longword) a *(longword) b + 16384;\n      prod >>= 15;\n      return prod & 0xFFFF;\n    }\n}\n\nword\ngsm_abs (word a)\n{\n  return a < 0 ? (a == MIN_WORD ? MAX_WORD : -a) : a;\n}\n\nconst unsigned char bitoff[256] = {\n  8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n};\n\nword\ngsm_norm (longword a)\n/*\n * the number of left shifts needed to normalize the 32 bit\n * variable L_var1 for positive values on the interval\n *\n * with minimum of\n * minimum of 1073741824  (01000000000000000000000000000000) and \n * maximum of 2147483647  (01111111111111111111111111111111)\n *\n *\n * and for negative values on the interval with\n * minimum of -2147483648 (-10000000000000000000000000000000) and\n * maximum of -1073741824 ( -1000000000000000000000000000000).\n *\n * in order to normalize the result, the following\n * operation must be done: L_norm_var1 = L_var1 << norm( L_var1 );\n *\n * (That's 'ffs', only from the left, not the right..)\n */\n{\n\n  if (a < 0)\n    {\n      if (a <= -1073741824)\n\treturn 0;\n      a = ~a;\n    }\n\n  return a & 0xffff0000 ?\n    (a & 0xff000000 ? -1 + bitoff[0xFF & (a >> 24)] :\n     7 + bitoff[0xFF & (a >> 16)])\n    : (a & 0xff00 ? 15 + bitoff[0xFF & (a >> 8)] : 23 + bitoff[0xFF & a]);\n}\n\nword\ngsm_div (word num, word denum)\n{\n  longword L_num;\n  longword L_denum;\n  word div;\n  int k;\n\n  L_num = num;\n  L_denum = denum;\n  div = 0;\n  k = 15;\n  /* The parameter num sometimes becomes zero.\n   * Although this is explicitly guarded against in 4.2.5,\n   * we assume that the result should then be zero as well.\n   */\n\n  if (num == 0)\n    return 0;\n\n  gsmdiv_lp: while (k--)\n  {\n    div <<= 1;\n    L_num <<= 1;\n\n    if (L_num >= L_denum)\n\t  {\n\t    L_num -= L_denum;\n\t    div++;\n\t  }\n  }\n\n  return div;\n}\n\n\nvoid\nAutocorrelation (word * s /* [0..159]     IN/OUT  */ ,\n\t\t longword * L_ACF /* [0..8]       OUT     */ )\n/*\n *  The goal is to compute the array L_ACF[k].  The signal s[i] must\n *  be scaled in order to avoid an overflow situation.\n */\n{\n  register int k, i;\n\n  word temp;\n  word smax;\n  word scalauto, n;\n  word *sp;\n  word sl;\n\n  /*  Search for the maximum.\n   */\n  smax = 0;\n  autocol_lp1: for (k = 0; k <= 159; k++)\n  {\n    temp = GSM_ABS (s[k]);\n    if (temp > smax)\n\t    smax = temp;\n  }\n\n  /*  Computation of the scaling factor.\n   */\n  if (smax == 0)\n    scalauto = 0;\n  else\n    scalauto = 4 - gsm_norm ((longword) smax << 16);\t/* sub(4,..) */\n\n  if (scalauto > 0 && scalauto <= 4)\n    {\n      n = scalauto;\n      for (k = 0; k <= 159; k++)\n\ts[k] = GSM_MULT_R (s[k], 16384 >> (n - 1));\n    }\n\n  /*  Compute the L_ACF[..].\n   */\n  {\n    sp = s;\n    sl = *sp;\n\n#define STEP(k)\t L_ACF[k] += ((longword)sl * sp[ -(k) ]);\n\n#define NEXTI\t sl = *++sp\n    for (k = 8; k >= 0; k--)\n      L_ACF[k] = 0;\n\n    STEP (0);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    STEP (2);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    STEP (2);\n    STEP (3);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    STEP (2);\n    STEP (3);\n    STEP (4);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    STEP (2);\n    STEP (3);\n    STEP (4);\n    STEP (5);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    STEP (2);\n    STEP (3);\n    STEP (4);\n    STEP (5);\n    STEP (6);\n    NEXTI;\n    STEP (0);\n    STEP (1);\n    STEP (2);\n    STEP (3);\n    STEP (4);\n    STEP (5);\n    STEP (6);\n    STEP (7);\n\n    autocol_lp2: for (i = 8; i <= 159; i++)\n      {\n\n\tNEXTI;\n\n\tSTEP (0);\n\tSTEP (1);\n\tSTEP (2);\n\tSTEP (3);\n\tSTEP (4);\n\tSTEP (5);\n\tSTEP (6);\n\tSTEP (7);\n\tSTEP (8);\n      }\n\n    autocol_lp3: for (k = 8; k >= 0; k--)\n      L_ACF[k] <<= 1;\n\n  }\n  /*   Rescaling of the array s[0..159]\n   */\n  if (scalauto > 0)\n    autocol_lp4: for (k = 159; k >= 0; k--)\n      *s++ <<= scalauto;\n}\n\n/* 4.2.5 */\n\nvoid\nReflection_coefficients (longword * L_ACF /* 0...8        IN      */ ,\n\t\t\t register word * r /* 0...7        OUT     */ )\n{\n  register int i, m, n;\n  register word temp;\n  word ACF[9];\t\t\t/* 0..8 */\n  word P[9];\t\t\t/* 0..8 */\n  word K[9];\t\t\t/* 2..8 */\n\n  /*  Schur recursion with 16 bits arithmetic.\n   */\n\n  if (L_ACF[0] == 0)\n    {\n      for (i = 8; i > 0; i--)\n\t*r++ = 0;\n      return;\n    }\n\n  temp = gsm_norm (L_ACF[0]);\n  Reflc_lp1: for (i = 0; i <= 8; i++)\n    ACF[i] = SASR (L_ACF[i] << temp, 16);\n\n  /*   Initialize array P[..] and K[..] for the recursion.\n   */\n\n  Reflc_lp2: for (i = 1; i <= 7; i++)\n    K[i] = ACF[i];\n  Reflc_lp3: for (i = 0; i <= 8; i++)\n    P[i] = ACF[i];\n\n  /*   Compute reflection coefficients\n   */\n  Reflc_lp4: for (n = 1; n <= 8; n++, r++)\n  {\n\n    temp = P[1];\n    temp = GSM_ABS (temp);\n    if (P[0] < temp)\n\t  {\n\t    Reflc_lp5: for (i = n; i <= 8; i++)\n\t    *r++ = 0;\n\t    return;\n\t  }\n\n    *r = gsm_div (temp, P[0]);\n\n    if (P[1] > 0)\n\t    *r = -*r;\t\t/* r[n] = sub(0, r[n]) */\n      if (n == 8)\n\t      return;\n\n      /*  Schur recursion\n       */\n    temp = GSM_MULT_R (P[1], *r);\n    P[0] = GSM_ADD (P[0], temp);\n\n    Reflc_lp6: for (m = 1; m <= 8 - n; m++)\n\t  {\n\t    temp = GSM_MULT_R (K[m], *r);\n\t    P[m] = GSM_ADD (P[m + 1], temp);\n\n\t    temp = GSM_MULT_R (P[m + 1], *r);\n\t    K[m] = GSM_ADD (K[m], temp);\n\t  }\n  }\n}\n\n/* 4.2.6 */\n\nvoid\nTransformation_to_Log_Area_Ratios (register word * r /* 0..7    IN/OUT */ )\n/*\n *  The following scaling for r[..] and LAR[..] has been used:\n *\n *  r[..]   = integer( real_r[..]*32768. ); -1 <= real_r < 1.\n *  LAR[..] = integer( real_LAR[..] * 16384 );\n *  with -1.625 <= real_LAR <= 1.625\n */\n{\n  register word temp;\n  register int i;\n\n\n  /* Computation of the LAR[0..7] from the r[0..7]\n   */\n  trans_lp: for (i = 1; i <= 8; i++, r++)\n  {\n\n    temp = *r;\n    temp = GSM_ABS (temp);\n\n    if (temp < 22118)\n\t  {\n\t    temp >>= 1;\n\t  }\n    else if (temp < 31130)\n\t  {\n\t    temp -= 11059;\n\t  }\n    else\n\t  {\n\t    temp -= 26112;\n\t    temp <<= 2;\n\t  }\n\n      *r = *r < 0 ? -temp : temp;\n  }\n}\n\n/* 4.2.7 */\n\nvoid\nQuantization_and_coding (register word * LAR /* [0..7]       IN/OUT  */ )\n{\n  register word temp;\n\n\n  /*  This procedure needs four tables; the following equations\n   *  give the optimum scaling for the constants:\n   *  \n   *  A[0..7] = integer( real_A[0..7] * 1024 )\n   *  B[0..7] = integer( real_B[0..7] *  512 )\n   *  MAC[0..7] = maximum of the LARc[0..7]\n   *  MIC[0..7] = minimum of the LARc[0..7]\n   */\n\n#\tundef STEP\n#\tdefine\tSTEP( A, B, MAC, MIC )\t\t\\\n\t\ttemp = GSM_MULT( A,   *LAR );\t\\\n\t\ttemp = GSM_ADD(  temp,   B );\t\\\n\t\ttemp = GSM_ADD(  temp, 256 );\t\\\n\t\ttemp = SASR(     temp,   9 );\t\\\n\t\t*LAR  =  temp>MAC ? MAC - MIC : (temp<MIC ? 0 : temp - MIC); \\\n\t\tLAR++;\n\n  STEP (20480, 0, 31, -32);\n  STEP (20480, 0, 31, -32);\n  STEP (20480, 2048, 15, -16);\n  STEP (20480, -2560, 15, -16);\n\n  STEP (13964, 94, 7, -8);\n  STEP (15360, -1792, 7, -8);\n  STEP (8534, -341, 3, -4);\n  STEP (9036, -1144, 3, -4);\n\n#\tundef\tSTEP\n}\n\nvoid\nGsm_LPC_Analysis (word s[160] /* 0..159 signals       IN/OUT  */ ,\n\t\t  word LARc[8] /* 0..7   LARc's        OUT     */ )\n{\n  longword L_ACF[9];\n\n  Autocorrelation (s, L_ACF);\n  Reflection_coefficients (L_ACF, LARc);\n  Transformation_to_Log_Area_Ratios (LARc);\n  Quantization_and_coding (LARc);\n}"
      },
      {
        "file_name": "private.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*\n * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische\n * Universitaet Berlin.  See the accompanying file \"COPYRIGHT\" for\n * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.\n */\n\n/*$Header: /home/kbs/jutta/src/gsm/gsm-1.0/inc/RCS/private.h,v 1.4 1994/11/28 20:25:03 jutta Exp $*/\n\n#ifndef\tPRIVATE_H\n#define\tPRIVATE_H\n\ntypedef short word;\t\t/* 16 bit signed int    */\ntypedef long longword;\t\t/* 32 bit signed int    */\n\n#define\tMIN_WORD\t((-32767)-1)\n#define\tMAX_WORD\t( 32767)\n\n#define\tSASR(x, by)\t((x) >> (by))\n\n#define GSM_MULT_R(a, b)\tgsm_mult_r(a, b)\n#define GSM_MULT(a, b)\t\tgsm_mult(a, b)\n#define GSM_ADD(a, b)\t\tgsm_add(a, b)\n#define GSM_ABS(a)\t\tgsm_abs(a)\n\nword gsm_div (word num, word denum);\nword gsm_add (word a, word b);\nword gsm_mult (word a, word b);\nword gsm_abs (word a);\nword gsm_norm (longword a);\nword gsm_mult_r (word a, word b);\n\n#endif /* PRIVATE_H */\n"
      }
    ],
    "code_length": 9869,
    "token_count": 3930,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hamming_distance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 915,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hamming_distance",
    "ResourceMetric": 0.0001778619,
    "design_id": "project",
    "algo_name": "hamming_distance",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hamming_distance.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid hamming_distance(ap_uint<32> array1[ARRAY_SIZE], ap_uint<32> array2[ARRAY_SIZE], ap_uint<32> result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<32> x = array1[i] ^ array2[i];\n        ap_uint<32> count = 0;\n        for (int j = 0; j < 32; j++) {\n            count += x[j];\n        }\n        result[i] = count;\n    }\n}\n\n// Top function name: hamming_distance\n"
      }
    ],
    "code_length": 438,
    "token_count": 139,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/hamming_encoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 103,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hamming_encoder",
    "ResourceMetric": 2.21488e-05,
    "design_id": "project",
    "algo_name": "hamming_encoder",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "hamming_encoder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid hamming_encoder(ap_uint<8> data_in[DATA_SIZE], ap_uint<12> data_out[DATA_SIZE]) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        ap_uint<8> d = data_in[i];\n        ap_uint<12> encoded = 0;\n\n        // Assign data bits\n        encoded[2] = d[0];\n        encoded[4] = d[1];\n        encoded[5] = d[2];\n        encoded[6] = d[3];\n        encoded[8] = d[4];\n        encoded[9] = d[5];\n        encoded[10] = d[6];\n        encoded[11] = d[7];\n\n        // Calculate parity bits\n        encoded[0] = d[0] ^ d[1] ^ d[3] ^ d[4] ^ d[6];\n        encoded[1] = d[0] ^ d[2] ^ d[3] ^ d[5] ^ d[6];\n        encoded[3] = d[1] ^ d[2] ^ d[3] ^ d[7];\n        encoded[7] = d[4] ^ d[5] ^ d[6] ^ d[7];\n\n        data_out[i] = encoded;\n    }\n}\n\n// Top function name: hamming_encoder\n"
      }
    ],
    "code_length": 808,
    "token_count": 302,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/hamming_encoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 147,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hamming_encoder",
    "ResourceMetric": 3.05865e-05,
    "design_id": "project",
    "algo_name": "hamming_encoder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "hamming_encoder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid hamming_encoder(ap_uint<16> input[DATA_SIZE], ap_uint<21> output[DATA_SIZE]) {\n    for (int idx = 0; idx < DATA_SIZE; idx++) {\n        ap_uint<16> data = input[idx];\n        ap_uint<21> encoded = 0;\n\n        // Assign data bits to encoded positions\n        encoded[2] = data[0];\n        encoded[4] = data[1];\n        encoded[5] = data[2];\n        encoded[6] = data[3];\n        encoded[8] = data[4];\n        encoded[9] = data[5];\n        encoded[10] = data[6];\n        encoded[11] = data[7];\n        encoded[12] = data[8];\n        encoded[13] = data[9];\n        encoded[14] = data[10];\n        encoded[16] = data[11];\n        encoded[17] = data[12];\n        encoded[18] = data[13];\n        encoded[19] = data[14];\n        encoded[20] = data[15];\n\n        // Calculate parity bits\n        encoded[0] = encoded[2] ^ encoded[4] ^ encoded[6] ^ encoded[8] ^ encoded[10] ^ encoded[12] ^ encoded[14] ^ encoded[16] ^ encoded[18] ^ encoded[20];\n        encoded[1] = encoded[2] ^ encoded[5] ^ encoded[6] ^ encoded[9] ^ encoded[10] ^ encoded[13] ^ encoded[14] ^ encoded[17] ^ encoded[18];\n        encoded[3] = encoded[4] ^ encoded[5] ^ encoded[6] ^ encoded[11] ^ encoded[12] ^ encoded[13] ^ encoded[14] ^ encoded[19] ^ encoded[20];\n        encoded[7] = encoded[8] ^ encoded[9] ^ encoded[10] ^ encoded[11] ^ encoded[12] ^ encoded[13] ^ encoded[14];\n        encoded[15] = encoded[16] ^ encoded[17] ^ encoded[18] ^ encoded[19] ^ encoded[20];\n\n        output[idx] = encoded;\n    }\n}\n\n// Top function name: hamming_encoder\n"
      }
    ],
    "code_length": 1556,
    "token_count": 496,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hamming_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 129,
    "DSP": 0,
    "FF": 24,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hamming_loss",
    "ResourceMetric": 2.70388e-05,
    "design_id": "project",
    "algo_name": "hamming_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hamming_loss.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid hamming_loss(ap_uint<1> y_true[ARRAY_SIZE], ap_uint<1> y_pred[ARRAY_SIZE], ap_uint<10> &loss) {\n    ap_uint<10> count = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (y_true[i] != y_pred[i]) {\n            count++;\n        }\n    }\n    loss = count;\n}\n\n// Top function name: hamming_loss\n"
      }
    ],
    "code_length": 348,
    "token_count": 111,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hash_encoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 118,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hash_encoding",
    "ResourceMetric": 2.80936e-05,
    "design_id": "project",
    "algo_name": "hash_encoding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hash_encoding.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid hash_encoding(ap_uint<32> input[ARRAY_SIZE], ap_uint<32> output[ARRAY_SIZE]) {\n    ap_uint<32> hash = 0xDEADBEEF;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        hash = (hash << 5) ^ (hash >> 27) ^ input[i];\n        output[i] = hash;\n    }\n}\n\n// Top function name: hash_encoding\n"
      }
    ],
    "code_length": 333,
    "token_count": 107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hashing_techniques/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3083,
    "Worst-caseLatency": 3083.0,
    "BRAM_18K": 2,
    "LUT": 319,
    "DSP": 0,
    "FF": 61,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hashing_techniques",
    "ResourceMetric": 0.0001910298,
    "design_id": "project",
    "algo_name": "hashing_techniques",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hashing_techniques.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid hashing_techniques(ap_uint<32> input[ARRAY_SIZE], ap_uint<32> output[ARRAY_SIZE]) {\n    ap_uint<32> hash_table[ARRAY_SIZE];\n\n    // Initialize hash table\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        hash_table[i] = 0;\n    }\n\n    // Simple hash function and insertion\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<32> hash_value = input[i] % ARRAY_SIZE;\n        hash_table[hash_value] = input[i];\n    }\n\n    // Output the hash table\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = hash_table[i];\n    }\n}\n\n// Top function name: hashing_techniques\n"
      }
    ],
    "code_length": 630,
    "token_count": 184,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/hazard_detection_resolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 297,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hazard_detection_resolution",
    "ResourceMetric": 5.93512e-05,
    "design_id": "project",
    "algo_name": "hazard_detection_resolution",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "hazard_detection_resolution.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid hazard_detection_resolution(int32_t input1[ARRAY_SIZE], int32_t input2[ARRAY_SIZE], int32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        int32_t temp1 = input1[i];\n        int32_t temp2 = input2[i];\n        \n        // Hazard detection and resolution logic\n        if (temp1 > temp2) {\n            output[i] = temp1 - temp2;\n        } else if (temp1 < temp2) {\n            output[i] = temp2 - temp1;\n        } else {\n            output[i] = 0; // No hazard\n        }\n    }\n}\n\n// Top function name: hazard_detection_resolution\n"
      }
    ],
    "code_length": 605,
    "token_count": 165,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/hcmos_enhanced_floating_point_coprocessor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1042,
    "Worst-caseLatency": 1042.0,
    "BRAM_18K": 0,
    "LUT": 5602,
    "DSP": 33,
    "FF": 2288,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hcmos_enhanced_floating_point_coprocessor",
    "ResourceMetric": 0.0022078744,
    "design_id": "project",
    "algo_name": "hcmos_enhanced_floating_point_coprocessor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "hcmos_enhanced_floating_point_coprocessor.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid hcmos_enhanced_floating_point_coprocessor(float input1[SIZE], float input2[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        float a = input1[i];\n        float b = input2[i];\n        float result = 0.0f;\n\n        // Perform some floating-point operations\n        result = a * b;\n        result += std::sin(a);\n        result -= std::cos(b);\n        result = std::sqrt(result);\n\n        output[i] = result;\n    }\n}\n\n// Top function name: hcmos_enhanced_floating_point_coprocessor\n"
      }
    ],
    "code_length": 545,
    "token_count": 152,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/hcmos_floating_point_coprocessor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1037,
    "Worst-caseLatency": 1037.0,
    "BRAM_18K": 0,
    "LUT": 973,
    "DSP": 12,
    "FF": 1218,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hcmos_floating_point_coprocessor",
    "ResourceMetric": 0.0006358188,
    "design_id": "project",
    "algo_name": "hcmos_floating_point_coprocessor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "hcmos_floating_point_coprocessor.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid hcmos_floating_point_coprocessor(float input1[ARRAY_SIZE], float input2[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float a = input1[i];\n        float b = input2[i];\n        output[i] = (a + b) * (a - b) + std::sqrt(a * b);\n    }\n}\n\n// Top function name: hcmos_floating_point_coprocessor\n"
      }
    ],
    "code_length": 384,
    "token_count": 119,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/hier_func/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 78,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hier_func4",
    "ResourceMetric": 1.49577e-05,
    "design_id": "project",
    "algo_name": "hier_func",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*******************************************************************************\nVendor: Xilinx\nAssociated Filename: hier_func4.c\nPurpose:Vivado HLS Coding Style example\nDevice: All\nRevision History: May 30, 2008 - initial release\n\n*******************************************************************************\nCopyright (C) 2014-2019 XILINX, Inc.\n\nThis file contains confidential and proprietary information of Xilinx, Inc. and\nis protected under U.S. and international copyright and other intellectual\nproperty laws.\n\nDISCLAIMER\nThis disclaimer is not a license and does not grant any rights to the materials\ndistributed herewith. Except as otherwise provided in a valid license issued to\nyou by Xilinx, and to the maximum extent permitted by applicable law:\n(1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND WITH ALL FAULTS, AND XILINX\nHEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,\nINCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR\nFITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether\nin contract or tort, including negligence, or under any other theory of\nliability) for any loss or damage of any kind or nature related to, arising\nunder or in connection with these materials, including for any direct, or any\nindirect, special, incidental, or consequential loss or damage (including loss\nof data, profits, goodwill, or any type of loss or damage suffered as a result\nof any action brought by a third party) even if such damage or loss was\nreasonably foreseeable or Xilinx had been advised of the possibility of the\nsame.\n\nCRITICAL APPLICATIONS\nXilinx products are not designed or intended to be fail-safe, or for use in any\napplication requiring fail-safe performance, such as life-support or safety\ndevices or systems, Class III medical devices, nuclear facilities, applications\nrelated to the deployment of airbags, or any other applications that could lead\nto death, personal injury, or severe property or environmental damage\n(individually and collectively, \"Critical Applications\"). Customer assumes the\nsole risk and liability of any use of Xilinx products in Critical Applications,\nsubject only to applicable laws and regulations governing limitations on product\nliability.\n\nTHIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT\nALL TIMES.\n\n*******************************************************************************/\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _hier_func4_H_\n#define _hier_func4_H_\n\n// Missing include: #include <stdio.h>\n\n#define NUM_TRANS 40\n\ntypedef int din_t;\ntypedef int dint_t;\ntypedef int dout_t;\n\nvoid hier_func4(din_t A, din_t B, dout_t* C, dout_t* D);\n\n#endif\n\nvoid sumsub_func(din_t* in1, din_t* in2, dint_t* outSum, dint_t* outSub) {\n    *outSum = *in1 + *in2;\n    *outSub = *in1 - *in2;\n}\n\nvoid shift_func(dint_t* in1, dint_t* in2, dout_t* outA, dout_t* outB) {\n    *outA = *in1 >> 1;\n    *outB = *in2 >> 2;\n}\n\nvoid hier_func4(din_t A, din_t B, dout_t* C, dout_t* D) {\n    dint_t apb, amb;\n\n    sumsub_func(&A, &B, &apb, &amb);\n#ifndef __SYNTHESIS__\n    FILE* fp1;\n    char filename[255];\n    sprintf(filename, \"Out_apb_%03d.dat\", apb);\n    fp1 = fopen(filename, \"w\");\n    fprintf(fp1, \"%d \\n\", apb);\n    fclose(fp1);\n#endif\n    shift_func(&apb, &amb, C, D);\n}\n"
      }
    ],
    "code_length": 4678,
    "token_count": 1107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hierarchical_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097161,
    "Worst-caseLatency": 2097161.0,
    "BRAM_18K": 2048,
    "LUT": 616,
    "DSP": 3,
    "FF": 312,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hierarchical_attention",
    "ResourceMetric": 0.1272152812,
    "design_id": "project",
    "algo_name": "hierarchical_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hierarchical_attention.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define LARGE_SCALE 1024\n\nvoid hierarchical_attention(float input[LARGE_SCALE][LARGE_SCALE], float output[LARGE_SCALE][LARGE_SCALE], float weights1[LARGE_SCALE], float weights2[LARGE_SCALE]) {\n    float intermediate[LARGE_SCALE][LARGE_SCALE];\n\n    // First attention layer\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            intermediate[i][j] = input[i][j] * weights1[j];\n        }\n    }\n\n    // Second attention layer\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            output[i][j] = intermediate[i][j] * weights2[j];\n        }\n    }\n}\n\n// Top function name: hierarchical_attention\n"
      }
    ],
    "code_length": 726,
    "token_count": 195,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hierarchical_classification/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 0,
    "LUT": 503,
    "DSP": 0,
    "FF": 58,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hierarchical_classification",
    "ResourceMetric": 0.0001020189,
    "design_id": "project",
    "algo_name": "hierarchical_classification",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hierarchical_classification.cpp",
        "file_content": "#include <iostream>\n\n#define LARGE_SCALE 1024\n\nvoid hierarchical_classification(int input[LARGE_SCALE], int output[LARGE_SCALE]) {\n    int intermediate[LARGE_SCALE];\n\n    // First level classification\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        if (input[i] < 100) {\n            intermediate[i] = 0;\n        } else if (input[i] < 200) {\n            intermediate[i] = 1;\n        } else {\n            intermediate[i] = 2;\n        }\n    }\n\n    // Second level classification\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        if (intermediate[i] == 0) {\n            if (input[i] < 50) {\n                output[i] = 0;\n            } else {\n                output[i] = 1;\n            }\n        } else if (intermediate[i] == 1) {\n            if (input[i] < 150) {\n                output[i] = 2;\n            } else {\n                output[i] = 3;\n            }\n        } else {\n            if (input[i] < 250) {\n                output[i] = 4;\n            } else {\n                output[i] = 5;\n            }\n        }\n    }\n}\n\n// Top function name: hierarchical_classification\n"
      }
    ],
    "code_length": 1081,
    "token_count": 278,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hierarchical_federated_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048600,
    "Worst-caseLatency": 1048600.0,
    "BRAM_18K": 0,
    "LUT": 1615,
    "DSP": 7,
    "FF": 1236,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hierarchical_federated_learning",
    "ResourceMetric": 0.0006221382,
    "design_id": "project",
    "algo_name": "hierarchical_federated_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hierarchical_federated_learning.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define NUM_CLIENTS 1024\n#define NUM_FEATURES 256\n\nvoid hierarchical_federated_learning(\n    float global_model[NUM_FEATURES],\n    float local_models[NUM_CLIENTS][NUM_FEATURES],\n    float client_data[NUM_CLIENTS][NUM_FEATURES],\n    float learning_rate\n) {\n    // Initialize local models to global model\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            local_models[i][j] = global_model[j];\n        }\n    }\n\n    // Simulate local training\n    for (int i = 0; i < NUM_CLIENTS; i++) {\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            // Simple gradient descent step\n            float gradient = client_data[i][j] - local_models[i][j];\n            local_models[i][j] += learning_rate * gradient;\n        }\n    }\n\n    // Aggregate local models to update global model\n    for (int j = 0; j < NUM_FEATURES; j++) {\n        float sum = 0.0;\n        for (int i = 0; i < NUM_CLIENTS; i++) {\n            sum += local_models[i][j];\n        }\n        global_model[j] = sum / NUM_CLIENTS;\n    }\n}\n\n// Top function name: hierarchical_federated_learning\n"
      }
    ],
    "code_length": 1143,
    "token_count": 306,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/high_frequency_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 3,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "high_frequency_multiplier",
    "ResourceMetric": 0.00010411,
    "design_id": "project",
    "algo_name": "high_frequency_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "high_frequency_multiplier.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid high_frequency_multiplier(int input1[SIZE], int input2[SIZE], int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] * input2[i];\n    }\n}\n\n// Top function name: high_frequency_multiplier\n"
      }
    ],
    "code_length": 264,
    "token_count": 74,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/high_performance_floating_point_coprocessor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1037,
    "Worst-caseLatency": 1037.0,
    "BRAM_18K": 0,
    "LUT": 5538,
    "DSP": 33,
    "FF": 2150,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "high_performance_floating_point_coprocessor",
    "ResourceMetric": 0.0021823697,
    "design_id": "project",
    "algo_name": "high_performance_floating_point_coprocessor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "high_performance_floating_point_coprocessor.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid high_performance_floating_point_coprocessor(float input1[SIZE], float input2[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = std::sin(input1[i]) + std::cos(input2[i]) + std::sqrt(input1[i] * input2[i]);\n    }\n}\n\n// Top function name: high_performance_floating_point_coprocessor\n"
      }
    ],
    "code_length": 358,
    "token_count": 105,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/high_speed_advanced_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "high_speed_advanced_adder",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "high_speed_advanced_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "high_speed_advanced_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid high_speed_advanced_adder(ap_int<32> A[SIZE], ap_int<32> B[SIZE], ap_int<32> C[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: high_speed_advanced_adder\n"
      }
    ],
    "code_length": 255,
    "token_count": 88,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/high_speed_cmos_logic_4bit_binary_full_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "high_speed_cmos_logic_4bit_binary_full_adder",
    "ResourceMetric": 2.09983e-05,
    "design_id": "project",
    "algo_name": "high_speed_cmos_logic_4bit_binary_full_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "high_speed_cmos_logic_4bit_binary_full_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid high_speed_cmos_logic_4bit_binary_full_adder(ap_uint<4> A[N], ap_uint<4> B[N], ap_uint<1> Cin[N], ap_uint<4> Sum[N], ap_uint<1> Cout[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<5> temp_sum = A[i] + B[i] + Cin[i];\n        Sum[i] = temp_sum.range(3, 0);\n        Cout[i] = temp_sum[4];\n    }\n}\n\n// Top function name: high_speed_cmos_logic_4bit_binary_full_adder\n"
      }
    ],
    "code_length": 413,
    "token_count": 145,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/high_speed_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "high_speed_comparator",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "high_speed_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "high_speed_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid high_speed_comparator(ap_int<32> input1[ARRAY_SIZE], ap_int<32> input2[ARRAY_SIZE], ap_int<1> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input1[i] > input2[i]) ? 1 : 0;\n    }\n}\n\n// Top function name: high_speed_comparator\n"
      }
    ],
    "code_length": 316,
    "token_count": 103,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hinge_embedding_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1033,
    "Worst-caseLatency": 1033.0,
    "BRAM_18K": 0,
    "LUT": 638,
    "DSP": 5,
    "FF": 794,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hinge_embedding_loss",
    "ResourceMetric": 0.0003369961,
    "design_id": "project",
    "algo_name": "hinge_embedding_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hinge_embedding_loss.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid hinge_embedding_loss(float input1[SIZE], float input2[SIZE], float output[SIZE], float margin) {\n    for (int i = 0; i < SIZE; i++) {\n        float distance = input1[i] - input2[i];\n        float squared_distance = distance * distance;\n        if (squared_distance < margin) {\n            output[i] = squared_distance;\n        } else {\n            output[i] = margin;\n        }\n    }\n}\n\n// Top function name: hinge_embedding_loss\n"
      }
    ],
    "code_length": 472,
    "token_count": 116,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/hinge_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1032,
    "Worst-caseLatency": 1032.0,
    "BRAM_18K": 0,
    "LUT": 493,
    "DSP": 5,
    "FF": 502,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hinge_loss",
    "ResourceMetric": 0.0002811926,
    "design_id": "project",
    "algo_name": "hinge_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "hinge_loss.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid hinge_loss(float y_true[ARRAY_SIZE], float y_pred[ARRAY_SIZE], float loss[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float margin = 1.0f - y_true[i] * y_pred[i];\n        if (margin > 0) {\n            loss[i] = margin;\n        } else {\n            loss[i] = 0.0f;\n        }\n    }\n}\n\n// Top function name: hinge_loss\n"
      }
    ],
    "code_length": 386,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/histogram_equalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2837,
    "Worst-caseLatency": 2837.0,
    "BRAM_18K": 2,
    "LUT": 1125,
    "DSP": 0,
    "FF": 323,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "histogram_equalization",
    "ResourceMetric": 0.0003707134,
    "design_id": "project",
    "algo_name": "histogram_equalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "histogram_equalization.cpp",
        "file_content": "#include <ap_int.h>\n\n#define IMAGE_SIZE 1024\n#define GRAY_LEVELS 256\n\nvoid histogram_equalization(ap_uint<8> input_image[IMAGE_SIZE], ap_uint<8> output_image[IMAGE_SIZE]) {\n    ap_uint<32> histogram[GRAY_LEVELS] = {0};\n    ap_uint<32> cumulative_histogram[GRAY_LEVELS] = {0};\n    ap_uint<8> lut[GRAY_LEVELS] = {0};\n\n    // Calculate histogram\n    for (int i = 0; i < IMAGE_SIZE; i++) {\n        histogram[input_image[i]]++;\n    }\n\n    // Calculate cumulative histogram\n    cumulative_histogram[0] = histogram[0];\n    for (int i = 1; i < GRAY_LEVELS; i++) {\n        cumulative_histogram[i] = cumulative_histogram[i - 1] + histogram[i];\n    }\n\n    // Calculate LUT (Look-Up Table)\n    for (int i = 0; i < GRAY_LEVELS; i++) {\n        lut[i] = (cumulative_histogram[i] * (GRAY_LEVELS - 1)) / IMAGE_SIZE;\n    }\n\n    // Apply LUT to input image to get the output image\n    for (int i = 0; i < IMAGE_SIZE; i++) {\n        output_image[i] = lut[input_image[i]];\n    }\n}\n\n// Top function name: histogram_equalization\n"
      }
    ],
    "code_length": 1006,
    "token_count": 292,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/histogram_equalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2618,
    "Worst-caseLatency": 3131.0,
    "BRAM_18K": 2,
    "LUT": 2884,
    "DSP": 0,
    "FF": 2845,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "histogram_equalization",
    "ResourceMetric": 0.0009498433,
    "design_id": "project",
    "algo_name": "histogram_equalization",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "histogram_equalization.cpp",
        "file_content": "#include <ap_int.h>\n\n#define IMAGE_SIZE 1024\n#define GRAY_LEVELS 256\n\nvoid histogram_equalization(ap_uint<8> input_image[IMAGE_SIZE], ap_uint<8> output_image[IMAGE_SIZE]) {\n    int histogram[GRAY_LEVELS] = {0};\n    int cdf[GRAY_LEVELS] = {0};\n    int cdf_min = 0;\n    int num_pixels = IMAGE_SIZE;\n\n    // Calculate histogram\n    for (int i = 0; i < IMAGE_SIZE; i++) {\n        histogram[input_image[i]]++;\n    }\n\n    // Calculate CDF (Cumulative Distribution Function)\n    cdf[0] = histogram[0];\n    for (int i = 1; i < GRAY_LEVELS; i++) {\n        cdf[i] = cdf[i - 1] + histogram[i];\n    }\n\n    // Find the minimum non-zero value in CDF\n    for (int i = 0; i < GRAY_LEVELS; i++) {\n        if (cdf[i] != 0) {\n            cdf_min = cdf[i];\n            break;\n        }\n    }\n\n    // Apply histogram equalization\n    for (int i = 0; i < IMAGE_SIZE; i++) {\n        output_image[i] = (ap_uint<8>)(((cdf[input_image[i]] - cdf_min) * (GRAY_LEVELS - 1)) / (num_pixels - cdf_min));\n    }\n}\n\n// Top function name: histogram_equalization\n"
      }
    ],
    "code_length": 1026,
    "token_count": 316,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/histogram_hough_transform_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097353,
    "Worst-caseLatency": 2097353.0,
    "BRAM_18K": 0,
    "LUT": 710,
    "DSP": 0,
    "FF": 513,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "histogram_hough_transform_processor",
    "ResourceMetric": 0.0001853407,
    "design_id": "project",
    "algo_name": "histogram_hough_transform_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "histogram_hough_transform_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define IMAGE_WIDTH 1024\n#define IMAGE_HEIGHT 1024\n#define MAX_BINS 180\n\nvoid histogram_hough_transform_processor(ap_uint<8> image[IMAGE_HEIGHT][IMAGE_WIDTH], ap_uint<16> histogram[MAX_BINS]) {\n    // Initialize histogram bins to zero\n    for (int i = 0; i < MAX_BINS; i++) {\n        histogram[i] = 0;\n    }\n\n    // Process the image and populate the histogram\n    for (int y = 0; y < IMAGE_HEIGHT; y++) {\n        for (int x = 0; x < IMAGE_WIDTH; x++) {\n            // Example processing: simple threshold to detect edges\n            if (image[y][x] > 128) {\n                // Calculate a simple angle for demonstration purposes\n                int angle = (x + y) % MAX_BINS;\n                histogram[angle]++;\n            }\n        }\n    }\n}\n// Top function name: histogram_hough_transform_processor\n"
      }
    ],
    "code_length": 825,
    "token_count": 208,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/homogeneity_score/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5277696,
    "Worst-caseLatency": 5277696.0,
    "BRAM_18K": 0,
    "LUT": 2770,
    "DSP": 3,
    "FF": 1203,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "homogeneity_score",
    "ResourceMetric": 0.0007296469,
    "design_id": "project",
    "algo_name": "homogeneity_score",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "homogeneity_score.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define SIZE 1024\n\nvoid homogeneity_score(int input[SIZE][SIZE], double output[SIZE][SIZE]) {\n    int i, j;\n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            int sum = 0;\n            int count = 0;\n\n            // Check the 3x3 neighborhood\n            for (int di = -1; di <= 1; di++) {\n                for (int dj = -1; dj <= 1; dj++) {\n                    int ni = i + di;\n                    int nj = j + dj;\n                    if (ni >= 0 && ni < SIZE && nj >= 0 && nj < SIZE) {\n                        sum += std::abs(input[i][j] - input[ni][nj]);\n                        count++;\n                    }\n                }\n            }\n\n            // Calculate the homogeneity score\n            output[i][j] = 1.0 / (1.0 + (double)sum / count);\n        }\n    }\n}\n\n// Top function name: homogeneity_score\n"
      }
    ],
    "code_length": 880,
    "token_count": 238,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/homomorphic_encryption/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "homomorphic_encryption",
    "ResourceMetric": 2.32994e-05,
    "design_id": "project",
    "algo_name": "homomorphic_encryption",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "homomorphic_encryption.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid homomorphic_encryption(ap_uint<32> input[N], ap_uint<32> key[N], ap_uint<32> output[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<32> encrypted_value = input[i] ^ key[i];\n        output[i] = encrypted_value;\n    }\n}\n\n// Top function name: homomorphic_encryption\n"
      }
    ],
    "code_length": 314,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/hough_transform/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3406374,
    "Worst-caseLatency": 231995942.0,
    "BRAM_18K": 0,
    "LUT": 14805,
    "DSP": 201,
    "FF": 5974,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "hough_transform",
    "ResourceMetric": 0.0089803643,
    "design_id": "project",
    "algo_name": "hough_transform",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "hough_transform.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n#define THETA_SIZE 180\n#define RHO_SIZE 1448\n\nvoid hough_transform(ap_uint<8> image[HEIGHT][WIDTH], ap_uint<32> accumulator[THETA_SIZE][RHO_SIZE]) {\n    int x, y, theta;\n    int rho;\n    float theta_radians;\n    float cos_theta, sin_theta;\n\n    // Initialize the accumulator array\n    for (theta = 0; theta < THETA_SIZE; theta++) {\n        for (rho = 0; rho < RHO_SIZE; rho++) {\n            accumulator[theta][rho] = 0;\n        }\n    }\n\n    // Perform the Hough Transform\n    for (y = 0; y < HEIGHT; y++) {\n        for (x = 0; x < WIDTH; x++) {\n            if (image[y][x] > 0) { // Edge pixel\n                for (theta = 0; theta < THETA_SIZE; theta++) {\n                    theta_radians = theta * M_PI / 180.0;\n                    cos_theta = cos(theta_radians);\n                    sin_theta = sin(theta_radians);\n                    rho = (int)(x * cos_theta + y * sin_theta + (RHO_SIZE / 2));\n                    if (rho >= 0 && rho < RHO_SIZE) {\n                        accumulator[theta][rho]++;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Top function name: hough_transform\n"
      }
    ],
    "code_length": 1193,
    "token_count": 321,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/huber_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1045,
    "Worst-caseLatency": 1045.0,
    "BRAM_18K": 0,
    "LUT": 1654,
    "DSP": 21,
    "FF": 2017,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "huber_loss",
    "ResourceMetric": 0.0010923558,
    "design_id": "project",
    "algo_name": "huber_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "huber_loss.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid huber_loss(float y_true[N], float y_pred[N], float delta, float loss[N]) {\n    for (int i = 0; i < N; i++) {\n        float diff = y_true[i] - y_pred[i];\n        if (std::abs(diff) <= delta) {\n            loss[i] = 0.5 * diff * diff;\n        } else {\n            loss[i] = delta * (std::abs(diff) - 0.5 * delta);\n        }\n    }\n}\n\n// Top function name: huber_loss\n"
      }
    ],
    "code_length": 403,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/i2c_master_slave_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 221,
    "DSP": 0,
    "FF": 48,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "i2c_master_slave_controller",
    "ResourceMetric": 4.69824e-05,
    "design_id": "project",
    "algo_name": "i2c_master_slave_controller",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "i2c_master_slave_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid i2c_master_slave_controller(\n    uint8_t master_tx[ARRAY_SIZE], \n    uint8_t master_rx[ARRAY_SIZE], \n    uint8_t slave_tx[ARRAY_SIZE], \n    uint8_t slave_rx[ARRAY_SIZE], \n    uint8_t master_tx_size, \n    uint8_t slave_tx_size)\n{\n    uint8_t master_tx_index = 0;\n    uint8_t slave_tx_index = 0;\n    uint8_t master_rx_index = 0;\n    uint8_t slave_rx_index = 0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (master_tx_index < master_tx_size) {\n            slave_rx[slave_rx_index++] = master_tx[master_tx_index++];\n        }\n        if (slave_tx_index < slave_tx_size) {\n            master_rx[master_rx_index++] = slave_tx[slave_tx_index++];\n        }\n    }\n}\n\n// Top function name: i2c_master_slave_controller\n"
      }
    ],
    "code_length": 769,
    "token_count": 218,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/identity_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 36,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "identity_comparator",
    "ResourceMetric": 2.56965e-05,
    "design_id": "project",
    "algo_name": "identity_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "identity_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid identity_comparator(ap_int<32> input_array[ARRAY_SIZE], ap_int<1> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_array[i] == i) {\n            output_array[i] = 1;\n        } else {\n            output_array[i] = 0;\n        }\n    }\n}\n\n// Top function name: identity_comparator\n"
      }
    ],
    "code_length": 367,
    "token_count": 104,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/iir_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4100,
    "Worst-caseLatency": 4100.0,
    "BRAM_18K": 0,
    "LUT": 186,
    "DSP": 5,
    "FF": 257,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "iir_filter",
    "ResourceMetric": 0.0001988295,
    "design_id": "project",
    "algo_name": "iir_filter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "iir_filter.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define N 1024\n\nvoid iir_filter(ap_fixed<16, 8> input[N], ap_fixed<16, 8> output[N], ap_fixed<16, 8> a1, ap_fixed<16, 8> a2, ap_fixed<16, 8> b0, ap_fixed<16, 8> b1, ap_fixed<16, 8> b2) {\n    ap_fixed<16, 8> x1 = 0, x2 = 0, y1 = 0, y2 = 0;\n\n    for (int i = 0; i < N; i++) {\n        ap_fixed<16, 8> x0 = input[i];\n        ap_fixed<16, 8> y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;\n\n        output[i] = y0;\n\n        x2 = x1;\n        x1 = x0;\n        y2 = y1;\n        y1 = y0;\n    }\n}\n\n// Top function name: iir_filter\n"
      }
    ],
    "code_length": 550,
    "token_count": 248,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/iir_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9236,
    "Worst-caseLatency": 9236.0,
    "BRAM_18K": 2,
    "LUT": 1133,
    "DSP": 5,
    "FF": 1408,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "iir_filter",
    "ResourceMetric": 0.0006147995,
    "design_id": "project",
    "algo_name": "iir_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "iir_filter.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid iir_filter(float input[N], float output[N], float a[3], float b[3]) {\n    float w[N] = {0};\n\n    for (int n = 0; n < N; n++) {\n        float wn = input[n];\n        if (n >= 1) {\n            wn -= a[1] * w[n - 1];\n        }\n        if (n >= 2) {\n            wn -= a[2] * w[n - 2];\n        }\n        w[n] = wn;\n\n        output[n] = b[0] * w[n];\n        if (n >= 1) {\n            output[n] += b[1] * w[n - 1];\n        }\n        if (n >= 2) {\n            output[n] += b[2] * w[n - 2];\n        }\n    }\n}\n\n// Top function name: iir_filter\n"
      }
    ],
    "code_length": 572,
    "token_count": 201,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/operators/iir_filter_4th_order/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 15390,
    "Worst-caseLatency": 15390.0,
    "BRAM_18K": 4,
    "LUT": 1093,
    "DSP": 8,
    "FF": 1735,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "iir_filter_4th_order",
    "ResourceMetric": 0.0008456021,
    "design_id": "project",
    "algo_name": "iir_filter_4th_order",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "iir_filter_4th_order.cpp",
        "file_content": "#include <iostream>\n\n#define N 1024\n\nvoid iir_filter_4th_order(float input[N], float output[N], float a[5], float b[5]) {\n    float w[N + 4] = {0}; // Intermediate storage for filter states\n\n    for (int n = 0; n < N; n++) {\n        w[n + 4] = input[n] - (a[1] * w[n + 3] + a[2] * w[n + 2] + a[3] * w[n + 1] + a[4] * w[n]);\n        output[n] = b[0] * w[n + 4] + b[1] * w[n + 3] + b[2] * w[n + 2] + b[3] * w[n + 1] + b[4] * w[n];\n    }\n}\n\n// Top function name: iir_filter_4th_order\n"
      }
    ],
    "code_length": 481,
    "token_count": 206,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/image_convolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5249029,
    "Worst-caseLatency": 5249029.0,
    "BRAM_18K": 0,
    "LUT": 1390,
    "DSP": 6,
    "FF": 709,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "image_convolution",
    "ResourceMetric": 0.0005007572,
    "design_id": "project",
    "algo_name": "image_convolution",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "image_convolution.cpp",
        "file_content": "#include <iostream>\n\n#define IMG_SIZE 1024\n#define KERNEL_SIZE 3\n\nvoid image_convolution(int img[IMG_SIZE][IMG_SIZE], int kernel[KERNEL_SIZE][KERNEL_SIZE], int result[IMG_SIZE][IMG_SIZE]) {\n    int i, j, m, n;\n    int sum;\n\n    for (i = 0; i < IMG_SIZE; i++) {\n        for (j = 0; j < IMG_SIZE; j++) {\n            sum = 0;\n            for (m = 0; m < KERNEL_SIZE; m++) {\n                for (n = 0; n < KERNEL_SIZE; n++) {\n                    int x = i + m - KERNEL_SIZE / 2;\n                    int y = j + n - KERNEL_SIZE / 2;\n                    if (x >= 0 && x < IMG_SIZE && y >= 0 && y < IMG_SIZE) {\n                        sum += img[x][y] * kernel[m][n];\n                    }\n                }\n            }\n            result[i][j] = sum;\n        }\n    }\n}\n\n// Top function name: image_convolution\n"
      }
    ],
    "code_length": 807,
    "token_count": 228,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/image_resize/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 262146,
    "Worst-caseLatency": 262146.0,
    "BRAM_18K": 0,
    "LUT": 226,
    "DSP": 0,
    "FF": 60,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "image_resize",
    "ResourceMetric": 4.90918e-05,
    "design_id": "project",
    "algo_name": "image_resize",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "image_resize.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH_IN 1024\n#define HEIGHT_IN 1024\n#define WIDTH_OUT 512\n#define HEIGHT_OUT 512\n\nvoid image_resize(ap_uint<8> input_image[WIDTH_IN][HEIGHT_IN], ap_uint<8> output_image[WIDTH_OUT][HEIGHT_OUT]) {\n    int x_ratio = (int)((WIDTH_IN << 16) / WIDTH_OUT) + 1;\n    int y_ratio = (int)((HEIGHT_IN << 16) / HEIGHT_OUT) + 1;\n\n    for (int i = 0; i < HEIGHT_OUT; i++) {\n        for (int j = 0; j < WIDTH_OUT; j++) {\n            int x = ((j * x_ratio) >> 16);\n            int y = ((i * y_ratio) >> 16);\n            output_image[j][i] = input_image[x][y];\n        }\n    }\n}\n\n// Top function name: image_resize\n"
      }
    ],
    "code_length": 627,
    "token_count": 197,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/image_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 245,
    "DSP": 0,
    "FF": 66,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "image_signal_processor",
    "ResourceMetric": 5.33106e-05,
    "design_id": "project",
    "algo_name": "image_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "image_signal_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid image_signal_processor(uint8_t input_image[IMG_HEIGHT][IMG_WIDTH], uint8_t output_image[IMG_HEIGHT][IMG_WIDTH]) {\n    int i, j;\n    // Simple image processing: Invert colors\n    for (i = 0; i < IMG_HEIGHT; i++) {\n        for (j = 0; j < IMG_WIDTH; j++) {\n            output_image[i][j] = 255 - input_image[i][j];\n        }\n    }\n}\n\n// Top function name: image_signal_processor\n"
      }
    ],
    "code_length": 450,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/imbalanced_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3105,
    "Worst-caseLatency": 3105.0,
    "BRAM_18K": 0,
    "LUT": 623,
    "DSP": 1,
    "FF": 402,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "imbalanced_learning",
    "ResourceMetric": 0.0001857181,
    "design_id": "project",
    "algo_name": "imbalanced_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "imbalanced_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid imbalanced_learning(ap_int<16> data[N], ap_int<16> labels[N], ap_int<16> weights[N], ap_int<16> output[N]) {\n    ap_int<16> sum_weights = 0;\n    ap_int<16> weighted_sum = 0;\n\n    // Calculate the sum of weights\n    for (int i = 0; i < N; i++) {\n        sum_weights += weights[i];\n    }\n\n    // Calculate the weighted sum of data\n    for (int i = 0; i < N; i++) {\n        weighted_sum += data[i] * weights[i];\n    }\n\n    // Normalize the weighted sum\n    ap_int<16> mean = weighted_sum / sum_weights;\n\n    // Generate output based on the mean and labels\n    for (int i = 0; i < N; i++) {\n        if (data[i] > mean) {\n            output[i] = labels[i];\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: imbalanced_learning\n"
      }
    ],
    "code_length": 799,
    "token_count": 236,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/imperfect_loop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 36,
    "Worst-caseLatency": 36.0,
    "BRAM_18K": 0,
    "LUT": 775,
    "DSP": 4,
    "FF": 260,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "loop_imperfect",
    "ResourceMetric": 0.0002843628,
    "design_id": "project",
    "algo_name": "imperfect_loop",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _LOOP_IMPERFECT_H_\n#define _LOOP_IMPERFECT_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 20\n\ntypedef ap_int<5> din_t;\ntypedef ap_int<12> dint_t;\ntypedef ap_int<6> dout_t;\n\nvoid loop_imperfect(din_t A[N], dout_t B[N]);\n\n#endif\n\nvoid loop_imperfect(din_t A[N], dout_t B[N]) {\n\n    int i, j;\n    dint_t acc;\n\nLOOP_I:\n    for (i = 0; i < 20; i++) {\n        acc = 0;\n    LOOP_J:\n        for (j = 0; j < 20; j++) {\n            acc += A[j] * j;\n        }\n        if (i % 2 == 0)\n            B[i] = acc / 20;\n        else\n            B[i] = 0;\n    }\n}\n"
      }
    ],
    "code_length": 1989,
    "token_count": 517,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/incremental_gradient_methods/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1034,
    "Worst-caseLatency": 1034.0,
    "BRAM_18K": 0,
    "LUT": 747,
    "DSP": 10,
    "FF": 1003,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "incremental_gradient_methods",
    "ResourceMetric": 0.0005164574,
    "design_id": "project",
    "algo_name": "incremental_gradient_methods",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "incremental_gradient_methods.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid incremental_gradient_methods(float alpha, float beta, float gamma, float x[N], float y[N], float gradient[N]) {\n    for (int i = 0; i < N; i++) {\n        gradient[i] = alpha * x[i] + beta * y[i] + gamma;\n    }\n}\n\n// Top function name: incremental_gradient_methods\n"
      }
    ],
    "code_length": 303,
    "token_count": 83,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/incremental_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1038,
    "Worst-caseLatency": 1038.0,
    "BRAM_18K": 0,
    "LUT": 888,
    "DSP": 13,
    "FF": 1341,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "incremental_learning",
    "ResourceMetric": 0.0006590162,
    "design_id": "project",
    "algo_name": "incremental_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "incremental_learning.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid incremental_learning(float input_data[ARRAY_SIZE], float weights[ARRAY_SIZE], float output_data[ARRAY_SIZE], float learning_rate) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float prediction = input_data[i] * weights[i];\n        float error = output_data[i] - prediction;\n        weights[i] += learning_rate * error * input_data[i];\n    }\n}\n\n// Top function name: incremental_learning\n"
      }
    ],
    "code_length": 445,
    "token_count": 104,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/inorder_traversal/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1032,
    "Worst-caseLatency": 5128.0,
    "BRAM_18K": 1,
    "LUT": 547,
    "DSP": 0,
    "FF": 167,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "inorder_traversal",
    "ResourceMetric": 0.0001829117,
    "design_id": "project",
    "algo_name": "inorder_traversal",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "inorder_traversal.cpp",
        "file_content": "#include <iostream>\n\n#define NODES 1024\n\nstruct TreeNode {\n    int val;\n    int left;\n    int right;\n};\n\nvoid inorder_traversal(TreeNode nodes[NODES], int root, int result[NODES], int &index) {\n    int stack[NODES];\n    int top = -1;\n    int current = root;\n\n    for (int i = 0; i < NODES; i++) {\n        result[i] = -1;\n    }\n\n    index = 0;\n\n    for (int i = 0; i < NODES * 2; i++) {\n        if (current != -1) {\n            stack[++top] = current;\n            current = nodes[current].left;\n        } else if (top != -1) {\n            current = stack[top--];\n            result[index++] = nodes[current].val;\n            current = nodes[current].right;\n        } else {\n            break;\n        }\n    }\n}\n\n// Top function name: inorder_traversal\n"
      }
    ],
    "code_length": 751,
    "token_count": 206,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/instance_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5182,
    "Worst-caseLatency": 5182.0,
    "BRAM_18K": 0,
    "LUT": 1873,
    "DSP": 16,
    "FF": 2153,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "instance_normalization",
    "ResourceMetric": 0.0010088728,
    "design_id": "project",
    "algo_name": "instance_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "instance_normalization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid instance_normalization(float input[N], float output[N], float gamma[N], float beta[N]) {\n    float mean = 0.0;\n    float variance = 0.0;\n\n    // Calculate mean\n    for (int i = 0; i < N; i++) {\n        mean += input[i];\n    }\n    mean /= N;\n\n    // Calculate variance\n    for (int i = 0; i < N; i++) {\n        variance += (input[i] - mean) * (input[i] - mean);\n    }\n    variance /= N;\n\n    // Normalize and scale\n    for (int i = 0; i < N; i++) {\n        output[i] = gamma[i] * ((input[i] - mean) / sqrt(variance + 1e-5)) + beta[i];\n    }\n}\n\n// Top function name: instance_normalization\n"
      }
    ],
    "code_length": 627,
    "token_count": 194,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/instruction_pipeline/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4111,
    "Worst-caseLatency": 4111.0,
    "BRAM_18K": 6,
    "LUT": 537,
    "DSP": 0,
    "FF": 112,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "instruction_pipeline",
    "ResourceMetric": 0.0004857404,
    "design_id": "project",
    "algo_name": "instruction_pipeline",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "instruction_pipeline.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid instruction_pipeline(int input[ARRAY_SIZE], int output[ARRAY_SIZE]) {\n    int stage1[ARRAY_SIZE];\n    int stage2[ARRAY_SIZE];\n    int stage3[ARRAY_SIZE];\n\n    // Stage 1: Simple transformation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        stage1[i] = input[i] + 1;\n    }\n\n    // Stage 2: Another transformation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        stage2[i] = stage1[i] * 2;\n    }\n\n    // Stage 3: Final transformation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        stage3[i] = stage2[i] - 3;\n    }\n\n    // Output the result\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = stage3[i];\n    }\n}\n\n// Top function name: instruction_pipeline\n"
      }
    ],
    "code_length": 725,
    "token_count": 219,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/int_to_float_pipelined/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "int_to_float_pipelined",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "int_to_float_pipelined",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "int_to_float_pipelined.cpp",
        "file_content": "#include <ap_int.h>\n#include <ap_fixed.h>\n\n#define SIZE 1024\n\nvoid int_to_float_pipelined(ap_int<32> input[SIZE], ap_fixed<32,16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (ap_fixed<32,16>)input[i];\n    }\n}\n\n// Top function name: int_to_float_pipelined\n"
      }
    ],
    "code_length": 284,
    "token_count": 93,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/intelligent_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 157,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "intelligent_counter",
    "ResourceMetric": 3.55724e-05,
    "design_id": "project",
    "algo_name": "intelligent_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "intelligent_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid intelligent_counter(ap_uint<32> input_array[SIZE], ap_uint<32> output_array[SIZE]) {\n    ap_uint<32> count = 0;\n\n    for (int i = 0; i < SIZE; i++) {\n        if (input_array[i] % 2 == 0) {\n            count++;\n        }\n        output_array[i] = count;\n    }\n}\n\n// Top function name: intelligent_counter\n"
      }
    ],
    "code_length": 349,
    "token_count": 102,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/interface_array/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4226,
    "Worst-caseLatency": 4226.0,
    "BRAM_18K": 5,
    "LUT": 8411,
    "DSP": 0,
    "FF": 10231,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "fft_top",
    "ResourceMetric": 0.0029039271,
    "design_id": "project",
    "algo_name": "interface_array",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_fixed.h\"\n#include \"hls_fft.h\"\n\n// configurable params\nconst char FFT_INPUT_WIDTH = 16;\nconst char FFT_OUTPUT_WIDTH = FFT_INPUT_WIDTH;\nconst char FFT_CONFIG_WIDTH = 16;\nconst char FFT_NFFT_MAX = 10;\nconst int FFT_LENGTH = 1 << FFT_NFFT_MAX;\n\n#include <complex>\nusing namespace std;\n\nstruct config1 : hls::ip_fft::params_t {\n    static const unsigned ordering_opt = hls::ip_fft::natural_order;\n    static const unsigned config_width = FFT_CONFIG_WIDTH;\n};\n\ntypedef hls::ip_fft::config_t<config1> config_t;\ntypedef hls::ip_fft::status_t<config1> status_t;\n\ntypedef ap_fixed<FFT_INPUT_WIDTH, 1> data_in_t;\ntypedef ap_fixed<FFT_OUTPUT_WIDTH, FFT_OUTPUT_WIDTH - FFT_INPUT_WIDTH + 1>\n    data_out_t;\ntypedef std::complex<data_in_t> cmpxDataIn;\ntypedef std::complex<data_out_t> cmpxDataOut;\n\nvoid dummy_proc_fe(bool direction, config_t* config, cmpxDataIn in[FFT_LENGTH],\n                   cmpxDataIn out[FFT_LENGTH]);\n\nvoid dummy_proc_be(status_t* status_in, bool* ovflo, cmpxDataOut in[FFT_LENGTH],\n                   cmpxDataOut out[FFT_LENGTH]);\n\nvoid fft_top(bool direction, cmpxDataIn in[FFT_LENGTH],\n             cmpxDataOut out[FFT_LENGTH], bool* ovflo);\n\nvoid inputdatamover(bool direction, config_t* config, cmpxDataIn in[FFT_LENGTH],\n                    cmpxDataIn out[FFT_LENGTH]) {\n    config->setDir(direction);\n    config->setSch(0x2AB);\nL0:\n    for (int i = 0; i < FFT_LENGTH; i++) {\n        out[i] = in[i];\n    }\n}\n\nvoid outputdatamover(status_t* status_in, bool* ovflo,\n                     cmpxDataOut in[FFT_LENGTH], cmpxDataOut out[FFT_LENGTH]) {\nL0:\n    for (int i = 0; i < FFT_LENGTH; i++) {\n        out[i] = in[i];\n    }\n    *ovflo = status_in->getOvflo() & 0x1;\n}\n\nvoid myfftwrapper(cmpxDataIn xn[FFT_LENGTH], cmpxDataIn xk[FFT_LENGTH],\n                  status_t& fft_status, config_t& fft_config) {\n#pragma HLS dataflow\n#pragma HLS INLINE recursive\n    hls::fft<config1>(xn, xk, &fft_status, &fft_config);\n}\n\nvoid fft_top(bool direction, complex<data_in_t> in[FFT_LENGTH],\n             complex<data_out_t> out[FFT_LENGTH], bool* ovflo) {\n#pragma HLS interface ap_hs port = direction\n#pragma HLS interface ap_fifo depth = 1 port = ovflo\n#pragma HLS interface ap_fifo depth = FFT_LENGTH port = in, out\n#pragma HLS dataflow\n\n    complex<data_in_t> xn[FFT_LENGTH];\n    complex<data_out_t> xk[FFT_LENGTH];\n    config_t fft_config;\n    status_t fft_status;\n\n    inputdatamover(direction, &fft_config, in, xn);\n\n    // FFT IP\n    myfftwrapper(xn, xk, fft_status, fft_config);\n\n    outputdatamover(&fft_status, ovflo, xk, out);\n}\n"
      }
    ],
    "code_length": 3943,
    "token_count": 1028,
    "pragma_number": 6,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/interface_stream/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 146,
    "DSP": 0,
    "FF": 18,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "inputdatamover",
    "ResourceMetric": 2.97236e-05,
    "design_id": "project",
    "algo_name": "interface_stream",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_fixed.h\"\n#include \"hls_fft.h\"\n\n// configurable params\nconst char FFT_INPUT_WIDTH = 16;\nconst char FFT_OUTPUT_WIDTH = FFT_INPUT_WIDTH;\nconst char FFT_CONFIG_WIDTH = 16;\nconst char FFT_NFFT_MAX = 10;\nconst int FFT_LENGTH = 1 << FFT_NFFT_MAX;\n\n#include <complex>\nusing namespace std;\n\nstruct config1 : hls::ip_fft::params_t {\n    static const unsigned ordering_opt = hls::ip_fft::natural_order;\n    static const unsigned config_width = FFT_CONFIG_WIDTH;\n};\n\ntypedef hls::ip_fft::config_t<config1> config_t;\ntypedef hls::ip_fft::status_t<config1> status_t;\n\ntypedef ap_fixed<FFT_INPUT_WIDTH, 1> data_in_t;\ntypedef ap_fixed<FFT_OUTPUT_WIDTH, FFT_OUTPUT_WIDTH - FFT_INPUT_WIDTH + 1>\n    data_out_t;\ntypedef std::complex<data_in_t> cmpxDataIn;\ntypedef std::complex<data_out_t> cmpxDataOut;\n\nvoid dummy_proc_fe(bool direction, config_t* config, cmpxDataIn in[FFT_LENGTH],\n                   cmpxDataIn out[FFT_LENGTH]);\n\nvoid dummy_proc_be(status_t* status_in, bool* ovflo, cmpxDataOut in[FFT_LENGTH],\n                   cmpxDataOut out[FFT_LENGTH]);\n\nvoid fft_top(bool direction, hls::stream<cmpxDataIn>& in,\n             hls::stream<cmpxDataOut>& out, bool* ovflo);\n\nvoid inputdatamover(bool direction, hls::stream<config_t>& config_strm,\n                    hls::stream<cmpxDataIn>& in,\n                    hls::stream<cmpxDataIn>& out_strm) {\n    config_t config;\n    config.setDir(direction);\n    config.setSch(0x2AB);\n    config_strm.write(config);\nL0:\n    for (int i = 0; i < FFT_LENGTH; i++) {\n        out_strm.write(in.read());\n    }\n}\n\nvoid outputdatamover(hls::stream<status_t>& status_in_strm, bool* ovflo,\n                     hls::stream<cmpxDataOut>& in_strm,\n                     hls::stream<cmpxDataOut>& out) {\nL0:\n    for (int i = 0; i < FFT_LENGTH; i++) {\n        out.write(in_strm.read());\n    }\n    status_t status = status_in_strm.read();\n    *ovflo = status.getOvflo() & 0x1;\n}\n\nvoid fft_top(bool direction, hls::stream<cmpxDataIn>& in,\n             hls::stream<cmpxDataOut>& out, bool* ovflo) {\n#pragma HLS interface ap_hs port = direction\n#pragma HLS interface ap_fifo depth = 1 port = ovflo\n#pragma HLS interface ap_fifo depth = FFT_LENGTH port = in, out\n#pragma HLS dataflow\n\n    hls::stream<complex<data_in_t>> xn;\n    hls::stream<complex<data_out_t>> xk;\n    hls::stream<config_t> fft_config;\n    hls::stream<status_t> fft_status;\n\n    inputdatamover(direction, fft_config, in, xn);\n\n    // FFT IP\n    hls::fft<config1>(xn, xk, fft_status, fft_config);\n\n    outputdatamover(fft_status, ovflo, xk, out);\n}\n"
      }
    ],
    "code_length": 3928,
    "token_count": 1036,
    "pragma_number": 4,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/interrupt_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 315,
    "DSP": 0,
    "FF": 89,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "interrupt_controller",
    "ResourceMetric": 6.89395e-05,
    "design_id": "project",
    "algo_name": "interrupt_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "interrupt_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LARGE_SCALE 1024\n\nvoid interrupt_controller(ap_uint<32> interrupt_requests[LARGE_SCALE], ap_uint<32> interrupt_priorities[LARGE_SCALE], ap_uint<32> &highest_priority_interrupt) {\n    ap_uint<32> max_priority = 0;\n    ap_uint<32> max_priority_index = 0;\n\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        if (interrupt_requests[i] == 1 && interrupt_priorities[i] > max_priority) {\n            max_priority = interrupt_priorities[i];\n            max_priority_index = i;\n        }\n    }\n\n    highest_priority_interrupt = max_priority_index;\n}\n\n// Top function name: interrupt_controller\n"
      }
    ],
    "code_length": 615,
    "token_count": 151,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/inverted_residuals/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4117,
    "Worst-caseLatency": 4117.0,
    "BRAM_18K": 1,
    "LUT": 606,
    "DSP": 2,
    "FF": 250,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "inverted_residuals",
    "ResourceMetric": 0.0002575919,
    "design_id": "project",
    "algo_name": "inverted_residuals",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "inverted_residuals.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid inverted_residuals(ap_int<16> input[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE], ap_int<16> weights1[ARRAY_SIZE], ap_int<16> weights2[ARRAY_SIZE], ap_int<16> bias1, ap_int<16> bias2) {\n    ap_int<16> intermediate[ARRAY_SIZE];\n\n    // First convolution layer\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        intermediate[i] = input[i] * weights1[i] + bias1;\n    }\n\n    // Activation function (ReLU)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (intermediate[i] < 0) {\n            intermediate[i] = 0;\n        }\n    }\n\n    // Second convolution layer\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = intermediate[i] * weights2[i] + bias2;\n    }\n\n    // Skip connection and output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] += input[i];\n    }\n}\n\n// Top function name: inverted_residuals\n"
      }
    ],
    "code_length": 877,
    "token_count": 263,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/ip_checksum/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 191,
    "DSP": 0,
    "FF": 31,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ip_checksum",
    "ResourceMetric": 3.95994e-05,
    "design_id": "project",
    "algo_name": "ip_checksum",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "ip_checksum.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid ip_checksum(uint16_t data[ARRAY_SIZE], uint16_t& checksum) {\n    uint32_t sum = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += data[i];\n        if (sum > 0xFFFF) {\n            sum = (sum & 0xFFFF) + (sum >> 16);\n        }\n    }\n    checksum = ~((uint16_t)sum);\n}\n\n// Top function name: ip_checksum\n"
      }
    ],
    "code_length": 363,
    "token_count": 113,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/ip_frame_routing_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 967,
    "DSP": 0,
    "FF": 549,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ip_frame_routing_processor",
    "ResourceMetric": 0.0002380761,
    "design_id": "project",
    "algo_name": "ip_frame_routing_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "ip_frame_routing_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_PACKETS 1024\n#define NUM_PORTS 16\n\ntypedef ap_uint<32> ip_address_t;\ntypedef ap_uint<8> port_t;\n\nstruct Packet {\n    ip_address_t src_ip;\n    ip_address_t dest_ip;\n    port_t dest_port;\n};\n\nvoid ip_frame_routing_processor(Packet packets_in[NUM_PACKETS], Packet packets_out[NUM_PACKETS], ip_address_t routing_table[NUM_PORTS]) {\n    for (int i = 0; i < NUM_PACKETS; i++) {\n        ip_address_t dest_ip = packets_in[i].dest_ip;\n        port_t port = 0;\n\n        for (int j = 0; j < NUM_PORTS; j++) {\n            if (routing_table[j] == dest_ip) {\n                port = j;\n                break;\n            }\n        }\n\n        packets_out[i].src_ip = packets_in[i].src_ip;\n        packets_out[i].dest_ip = dest_ip;\n        packets_out[i].dest_port = port;\n    }\n}\n\n// Top function name: ip_frame_routing_processor\n"
      }
    ],
    "code_length": 847,
    "token_count": 221,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/jaccard_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2068,
    "Worst-caseLatency": 2068.0,
    "BRAM_18K": 0,
    "LUT": 958,
    "DSP": 7,
    "FF": 903,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jaccard_loss",
    "ResourceMetric": 0.0004642199,
    "design_id": "project",
    "algo_name": "jaccard_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "jaccard_loss.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid jaccard_loss(float y_true[ARRAY_SIZE], float y_pred[ARRAY_SIZE], float &loss) {\n    float intersection = 0.0;\n    float union_set = 0.0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        intersection += y_true[i] * y_pred[i];\n        union_set += y_true[i] + y_pred[i] - y_true[i] * y_pred[i];\n    }\n\n    loss = 1.0 - (intersection / union_set);\n}\n\n// Top function name: jaccard_loss\n"
      }
    ],
    "code_length": 434,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/jaccard_similarity/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 501,
    "DSP": 0,
    "FF": 219,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jaccard_similarity",
    "ResourceMetric": 0.0001170724,
    "design_id": "project",
    "algo_name": "jaccard_similarity",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "jaccard_similarity.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid jaccard_similarity(int32_t A[SIZE], int32_t B[SIZE], float *similarity) {\n    int32_t intersection = 0;\n    int32_t union_set = 0;\n\n    for (int i = 0; i < SIZE; i++) {\n        if (A[i] == 1 && B[i] == 1) {\n            intersection++;\n        }\n        if (A[i] == 1 || B[i] == 1) {\n            union_set++;\n        }\n    }\n\n    if (union_set == 0) {\n        *similarity = 0.0f;\n    } else {\n        *similarity = (float)intersection / (float)union_set;\n    }\n}\n\n// Top function name: jaccard_similarity\n"
      }
    ],
    "code_length": 549,
    "token_count": 174,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/jackknife_resampling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2056,
    "Worst-caseLatency": 2056.0,
    "BRAM_18K": 0,
    "LUT": 484,
    "DSP": 4,
    "FF": 157,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jackknife_resampling",
    "ResourceMetric": 0.0002186833,
    "design_id": "project",
    "algo_name": "jackknife_resampling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "jackknife_resampling.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid jackknife_resampling(ap_int<32> data[N], ap_int<32> resampled_means[N]) {\n    ap_int<32> sum = 0;\n    ap_int<32> mean = 0;\n\n    // Calculate the total sum of the data\n    for (int i = 0; i < N; i++) {\n        sum += data[i];\n    }\n\n    // Calculate the mean excluding each element\n    for (int i = 0; i < N; i++) {\n        mean = (sum - data[i]) / (N - 1);\n        resampled_means[i] = mean;\n    }\n}\n\n// Top function name: jackknife_resampling\n"
      }
    ],
    "code_length": 486,
    "token_count": 155,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/jensen_shannon_divergence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 7199,
    "Worst-caseLatency": 7199.0,
    "BRAM_18K": 2,
    "LUT": 1667,
    "DSP": 18,
    "FF": 1660,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jensen_shannon_divergence",
    "ResourceMetric": 0.001101515,
    "design_id": "project",
    "algo_name": "jensen_shannon_divergence",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "jensen_shannon_divergence.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid jensen_shannon_divergence(float P[ARRAY_SIZE], float Q[ARRAY_SIZE], float& result) {\n    float M[ARRAY_SIZE];\n    float divergence = 0.0;\n\n    // Calculate M = 0.5 * (P + Q)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        M[i] = 0.5 * (P[i] + Q[i]);\n    }\n\n    // Calculate divergence = 0.5 * (sum(P * log(P / M)) + sum(Q * log(Q / M)))\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (P[i] > 0) {\n            divergence += P[i] * logf(P[i] / M[i]);\n        }\n        if (Q[i] > 0) {\n            divergence += Q[i] * logf(Q[i] / M[i]);\n        }\n    }\n\n    result = 0.5 * divergence;\n}\n\n// Top function name: jensen_shannon_divergence\n"
      }
    ],
    "code_length": 712,
    "token_count": 239,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/jk_flip_flop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 104,
    "DSP": 0,
    "FF": 28,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jk_flip_flop",
    "ResourceMetric": 2.26283e-05,
    "design_id": "project",
    "algo_name": "jk_flip_flop",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "jk_flip_flop.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid jk_flip_flop(ap_uint<1> J[SIZE], ap_uint<1> K[SIZE], ap_uint<1> clk[SIZE], ap_uint<1> Q[SIZE], ap_uint<1> Qn[SIZE]) {\n    ap_uint<1> state = 0; // Initial state of the flip-flop\n    for (int i = 0; i < SIZE; i++) {\n        if (clk[i] == 1) { // On the rising edge of the clock\n            if (J[i] == 0 && K[i] == 0) {\n                // No change\n            } else if (J[i] == 0 && K[i] == 1) {\n                state = 0; // Reset\n            } else if (J[i] == 1 && K[i] == 0) {\n                state = 1; // Set\n            } else if (J[i] == 1 && K[i] == 1) {\n                state = ~state; // Toggle\n            }\n        }\n        Q[i] = state;\n        Qn[i] = ~state;\n    }\n}\n\n// Top function name: jk_flip_flop\n"
      }
    ],
    "code_length": 766,
    "token_count": 265,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/jk_latch/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 98,
    "DSP": 0,
    "FF": 28,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jk_latch",
    "ResourceMetric": 2.14777e-05,
    "design_id": "project",
    "algo_name": "jk_latch",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "jk_latch.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid jk_latch(ap_uint<1> J[SIZE], ap_uint<1> K[SIZE], ap_uint<1> Q[SIZE]) {\n    ap_uint<1> state = 0;\n    for (int i = 0; i < SIZE; i++) {\n        if (J[i] == 1 && K[i] == 0) {\n            state = 1;\n        } else if (J[i] == 0 && K[i] == 1) {\n            state = 0;\n        } else if (J[i] == 1 && K[i] == 1) {\n            state = ~state;\n        }\n        Q[i] = state;\n    }\n}\n// Top function name: jk_latch\n"
      }
    ],
    "code_length": 452,
    "token_count": 170,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/jpeg_compression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8593116205,
    "Worst-caseLatency": 8593116205.0,
    "BRAM_18K": 7432,
    "LUT": 15998,
    "DSP": 102,
    "FF": 5610,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jpeg_compression",
    "ResourceMetric": 0.4672450444,
    "design_id": "project",
    "algo_name": "jpeg_compression",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "jpeg_compression.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid dct_1d(const double input[N], double output[N]) {\n    const double PI = 3.14159265358979323846;\n    for (int k = 0; k < N; k++) {\n        double sum = 0.0;\n        for (int n = 0; n < N; n++) {\n            sum += input[n] * cos(PI / N * (n + 0.5) * k);\n        }\n        output[k] = sum;\n    }\n}\n\nvoid dct_2d(const double input[N][N], double output[N][N]) {\n    double temp[N][N];\n    for (int i = 0; i < N; i++) {\n        dct_1d(input[i], temp[i]);\n    }\n    for (int j = 0; j < N; j++) {\n        double col_in[N], col_out[N];\n        for (int i = 0; i < N; i++) {\n            col_in[i] = temp[i][j];\n        }\n        dct_1d(col_in, col_out);\n        for (int i = 0; i < N; i++) {\n            output[i][j] = col_out[i];\n        }\n    }\n}\n\nvoid quantize(const double input[N][N], int output[N][N], const int q_table[N][N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            output[i][j] = round(input[i][j] / q_table[i][j]);\n        }\n    }\n}\n\nvoid jpeg_compression(const double input[N][N], int output[N][N], const int q_table[N][N]) {\n    double dct_output[N][N];\n    dct_2d(input, dct_output);\n    quantize(dct_output, output, q_table);\n}\n\n// Top function name: jpeg_compression\n"
      }
    ],
    "code_length": 1276,
    "token_count": 423,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/jpeg_compression_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 112050177,
    "Worst-caseLatency": 112050177.0,
    "BRAM_18K": 0,
    "LUT": 11680,
    "DSP": 102,
    "FF": 5683,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jpeg_compression_processor",
    "ResourceMetric": 0.0056105111,
    "design_id": "project",
    "algo_name": "jpeg_compression_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "jpeg_compression_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define IMAGE_WIDTH 1024\n#define IMAGE_HEIGHT 1024\n#define BLOCK_SIZE 8\n#define NUM_BLOCKS (IMAGE_WIDTH * IMAGE_HEIGHT) / (BLOCK_SIZE * BLOCK_SIZE)\n\nvoid dct_1d(float input[BLOCK_SIZE], float output[BLOCK_SIZE]) {\n    const float PI = 3.14159265358979323846;\n    for (int u = 0; u < BLOCK_SIZE; u++) {\n        float sum = 0.0;\n        for (int x = 0; x < BLOCK_SIZE; x++) {\n            sum += input[x] * cos((PI / BLOCK_SIZE) * (x + 0.5) * u);\n        }\n        output[u] = sum * (u == 0 ? sqrt(1.0 / BLOCK_SIZE) : sqrt(2.0 / BLOCK_SIZE));\n    }\n}\n\nvoid dct_2d(float input[BLOCK_SIZE][BLOCK_SIZE], float output[BLOCK_SIZE][BLOCK_SIZE]) {\n    float temp[BLOCK_SIZE][BLOCK_SIZE];\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        dct_1d(input[i], temp[i]);\n    }\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        float col[BLOCK_SIZE], col_out[BLOCK_SIZE];\n        for (int j = 0; j < BLOCK_SIZE; j++) {\n            col[j] = temp[j][i];\n        }\n        dct_1d(col, col_out);\n        for (int j = 0; j < BLOCK_SIZE; j++) {\n            output[j][i] = col_out[j];\n        }\n    }\n}\n\nvoid quantize(float input[BLOCK_SIZE][BLOCK_SIZE], int output[BLOCK_SIZE][BLOCK_SIZE], const int quant_matrix[BLOCK_SIZE][BLOCK_SIZE]) {\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        for (int j = 0; j < BLOCK_SIZE; j++) {\n            output[i][j] = round(input[i][j] / quant_matrix[i][j]);\n        }\n    }\n}\n\nvoid jpeg_compression_processor(uint8_t image[IMAGE_HEIGHT][IMAGE_WIDTH], int compressed[NUM_BLOCKS][BLOCK_SIZE][BLOCK_SIZE], const int quant_matrix[BLOCK_SIZE][BLOCK_SIZE]) {\n    float block[BLOCK_SIZE][BLOCK_SIZE];\n    float dct_block[BLOCK_SIZE][BLOCK_SIZE];\n    int quant_block[BLOCK_SIZE][BLOCK_SIZE];\n\n    for (int by = 0; by < IMAGE_HEIGHT; by += BLOCK_SIZE) {\n        for (int bx = 0; bx < IMAGE_WIDTH; bx += BLOCK_SIZE) {\n            for (int i = 0; i < BLOCK_SIZE; i++) {\n                for (int j = 0; j < BLOCK_SIZE; j++) {\n                    block[i][j] = image[by + i][bx + j] - 128.0;\n                }\n            }\n\n            dct_2d(block, dct_block);\n            quantize(dct_block, quant_block, quant_matrix);\n\n            int block_index = (by / BLOCK_SIZE) * (IMAGE_WIDTH / BLOCK_SIZE) + (bx / BLOCK_SIZE);\n            for (int i = 0; i < BLOCK_SIZE; i++) {\n                for (int j = 0; j < BLOCK_SIZE; j++) {\n                    compressed[block_index][i][j] = quant_block[i][j];\n                }\n            }\n        }\n    }\n}\n\n// Top function name: jpeg_compression_processor\n"
      }
    ],
    "code_length": 2542,
    "token_count": 734,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/jpeg_image_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 277,
    "DSP": 4,
    "FF": 66,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "jpeg_image_processor",
    "ResourceMetric": 0.0001702627,
    "design_id": "project",
    "algo_name": "jpeg_image_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "jpeg_image_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid jpeg_image_processor(uint8_t input_image[IMG_HEIGHT][IMG_WIDTH], uint8_t output_image[IMG_HEIGHT][IMG_WIDTH]) {\n    int i, j;\n    for (i = 0; i < IMG_HEIGHT; i++) {\n        for (j = 0; j < IMG_WIDTH; j++) {\n            // Simple grayscale conversion\n            uint8_t pixel = input_image[i][j];\n            uint8_t gray = (pixel * 3) / 10; // Example transformation\n            output_image[i][j] = gray;\n        }\n    }\n}\n\n// Top function name: jpeg_image_processor\n"
      }
    ],
    "code_length": 542,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/kalman_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 27625,
    "Worst-caseLatency": 27625.0,
    "BRAM_18K": 0,
    "LUT": 816,
    "DSP": 5,
    "FF": 681,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kalman_filter",
    "ResourceMetric": 0.0003602956,
    "design_id": "project",
    "algo_name": "kalman_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "kalman_filter.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n\nvoid kalman_filter(\n    float z[N], // Measurement input\n    float x[N], // State estimate output\n    float P[N], // Estimate covariance output\n    float A,    // State transition coefficient\n    float H,    // Measurement coefficient\n    float Q,    // Process noise covariance\n    float R,    // Measurement noise covariance\n    float x0,   // Initial state estimate\n    float P0    // Initial estimate covariance\n) {\n    float x_pred, P_pred, K;\n    x[0] = x0;\n    P[0] = P0;\n\n    for (int k = 1; k < N; k++) {\n        // Prediction step\n        x_pred = A * x[k-1];\n        P_pred = A * P[k-1] * A + Q;\n\n        // Update step\n        K = P_pred * H / (H * P_pred * H + R);\n        x[k] = x_pred + K * (z[k] - H * x_pred);\n        P[k] = (1 - K * H) * P_pred;\n    }\n}\n\n// Top function name: kalman_filter\n"
      }
    ],
    "code_length": 863,
    "token_count": 257,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/karaoke_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 489,
    "DSP": 8,
    "FF": 692,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "karaoke_processor",
    "ResourceMetric": 0.0003817549,
    "design_id": "project",
    "algo_name": "karaoke_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "karaoke_processor.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define SIZE 1024\n\nvoid karaoke_processor(float input_audio[SIZE], float output_audio[SIZE], float vocal_gain, float music_gain) {\n    for (int i = 0; i < SIZE; i++) {\n        float vocal = input_audio[i] * vocal_gain;\n        float music = input_audio[i] * music_gain;\n        output_audio[i] = vocal + music;\n    }\n}\n\n// Top function name: karaoke_processor\n"
      }
    ],
    "code_length": 398,
    "token_count": 101,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/kmeans/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 214101,
    "Worst-caseLatency": 214101.0,
    "BRAM_18K": 0,
    "LUT": 12508,
    "DSP": 98,
    "FF": 13506,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kmeans",
    "ResourceMetric": 0.0064085651,
    "design_id": "project",
    "algo_name": "kmeans",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "kmeans.cpp",
        "file_content": "#include <cmath>\n#include <limits>\n\n#define N 1024\n#define K 16\n#define MAX_ITER 100\n\nvoid kmeans(float data[N][2], float centroids[K][2], int labels[N]) {\n    float new_centroids[K][2];\n    int counts[K];\n    int i, j, k, iter;\n\n    for (iter = 0; iter < MAX_ITER; iter++) {\n        // Initialize new centroids and counts\n        for (k = 0; k < K; k++) {\n            new_centroids[k][0] = 0;\n            new_centroids[k][1] = 0;\n            counts[k] = 0;\n        }\n\n        // Assign labels based on closest centroid\n        for (i = 0; i < N; i++) {\n            float min_dist = std::numeric_limits<float>::max();\n            int min_index = 0;\n            for (k = 0; k < K; k++) {\n                float dist = (data[i][0] - centroids[k][0]) * (data[i][0] - centroids[k][0]) +\n                             (data[i][1] - centroids[k][1]) * (data[i][1] - centroids[k][1]);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                    min_index = k;\n                }\n            }\n            labels[i] = min_index;\n            new_centroids[min_index][0] += data[i][0];\n            new_centroids[min_index][1] += data[i][1];\n            counts[min_index]++;\n        }\n\n        // Update centroids\n        for (k = 0; k < K; k++) {\n            if (counts[k] != 0) {\n                centroids[k][0] = new_centroids[k][0] / counts[k];\n                centroids[k][1] = new_centroids[k][1] / counts[k];\n            }\n        }\n    }\n}\n\n// Top function name: kmeans\n"
      }
    ],
    "code_length": 1500,
    "token_count": 410,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/kmeans_clustering/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4250,
    "Worst-caseLatency": 4250.0,
    "BRAM_18K": 0,
    "LUT": 17505,
    "DSP": 124,
    "FF": 19902,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kmeans_clustering",
    "ResourceMetric": 0.0087003794,
    "design_id": "project",
    "algo_name": "kmeans_clustering",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "kmeans_clustering.cpp",
        "file_content": "#include <cmath>\n#include <limits>\n\n#define N_POINTS 1024\n#define N_CLUSTERS 16\n#define N_FEATURES 3\n\nvoid kmeans_clustering(float points[N_POINTS][N_FEATURES], float centroids[N_CLUSTERS][N_FEATURES], int assignments[N_POINTS]) {\n    float new_centroids[N_CLUSTERS][N_FEATURES] = {0};\n    int counts[N_CLUSTERS] = {0};\n\n    for (int i = 0; i < N_POINTS; i++) {\n        float min_dist = std::numeric_limits<float>::max();\n        int closest_centroid = 0;\n\n        for (int j = 0; j < N_CLUSTERS; j++) {\n            float dist = 0;\n            for (int k = 0; k < N_FEATURES; k++) {\n                float diff = points[i][k] - centroids[j][k];\n                dist += diff * diff;\n            }\n\n            if (dist < min_dist) {\n                min_dist = dist;\n                closest_centroid = j;\n            }\n        }\n\n        assignments[i] = closest_centroid;\n        counts[closest_centroid]++;\n        for (int k = 0; k < N_FEATURES; k++) {\n            new_centroids[closest_centroid][k] += points[i][k];\n        }\n    }\n\n    for (int j = 0; j < N_CLUSTERS; j++) {\n        if (counts[j] > 0) {\n            for (int k = 0; k < N_FEATURES; k++) {\n                centroids[j][k] = new_centroids[j][k] / counts[j];\n            }\n        }\n    }\n}\n\n// Top function name: kmeans_clustering\n"
      }
    ],
    "code_length": 1297,
    "token_count": 362,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/kmp/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 324142,
    "Worst-caseLatency": 518626.0,
    "BRAM_18K": 0,
    "LUT": 851,
    "DSP": 0,
    "FF": 426,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kmp",
    "ResourceMetric": 0.0002040378,
    "design_id": "project",
    "algo_name": "kmp",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "kmp.h",
        "file_content": "/*\nImplementation based on http://www-igm.univ-mlv.fr/~lecroq/string/node8.html\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include \"support.h\"\n\n#define PATTERN_SIZE 4\n#define STRING_SIZE (32411)\n\nint kmp(char pattern[PATTERN_SIZE], char input[STRING_SIZE], int32_t kmpNext[PATTERN_SIZE], int32_t n_matches[1]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  char pattern[PATTERN_SIZE];\n  char input[STRING_SIZE];\n  int32_t kmpNext[PATTERN_SIZE];\n  int32_t n_matches[1];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "kmp.c",
        "file_content": "/*\nImplementation based on http://www-igm.univ-mlv.fr/~lecroq/string/node8.html\n*/\n\n#include \"kmp.h\"\n\nvoid CPF(char pattern[PATTERN_SIZE], int32_t kmpNext[PATTERN_SIZE]) {\n    int32_t k, q;\n    k = 0;\n    kmpNext[0] = 0;\n\n    c1 : for(q = 1; q < PATTERN_SIZE; q++){\n        c2 : while(k > 0 && pattern[k] != pattern[q]){\n            #pragma HLS loop_tripcount min=1 max=PATTERN_SIZE avg=1\n            k = kmpNext[q];\n        }\n        if(pattern[k] == pattern[q]){\n            k++;\n        }\n        kmpNext[q] = k;\n    }\n}\n\n\nint kmp(char pattern[PATTERN_SIZE], char input[STRING_SIZE], int32_t kmpNext[PATTERN_SIZE], int32_t n_matches[1]) {\n    int32_t i, q;\n    n_matches[0] = 0;\n\n    CPF(pattern, kmpNext);\n\n    q = 0;\n    k1 : for(i = 0; i < STRING_SIZE; i++){\n        k2 : while (q > 0 && pattern[q] != input[i]){\n            #pragma HLS loop_tripcount min=1 max=PATTERN_SIZE avg=1\n            q = kmpNext[q];\n        }\n        if (pattern[q] == input[i]){\n            q++;\n        }\n        if (q >= PATTERN_SIZE){\n            n_matches[0]++;\n            q = kmpNext[q - 1];\n        }\n    }\n    return 0;\n}\n"
      }
    ],
    "code_length": 1113,
    "token_count": 344,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/knn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 21550,
    "Worst-caseLatency": 21550.0,
    "BRAM_18K": 2,
    "LUT": 2158,
    "DSP": 12,
    "FF": 1583,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "knn",
    "ResourceMetric": 0.0010220652,
    "design_id": "project",
    "algo_name": "knn",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "knn.cpp",
        "file_content": "#include <cmath>\n#include <limits>\n\n#define DATA_SIZE 1024\n#define K 5\n\nvoid knn(float query_point[2], float data_points[DATA_SIZE][2], int labels[DATA_SIZE], int& predicted_label) {\n    float distances[DATA_SIZE];\n    int nearest_labels[K];\n\n    // Calculate distances from the query point to all data points\n    for (int i = 0; i < DATA_SIZE; i++) {\n        float dx = data_points[i][0] - query_point[0];\n        float dy = data_points[i][1] - query_point[1];\n        distances[i] = std::sqrt(dx * dx + dy * dy);\n    }\n\n    // Initialize nearest labels with maximum possible distance\n    for (int i = 0; i < K; i++) {\n        nearest_labels[i] = -1;\n    }\n\n    // Find K nearest neighbors\n    for (int i = 0; i < K; i++) {\n        float min_distance = std::numeric_limits<float>::max();\n        int min_index = -1;\n        for (int j = 0; j < DATA_SIZE; j++) {\n            if (distances[j] < min_distance) {\n                min_distance = distances[j];\n                min_index = j;\n            }\n        }\n        nearest_labels[i] = labels[min_index];\n        distances[min_index] = std::numeric_limits<float>::max(); // Mark this point as visited\n    }\n\n    // Perform majority voting\n    int vote_count[10] = {0}; // Assuming labels are in the range [0, 9]\n    for (int i = 0; i < K; i++) {\n        vote_count[nearest_labels[i]]++;\n    }\n\n    int max_votes = 0;\n    for (int i = 0; i < 10; i++) {\n        if (vote_count[i] > max_votes) {\n            max_votes = vote_count[i];\n            predicted_label = i;\n        }\n    }\n}\n\n// Top function name: knn\n"
      }
    ],
    "code_length": 1562,
    "token_count": 424,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/knn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 29777,
    "Worst-caseLatency": 29777.0,
    "BRAM_18K": 4,
    "LUT": 3766,
    "DSP": 14,
    "FF": 4273,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "knn",
    "ResourceMetric": 0.0017677625,
    "design_id": "project",
    "algo_name": "knn",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "knn.cpp",
        "file_content": "#include <cmath>\n\n#define NUM_SAMPLES 1024\n#define NUM_FEATURES 16\n#define K 5\n\nvoid knn(float query[NUM_FEATURES], float samples[NUM_SAMPLES][NUM_FEATURES], int labels[NUM_SAMPLES], int &predicted_label) {\n    float distances[NUM_SAMPLES];\n    int nearest_labels[K];\n\n    // Calculate distances from the query to each sample\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        float dist = 0.0f;\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            float diff = query[j] - samples[i][j];\n            dist += diff * diff;\n        }\n        distances[i] = std::sqrt(dist);\n    }\n\n    // Initialize nearest labels with a large value\n    for (int i = 0; i < K; i++) {\n        nearest_labels[i] = -1;\n    }\n\n    // Find K nearest neighbors\n    for (int i = 0; i < K; i++) {\n        float min_dist = 1e9;\n        int min_index = -1;\n        for (int j = 0; j < NUM_SAMPLES; j++) {\n            if (distances[j] < min_dist) {\n                min_dist = distances[j];\n                min_index = j;\n            }\n        }\n        nearest_labels[i] = labels[min_index];\n        distances[min_index] = 1e9; // Mark this distance as used\n    }\n\n    // Majority voting\n    int vote_count[NUM_SAMPLES] = {0};\n    for (int i = 0; i < K; i++) {\n        vote_count[nearest_labels[i]]++;\n    }\n\n    int max_votes = 0;\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        if (vote_count[i] > max_votes) {\n            max_votes = vote_count[i];\n            predicted_label = i;\n        }\n    }\n}\n\n// Top function name: knn\n"
      }
    ],
    "code_length": 1512,
    "token_count": 415,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/knowledge_distillation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 15443,
    "Worst-caseLatency": 15443.0,
    "BRAM_18K": 4,
    "LUT": 5633,
    "DSP": 102,
    "FF": 5514,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "knowledge_distillation",
    "ResourceMetric": 0.0046827208,
    "design_id": "project",
    "algo_name": "knowledge_distillation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "knowledge_distillation.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid knowledge_distillation(float teacher_logits[ARRAY_SIZE], float student_logits[ARRAY_SIZE], float temperature, float lambda, float output_loss[1]) {\n    float teacher_softmax[ARRAY_SIZE];\n    float student_softmax[ARRAY_SIZE];\n    float teacher_sum = 0.0;\n    float student_sum = 0.0;\n    float distillation_loss = 0.0;\n    float student_loss = 0.0;\n\n    // Compute softmax for teacher and student logits\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        teacher_softmax[i] = exp(teacher_logits[i] / temperature);\n        student_softmax[i] = exp(student_logits[i] / temperature);\n        teacher_sum += teacher_softmax[i];\n        student_sum += student_softmax[i];\n    }\n\n    // Normalize softmax values\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        teacher_softmax[i] /= teacher_sum;\n        student_softmax[i] /= student_sum;\n    }\n\n    // Compute distillation loss (KL divergence)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        distillation_loss += teacher_softmax[i] * log(teacher_softmax[i] / student_softmax[i]);\n    }\n\n    // Compute student loss (cross-entropy)\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        student_loss += -teacher_softmax[i] * log(student_softmax[i]);\n    }\n\n    // Combine losses\n    output_loss[0] = lambda * distillation_loss + (1 - lambda) * student_loss;\n}\n\n// Top function name: knowledge_distillation\n"
      }
    ],
    "code_length": 1399,
    "token_count": 347,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/kogge_stone_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 22617,
    "Worst-caseLatency": 22617.0,
    "BRAM_18K": 120,
    "LUT": 2785,
    "DSP": 0,
    "FF": 2304,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kogge_stone_adder",
    "ResourceMetric": 0.0081954544,
    "design_id": "project",
    "algo_name": "kogge_stone_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "kogge_stone_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid kogge_stone_adder(ap_uint<N> a, ap_uint<N> b, ap_uint<N>& sum) {\n    ap_uint<N> p[N], g[N], c[N];\n\n    // Step 1: Initialize propagate and generate\n    for (int i = 0; i < N; i++) {\n        p[i] = a[i] ^ b[i];\n        g[i] = a[i] & b[i];\n    }\n\n    // Step 2: Compute carries\n    for (int d = 1; d < N; d *= 2) {\n        for (int i = 0; i < N; i++) {\n            if (i >= d) {\n                c[i] = g[i] | (p[i] & c[i - d]);\n            } else {\n                c[i] = g[i];\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            g[i] = c[i];\n        }\n    }\n\n    // Step 3: Compute sum\n    for (int i = 0; i < N; i++) {\n        sum[i] = p[i] ^ c[i];\n    }\n}\n\n// Top function name: kogge_stone_adder\n"
      }
    ],
    "code_length": 762,
    "token_count": 274,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/kullback_leibler_divergence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2068,
    "Worst-caseLatency": 2068.0,
    "BRAM_18K": 0,
    "LUT": 1256,
    "DSP": 18,
    "FF": 1051,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kullback_leibler_divergence",
    "ResourceMetric": 0.0008402993,
    "design_id": "project",
    "algo_name": "kullback_leibler_divergence",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "kullback_leibler_divergence.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid kullback_leibler_divergence(const float P[ARRAY_SIZE], const float Q[ARRAY_SIZE], float &result) {\n    result = 0.0f;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (P[i] > 0 && Q[i] > 0) {\n            result += P[i] * logf(P[i] / Q[i]);\n        }\n    }\n}\n\n// Top function name: kullback_leibler_divergence\n"
      }
    ],
    "code_length": 362,
    "token_count": 120,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/l1_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3088,
    "Worst-caseLatency": 3088.0,
    "BRAM_18K": 0,
    "LUT": 521,
    "DSP": 2,
    "FF": 432,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "l1_normalization",
    "ResourceMetric": 0.0001967385,
    "design_id": "project",
    "algo_name": "l1_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "l1_normalization.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid l1_normalization(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float sum = 0.0;\n\n    // Calculate the L1 norm\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += std::abs(input[i]);\n    }\n\n    // Normalize the input array\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] / sum;\n    }\n}\n\n// Top function name: l1_normalization\n"
      }
    ],
    "code_length": 433,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/l2_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3094,
    "Worst-caseLatency": 3094.0,
    "BRAM_18K": 0,
    "LUT": 608,
    "DSP": 5,
    "FF": 599,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "l2_normalization",
    "ResourceMetric": 0.0003125461,
    "design_id": "project",
    "algo_name": "l2_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "l2_normalization.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid l2_normalization(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float sum = 0.0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += input[i] * input[i];\n    }\n    float norm = std::sqrt(sum);\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] / norm;\n    }\n}\n\n// Top function name: l2_normalization\n"
      }
    ],
    "code_length": 404,
    "token_count": 121,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/label_smoothing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1036,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 925,
    "DSP": 11,
    "FF": 951,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "label_smoothing",
    "ResourceMetric": 0.0005733096,
    "design_id": "project",
    "algo_name": "label_smoothing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "label_smoothing.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n#define SMOOTHING_FACTOR 0.1\n\nvoid label_smoothing(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * (1.0 - SMOOTHING_FACTOR) + SMOOTHING_FACTOR / ARRAY_SIZE;\n    }\n}\n\n// Top function name: label_smoothing\n"
      }
    ],
    "code_length": 325,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/laplace_approximation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5256146,
    "Worst-caseLatency": 5256146.0,
    "BRAM_18K": 0,
    "LUT": 2328,
    "DSP": 14,
    "FF": 2855,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "laplace_approximation",
    "ResourceMetric": 0.0011080275,
    "design_id": "project",
    "algo_name": "laplace_approximation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "laplace_approximation.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid laplace_approximation(double input[N][N], double output[N][N]) {\n    double laplace_kernel[3][3] = {\n        {0,  1, 0},\n        {1, -4, 1},\n        {0,  1, 0}\n    };\n\n    for (int i = 1; i < N-1; i++) {\n        for (int j = 1; j < N-1; j++) {\n            double sum = 0.0;\n            for (int ki = -1; ki <= 1; ki++) {\n                for (int kj = -1; kj <= 1; kj++) {\n                    sum += input[i + ki][j + kj] * laplace_kernel[ki + 1][kj + 1];\n                }\n            }\n            output[i][j] = sum;\n        }\n    }\n}\n\n// Top function name: laplace_approximation\n"
      }
    ],
    "code_length": 621,
    "token_count": 208,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/large_scale_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 122,
    "DSP": 10,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "large_scale_multiplier",
    "ResourceMetric": 0.0003028314,
    "design_id": "project",
    "algo_name": "large_scale_multiplier",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "large_scale_multiplier.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid large_scale_multiplier(uint64_t input1[ARRAY_SIZE], uint64_t input2[ARRAY_SIZE], uint64_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input1[i] * input2[i];\n    }\n}\n\n// Top function name: large_scale_multiplier\n"
      }
    ],
    "code_length": 303,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/lasso_regression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097703516,
    "Worst-caseLatency": 2097703516.0,
    "BRAM_18K": 3,
    "LUT": 2624,
    "DSP": 16,
    "FF": 2299,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lasso_regression",
    "ResourceMetric": 0.001352899,
    "design_id": "project",
    "algo_name": "lasso_regression",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "lasso_regression.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define M 512\n#define LAMBDA 0.1\n\nvoid lasso_regression(float X[N][M], float y[N], float beta[M], float lambda) {\n    float residuals[N];\n    float gradient[M];\n    float learning_rate = 0.01;\n    int max_iter = 1000;\n\n    // Initialize beta to zero\n    for (int j = 0; j < M; j++) {\n        beta[j] = 0.0;\n    }\n\n    // Gradient descent iterations\n    for (int iter = 0; iter < max_iter; iter++) {\n        // Compute residuals\n        for (int i = 0; i < N; i++) {\n            residuals[i] = y[i];\n            for (int j = 0; j < M; j++) {\n                residuals[i] -= X[i][j] * beta[j];\n            }\n        }\n\n        // Compute gradient\n        for (int j = 0; j < M; j++) {\n            gradient[j] = 0.0;\n            for (int i = 0; i < N; i++) {\n                gradient[j] += X[i][j] * residuals[i];\n            }\n            gradient[j] = -2.0 * gradient[j] / N + lambda * (beta[j] > 0 ? 1 : -1);\n        }\n\n        // Update beta\n        for (int j = 0; j < M; j++) {\n            beta[j] -= learning_rate * gradient[j];\n        }\n    }\n}\n\n// Top function name: lasso_regression\n"
      }
    ],
    "code_length": 1124,
    "token_count": 339,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/latched_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 111,
    "DSP": 0,
    "FF": 44,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "latched_comparator",
    "ResourceMetric": 2.55047e-05,
    "design_id": "project",
    "algo_name": "latched_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "latched_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid latched_comparator(ap_int<16> input_array[ARRAY_SIZE], ap_int<16> threshold, ap_int<1> output_array[ARRAY_SIZE]) {\n    ap_int<1> latch = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_array[i] > threshold) {\n            latch = 1;\n        }\n        output_array[i] = latch;\n    }\n}\n\n// Top function name: latched_comparator\n"
      }
    ],
    "code_length": 392,
    "token_count": 116,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/layer_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5180,
    "Worst-caseLatency": 5180.0,
    "BRAM_18K": 0,
    "LUT": 1763,
    "DSP": 8,
    "FF": 1714,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "layer_normalization",
    "ResourceMetric": 0.0007240551,
    "design_id": "project",
    "algo_name": "layer_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "layer_normalization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid layer_normalization(float input[N], float output[N], float gamma[N], float beta[N]) {\n    float mean = 0.0;\n    float variance = 0.0;\n    float epsilon = 1e-5;\n\n    // Calculate mean\n    for (int i = 0; i < N; i++) {\n        mean += input[i];\n    }\n    mean /= N;\n\n    // Calculate variance\n    for (int i = 0; i < N; i++) {\n        variance += (input[i] - mean) * (input[i] - mean);\n    }\n    variance /= N;\n\n    // Normalize and scale\n    for (int i = 0; i < N; i++) {\n        output[i] = gamma[i] * (input[i] - mean) / sqrt(variance + epsilon) + beta[i];\n    }\n}\n\n// Top function name: layer_normalization\n"
      }
    ],
    "code_length": 648,
    "token_count": 200,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/layer_scaling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "layer_scaling",
    "ResourceMetric": 4.73598e-05,
    "design_id": "project",
    "algo_name": "layer_scaling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "layer_scaling.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid layer_scaling(ap_int<16> input[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE], ap_int<16> scale_factor) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * scale_factor;\n    }\n}\n\n// Top function name: layer_scaling\n"
      }
    ],
    "code_length": 286,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/lcd_flat_panel_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 786434,
    "Worst-caseLatency": 786434.0,
    "BRAM_18K": 0,
    "LUT": 240,
    "DSP": 0,
    "FF": 64,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lcd_flat_panel_processor",
    "ResourceMetric": 5.216e-05,
    "design_id": "project",
    "algo_name": "lcd_flat_panel_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "lcd_flat_panel_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1024\n#define HEIGHT 768\n\nvoid lcd_flat_panel_processor(ap_uint<8> input[HEIGHT][WIDTH], ap_uint<8> output[HEIGHT][WIDTH]) {\n    for (int y = 0; y < HEIGHT; y++) {\n        for (int x = 0; x < WIDTH; x++) {\n            // Simple processing: invert colors\n            output[y][x] = 255 - input[y][x];\n        }\n    }\n}\n\n// Top function name: lcd_flat_panel_processor\n"
      }
    ],
    "code_length": 400,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/lda/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 134145,
    "Worst-caseLatency": 134145.0,
    "BRAM_18K": 0,
    "LUT": 2171,
    "DSP": 10,
    "FF": 2488,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lda",
    "ResourceMetric": 0.000931916,
    "design_id": "project",
    "algo_name": "lda",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "lda.cpp",
        "file_content": "#include <hls_math.h>\n\n#define N 1024\n#define D 10\n\nvoid lda(float data[N][D], float mean[D], float cov_inv[D][D], float result[N]) {\n    float diff[D];\n    float temp[D];\n    \n    for (int i = 0; i < N; i++) {\n        // Compute the difference vector\n        for (int j = 0; j < D; j++) {\n            diff[j] = data[i][j] - mean[j];\n        }\n        \n        // Matrix-vector multiplication with the inverse covariance matrix\n        for (int j = 0; j < D; j++) {\n            temp[j] = 0;\n            for (int k = 0; k < D; k++) {\n                temp[j] += cov_inv[j][k] * diff[k];\n            }\n        }\n        \n        // Compute the final result for the i-th data point\n        result[i] = 0;\n        for (int j = 0; j < D; j++) {\n            result[i] += temp[j] * diff[j];\n        }\n    }\n}\n\n// Top function name: lda\n"
      }
    ],
    "code_length": 828,
    "token_count": 241,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/ldo_regulator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 176,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ldo_regulator",
    "ResourceMetric": 3.80653e-05,
    "design_id": "project",
    "algo_name": "ldo_regulator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "ldo_regulator.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\nvoid ldo_regulator(ap_fixed<16, 8> input_voltage[ARRAY_SIZE], ap_fixed<16, 8> output_voltage[ARRAY_SIZE], ap_fixed<16, 8> reference_voltage, ap_fixed<16, 8> dropout_voltage) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_voltage[i] > reference_voltage + dropout_voltage) {\n            output_voltage[i] = reference_voltage;\n        } else {\n            output_voltage[i] = input_voltage[i] - dropout_voltage;\n        }\n    }\n}\n\n// Top function name: ldo_regulator\n"
      }
    ],
    "code_length": 528,
    "token_count": 143,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/levenshtein_distance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3,
    "Worst-caseLatency": null,
    "BRAM_18K": 0,
    "LUT": 1470,
    "DSP": 0,
    "FF": 464,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "levenshtein_distance",
    "ResourceMetric": 0.0003263838,
    "design_id": "project",
    "algo_name": "levenshtein_distance",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "levenshtein_distance.cpp",
        "file_content": "#include <cstdint>\n#include <algorithm>\n\n#define MAX_LEN 1024\n\nvoid levenshtein_distance(const char str1[MAX_LEN], const char str2[MAX_LEN], int len1, int len2, int result[MAX_LEN][MAX_LEN]) {\n    int i, j;\n\n    // Initialize the first row and column of the result matrix\n    for (i = 0; i <= len1; i++) {\n        result[i][0] = i;\n    }\n    for (j = 0; j <= len2; j++) {\n        result[0][j] = j;\n    }\n\n    // Compute the Levenshtein distance\n    for (i = 1; i <= len1; i++) {\n        for (j = 1; j <= len2; j++) {\n            int cost = (str1[i - 1] == str2[j - 1]) ? 0 : 1;\n            result[i][j] = std::min({result[i - 1][j] + 1, result[i][j - 1] + 1, result[i - 1][j - 1] + cost});\n        }\n    }\n}\n\n// Top function name: levenshtein_distance\n"
      }
    ],
    "code_length": 752,
    "token_count": 260,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/lfsr/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 118,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lfsr",
    "ResourceMetric": 2.6943e-05,
    "design_id": "project",
    "algo_name": "lfsr",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "lfsr.cpp",
        "file_content": "#include <ap_int.h>\n\n#define LFSR_SIZE 1024\n\nvoid lfsr(ap_uint<32> seed, ap_uint<32> lfsr_output[LFSR_SIZE]) {\n    ap_uint<32> lfsr_reg = seed;\n    ap_uint<32> feedback;\n\n    for (int i = 0; i < LFSR_SIZE; i++) {\n        feedback = (lfsr_reg ^ (lfsr_reg >> 1) ^ (lfsr_reg >> 21) ^ (lfsr_reg >> 31)) & 1;\n        lfsr_reg = (lfsr_reg >> 1) | (feedback << 31);\n        lfsr_output[i] = lfsr_reg;\n    }\n}\n\n// Top function name: lfsr\n"
      }
    ],
    "code_length": 430,
    "token_count": 170,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/lfsr_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 88,
    "DSP": 0,
    "FF": 29,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lfsr_16bit",
    "ResourceMetric": 1.96559e-05,
    "design_id": "project",
    "algo_name": "lfsr_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "lfsr_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define SIZE 1024\n\nvoid lfsr_16bit(uint16_t seed, uint16_t output[SIZE]) {\n    uint16_t lfsr = seed;\n    for (int i = 0; i < SIZE; i++) {\n        bool bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1;\n        lfsr = (lfsr >> 1) | (bit << 15);\n        output[i] = lfsr;\n    }\n}\n\n// Top function name: lfsr_16bit\n"
      }
    ],
    "code_length": 349,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/lfsr_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 118,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lfsr_32bit",
    "ResourceMetric": 2.6943e-05,
    "design_id": "project",
    "algo_name": "lfsr_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "lfsr_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define LFSR_SIZE 1024\n\nvoid lfsr_32bit(uint32_t seed, uint32_t lfsr_output[LFSR_SIZE]) {\n    uint32_t lfsr = seed;\n    for (int i = 0; i < LFSR_SIZE; i++) {\n        bool bit = ((lfsr >> 0) ^ (lfsr >> 10) ^ (lfsr >> 30) ^ (lfsr >> 31)) & 1;\n        lfsr = (lfsr >> 1) | (bit << 31);\n        lfsr_output[i] = lfsr;\n    }\n}\n\n// Top function name: lfsr_32bit\n"
      }
    ],
    "code_length": 377,
    "token_count": 158,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/lfsr_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 88,
    "DSP": 0,
    "FF": 21,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lfsr_8bit",
    "ResourceMetric": 1.88888e-05,
    "design_id": "project",
    "algo_name": "lfsr_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "lfsr_8bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid lfsr_8bit(ap_uint<8> seed, ap_uint<8> lfsr_out[SIZE]) {\n    ap_uint<8> lfsr = seed;\n    for (int i = 0; i < SIZE; i++) {\n        bool bit = ((lfsr >> 0) ^ (lfsr >> 1) ^ (lfsr >> 5) ^ (lfsr >> 6)) & 1;\n        lfsr = (lfsr >> 1) | (bit << 7);\n        lfsr_out[i] = lfsr;\n    }\n}\n\n// Top function name: lfsr_8bit\n"
      }
    ],
    "code_length": 356,
    "token_count": 157,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/lifelong_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 105,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lifelong_learning",
    "ResourceMetric": 5.02363e-05,
    "design_id": "project",
    "algo_name": "lifelong_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "lifelong_learning.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid lifelong_learning(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> temp = input1[i] + input2[i];\n        output[i] = temp * temp;\n    }\n}\n\n// Top function name: lifelong_learning\n"
      }
    ],
    "code_length": 338,
    "token_count": 103,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/lifo_stack/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 2.0,
    "BRAM_18K": 2,
    "LUT": 263,
    "DSP": 0,
    "FF": 101,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lifo_stack",
    "ResourceMetric": 0.0001841262,
    "design_id": "project",
    "algo_name": "lifo_stack",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "lifo_stack.cpp",
        "file_content": "#include <iostream>\n\n#define STACK_SIZE 1024\n\nvoid lifo_stack(bool push, int data_in, bool pop, int &data_out, bool &empty, bool &full) {\n    static int stack[STACK_SIZE];\n    static int top = -1;\n\n    if (push && !full) {\n        top++;\n        stack[top] = data_in;\n    }\n\n    if (pop && !empty) {\n        data_out = stack[top];\n        top--;\n    }\n\n    empty = (top == -1);\n    full = (top == STACK_SIZE - 1);\n}\n\n// Top function name: lifo_stack\n"
      }
    ],
    "code_length": 450,
    "token_count": 129,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/linear_regression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2076,
    "Worst-caseLatency": 2076.0,
    "BRAM_18K": 0,
    "LUT": 1213,
    "DSP": 10,
    "FF": 1198,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "linear_regression",
    "ResourceMetric": 0.0006245169,
    "design_id": "project",
    "algo_name": "linear_regression",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "linear_regression.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid linear_regression(float X[N], float Y[N], float &slope, float &intercept) {\n    float sumX = 0.0;\n    float sumY = 0.0;\n    float sumXY = 0.0;\n    float sumX2 = 0.0;\n\n    for (int i = 0; i < N; i++) {\n        sumX += X[i];\n        sumY += Y[i];\n        sumXY += X[i] * Y[i];\n        sumX2 += X[i] * X[i];\n    }\n\n    float meanX = sumX / N;\n    float meanY = sumY / N;\n\n    slope = (sumXY - N * meanX * meanY) / (sumX2 - N * meanX * meanX);\n    intercept = meanY - slope * meanX;\n}\n\n// Top function name: linear_regression\n"
      }
    ],
    "code_length": 561,
    "token_count": 196,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/linear_voltage_regulator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "linear_voltage_regulator",
    "ResourceMetric": 2.61759e-05,
    "design_id": "project",
    "algo_name": "linear_voltage_regulator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "linear_voltage_regulator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid linear_voltage_regulator(ap_int<16> input_voltage[ARRAY_SIZE], ap_int<16> output_voltage[ARRAY_SIZE], ap_int<16> reference_voltage) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_voltage[i] > reference_voltage) {\n            output_voltage[i] = reference_voltage;\n        } else {\n            output_voltage[i] = input_voltage[i];\n        }\n    }\n}\n\n// Top function name: linear_voltage_regulator\n"
      }
    ],
    "code_length": 464,
    "token_count": 116,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/linked_list_traversal/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "linked_list_traversal",
    "ResourceMetric": 3.10659e-05,
    "design_id": "project",
    "algo_name": "linked_list_traversal",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "linked_list_traversal.cpp",
        "file_content": "#include <cstdint>\n\n#define LIST_SIZE 1024\n\nstruct Node {\n    int data;\n    uint16_t next;\n};\n\nvoid linked_list_traversal(Node nodes[LIST_SIZE], int& sum) {\n    sum = 0;\n    for (uint16_t i = 0; i < LIST_SIZE; ++i) {\n        sum += nodes[i].data;\n    }\n}\n\n// Top function name: linked_list_traversal\n"
      }
    ],
    "code_length": 300,
    "token_count": 88,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/lmem_2rw/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9,
    "Worst-caseLatency": 16549.0,
    "BRAM_18K": 8,
    "LUT": 2476,
    "DSP": 0,
    "FF": 1723,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vadd",
    "ResourceMetric": 0.0011360469,
    "design_id": "project",
    "algo_name": "lmem_2rw",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/**\n* Copyright (C) 2019-2021 Xilinx, Inc\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\"). You may\n* not use this file except in compliance with the License. A copy of the\n* License is located at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n* License for the specific language governing permissions and limitations\n* under the License.\n*/\n\n/*******************************************************************************\nDescription:\n    C Kernel to showcase 2 parallel read/write from  Local Memory\n    Description: This is vector addition to demonstrate how to utilized both\n    ports of Local Memory.\n*******************************************************************************/\n\n// Missing include: #include <string.h>\n#define DATA_SIZE 4096\n#define BUFFER_SIZE 1024\n\nvoid vadd(const unsigned int* in1, // Read-Only Vector 1\n          const unsigned int* in2, // Read-Only Vector 2\n          unsigned int* out_r,     // Output Result\n          int size                 // Size in integer\n          );\n\n\n// TRIPCOUNT identifiers\nconst unsigned int c_chunk_sz = BUFFER_SIZE;\nconst unsigned int c_size = DATA_SIZE;\n\n/*\n    Vector Addition Kernel Implementation\n    Arguments:\n        in1   (input)     --> Input Vector1\n        in2   (input)     --> Input Vector2\n        out_r   (output)    --> Output Vector\n        size  (input)     --> Size of Vector in Integer\n   */\nvoid vadd(const unsigned int* in1, // Read-Only Vector 1\n          const unsigned int* in2, // Read-Only Vector 2\n          unsigned int* out_r,     // Output Result\n          int size                 // Size in integer\n          ) {\n    unsigned int v1_buffer[BUFFER_SIZE];   // Local memory to store vector1\n    unsigned int v2_buffer[BUFFER_SIZE];   // Local memory to store vector2\n    unsigned int vout_buffer[BUFFER_SIZE]; // Local Memory to store result\n\n#pragma HLS INTERFACE m_axi port = in1 depth = DATA_SIZE\n#pragma HLS INTERFACE m_axi port = in2 depth = DATA_SIZE\n#pragma HLS INTERFACE m_axi port = out_r depth = DATA_SIZE\n    // Per iteration of this loop perform BUFFER_SIZE vector addition\n    for (int i = 0; i < size; i += BUFFER_SIZE) {\n#pragma HLS LOOP_TRIPCOUNT min = c_size / c_chunk_sz max = c_size / c_chunk_sz\n        int chunk_size = BUFFER_SIZE;\n        // boundary checks\n        if ((i + BUFFER_SIZE) > size) chunk_size = size - i;\n\n    // burst read of v1 and v2 vector from global memory\n    read1:\n        for (int j = 0; j < chunk_size; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_chunk_sz max = c_chunk_sz\n            v1_buffer[j] = in1[i + j];\n        }\n    read2:\n        for (int j = 0; j < chunk_size; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_chunk_sz max = c_chunk_sz\n            v2_buffer[j] = in2[i + j];\n        }\n\n    // FPGA implementation, local array is mostly implemented as BRAM Memory\n    // block.\n    // BRAM Memory Block contains two memory ports which allow two parallel access\n    // to memory. To utilized both ports of BRAM block, vector addition loop is\n    // unroll with factor of 2. It is equivalent to following code:\n    //  for (int j = 0 ; j < chunk_size ; j+= 2){\n    //    vout_buffer[j]   = v1_buffer[j] + v2_buffer[j];\n    //    vout_buffer[j+1] = v1_buffer[j+1] + v2_buffer[j+1];\n    //  }\n    // Which means two iterations of loop will be executed together and as a\n    // result\n    // it will double the performance.\n    // Auto-pipeline is going to apply pipeline to this loop\n    vadd:\n        for (int j = 0; j < chunk_size; j++) {\n// As the outer loop is not a perfect loop\n#pragma HLS loop_flatten off\n#pragma HLS LOOP_TRIPCOUNT min = c_chunk_sz max = c_chunk_sz\n            // perform vector addition\n            vout_buffer[j] = v1_buffer[j] + v2_buffer[j];\n        }\n\n    // burst write the result\n    write:\n        for (int j = 0; j < chunk_size; j++) {\n#pragma HLS LOOP_TRIPCOUNT min = c_chunk_sz max = c_chunk_sz\n            out_r[i + j] = vout_buffer[j];\n        }\n    }\n}\n"
      },
      {
        "file_name": "xvadd_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xvadd.h\"\n\nextern XVadd_Config XVadd_ConfigTable[];\n\n#ifdef SDT\nXVadd_Config *XVadd_LookupConfig(UINTPTR BaseAddress) {\n\tXVadd_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XVadd_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XVadd_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XVadd_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, UINTPTR BaseAddress) {\n\tXVadd_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XVadd_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XVadd_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXVadd_Config *XVadd_LookupConfig(u16 DeviceId) {\n\tXVadd_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XVADD_NUM_INSTANCES; Index++) {\n\t\tif (XVadd_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XVadd_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, u16 DeviceId) {\n\tXVadd_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XVadd_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XVadd_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xvadd_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of in1\n//        bit 31~0 - in1[31:0] (Read/Write)\n// 0x14 : Data signal of in1\n//        bit 31~0 - in1[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of in2\n//        bit 31~0 - in2[31:0] (Read/Write)\n// 0x20 : Data signal of in2\n//        bit 31~0 - in2[63:32] (Read/Write)\n// 0x24 : reserved\n// 0x28 : Data signal of out_r\n//        bit 31~0 - out_r[31:0] (Read/Write)\n// 0x2c : Data signal of out_r\n//        bit 31~0 - out_r[63:32] (Read/Write)\n// 0x30 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XVADD_CONTROL_ADDR_IN1_DATA   0x10\n#define XVADD_CONTROL_BITS_IN1_DATA   64\n#define XVADD_CONTROL_ADDR_IN2_DATA   0x1c\n#define XVADD_CONTROL_BITS_IN2_DATA   64\n#define XVADD_CONTROL_ADDR_OUT_R_DATA 0x28\n#define XVADD_CONTROL_BITS_OUT_R_DATA 64\n\n"
      },
      {
        "file_name": "xvadd.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xvadd.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XVadd_CfgInitialize(XVadd *InstancePtr, XVadd_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XVadd_Set_in1(XVadd *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN1_DATA, (u32)(Data));\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN1_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XVadd_Get_in1(XVadd *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN1_DATA);\n    Data += (u64)XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN1_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XVadd_Set_in2(XVadd *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN2_DATA, (u32)(Data));\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN2_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XVadd_Get_in2(XVadd *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN2_DATA);\n    Data += (u64)XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_IN2_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XVadd_Set_out_r(XVadd *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_OUT_R_DATA, (u32)(Data));\n    XVadd_WriteReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_OUT_R_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XVadd_Get_out_r(XVadd *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_OUT_R_DATA);\n    Data += (u64)XVadd_ReadReg(InstancePtr->Control_BaseAddress, XVADD_CONTROL_ADDR_OUT_R_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xvadd.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XVADD_H\n#define XVADD_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xvadd_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XVadd_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XVadd;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XVadd_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XVadd_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XVadd_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XVadd_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XVadd_Initialize(XVadd *InstancePtr, UINTPTR BaseAddress);\nXVadd_Config* XVadd_LookupConfig(UINTPTR BaseAddress);\n#else\nint XVadd_Initialize(XVadd *InstancePtr, u16 DeviceId);\nXVadd_Config* XVadd_LookupConfig(u16 DeviceId);\n#endif\nint XVadd_CfgInitialize(XVadd *InstancePtr, XVadd_Config *ConfigPtr);\n#else\nint XVadd_Initialize(XVadd *InstancePtr, const char* InstanceName);\nint XVadd_Release(XVadd *InstancePtr);\n#endif\n\n\nvoid XVadd_Set_in1(XVadd *InstancePtr, u64 Data);\nu64 XVadd_Get_in1(XVadd *InstancePtr);\nvoid XVadd_Set_in2(XVadd *InstancePtr, u64 Data);\nu64 XVadd_Get_in2(XVadd *InstancePtr);\nvoid XVadd_Set_out_r(XVadd *InstancePtr, u64 Data);\nu64 XVadd_Get_out_r(XVadd *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xvadd_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xvadd.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XVadd_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XVadd_uio_map maps[ MAX_UIO_MAPS ];\n} XVadd_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XVadd_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XVadd_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XVadd_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XVadd_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XVadd_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XVadd_Initialize(XVadd *InstancePtr, const char* InstanceName) {\n\tXVadd_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XVadd_Release(XVadd *InstancePtr) {\n\tXVadd_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      }
    ],
    "code_length": 13753,
    "token_count": 3724,
    "pragma_number": 9,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/log_cosh_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 25602,
    "Worst-caseLatency": 342018.0,
    "BRAM_18K": 4,
    "LUT": 26657,
    "DSP": 90,
    "FF": 6507,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "log_cosh_loss",
    "ResourceMetric": 0.0084771495,
    "design_id": "project",
    "algo_name": "log_cosh_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "log_cosh_loss.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid log_cosh_loss(const float y_true[ARRAY_SIZE], const float y_pred[ARRAY_SIZE], float &loss) {\n    loss = 0.0f;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float diff = y_pred[i] - y_true[i];\n        loss += log(cosh(diff));\n    }\n    loss /= ARRAY_SIZE;\n}\n\n// Top function name: log_cosh_loss\n"
      }
    ],
    "code_length": 347,
    "token_count": 103,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/log_transform/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 820,
    "DSP": 15,
    "FF": 562,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "log_transform",
    "ResourceMetric": 0.0006266916,
    "design_id": "project",
    "algo_name": "log_transform",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "log_transform.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid log_transform(const float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = logf(input[i] + 1.0f); // Adding 1 to avoid log(0)\n    }\n}\n\n// Top function name: log_transform\n"
      }
    ],
    "code_length": 299,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/longest_common_subsequence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": null,
    "BRAM_18K": 0,
    "LUT": 1060,
    "DSP": 0,
    "FF": 381,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "longest_common_subsequence",
    "ResourceMetric": 0.0002398019,
    "design_id": "project",
    "algo_name": "longest_common_subsequence",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "longest_common_subsequence.cpp",
        "file_content": "#include <cstring>\n\n#define MAX_SIZE 1024\n\nvoid longest_common_subsequence(char X[MAX_SIZE], char Y[MAX_SIZE], int m, int n, int L[MAX_SIZE][MAX_SIZE]) {\n    int i, j;\n\n    // Initialize the L array\n    for (i = 0; i <= m; i++) {\n        for (j = 0; j <= n; j++) {\n            if (i == 0 || j == 0)\n                L[i][j] = 0;\n            else if (X[i - 1] == Y[j - 1])\n                L[i][j] = L[i - 1][j - 1] + 1;\n            else\n                L[i][j] = (L[i - 1][j] > L[i][j - 1]) ? L[i - 1][j] : L[i][j - 1];\n        }\n    }\n}\n\n// Top function name: longest_common_subsequence\n"
      }
    ],
    "code_length": 586,
    "token_count": 207,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/loocv/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2116612,
    "Worst-caseLatency": 2116612.0,
    "BRAM_18K": 4,
    "LUT": 1188,
    "DSP": 5,
    "FF": 974,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "loocv",
    "ResourceMetric": 0.0007077415,
    "design_id": "project",
    "algo_name": "loocv",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "loocv.cpp",
        "file_content": "#include <cmath>\n\n#define DATA_SIZE 1024\n\nvoid loocv(float data[DATA_SIZE], float labels[DATA_SIZE], float &accuracy) {\n    int correct_predictions = 0;\n\n    for (int i = 0; i < DATA_SIZE; i++) {\n        float train_data[DATA_SIZE - 1];\n        float train_labels[DATA_SIZE - 1];\n        float test_data = data[i];\n        float test_label = labels[i];\n\n        int idx = 0;\n        for (int j = 0; j < DATA_SIZE; j++) {\n            if (j != i) {\n                train_data[idx] = data[j];\n                train_labels[idx] = labels[j];\n                idx++;\n            }\n        }\n\n        // Simple nearest neighbor classifier\n        float min_dist = INFINITY;\n        float predicted_label = 0;\n        for (int k = 0; k < DATA_SIZE - 1; k++) {\n            float dist = fabs(train_data[k] - test_data);\n            if (dist < min_dist) {\n                min_dist = dist;\n                predicted_label = train_labels[k];\n            }\n        }\n\n        if (predicted_label == test_label) {\n            correct_predictions++;\n        }\n    }\n\n    accuracy = (float)correct_predictions / DATA_SIZE;\n}\n\n// Top function name: loocv\n"
      }
    ],
    "code_length": 1136,
    "token_count": 275,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/lookahead_optimizer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4105,
    "Worst-caseLatency": 4105.0,
    "BRAM_18K": 1,
    "LUT": 376,
    "DSP": 0,
    "FF": 92,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lookahead_optimizer",
    "ResourceMetric": 0.0001429287,
    "design_id": "project",
    "algo_name": "lookahead_optimizer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "lookahead_optimizer.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid lookahead_optimizer(ap_int<16> input[N], ap_int<16> output[N]) {\n    ap_int<16> temp[N];\n    \n    // Initialize the temp array\n    for (int i = 0; i < N; i++) {\n        temp[i] = input[i];\n    }\n    \n    // Lookahead optimization\n    for (int i = 0; i < N - 1; i++) {\n        if (temp[i] > temp[i + 1]) {\n            temp[i + 1] = temp[i];\n        }\n    }\n    \n    // Copy the result to output\n    for (int i = 0; i < N; i++) {\n        output[i] = temp[i];\n    }\n}\n\n// Top function name: lookahead_optimizer\n"
      }
    ],
    "code_length": 550,
    "token_count": 174,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/low_voltage_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "low_voltage_comparator",
    "ResourceMetric": 2.31077e-05,
    "design_id": "project",
    "algo_name": "low_voltage_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "low_voltage_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid low_voltage_comparator(ap_int<16> voltage[SIZE], ap_int<1> result[SIZE], ap_int<16> threshold) {\n    for (int i = 0; i < SIZE; i++) {\n        if (voltage[i] < threshold) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n}\n\n// Top function name: low_voltage_comparator\n"
      }
    ],
    "code_length": 352,
    "token_count": 105,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/lstm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4386780161,
    "Worst-caseLatency": 4386780161.0,
    "BRAM_18K": 11,
    "LUT": 14348,
    "DSP": 95,
    "FF": 11891,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lstm",
    "ResourceMetric": 0.0072054942,
    "design_id": "project",
    "algo_name": "lstm",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "lstm.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define SEQ_LEN 1024\n#define INPUT_SIZE 512\n#define HIDDEN_SIZE 512\n\nvoid lstm(float input[SEQ_LEN][INPUT_SIZE], float hidden[HIDDEN_SIZE], float cell[HIDDEN_SIZE],\n          float W_i[INPUT_SIZE][HIDDEN_SIZE], float W_f[INPUT_SIZE][HIDDEN_SIZE], \n          float W_o[INPUT_SIZE][HIDDEN_SIZE], float W_c[INPUT_SIZE][HIDDEN_SIZE],\n          float U_i[HIDDEN_SIZE][HIDDEN_SIZE], float U_f[HIDDEN_SIZE][HIDDEN_SIZE], \n          float U_o[HIDDEN_SIZE][HIDDEN_SIZE], float U_c[HIDDEN_SIZE][HIDDEN_SIZE],\n          float b_i[HIDDEN_SIZE], float b_f[HIDDEN_SIZE], float b_o[HIDDEN_SIZE], \n          float b_c[HIDDEN_SIZE], float output[SEQ_LEN][HIDDEN_SIZE]) {\n    \n    float temp_i[HIDDEN_SIZE], temp_f[HIDDEN_SIZE], temp_o[HIDDEN_SIZE], temp_c[HIDDEN_SIZE];\n    float new_hidden[HIDDEN_SIZE], new_cell[HIDDEN_SIZE];\n\n    for (int t = 0; t < SEQ_LEN; t++) {\n        // Input gate\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            temp_i[i] = b_i[i];\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                temp_i[i] += input[t][j] * W_i[j][i];\n            }\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                temp_i[i] += hidden[j] * U_i[j][i];\n            }\n            temp_i[i] = 1.0 / (1.0 + exp(-temp_i[i]));\n        }\n\n        // Forget gate\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            temp_f[i] = b_f[i];\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                temp_f[i] += input[t][j] * W_f[j][i];\n            }\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                temp_f[i] += hidden[j] * U_f[j][i];\n            }\n            temp_f[i] = 1.0 / (1.0 + exp(-temp_f[i]));\n        }\n\n        // Output gate\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            temp_o[i] = b_o[i];\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                temp_o[i] += input[t][j] * W_o[j][i];\n            }\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                temp_o[i] += hidden[j] * U_o[j][i];\n            }\n            temp_o[i] = 1.0 / (1.0 + exp(-temp_o[i]));\n        }\n\n        // Cell gate\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            temp_c[i] = b_c[i];\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                temp_c[i] += input[t][j] * W_c[j][i];\n            }\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                temp_c[i] += hidden[j] * U_c[j][i];\n            }\n            temp_c[i] = tanh(temp_c[i]);\n        }\n\n        // Update cell state\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            new_cell[i] = temp_f[i] * cell[i] + temp_i[i] * temp_c[i];\n        }\n\n        // Update hidden state\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            new_hidden[i] = temp_o[i] * tanh(new_cell[i]);\n        }\n\n        // Copy new states to the output\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            hidden[i] = new_hidden[i];\n            cell[i] = new_cell[i];\n            output[t][i] = new_hidden[i];\n        }\n    }\n}\n\n// Top function name: lstm\n"
      }
    ],
    "code_length": 3055,
    "token_count": 916,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/lstm_cell/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2152822785,
    "Worst-caseLatency": 2152822785.0,
    "BRAM_18K": 25,
    "LUT": 16594,
    "DSP": 117,
    "FF": 13220,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lstm_cell",
    "ResourceMetric": 0.0092411672,
    "design_id": "project",
    "algo_name": "lstm_cell",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "lstm_cell.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define SEQ_LEN 1024\n#define INPUT_SIZE 256\n#define HIDDEN_SIZE 512\n\nvoid lstm_cell(\n    float input[SEQ_LEN][INPUT_SIZE],\n    float prev_hidden[HIDDEN_SIZE],\n    float prev_cell[HIDDEN_SIZE],\n    float weights_input[4 * HIDDEN_SIZE][INPUT_SIZE],\n    float weights_hidden[4 * HIDDEN_SIZE][HIDDEN_SIZE],\n    float bias[4 * HIDDEN_SIZE],\n    float output_hidden[SEQ_LEN][HIDDEN_SIZE],\n    float output_cell[SEQ_LEN][HIDDEN_SIZE])\n{\n    float temp_input[4 * HIDDEN_SIZE];\n    float temp_hidden[4 * HIDDEN_SIZE];\n    float gates[4 * HIDDEN_SIZE];\n    float cell_state[HIDDEN_SIZE];\n    float hidden_state[HIDDEN_SIZE];\n\n    for (int t = 0; t < SEQ_LEN; t++) {\n        for (int i = 0; i < 4 * HIDDEN_SIZE; i++) {\n            temp_input[i] = bias[i];\n            temp_hidden[i] = 0.0f;\n        }\n\n        for (int i = 0; i < 4 * HIDDEN_SIZE; i++) {\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                temp_input[i] += weights_input[i][j] * input[t][j];\n            }\n        }\n\n        for (int i = 0; i < 4 * HIDDEN_SIZE; i++) {\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                temp_hidden[i] += weights_hidden[i][j] * prev_hidden[j];\n            }\n        }\n\n        for (int i = 0; i < 4 * HIDDEN_SIZE; i++) {\n            gates[i] = temp_input[i] + temp_hidden[i];\n        }\n\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            float input_gate = 1.0f / (1.0f + expf(-gates[i]));\n            float forget_gate = 1.0f / (1.0f + expf(-gates[HIDDEN_SIZE + i]));\n            float output_gate = 1.0f / (1.0f + expf(-gates[2 * HIDDEN_SIZE + i]));\n            float cell_gate = tanhf(gates[3 * HIDDEN_SIZE + i]);\n\n            cell_state[i] = forget_gate * prev_cell[i] + input_gate * cell_gate;\n            hidden_state[i] = output_gate * tanhf(cell_state[i]);\n        }\n\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            prev_hidden[i] = hidden_state[i];\n            prev_cell[i] = cell_state[i];\n            output_hidden[t][i] = hidden_state[i];\n            output_cell[t][i] = cell_state[i];\n        }\n    }\n}\n\n// Top function name: lstm_cell\n"
      }
    ],
    "code_length": 2127,
    "token_count": 619,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/lu_decomposition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1068017,
    "Worst-caseLatency": 4284519398.0,
    "BRAM_18K": 0,
    "LUT": 2116,
    "DSP": 11,
    "FF": 1747,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lu_decomposition",
    "ResourceMetric": 0.0008780239,
    "design_id": "project",
    "algo_name": "lu_decomposition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "lu_decomposition.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid lu_decomposition(double A[N][N], double L[N][N], double U[N][N]) {\n    int i, j, k;\n\n    // Initialize L and U matrices\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            if (i == j) {\n                L[i][j] = 1.0;\n            } else {\n                L[i][j] = 0.0;\n            }\n            U[i][j] = 0.0;\n        }\n    }\n\n    // Perform LU Decomposition\n    for (k = 0; k < N; k++) {\n        U[k][k] = A[k][k];\n        for (i = k + 1; i < N; i++) {\n            L[i][k] = A[i][k] / U[k][k];\n            U[k][i] = A[k][i];\n        }\n        for (i = k + 1; i < N; i++) {\n            for (j = k + 1; j < N; j++) {\n                A[i][j] = A[i][j] - L[i][k] * U[k][j];\n            }\n        }\n    }\n}\n\n// Top function name: lu_decomposition\n"
      }
    ],
    "code_length": 806,
    "token_count": 290,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/lzw_compress/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3329,
    "Worst-caseLatency": 8386814.0,
    "BRAM_18K": 4,
    "LUT": 472,
    "DSP": 0,
    "FF": 176,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "lzw_compress",
    "ResourceMetric": 0.0003554042,
    "design_id": "project",
    "algo_name": "lzw_compress",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "lzw_compress.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DICT_SIZE 4096\n#define MAX_BITS 12\n#define INPUT_SIZE 1024\n\nvoid lzw_compress(ap_uint<8> input[INPUT_SIZE], ap_uint<12> output[INPUT_SIZE]) {\n    ap_uint<12> dictionary[DICT_SIZE];\n    ap_uint<12> dict_size = 256;\n    ap_uint<12> current_code = 0;\n    ap_uint<12> next_code = 256;\n\n    for (int i = 0; i < 256; i++) {\n        dictionary[i] = i;\n    }\n\n    ap_uint<12> prefix = input[0];\n    int output_index = 0;\n\n    for (int i = 1; i < INPUT_SIZE; i++) {\n        ap_uint<8> character = input[i];\n        ap_uint<12> combined = (prefix << 8) | character;\n\n        bool found = false;\n        for (int j = 0; j < dict_size; j++) {\n            if (dictionary[j] == combined) {\n                prefix = j;\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            output[output_index++] = prefix;\n            if (dict_size < DICT_SIZE) {\n                dictionary[dict_size++] = combined;\n            }\n            prefix = character;\n        }\n    }\n\n    output[output_index++] = prefix;\n}\n\n// Top function name: lzw_compress\n"
      }
    ],
    "code_length": 1109,
    "token_count": 305,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/mac/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 191,
    "DSP": 4,
    "FF": 78,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mac",
    "ResourceMetric": 0.0001549215,
    "design_id": "project",
    "algo_name": "mac",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "mac.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid mac(ap_int<32> in1[SIZE], ap_int<32> in2[SIZE], ap_int<64> &out) {\n    ap_int<64> acc = 0;\n    for (int i = 0; i < SIZE; i++) {\n        acc += in1[i] * in2[i];\n    }\n    out = acc;\n}\n\n// Top function name: mac\n"
      }
    ],
    "code_length": 255,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/magnitude_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "magnitude_comparator",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "magnitude_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "magnitude_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid magnitude_comparator(ap_int<16> A[ARRAY_SIZE], ap_int<16> B[ARRAY_SIZE], ap_int<1> result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (A[i] > B[i]) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n}\n\n// Top function name: magnitude_comparator\n"
      }
    ],
    "code_length": 359,
    "token_count": 110,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/malloc_removed/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 70,
    "Worst-caseLatency": 70.0,
    "BRAM_18K": 0,
    "LUT": 349,
    "DSP": 0,
    "FF": 98,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "malloc_removed",
    "ResourceMetric": 7.63224e-05,
    "design_id": "project",
    "algo_name": "malloc_removed",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.c",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*******************************************************************************\nVendor: Xilinx\nAssociated Filename: malloc_removed.c\nPurpose:Vivado HLS Coding Style example\nDevice: All\nRevision History: May 30, 2008 - initial release\n\n*******************************************************************************\n#-  (c) Copyright 2011-2022 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES.\n#- ************************************************************************\n\n\nThis file contains confidential and proprietary information of Xilinx, Inc. and\nis protected under U.S. and international copyright and other intellectual\nproperty laws.\n\nDISCLAIMER\nThis disclaimer is not a license and does not grant any rights to the materials\ndistributed herewith. Except as otherwise provided in a valid license issued to\nyou by Xilinx, and to the maximum extent permitted by applicable law:\n(1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND WITH ALL FAULTS, AND XILINX\nHEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,\nINCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR\nFITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether\nin contract or tort, including negligence, or under any other theory of\nliability) for any loss or damage of any kind or nature related to, arising\nunder or in connection with these materials, including for any direct, or any\nindirect, special, incidental, or consequential loss or damage (including loss\nof data, profits, goodwill, or any type of loss or damage suffered as a result\nof any action brought by a third party) even if such damage or loss was\nreasonably foreseeable or Xilinx had been advised of the possibility of the\nsame.\n\nCRITICAL APPLICATIONS\nXilinx products are not designed or intended to be fail-safe, or for use in any\napplication requiring fail-safe performance, such as life-support or safety\ndevices or systems, Class III medical devices, nuclear facilities, applications\nrelated to the deployment of airbags, or any other applications that could lead\nto death, personal injury, or severe property or environmental damage\n(individually and collectively, \"Critical Applications\"). Customer assumes the\nsole risk and liability of any use of Xilinx products in Critical Applications,\nsubject only to applicable laws and regulations governing limitations on product\nliability.\n\nTHIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT\nALL TIMES.\n\n*******************************************************************************/\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _MALLOC_REMOVED_H_\n#define _MALLOC_REMOVED_H_\n\n// Missing include: #include <stdio.h>\n#define N 32\n\ntypedef int din_t;\ntypedef long long dout_t;\ntypedef int dsel_t;\n\ndout_t malloc_removed(din_t din[N], dsel_t width);\n\n#endif\n// Missing include: #include <stdlib.h>\n//#define NO_SYNTH\n\ndout_t malloc_removed(din_t din[N], dsel_t width) {\n\n#ifdef NO_SYNTH\n  long long *out_accum = malloc(sizeof(long long));\n  int *array_local = malloc(64 * sizeof(int));\n#else\n  long long _out_accum;\n  long long *out_accum = &_out_accum;\n  int _array_local[64];\n  int *array_local = &_array_local[0];\n#endif\n  int i, j;\n\nLOOP_SHIFT:\n  for (i = 0; i < N - 1; i++) {\n    if (i < width)\n      *(array_local + i) = din[i];\n    else\n      *(array_local + i) = din[i] >> 2;\n  }\n\n  *out_accum = 0;\nLOOP_ACCUM:\n  for (j = 0; j < N - 1; j++) {\n    *out_accum += *(array_local + j);\n  }\n\n  return *out_accum;\n}\n"
      }
    ],
    "code_length": 6930,
    "token_count": 1616,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/manhattan_distance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 414,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "manhattan_distance",
    "ResourceMetric": 8.17877e-05,
    "design_id": "project",
    "algo_name": "manhattan_distance",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "manhattan_distance.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid manhattan_distance(int x1[SIZE], int y1[SIZE], int x2[SIZE], int y2[SIZE], int result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        result[i] = abs(x1[i] - x2[i]) + abs(y1[i] - y2[i]);\n    }\n}\n\n// Top function name: manhattan_distance\n"
      }
    ],
    "code_length": 285,
    "token_count": 98,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mann_whitney_u_test/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2100242,
    "Worst-caseLatency": 2100242.0,
    "BRAM_18K": 4,
    "LUT": 1124,
    "DSP": 2,
    "FF": 616,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mann_whitney_u_test",
    "ResourceMetric": 0.0005780309,
    "design_id": "project",
    "algo_name": "mann_whitney_u_test",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mann_whitney_u_test.cpp",
        "file_content": "#include <hls_math.h>\n#include <algorithm>\n\n#define N 1024\n\nvoid mann_whitney_u_test(float x[N], float y[N], float &U1, float &U2) {\n    int rank_x[N], rank_y[N];\n    int i, j;\n\n    // Initialize ranks\n    for (i = 0; i < N; i++) {\n        rank_x[i] = 0;\n        rank_y[i] = 0;\n    }\n\n    // Calculate ranks\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            if (x[i] > y[j]) {\n                rank_x[i]++;\n            } else if (x[i] < y[j]) {\n                rank_y[j]++;\n            }\n        }\n    }\n\n    // Calculate U statistics\n    float sum_rank_x = 0;\n    float sum_rank_y = 0;\n    for (i = 0; i < N; i++) {\n        sum_rank_x += rank_x[i];\n        sum_rank_y += rank_y[i];\n    }\n\n    U1 = sum_rank_x;\n    U2 = sum_rank_y;\n}\n\n// Top function name: mann_whitney_u_test\n"
      }
    ],
    "code_length": 802,
    "token_count": 262,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/manual_burst_with_conditionals/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 837,
    "Worst-caseLatency": 268436296.0,
    "BRAM_18K": 10,
    "LUT": 4916,
    "DSP": 2,
    "FF": 3357,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 0.0019400408,
    "design_id": "project",
    "algo_name": "manual_burst_with_conditionals",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"hls_burst_maxi.h\"\n\n#ifndef _LOOP_SEQUENTIAL_H_\n#define _LOOP_SEQUENTIAL_H_\n\n#include \"ap_int.h\"\n#define N 800\n\ntypedef ap_int<30> din_t;\ntypedef ap_int<20> dout_t;\n\ntypedef struct {\n    din_t A;\n    dout_t B;\n} DUO;\n\nvoid example(hls::burst_maxi<din_t> A, hls::burst_maxi<din_t> B,\n             hls::burst_maxi<dout_t> RES, din_t factor);\n\n#endif\n\nvoid read_a(hls::burst_maxi<din_t> IN, dout_t x_aux[N], din_t factor) {\n\n    IN.read_request(\n        0,\n        N / 4); // request to read N/4 elements from the first element\n    IN.read_request(\n        N - N / 4,\n        N / 4); // request to read N/4 elements from the last quarter element\n    dout_t X_accum = N / 4;\n    din_t temp;\n    for (int i = 0; i < factor / 2; i++) {\n        if (i < N / 4) {\n            temp = IN.read();\n            X_accum += temp;\n            x_aux[i] = X_accum;\n        } else {\n            if (i == N / 4) {\n                X_accum = i;\n            }\n            temp = IN.read();\n            X_accum += temp;\n            x_aux[N - N / 2 + i] = X_accum - N;\n        }\n    }\n}\n\nvoid read_b(hls::burst_maxi<din_t> IN, dout_t y_aux[N], din_t factor) {\n    IN.read_request(\n        0,\n        N / 4); // request to read N/4 elements from the first element\n    IN.read_request(\n        N - N / 4,\n        N / 4); // request to read N/4 elements from the last quarter element\n    dout_t Y_accum = N / 4;\n    din_t temp;\n    for (int i = 0; i < factor / 2; i++) {\n        if (i < N / 4) {\n            temp = IN.read();\n            Y_accum += temp;\n            y_aux[i] = Y_accum;\n        } else {\n            if (i == N / 4) {\n                Y_accum = i;\n            }\n            temp = IN.read();\n            Y_accum += temp;\n            y_aux[N - N / 2 + i] = Y_accum + N;\n        }\n    }\n}\n\nvoid write(hls::burst_maxi<dout_t> RES, dout_t x_aux[N], dout_t y_aux[N]) {\n    RES.write_request(\n        0, N / 4); // request to write N/4 elements from the first element\n    RES.write_request(\n        N - N / 4,\n        N / 4); // request to write N/4 elements from the last quarter element\n\n    for (int i = 0; i < N / 2; i++) {\n        if (i < N / 4)\n            RES.write(x_aux[i] - y_aux[i]);\n        else\n            RES.write(x_aux[N - N / 2 + i] - y_aux[N - N / 2 + i] / N);\n    }\n    RES.write_response(); // wait for the write operation to complete\n    RES.write_response(); // wait for the write operation to complete\n}\n\nvoid process(dout_t x_aux[N], dout_t y_aux[N], din_t factor) {\n\n    for (int i = 0; i < N / 4; i++) {\n        x_aux[i] = factor + x_aux[i];\n        y_aux[i] = factor + y_aux[i];\n    }\n\n    for (int i = N - N / 4; i < N; i++) {\n        x_aux[i] = x_aux[i] - factor;\n        y_aux[i] = y_aux[i] - factor;\n    }\n}\n\nvoid example(hls::burst_maxi<din_t> A, hls::burst_maxi<din_t> B,\n             hls::burst_maxi<dout_t> RES, din_t factor) {\n#pragma HLS INTERFACE m_axi depth = 800 port = A bundle = bundle1\n#pragma HLS INTERFACE m_axi depth = 800 port = B bundle = bundle2\n#pragma HLS INTERFACE m_axi depth = 800 port = RES bundle = bundle3\n\n    dout_t x_aux[N];\n    dout_t y_aux[N];\n    read_a(A, x_aux, factor);\n    read_b(B, y_aux, factor);\n\n    process(x_aux, y_aux, factor);\n\n    write(RES, x_aux, y_aux);\n}\n"
      },
      {
        "file_name": "xexample_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xexample.h\"\n\nextern XExample_Config XExample_ConfigTable[];\n\n#ifdef SDT\nXExample_Config *XExample_LookupConfig(UINTPTR BaseAddress) {\n\tXExample_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XExample_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XExample_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XExample_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XExample_Initialize(XExample *InstancePtr, UINTPTR BaseAddress) {\n\tXExample_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XExample_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XExample_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXExample_Config *XExample_LookupConfig(u16 DeviceId) {\n\tXExample_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XEXAMPLE_NUM_INSTANCES; Index++) {\n\t\tif (XExample_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XExample_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XExample_Initialize(XExample *InstancePtr, u16 DeviceId) {\n\tXExample_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XExample_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XExample_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xexample.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XEXAMPLE_H\n#define XEXAMPLE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xexample_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XExample_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XExample;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XExample_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XExample_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XExample_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XExample_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XExample_Initialize(XExample *InstancePtr, UINTPTR BaseAddress);\nXExample_Config* XExample_LookupConfig(UINTPTR BaseAddress);\n#else\nint XExample_Initialize(XExample *InstancePtr, u16 DeviceId);\nXExample_Config* XExample_LookupConfig(u16 DeviceId);\n#endif\nint XExample_CfgInitialize(XExample *InstancePtr, XExample_Config *ConfigPtr);\n#else\nint XExample_Initialize(XExample *InstancePtr, const char* InstanceName);\nint XExample_Release(XExample *InstancePtr);\n#endif\n\n\nvoid XExample_Set_A(XExample *InstancePtr, u64 Data);\nu64 XExample_Get_A(XExample *InstancePtr);\nvoid XExample_Set_B(XExample *InstancePtr, u64 Data);\nu64 XExample_Get_B(XExample *InstancePtr);\nvoid XExample_Set_RES(XExample *InstancePtr, u64 Data);\nu64 XExample_Get_RES(XExample *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xexample_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xexample.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XExample_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XExample_uio_map maps[ MAX_UIO_MAPS ];\n} XExample_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XExample_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XExample_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XExample_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XExample_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XExample_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XExample_Initialize(XExample *InstancePtr, const char* InstanceName) {\n\tXExample_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XExample_Release(XExample *InstancePtr) {\n\tXExample_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xexample.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xexample.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XExample_CfgInitialize(XExample *InstancePtr, XExample_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XExample_Set_A(XExample *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA, (u32)(Data));\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XExample_Get_A(XExample *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA);\n    Data += (u64)XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XExample_Set_B(XExample *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA, (u32)(Data));\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XExample_Get_B(XExample *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA);\n    Data += (u64)XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XExample_Set_RES(XExample *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_RES_DATA, (u32)(Data));\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_RES_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XExample_Get_RES(XExample *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_RES_DATA);\n    Data += (u64)XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_RES_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xexample_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of A\n//        bit 31~0 - A[31:0] (Read/Write)\n// 0x14 : Data signal of A\n//        bit 31~0 - A[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of B\n//        bit 31~0 - B[31:0] (Read/Write)\n// 0x20 : Data signal of B\n//        bit 31~0 - B[63:32] (Read/Write)\n// 0x24 : reserved\n// 0x28 : Data signal of RES\n//        bit 31~0 - RES[31:0] (Read/Write)\n// 0x2c : Data signal of RES\n//        bit 31~0 - RES[63:32] (Read/Write)\n// 0x30 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XEXAMPLE_CONTROL_ADDR_A_DATA   0x10\n#define XEXAMPLE_CONTROL_BITS_A_DATA   64\n#define XEXAMPLE_CONTROL_ADDR_B_DATA   0x1c\n#define XEXAMPLE_CONTROL_BITS_B_DATA   64\n#define XEXAMPLE_CONTROL_ADDR_RES_DATA 0x28\n#define XEXAMPLE_CONTROL_BITS_RES_DATA 64\n\n"
      }
    ],
    "code_length": 14389,
    "token_count": 3940,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/map_estimation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097161,
    "Worst-caseLatency": 2097161.0,
    "BRAM_18K": 0,
    "LUT": 1096,
    "DSP": 5,
    "FF": 1038,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "map_estimation",
    "ResourceMetric": 0.0004482197,
    "design_id": "project",
    "algo_name": "map_estimation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "map_estimation.cpp",
        "file_content": "#include <cmath>\n#include <cfloat>\n\n#define N 1024\n\nvoid map_estimation(float observations[N], float priors[N], float likelihoods[N][N], float posteriors[N]) {\n    float max_posterior = -FLT_MAX;\n    int max_index = 0;\n\n    for (int i = 0; i < N; i++) {\n        float posterior = priors[i];\n        for (int j = 0; j < N; j++) {\n            posterior += observations[j] * likelihoods[i][j];\n        }\n        posteriors[i] = posterior;\n        if (posterior > max_posterior) {\n            max_posterior = posterior;\n            max_index = i;\n        }\n    }\n    // The MAP estimate is the index with the maximum posterior probability\n    posteriors[max_index] = max_posterior;\n}\n\n// Top function name: map_estimation\n"
      }
    ],
    "code_length": 718,
    "token_count": 185,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/master_slave_d_latch/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 99,
    "DSP": 0,
    "FF": 29,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "master_slave_d_latch",
    "ResourceMetric": 2.17653e-05,
    "design_id": "project",
    "algo_name": "master_slave_d_latch",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "master_slave_d_latch.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid master_slave_d_latch(ap_uint<1> D[SIZE], ap_uint<1> CLK[SIZE], ap_uint<1> Q[SIZE]) {\n    ap_uint<1> master_latch = 0;\n    ap_uint<1> slave_latch = 0;\n\n    for (int i = 0; i < SIZE; i++) {\n        if (CLK[i] == 1) {\n            master_latch = D[i];\n        } else {\n            slave_latch = master_latch;\n        }\n        Q[i] = slave_latch;\n    }\n}\n\n// Top function name: master_slave_d_latch\n"
      }
    ],
    "code_length": 440,
    "token_count": 145,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/matrix_inversion/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4208644,
    "Worst-caseLatency": 2161129476.0,
    "BRAM_18K": 0,
    "LUT": 1473,
    "DSP": 5,
    "FF": 1273,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "matrix_inversion",
    "ResourceMetric": 0.0005430475,
    "design_id": "project",
    "algo_name": "matrix_inversion",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "matrix_inversion.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define MATRIX_SIZE 1024\n\nvoid matrix_inversion(float A[MATRIX_SIZE][MATRIX_SIZE], float A_inv[MATRIX_SIZE][MATRIX_SIZE]) {\n    int i, j, k;\n    float temp;\n\n    // Initialize A_inv to identity matrix\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        for (j = 0; j < MATRIX_SIZE; j++) {\n            if (i == j) {\n                A_inv[i][j] = 1.0;\n            } else {\n                A_inv[i][j] = 0.0;\n            }\n        }\n    }\n\n    // Perform Gaussian elimination\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        temp = A[i][i];\n        for (j = 0; j < MATRIX_SIZE; j++) {\n            A[i][j] /= temp;\n            A_inv[i][j] /= temp;\n        }\n        for (j = 0; j < MATRIX_SIZE; j++) {\n            if (i != j) {\n                temp = A[j][i];\n                for (k = 0; k < MATRIX_SIZE; k++) {\n                    A[j][k] -= A[i][k] * temp;\n                    A_inv[j][k] -= A_inv[i][k] * temp;\n                }\n            }\n        }\n    }\n}\n\n// Top function name: matrix_inversion\n"
      }
    ],
    "code_length": 1032,
    "token_count": 301,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/matrix_multiply/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1073741829,
    "Worst-caseLatency": 1073741829.0,
    "BRAM_18K": 0,
    "LUT": 640,
    "DSP": 1,
    "FF": 341,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "matrix_multiply",
    "ResourceMetric": 0.0001831293,
    "design_id": "project",
    "algo_name": "matrix_multiply",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "matrix_multiply.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid matrix_multiply(ap_int<16> A[SIZE][SIZE], ap_int<16> B[SIZE][SIZE], ap_int<32> C[SIZE][SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            C[i][j] = 0;\n            for (int k = 0; k < SIZE; k++) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\n// Top function name: matrix_multiply\n"
      }
    ],
    "code_length": 406,
    "token_count": 140,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/max_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2064,
    "Worst-caseLatency": 2064.0,
    "BRAM_18K": 0,
    "LUT": 384,
    "DSP": 0,
    "FF": 291,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "max_normalization",
    "ResourceMetric": 0.0001015395,
    "design_id": "project",
    "algo_name": "max_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "max_normalization.cpp",
        "file_content": "#include <limits>\n\n#define ARRAY_SIZE 1024\n\nvoid max_normalization(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float max_val = -std::numeric_limits<float>::infinity();\n    \n    // Find the maximum value in the input array\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n    }\n    \n    // Normalize the input array by the maximum value\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] / max_val;\n    }\n}\n\n// Top function name: max_normalization\n"
      }
    ],
    "code_length": 551,
    "token_count": 146,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/max_widen_port_width/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 81,
    "Worst-caseLatency": 81.0,
    "BRAM_18K": 2,
    "LUT": 1235,
    "DSP": 0,
    "FF": 1152,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 0.0004712941,
    "design_id": "project",
    "algo_name": "max_widen_port_width",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef EXAMPLE__H_\n#define EXAMPLE__H_\n\n#include <cstdlib>\n#include <iostream>\n\nconstexpr uint64_t N = 64;\nconstexpr uint64_t MAXWBW = 256;\n\nvoid example(int a[N], int b[N]);\n\n#endif\nusing namespace std;\n\nvoid example(int a[N], int b[N]) {\n#pragma HLS INTERFACE m_axi port = a depth = N bundle =                        \\\n    gmem max_widen_bitwidth = MAXWBW\n#pragma HLS INTERFACE m_axi port = b depth = N bundle = gmem\n    int buff[N];\n    for (size_t i = 0; i < N; ++i) {\n        buff[i] = a[i];\n        buff[i] = buff[i] + 100;\n        b[i] = buff[i];\n    }\n}\n"
      },
      {
        "file_name": "xexample_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xexample.h\"\n\nextern XExample_Config XExample_ConfigTable[];\n\n#ifdef SDT\nXExample_Config *XExample_LookupConfig(UINTPTR BaseAddress) {\n\tXExample_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XExample_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XExample_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XExample_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XExample_Initialize(XExample *InstancePtr, UINTPTR BaseAddress) {\n\tXExample_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XExample_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XExample_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXExample_Config *XExample_LookupConfig(u16 DeviceId) {\n\tXExample_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XEXAMPLE_NUM_INSTANCES; Index++) {\n\t\tif (XExample_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XExample_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XExample_Initialize(XExample *InstancePtr, u16 DeviceId) {\n\tXExample_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XExample_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XExample_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xexample.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XEXAMPLE_H\n#define XEXAMPLE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xexample_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XExample_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XExample;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XExample_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XExample_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XExample_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XExample_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XExample_Initialize(XExample *InstancePtr, UINTPTR BaseAddress);\nXExample_Config* XExample_LookupConfig(UINTPTR BaseAddress);\n#else\nint XExample_Initialize(XExample *InstancePtr, u16 DeviceId);\nXExample_Config* XExample_LookupConfig(u16 DeviceId);\n#endif\nint XExample_CfgInitialize(XExample *InstancePtr, XExample_Config *ConfigPtr);\n#else\nint XExample_Initialize(XExample *InstancePtr, const char* InstanceName);\nint XExample_Release(XExample *InstancePtr);\n#endif\n\n\nvoid XExample_Set_a(XExample *InstancePtr, u64 Data);\nu64 XExample_Get_a(XExample *InstancePtr);\nvoid XExample_Set_b(XExample *InstancePtr, u64 Data);\nu64 XExample_Get_b(XExample *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xexample_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xexample.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XExample_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XExample_uio_map maps[ MAX_UIO_MAPS ];\n} XExample_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XExample_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XExample_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XExample_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XExample_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XExample_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XExample_Initialize(XExample *InstancePtr, const char* InstanceName) {\n\tXExample_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XExample_Release(XExample *InstancePtr) {\n\tXExample_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xexample.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xexample.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XExample_CfgInitialize(XExample *InstancePtr, XExample_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XExample_Set_a(XExample *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA, (u32)(Data));\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XExample_Get_a(XExample *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA);\n    Data += (u64)XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_A_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XExample_Set_b(XExample *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA, (u32)(Data));\n    XExample_WriteReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XExample_Get_b(XExample *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA);\n    Data += (u64)XExample_ReadReg(InstancePtr->Control_BaseAddress, XEXAMPLE_CONTROL_ADDR_B_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xexample_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of a\n//        bit 31~0 - a[31:0] (Read/Write)\n// 0x14 : Data signal of a\n//        bit 31~0 - a[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of b\n//        bit 31~0 - b[31:0] (Read/Write)\n// 0x20 : Data signal of b\n//        bit 31~0 - b[63:32] (Read/Write)\n// 0x24 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XEXAMPLE_CONTROL_ADDR_A_DATA 0x10\n#define XEXAMPLE_CONTROL_BITS_A_DATA 64\n#define XEXAMPLE_CONTROL_ADDR_B_DATA 0x1c\n#define XEXAMPLE_CONTROL_BITS_B_DATA 64\n\n"
      }
    ],
    "code_length": 10940,
    "token_count": 2888,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/maximum_likelihood_estimation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6170,
    "Worst-caseLatency": 6170.0,
    "BRAM_18K": 0,
    "LUT": 1362,
    "DSP": 11,
    "FF": 1314,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "maximum_likelihood_estimation",
    "ResourceMetric": 0.0006919161,
    "design_id": "project",
    "algo_name": "maximum_likelihood_estimation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "maximum_likelihood_estimation.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid maximum_likelihood_estimation(double data[N], double& mean, double& variance) {\n    double sum = 0.0;\n    double sum_sq = 0.0;\n\n    // Calculate mean\n    for (int i = 0; i < N; i++) {\n        sum += data[i];\n    }\n    mean = sum / N;\n\n    // Calculate variance\n    for (int i = 0; i < N; i++) {\n        sum_sq += (data[i] - mean) * (data[i] - mean);\n    }\n    variance = sum_sq / N;\n}\n\n// Top function name: maximum_likelihood_estimation\n"
      }
    ],
    "code_length": 477,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/md5/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2395,
    "Worst-caseLatency": 20007.0,
    "BRAM_18K": 0,
    "LUT": 2902,
    "DSP": 0,
    "FF": 729,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "md5",
    "ResourceMetric": 0.0006263999,
    "design_id": "project",
    "algo_name": "md5",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "md5.cpp",
        "file_content": "#include <cstdint>\n#include <cstring>\n\n#define INPUT_SIZE 1024\n\nconst uint32_t k[64] = {\n    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n    0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n    0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n    0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n    0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n    0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391\n};\n\nconst uint32_t r[] = {\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,\n    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21\n};\n\nvoid md5(const uint8_t input[INPUT_SIZE], uint8_t output[16]) {\n    uint32_t h0 = 0x67452301;\n    uint32_t h1 = 0xefcdab89;\n    uint32_t h2 = 0x98badcfe;\n    uint32_t h3 = 0x10325476;\n\n    uint8_t data[64];\n    uint32_t bit_len = INPUT_SIZE * 8;\n    uint32_t new_len = ((bit_len + 64) / 512 + 1) * 512 / 8;\n\n    for (uint32_t i = 0; i < new_len; i += 64) {\n        if (i + 64 <= INPUT_SIZE) {\n            memcpy(data, input + i, 64);\n        } else {\n            memset(data, 0, 64);\n            if (i < INPUT_SIZE) {\n                memcpy(data, input + i, INPUT_SIZE - i);\n                data[INPUT_SIZE - i] = 0x80;\n            } else if (i == INPUT_SIZE) {\n                data[0] = 0x80;\n            }\n            if (i + 64 - 8 <= INPUT_SIZE) {\n                uint32_t bits = bit_len;\n                memcpy(data + 56, &bits, 4);\n            }\n        }\n\n        uint32_t a = h0, b = h1, c = h2, d = h3, f, g;\n        for (uint32_t j = 0; j < 64; j++) {\n            if (j < 16) {\n                f = (b & c) | ((~b) & d);\n                g = j;\n            } else if (j < 32) {\n                f = (d & b) | ((~d) & c);\n                g = (5 * j + 1) % 16;\n            } else if (j < 48) {\n                f = b ^ c ^ d;\n                g = (3 * j + 5) % 16;\n            } else {\n                f = c ^ (b | (~d));\n                g = (7 * j) % 16;\n            }\n            uint32_t temp = d;\n            d = c;\n            c = b;\n            b = b + ((a + f + k[j] + ((uint32_t*)data)[g]) << r[j] | (a + f + k[j] + ((uint32_t*)data)[g]) >> (32 - r[j]));\n            a = temp;\n        }\n        h0 += a;\n        h1 += b;\n        h2 += c;\n        h3 += d;\n    }\n\n    memcpy(output, &h0, 4);\n    memcpy(output + 4, &h1, 4);\n    memcpy(output + 8, &h2, 4);\n    memcpy(output + 12, &h3, 4);\n}\n\n// Top function name: md5\n"
      }
    ],
    "code_length": 2997,
    "token_count": 1402,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/md_grid/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4865,
    "Worst-caseLatency": 67895681.0,
    "BRAM_18K": 0,
    "LUT": 7371,
    "DSP": 109,
    "FF": 7927,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "md",
    "ResourceMetric": 0.0051932839,
    "design_id": "project",
    "algo_name": "md_grid",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "md.c",
        "file_content": "#include \"md.h\"\n\n#define MIN(x,y) ( (x)<(y) ? (x) : (y) )\n#define MAX(x,y) ( (x)>(y) ? (x) : (y) )\n\nvoid md( int n_points[blockSide][blockSide][blockSide],\n         dvector_t force[blockSide][blockSide][blockSide][densityFactor],\n         dvector_t position[blockSide][blockSide][blockSide][densityFactor] )\n{\n  ivector_t b0, b1; // b0 is the current block, b1 is b0 or a neighboring block\n  dvector_t p, q; // p is a point in b0, q is a point in either b0 or b1\n  int32_t p_idx, q_idx;\n  TYPE dx, dy, dz, r2inv, r6inv, potential, f;\n\n  // Iterate over the grid, block by block\n  loop_grid0_x: for( b0.x=0; b0.x<blockSide; b0.x++ ) {\n  loop_grid0_y: for( b0.y=0; b0.y<blockSide; b0.y++ ) {\n  loop_grid0_z: for( b0.z=0; b0.z<blockSide; b0.z++ ) {\n  // Iterate over the 3x3x3 (modulo boundary conditions) cube of blocks around b0\n  loop_grid1_x: for( b1.x=MAX(0,b0.x-1); b1.x<MIN(blockSide,b0.x+2); b1.x++ ) {\n    #pragma HLS loop_tripcount min=1 max=blockSide\n  loop_grid1_y: for( b1.y=MAX(0,b0.y-1); b1.y<MIN(blockSide,b0.y+2); b1.y++ ) {\n    #pragma HLS loop_tripcount min=1 max=blockSide\n  loop_grid1_z: for( b1.z=MAX(0,b0.z-1); b1.z<MIN(blockSide,b0.z+2); b1.z++ ) {\n    #pragma HLS loop_tripcount min=1 max=blockSide\n    // For all points in b0\n    dvector_t *base_q = position[b1.x][b1.y][b1.z];\n    int q_idx_range = n_points[b1.x][b1.y][b1.z];\n    loop_p: for( p_idx=0; p_idx<n_points[b0.x][b0.y][b0.z]; p_idx++ ) {\n      #pragma HLS loop_tripcount min=1 max=64 avg=1\n      p = position[b0.x][b0.y][b0.z][p_idx];\n      TYPE sum_x = force[b0.x][b0.y][b0.z][p_idx].x;\n      TYPE sum_y = force[b0.x][b0.y][b0.z][p_idx].y;\n      TYPE sum_z = force[b0.x][b0.y][b0.z][p_idx].z;\n      // For all points in b1\n      loop_q: for( q_idx=0; q_idx< q_idx_range ; q_idx++ ) {\n        #pragma HLS loop_tripcount min=1 max=64 avg=1\n        q = *(base_q + q_idx);\n\n        // Don't compute our own\n        if( q.x!=p.x || q.y!=p.y || q.z!=p.z ) {\n          // Compute the LJ-potential\n          dx = p.x - q.x;\n          dy = p.y - q.y;\n          dz = p.z - q.z;\n          r2inv = 1.0/( dx*dx + dy*dy + dz*dz );\n          r6inv = r2inv*r2inv*r2inv;\n          potential = r6inv*(lj1*r6inv - lj2);\n          // Update forces\n          f = r2inv*potential;\n          sum_x += f*dx;\n          sum_y += f*dy;\n          sum_z += f*dz;\n        }\n      } // loop_q\n      force[b0.x][b0.y][b0.z][p_idx].x = sum_x ;\n      force[b0.x][b0.y][b0.z][p_idx].y = sum_y ;\n      force[b0.x][b0.y][b0.z][p_idx].z = sum_z ;\n    } // loop_p\n  }}} // loop_grid1_*\n  }}} // loop_grid0_*\n}\n"
      },
      {
        "file_name": "md.h",
        "file_content": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"support.h\"\n\n#define TYPE double\n\n// Problem Constants\n#define nAtoms        256\n#define domainEdge    20.0\n#define blockSide     4\n//#define blockSide     1\n#define nBlocks       (blockSide*blockSide*blockSide)\n#define blockEdge     (domainEdge/((TYPE)blockSide))\n// Memory Bound\n// This is an artifact of using statically-allocated arrays. We'll pretend that\n// it doesn't exist and instead track the actual number of points.\n#define densityFactor 10\n// LJ coefficients\n#define lj1           1.5\n#define lj2           2.0\n\ntypedef struct {\n  TYPE x, y, z;\n} dvector_t;\ntypedef struct {\n  int32_t x, y, z;\n} ivector_t;\n\nvoid md( int32_t n_points[blockSide][blockSide][blockSide],\n         dvector_t force[blockSide][blockSide][blockSide][densityFactor],\n         dvector_t position[blockSide][blockSide][blockSide][densityFactor]\n       );\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  int32_t n_points[blockSide][blockSide][blockSide];\n  dvector_t force[blockSide][blockSide][blockSide][densityFactor];\n  dvector_t position[blockSide][blockSide][blockSide][densityFactor];\n};\n"
      }
    ],
    "code_length": 2557,
    "token_count": 963,
    "pragma_number": 5,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/md_knn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2419,
    "Worst-caseLatency": 2419.0,
    "BRAM_18K": 0,
    "LUT": 21053,
    "DSP": 208,
    "FF": 35307,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "md_kernel",
    "ResourceMetric": 0.0131849575,
    "design_id": "project",
    "algo_name": "md_knn",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "md.c",
        "file_content": "/*\nImplemenataion based on:\nA. Danalis, G. Marin, C. McCurdy, J. S. Meredith, P. C. Roth, K. Spafford, V. Tipparaju, and J. S. Vetter.\nThe scalable heterogeneous computing (shoc) benchmark suite.\nIn Proceedings of the 3rd Workshop on General-Purpose Computation on Graphics Processing Units, 2010.\n*/\n\n#include \"md.h\"\n\nvoid md_kernel(TYPE force_x[nAtoms],\n               TYPE force_y[nAtoms],\n               TYPE force_z[nAtoms],\n               TYPE position_x[nAtoms],\n               TYPE position_y[nAtoms],\n               TYPE position_z[nAtoms],\n               int32_t NL[nAtoms*maxNeighbors])\n{\n    TYPE delx, dely, delz, r2inv;\n    TYPE r6inv, potential, force, j_x, j_y, j_z;\n    TYPE i_x, i_y, i_z, fx, fy, fz;\n\n    int32_t i, j, jidx;\n\nloop_i : for (i = 0; i < nAtoms; i++){\n             i_x = position_x[i];\n             i_y = position_y[i];\n             i_z = position_z[i];\n             fx = 0;\n             fy = 0;\n             fz = 0;\nloop_j : for( j = 0; j < maxNeighbors; j++){\n             // Get neighbor\n             jidx = NL[i*maxNeighbors + j];\n             // Look up x,y,z positions\n             j_x = position_x[jidx];\n             j_y = position_y[jidx];\n             j_z = position_z[jidx];\n             // Calc distance\n             delx = i_x - j_x;\n             dely = i_y - j_y;\n             delz = i_z - j_z;\n             r2inv = 1.0/( delx*delx + dely*dely + delz*delz );\n             // Assume no cutoff and aways account for all nodes in area\n             r6inv = r2inv * r2inv * r2inv;\n             potential = r6inv*(lj1*r6inv - lj2);\n             // Sum changes in force\n             force = r2inv*potential;\n             fx += delx * force;\n             fy += dely * force;\n             fz += delz * force;\n         }\n         //Update forces after all neighbors accounted for.\n         force_x[i] = fx;\n         force_y[i] = fy;\n         force_z[i] = fz;\n         //printf(\"dF=%lf,%lf,%lf\\n\", fx, fy, fz);\n         }\n}\n"
      },
      {
        "file_name": "md.h",
        "file_content": "/*\nImplemenataion based on:\nA. Danalis, G. Marin, C. McCurdy, J. S. Meredith, P. C. Roth, K. Spafford, V. Tipparaju, and J. S. Vetter.\nThe scalable heterogeneous computing (shoc) benchmark suite.\nIn Proceedings of the 3rd Workshop on General-Purpose Computation on Graphics Processing Units, 2010.\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"support.h\"\n\n#define TYPE double\n\n// Problem Constants\n#define nAtoms        256\n#define maxNeighbors  16\n// LJ coefficients\n#define lj1           1.5\n#define lj2           2.0\n\nvoid md_kernel(TYPE force_x[nAtoms],\n               TYPE force_y[nAtoms],\n               TYPE force_z[nAtoms],\n               TYPE position_x[nAtoms],\n               TYPE position_y[nAtoms],\n               TYPE position_z[nAtoms],\n               int32_t NL[nAtoms*maxNeighbors]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE force_x[nAtoms];\n  TYPE force_y[nAtoms];\n  TYPE force_z[nAtoms];\n  TYPE position_x[nAtoms];\n  TYPE position_y[nAtoms];\n  TYPE position_z[nAtoms];\n  int32_t NL[nAtoms*maxNeighbors];\n};\n"
      }
    ],
    "code_length": 1959,
    "token_count": 551,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mean_absolute_error/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 220,
    "DSP": 0,
    "FF": 40,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mean_absolute_error",
    "ResourceMetric": 4.60236e-05,
    "design_id": "project",
    "algo_name": "mean_absolute_error",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mean_absolute_error.cpp",
        "file_content": "#include <cmath>\n#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid mean_absolute_error(ap_int<16> A[ARRAY_SIZE], ap_int<16> B[ARRAY_SIZE], ap_int<32> &mae) {\n    ap_int<32> sum = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += abs(A[i] - B[i]);\n    }\n    mae = sum / ARRAY_SIZE;\n}\n\n// Top function name: mean_absolute_error\n"
      }
    ],
    "code_length": 338,
    "token_count": 111,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mean_shift_clustering/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1049623,
    "Worst-caseLatency": 216397227.0,
    "BRAM_18K": 0,
    "LUT": 3447,
    "DSP": 12,
    "FF": 3212,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mean_shift_clustering",
    "ResourceMetric": 0.0013014346,
    "design_id": "project",
    "algo_name": "mean_shift_clustering",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mean_shift_clustering.cpp",
        "file_content": "#include <cmath>\n#include <limits>\n\n#define N 1024\n#define MAX_ITER 100\n#define EPSILON 0.01\n\nvoid mean_shift_clustering(float data[N][2], float centroids[N][2], int labels[N]) {\n    float shift[N][2];\n    int i, j, k, iter;\n    float distance, max_shift, norm;\n\n    // Initialize centroids to the data points\n    for (i = 0; i < N; i++) {\n        centroids[i][0] = data[i][0];\n        centroids[i][1] = data[i][1];\n    }\n\n    for (iter = 0; iter < MAX_ITER; iter++) {\n        max_shift = 0.0;\n\n        for (i = 0; i < N; i++) {\n            float sum[2] = {0.0, 0.0};\n            int count = 0;\n\n            for (j = 0; j < N; j++) {\n                distance = std::sqrt((data[j][0] - centroids[i][0]) * (data[j][0] - centroids[i][0]) +\n                                     (data[j][1] - centroids[i][1]) * (data[j][1] - centroids[i][1]));\n\n                if (distance < EPSILON) {\n                    sum[0] += data[j][0];\n                    sum[1] += data[j][1];\n                    count++;\n                }\n            }\n\n            if (count > 0) {\n                shift[i][0] = sum[0] / count - centroids[i][0];\n                shift[i][1] = sum[1] / count - centroids[i][1];\n                centroids[i][0] += shift[i][0];\n                centroids[i][1] += shift[i][1];\n            } else {\n                shift[i][0] = 0.0;\n                shift[i][1] = 0.0;\n            }\n\n            norm = std::sqrt(shift[i][0] * shift[i][0] + shift[i][1] * shift[i][1]);\n            if (norm > max_shift) {\n                max_shift = norm;\n            }\n        }\n\n        if (max_shift < EPSILON) {\n            break;\n        }\n    }\n\n    // Assign labels based on the nearest centroid\n    for (i = 0; i < N; i++) {\n        float min_dist = std::numeric_limits<float>::max();\n        int min_index = -1;\n\n        for (j = 0; j < N; j++) {\n            distance = std::sqrt((data[i][0] - centroids[j][0]) * (data[i][0] - centroids[j][0]) +\n                                 (data[i][1] - centroids[j][1]) * (data[i][1] - centroids[j][1]));\n\n            if (distance < min_dist) {\n                min_dist = distance;\n                min_index = j;\n            }\n        }\n\n        labels[i] = min_index;\n    }\n}\n\n// Top function name: mean_shift_clustering\n"
      }
    ],
    "code_length": 2258,
    "token_count": 632,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mean_squared_error/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2060,
    "Worst-caseLatency": 2060.0,
    "BRAM_18K": 0,
    "LUT": 556,
    "DSP": 5,
    "FF": 557,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mean_squared_error",
    "ResourceMetric": 0.0002985473,
    "design_id": "project",
    "algo_name": "mean_squared_error",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mean_squared_error.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid mean_squared_error(const float A[SIZE], const float B[SIZE], float &mse) {\n    float sum = 0.0;\n    for (int i = 0; i < SIZE; i++) {\n        float diff = A[i] - B[i];\n        sum += diff * diff;\n    }\n    mse = sum / SIZE;\n}\n\n// Top function name: mean_squared_error\n"
      }
    ],
    "code_length": 309,
    "token_count": 93,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/median_filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16354,
    "Worst-caseLatency": 18398.0,
    "BRAM_18K": 0,
    "LUT": 656,
    "DSP": 0,
    "FF": 278,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "median_filter",
    "ResourceMetric": 0.0001524531,
    "design_id": "project",
    "algo_name": "median_filter",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "median_filter.cpp",
        "file_content": "#include <algorithm>\n\n#define SIZE 1024\n\nvoid median_filter(int input[SIZE], int output[SIZE]) {\n    int window[3];\n    for (int i = 1; i < SIZE - 1; i++) {\n        window[0] = input[i - 1];\n        window[1] = input[i];\n        window[2] = input[i + 1];\n        \n        // Sort the window to find the median\n        for (int j = 0; j < 2; j++) {\n            for (int k = j + 1; k < 3; k++) {\n                if (window[j] > window[k]) {\n                    int temp = window[j];\n                    window[j] = window[k];\n                    window[k] = temp;\n                }\n            }\n        }\n        \n        output[i] = window[1];\n    }\n    // Handle boundary conditions\n    output[0] = input[0];\n    output[SIZE - 1] = input[SIZE - 1];\n}\n\n// Top function name: median_filter\n"
      }
    ],
    "code_length": 789,
    "token_count": 221,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/memory_allocation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 2,
    "LUT": 252,
    "DSP": 0,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "memory_allocation",
    "ResourceMetric": 0.0001777021,
    "design_id": "project",
    "algo_name": "memory_allocation",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "memory_allocation.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid memory_allocation(int input[SIZE], int output[SIZE]) {\n    int temp[SIZE];\n\n    for (int i = 0; i < SIZE; i++) {\n        temp[i] = input[i] * 2;\n    }\n\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = temp[i] + 1;\n    }\n}\n\n// Top function name: memory_allocation\n"
      }
    ],
    "code_length": 316,
    "token_count": 99,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/merge_load_balance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 66,
    "Worst-caseLatency": 66.0,
    "BRAM_18K": 0,
    "LUT": 504,
    "DSP": 0,
    "FF": 175,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 0.0001134289,
    "design_id": "project",
    "algo_name": "merge_load_balance",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef __MERGE_LOAD_BALANCE_HH__\n#define __MERGE_LOAD_BALANCE_HH__\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"hls_np_channel.h\"\n#include \"hls_stream.h\"\n\nvoid dut(hls::stream<int>& in1, hls::stream<int>& out1, hls::stream<int>& out2,\n         hls::stream<int>& out3, hls::stream<int>& out4);\n\n#endif\n\nvoid producer1(hls::stream<int>& out, hls::stream<int>& in) {\n#pragma HLS inline off\n    for (int i = 0; i < 16; i++) {\n        int tmp_d = in.read();\n        out.write(tmp_d);\n    }\n}\n\nvoid producer2(hls::stream<int>& out, hls::stream<int>& in) {\n#pragma HLS inline off\n    for (int i = 0; i < 16; i++) {\n        int tmp_d = in.read();\n        out.write(tmp_d);\n    }\n}\n\nvoid producer3(hls::stream<int>& out, hls::stream<int>& in) {\n#pragma HLS inline off\n    for (int i = 0; i < 16; i++) {\n        int tmp_d = in.read();\n        out.write(tmp_d);\n    }\n}\n\nvoid producer4(hls::stream<int>& out, hls::stream<int>& in) {\n#pragma HLS inline off\n    for (int i = 0; i < 16; i++) {\n        int tmp_d = in.read();\n        out.write(tmp_d);\n    }\n}\n\nvoid consumer1(hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS inline off\n    for (int i = 0; i < 64; i++) {\n        int tmp = in.read();\n        out.write(tmp);\n    }\n}\n\nvoid dut(hls::stream<int>& in1, hls::stream<int>& out1, hls::stream<int>& out2,\n         hls::stream<int>& out3, hls::stream<int>& out4) {\n#pragma HLS dataflow\n\n    hls::merge::load_balance<int, 4, 20> s;\n\n    producer1(s.in[0], out1);\n    producer2(s.in[1], out2);\n    producer3(s.in[2], out3);\n    producer4(s.in[3], out4);\n    consumer1(s.out, in1);\n}\n"
      }
    ],
    "code_length": 2935,
    "token_count": 818,
    "pragma_number": 6,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/merge_two_sorted_lists/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2051,
    "Worst-caseLatency": 2051.0,
    "BRAM_18K": 0,
    "LUT": 304,
    "DSP": 0,
    "FF": 174,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "merge_two_sorted_lists",
    "ResourceMetric": 7.49801e-05,
    "design_id": "project",
    "algo_name": "merge_two_sorted_lists",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "merge_two_sorted_lists.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid merge_two_sorted_lists(int list1[SIZE], int list2[SIZE], int merged_list[2*SIZE]) {\n    int i = 0, j = 0, k = 0;\n    \n    for (k = 0; k < 2 * SIZE; k++) {\n        if (i < SIZE && (j >= SIZE || list1[i] <= list2[j])) {\n            merged_list[k] = list1[i];\n            i++;\n        } else {\n            merged_list[k] = list2[j];\n            j++;\n        }\n    }\n}\n\n// Top function name: merge_two_sorted_lists\n"
      }
    ],
    "code_length": 456,
    "token_count": 139,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/mersenne_twister/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2329,
    "Worst-caseLatency": 2329.0,
    "BRAM_18K": 0,
    "LUT": 3275,
    "DSP": 9,
    "FF": 1790,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mersenne_twister",
    "ResourceMetric": 0.0010489945,
    "design_id": "project",
    "algo_name": "mersenne_twister",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "mersenne_twister.cpp",
        "file_content": "#include <stdint.h>\n\n#define N 1024\n\nvoid mersenne_twister(uint32_t seed, uint32_t output[N]) {\n    const uint32_t w = 32;\n    const uint32_t n = 624;\n    const uint32_t m = 397;\n    const uint32_t r = 31;\n    const uint32_t a = 0x9908B0DF;\n    const uint32_t u = 11;\n    const uint32_t d = 0xFFFFFFFF;\n    const uint32_t s = 7;\n    const uint32_t b = 0x9D2C5680;\n    const uint32_t t = 15;\n    const uint32_t c = 0xEFC60000;\n    const uint32_t l = 18;\n    const uint32_t f = 1812433253;\n\n    uint32_t MT[n];\n    uint32_t index = n + 1;\n\n    // Initialize the generator from a seed\n    MT[0] = seed;\n    for (uint32_t i = 1; i < n; ++i) {\n        MT[i] = (f * (MT[i - 1] ^ (MT[i - 1] >> (w - 2))) + i);\n    }\n\n    // Generate an array of n untempered numbers\n    for (uint32_t i = 0; i < n - m; ++i) {\n        uint32_t x = (MT[i] & ((1 << r) - 1)) + (MT[i + 1] & ~((1 << r) - 1));\n        uint32_t xA = x >> 1;\n        if (x % 2 != 0) {\n            xA ^= a;\n        }\n        MT[i] = MT[i + m] ^ xA;\n    }\n    for (uint32_t i = n - m; i < n - 1; ++i) {\n        uint32_t x = (MT[i] & ((1 << r) - 1)) + (MT[i + 1] & ~((1 << r) - 1));\n        uint32_t xA = x >> 1;\n        if (x % 2 != 0) {\n            xA ^= a;\n        }\n        MT[i] = MT[i + (m - n)] ^ xA;\n    }\n    uint32_t x = (MT[n - 1] & ((1 << r) - 1)) + (MT[0] & ~((1 << r) - 1));\n    uint32_t xA = x >> 1;\n    if (x % 2 != 0) {\n        xA ^= a;\n    }\n    MT[n - 1] = MT[m - 1] ^ xA;\n\n    // Tempering\n    for (uint32_t i = 0; i < N; ++i) {\n        uint32_t y = MT[i % n];\n        y ^= (y >> u) & d;\n        y ^= (y << s) & b;\n        y ^= (y << t) & c;\n        y ^= (y >> l);\n        output[i] = y;\n    }\n}\n\n// Top function name: mersenne_twister\n"
      }
    ],
    "code_length": 1705,
    "token_count": 689,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/meta_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097161,
    "Worst-caseLatency": 2097161.0,
    "BRAM_18K": 0,
    "LUT": 724,
    "DSP": 5,
    "FF": 725,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "meta_learning",
    "ResourceMetric": 0.000346872,
    "design_id": "project",
    "algo_name": "meta_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "meta_learning.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid meta_learning(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float weights[ARRAY_SIZE], float bias) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float weighted_sum = 0.0;\n        for (int j = 0; j < ARRAY_SIZE; j++) {\n            weighted_sum += input[j] * weights[j];\n        }\n        output[i] = weighted_sum + bias;\n    }\n}\n\n// Top function name: meta_learning\n"
      }
    ],
    "code_length": 428,
    "token_count": 114,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/micro_power_quad_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 169,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "micro_power_quad_comparator",
    "ResourceMetric": 3.48053e-05,
    "design_id": "project",
    "algo_name": "micro_power_quad_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "micro_power_quad_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid micro_power_quad_comparator(\n    ap_int<16> input1[ARRAY_SIZE],\n    ap_int<16> input2[ARRAY_SIZE],\n    ap_int<16> input3[ARRAY_SIZE],\n    ap_int<16> input4[ARRAY_SIZE],\n    ap_int<1> output1[ARRAY_SIZE],\n    ap_int<1> output2[ARRAY_SIZE],\n    ap_int<1> output3[ARRAY_SIZE],\n    ap_int<1> output4[ARRAY_SIZE]\n) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output1[i] = (input1[i] > input2[i]) ? 1 : 0;\n        output2[i] = (input2[i] > input3[i]) ? 1 : 0;\n        output3[i] = (input3[i] > input4[i]) ? 1 : 0;\n        output4[i] = (input4[i] > input1[i]) ? 1 : 0;\n    }\n}\n\n// Top function name: micro_power_quad_comparator\n"
      }
    ],
    "code_length": 681,
    "token_count": 241,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/min_max_scaling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2070,
    "Worst-caseLatency": 2070.0,
    "BRAM_18K": 0,
    "LUT": 765,
    "DSP": 2,
    "FF": 605,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "min_max_scaling",
    "ResourceMetric": 0.0002601168,
    "design_id": "project",
    "algo_name": "min_max_scaling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "min_max_scaling.cpp",
        "file_content": "#include <limits>\n\n#define ARRAY_SIZE 1024\n\nvoid min_max_scaling(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float min_val = std::numeric_limits<float>::max();\n    float max_val = std::numeric_limits<float>::min();\n\n    // Find the minimum and maximum values in the input array\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] < min_val) {\n            min_val = input[i];\n        }\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n    }\n\n    // Perform min-max scaling\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] - min_val) / (max_val - min_val);\n    }\n}\n\n// Top function name: min_max_scaling\n"
      }
    ],
    "code_length": 678,
    "token_count": 183,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/miniature_lcd_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "miniature_lcd_counter",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "miniature_lcd_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "miniature_lcd_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid miniature_lcd_counter(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] + 1;\n    }\n}\n\n// Top function name: miniature_lcd_counter\n"
      }
    ],
    "code_length": 244,
    "token_count": 75,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/mips/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 76,
    "Worst-caseLatency": 76.0,
    "BRAM_18K": 0,
    "LUT": 2308,
    "DSP": 8,
    "FF": 366,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "main",
    "ResourceMetric": 0.0006993174,
    "design_id": "project",
    "algo_name": "mips",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "mips.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*\n * Copyright (C) 2008\n * Y. Hara, H. Tomiyama, S. Honda, H. Takada and K. Ishii\n * Nagoya University, Japan\n * All rights reserved.\n *\n * Disclaimer of Warranty\n *\n * These software programs are available to the user without any license fee or\n * royalty on an \"as is\" basis. The authors disclaims any and all warranties, \n * whether express, implied, or statuary, including any implied warranties or \n * merchantability or of fitness for a particular purpose. In no event shall the\n * copyright-holder be liable for any incidental, punitive, or consequential damages\n * of any kind whatsoever arising from the use of these programs. This disclaimer\n * of warranty extends to the user of these programs and user's customers, employees,\n * agents, transferees, successors, and assigns.\n *\n */\n#include <stdio.h>\n#include \"imem.h\"\nint main_result;\n\n#define R 0\n\n#define ADDU 33\n#define SUBU 35\n\n#define MULT 24\n#define MULTU 25\n\n#define MFHI 16\n#define MFLO 18\n\n#define AND 36\n#define OR 37\n#define XOR 38\n#define SLL 0\n#define SRL 2\n#define SLLV 4\n#define SRLV 6\n\n#define SLT 42\n#define SLTU 43\n\n#define JR 8\n\n#define J 2\n#define JAL 3\n\n#define ADDIU 9\n#define ANDI 12\n#define ORI 13\n#define XORI 14\n\n#define LW 35\n#define SW 43\n#define LUI 15\n\n#define BEQ 4\n#define BNE 5\n#define BGEZ 1\n\n#define SLTI 10\n#define SLTIU 11\n\n/*\n+--------------------------------------------------------------------------+\n| * Test Vectors (added for CHStone)                                       |\n|     A : input data                                                       |\n|     outData : expected output data                                       |\n+--------------------------------------------------------------------------+\n*/\nconst int A[8] = { 22, 5, -9, 3, -17, 38, 0, 11 };\nconst int outData[8] = { -17, -9, 0, 3, 5, 11, 22, 38 };\n\n#define IADDR(x)\t(((x)&0x000000ff)>>2)\n#define DADDR(x)\t(((x)&0x000000ff)>>2)\n\nint\nmain ()\n{\n  long long hilo;\n  int reg[32];\n  int Hi = 0;\n  int Lo = 0;\n  int pc = 0;\n  int dmem[64];\n  int j;\n\n  unsigned int ins;\n  int op;\n  int rs;\n  int rt;\n  int rd;\n  int shamt;\n  int funct;\n  short address;\n  int tgtadr;\n\n    while (1)\n    {\n\t#pragma HLS loop_tripcount min=1 max=1\n      int i;\n      int n_inst;\n\n      n_inst = 0;\n      main_result = 0;\n\n      for (i = 0; i < 32; i++)\n\t{\n\t  reg[i] = 0;\n\t}\n      reg[29] = 0x7fffeffc;\n\n      for (i = 0; i < 64; i++)\n\t{\n\t  dmem[i] = A[i];\n\t}\n\n      pc = 0x00400000;\n\n      do\n\t{\n\t\t#pragma HLS loop_tripcount min=1 max=1\n\t  ins = imem[IADDR (pc)];\n\t  pc = pc + 4;\n\n\t  op = ins >> 26;\n\n\t  switch (op)\n\t    {\n\t    case R:\n\t      funct = ins & 0x3f;\n\t      shamt = (ins >> 6) & 0x1f;\n\t      rd = (ins >> 11) & 0x1f;\n\t      rt = (ins >> 16) & 0x1f;\n\t      rs = (ins >> 21) & 0x1f;\n\n\t      switch (funct)\n\t\t{\n\n\t\tcase ADDU:\n\t\t  reg[rd] = reg[rs] + reg[rt];\n\t\t  break;\n\t\tcase SUBU:\n\t\t  reg[rd] = reg[rs] - reg[rt];\n\t\t  break;\n\n\t\tcase MULT:\n\t\t  hilo = (long long) reg[rs] * (long long) reg[rt];\n\t\t  Lo = hilo & 0x00000000ffffffffULL;\n\t\t  Hi = ((int) (hilo >> 32)) & 0xffffffffUL;\n\t\t  break;\n\t\tcase MULTU:\n\t\t  hilo =\n\t\t    (unsigned long long) ((unsigned int) (reg[rs])) *\n\t\t    (unsigned long long) ((unsigned int) (reg[rt]));\n\t\t  Lo = hilo & 0x00000000ffffffffULL;\n\t\t  Hi = ((int) (hilo >> 32)) & 0xffffffffUL;\n\t\t  break;\n\n\t\tcase MFHI:\n\t\t  reg[rd] = Hi;\n\t\t  break;\n\t\tcase MFLO:\n\t\t  reg[rd] = Lo;\n\t\t  break;\n\n\t\tcase AND:\n\t\t  reg[rd] = reg[rs] & reg[rt];\n\t\t  break;\n\t\tcase OR:\n\t\t  reg[rd] = reg[rs] | reg[rt];\n\t\t  break;\n\t\tcase XOR:\n\t\t  reg[rd] = reg[rs] ^ reg[rt];\n\t\t  break;\n\t\tcase SLL:\n\t\t  reg[rd] = reg[rt] << shamt;\n\t\t  break;\n\t\tcase SRL:\n\t\t  reg[rd] = reg[rt] >> shamt;\n\t\t  break;\n\t\tcase SLLV:\n\t\t  reg[rd] = reg[rt] << reg[rs];\n\t\t  break;\n\t\tcase SRLV:\n\t\t  reg[rd] = reg[rt] >> reg[rs];\n\t\t  break;\n\n\t\tcase SLT:\n\t\t  reg[rd] = reg[rs] < reg[rt];\n\t\t  break;\n\t\tcase SLTU:\n\t\t  reg[rd] = (unsigned int) reg[rs] < (unsigned int) reg[rt];\n\t\t  break;\n\n\t\tcase JR:\n\t\t  pc = reg[rs];\n\t\t  break;\n\t\tdefault:\n\t\t  pc = 0;\t// error\n\t\t  break;\n\t\t}\n\t      break;\n\n\t    case J:\n\t      tgtadr = ins & 0x3ffffff;\n\t      pc = tgtadr << 2;\n\t      break;\n\t    case JAL:\n\t      tgtadr = ins & 0x3ffffff;\n\t      reg[31] = pc;\n\t      pc = tgtadr << 2;\n\t      break;\n\n\t    default:\n\n\t      address = ins & 0xffff;\n\t      rt = (ins >> 16) & 0x1f;\n\t      rs = (ins >> 21) & 0x1f;\n\t      switch (op)\n\t\t{\n\t\tcase ADDIU:\n\t\t  reg[rt] = reg[rs] + address;\n\t\t  break;\n\n\t\tcase ANDI:\n\t\t  reg[rt] = reg[rs] & (unsigned short) address;\n\t\t  break;\n\t\tcase ORI:\n\t\t  reg[rt] = reg[rs] | (unsigned short) address;\n\t\t  break;\n\t\tcase XORI:\n\t\t  reg[rt] = reg[rs] ^ (unsigned short) address;\n\t\t  break;\n\n\t\tcase LW:\n\t\t  reg[rt] = dmem[DADDR (reg[rs] + address)];\n\t\t  break;\n\t\tcase SW:\n\t\t  dmem[DADDR (reg[rs] + address)] = reg[rt];\n\t\t  break;\n\n\t\tcase LUI:\n\t\t  reg[rt] = address << 16;\n\t\t  break;\n\n\t\tcase BEQ:\n\t\t  if (reg[rs] == reg[rt])\n\t\t    pc = pc - 4 + (address << 2);\n\t\t  break;\n\t\tcase BNE:\n\t\t  if (reg[rs] != reg[rt])\n\t\t    pc = pc - 4 + (address << 2);\n\t\t  break;\n\t\tcase BGEZ:\n\t\t  if (reg[rs] >= 0)\n\t\t    pc = pc - 4 + (address << 2);\n\t\t  break;\n\n\t\tcase SLTI:\n\t\t  reg[rt] = reg[rs] < address;\n\t\t  break;\n\n\t\tcase SLTIU:\n\t\t  reg[rt] = (unsigned int) reg[rs] < (unsigned short) address;\n\t\t  break;\n\n\t\tdefault:\n\t\t  pc = 0;\t/* error */\n\t\t  break;\n\t\t}\n\t      break;\n\t    }\n\t  reg[0] = 0;\n\t  n_inst = n_inst + 1;\n\t}\n      while (pc != 0);\n\n      return main_result;\n    }\n}\n"
      },
      {
        "file_name": "imem.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/*\n * Copyright (C) 2008\n * Y. Hara, H. Tomiyama, S. Honda, H. Takada and K. Ishii\n * Nagoya University, Japan\n * All rights reserved.\n *\n * Disclaimer of Warranty\n *\n * These software programs are available to the user without any license fee or\n * royalty on an \"as is\" basis. The authors disclaims any and all warranties, \n * whether express, implied, or statuary, including any implied warranties or \n * merchantability or of fitness for a particular purpose. In no event shall the\n * copyright-holder be liable for any incidental, punitive, or consequential damages\n * of any kind whatsoever arising from the use of these programs. This disclaimer\n * of warranty extends to the user of these programs and user's customers, employees,\n * agents, transferees, successors, and assigns.\n *\n */\nconst unsigned long imem[44] = {\n  0x8fa40000,\t\t\t// [0x00400000]  lw $4, 0($29)                   ; 175: lw $a0 0($sp)               # argc\n  0x27a50004,\t\t\t// [0x00400004]  addiu $5, $29, 4                ; 176: addiu $a1 $sp 4             # argv\n  0x24a60004,\t\t\t// [0x00400008]  addiu $6, $5, 4                 ; 177: addiu $a2 $a1 4             # envp\n  0x00041080,\t\t\t// [0x0040000c]  sll $2, $4, 2                   ; 178: sll $v0 $a0 2\n  0x00c23021,\t\t\t// [0x00400010]  addu $6, $6, $2                 ; 179: addu $a2 $a2 $v0\n  0x0c100016,\t\t\t// [0x00400014]  jal 0x00400058 [main]           ; 180: jal main\n  0x00000000,\t\t\t// [0x00400018]  nop                             ; 181: nop\n  0x3402000a,\t\t\t// [0x0040001c]  ori $2, $0, 10                  ; 183: li $v0 10\n  0x0000000c,\t\t\t// [0x00400020]  syscall                         ; 184: syscall                     # syscall 10 (exit)\n  0x3c011001,\t\t\t// [0x00400024]  lui $1, 4097 [A]                ; 4: la   $t0,A           ; C&S\n  0x34280000,\t\t\t// [0x00400028]  ori $8, $1, 0 [A]\n  0x00044880,\t\t\t// [0x0040002c]  sll $9, $4, 2                   ; 5: sll  $t1,$a0,2\n  0x01094821,\t\t\t// [0x00400030]  addu $9, $8, $9                 ; 6: addu $t1,$t0,$t1\n  0x8d2a0000,\t\t\t// [0x00400034]  lw $10, 0($9)                   ; 7: lw   $t2,($t1)\n  0x00055880,\t\t\t// [0x00400038]  sll $11, $5, 2                  ; 8: sll  $t3,$a1,2\n  0x010b5821,\t\t\t// [0x0040003c]  addu $11, $8, $11               ; 9: addu $t3,$t0,$t3\n  0x8d6c0000,\t\t\t// [0x00400040]  lw $12, 0($11)                  ; 10: lw   $t4,($t3)\n  0x018a682a,\t\t\t// [0x00400044]  slt $13, $12, $10               ; 11: slt  $t5,$t4,$t2\n  0x11a00003,\t\t\t// [0x00400048]  beq $13, $0, 12 [L1-0x00400048] ; 12: beq  $t5,$zero,L1\n  0xad2c0000,\t\t\t// [0x0040004c]  sw $12, 0($9)                   ; 13: sw   $t4,($t1)\n  0xad6a0000,\t\t\t// [0x00400050]  sw $10, 0($11)                  ; 14: sw   $t2,($t3)\n  0x03e00008,\t\t\t// [0x00400054]  jr $31                          ; 15: jr   $ra            ; L1\n  0x27bdfff4,\t\t\t// [0x00400058]  addiu $29, $29, -12             ; 17: addiu $sp,$sp,-12   ; main\n  0xafbf0008,\t\t\t// [0x0040005c]  sw $31, 8($29)                  ; 18: sw   $ra,8($sp)\n  0xafb10004,\t\t\t// [0x00400060]  sw $17, 4($29)                  ; 19: sw   $s1,4($sp)\n  0xafb00000,\t\t\t// [0x00400064]  sw $16, 0($29)                  ; 20: sw   $s0,0($sp)\n  0x24100000,\t\t\t// [0x00400068]  addiu $16, $0, 0                ; 21: addiu $s0,$zero,0\n  0x2a080008,\t\t\t// [0x0040006c]  slti $8, $16, 8                 ; 22: slti $t0,$s0,8      ; L5\n  0x1100000b,\t\t\t// [0x00400070]  beq $8, $0, 44 [L2-0x00400070]  ; 23: beq  $t0,$zero,L2\n  0x26110001,\t\t\t// [0x00400074]  addiu $17, $16, 1               ; 24: addiu $s1,$s0,1\n  0x2a280008,\t\t\t// [0x00400078]  slti $8, $17, 8                 ; 25: slti $t0,$s1,8      ; L4\n  0x11000006,\t\t\t// [0x0040007c]  beq $8, $0, 24 [L3-0x0040007c]  ; 26: beq  $t0,$zero,L3\n  0x26040000,\t\t\t// [0x00400080]  addiu $4, $16, 0                ; 27: addiu $a0,$s0,0\n  0x26250000,\t\t\t// [0x00400084]  addiu $5, $17, 0                ; 28: addiu $a1,$s1,0\n  0x0c100009,\t\t\t// [0x00400088]  jal 0x00400024 [compare_swap]   ; 29: jal  compare_swap\n  0x26310001,\t\t\t// [0x0040008c]  addiu $17, $17, 1               ; 30: addiu $s1,$s1,1\n  0x0810001e,\t\t\t// [0x00400090]  j 0x00400078 [L4]               ; 31: j    L4\n  0x26100001,\t\t\t// [0x00400094]  addiu $16, $16, 1               ; 32: addiu $s0,$s0,1     ; L3\n  0x0810001b,\t\t\t// [0x00400098]  j 0x0040006c [L5]               ; 33: j    L5\n  0x8fbf0008,\t\t\t// [0x0040009c]  lw $31, 8($29)                  ; 34: lw   $ra,8($sp)     ; L2\n  0x8fb10004,\t\t\t// [0x004000a0]  lw $17, 4($29)                  ; 35: lw   $s1,4($sp)\n  0x8fb00000,\t\t\t// [0x004000a4]  lw $16, 0($29)                  ; 36: lw   $s0,0($sp)\n  0x27bd000c,\t\t\t// [0x004000a8]  addiu $29, $29, 12              ; 37: addiu $sp,$sp,12\n  0x03e00008,\t\t\t// [0x004000ac]  jr $31                          ; 38: jr   $ra\n};\n"
      }
    ],
    "code_length": 6621,
    "token_count": 2012,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mirror_descent/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3094,
    "Worst-caseLatency": 3094.0,
    "BRAM_18K": 4,
    "LUT": 847,
    "DSP": 5,
    "FF": 710,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mirror_descent",
    "ResourceMetric": 0.0006170367,
    "design_id": "project",
    "algo_name": "mirror_descent",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mirror_descent.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid mirror_descent(float alpha, float beta, float gamma, float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float gradient[ARRAY_SIZE];\n    float mirror_map[ARRAY_SIZE];\n    \n    // Compute gradient\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        gradient[i] = 2 * input[i]; // Example gradient computation\n    }\n    \n    // Update mirror map\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        mirror_map[i] = input[i] - alpha * gradient[i];\n    }\n    \n    // Apply mirror map to get output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = beta * mirror_map[i] + gamma;\n    }\n}\n\n// Top function name: mirror_descent\n"
      }
    ],
    "code_length": 683,
    "token_count": 187,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mish_activation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1090,
    "Worst-caseLatency": 1090.0,
    "BRAM_18K": 5,
    "LUT": 12077,
    "DSP": 144,
    "FF": 11569,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mish_activation",
    "ResourceMetric": 0.0077245894,
    "design_id": "project",
    "algo_name": "mish_activation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mish_activation.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid mish_activation(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float x = input[i];\n        float softplus = log(1 + exp(x));\n        output[i] = x * tanh(softplus);\n    }\n}\n\n// Top function name: mish_activation\n"
      }
    ],
    "code_length": 317,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mixed_precision_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 1,
    "LUT": 223,
    "DSP": 2,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mixed_precision_training",
    "ResourceMetric": 0.0001655447,
    "design_id": "project",
    "algo_name": "mixed_precision_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mixed_precision_training.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_t;\n\nvoid mixed_precision_training(fixed_t input[SIZE], fixed_t weights[SIZE], fixed_t output[SIZE]) {\n    fixed_t temp[SIZE];\n    \n    // Forward pass\n    for (int i = 0; i < SIZE; i++) {\n        temp[i] = input[i] * weights[i];\n    }\n    \n    // Backward pass\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = temp[i] * fixed_t(0.1); // Example learning rate\n    }\n}\n// Top function name: mixed_precision_training\n"
      }
    ],
    "code_length": 494,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/mixed_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 131,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mixed_signal_processor",
    "ResourceMetric": 2.75183e-05,
    "design_id": "project",
    "algo_name": "mixed_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "mixed_signal_processor.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid mixed_signal_processor(fixed_point_t input_signal[ARRAY_SIZE], fixed_point_t output_signal[ARRAY_SIZE]) {\n    fixed_point_t gain = 1.5;\n    fixed_point_t offset = 0.25;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        fixed_point_t amplified_signal = input_signal[i] * gain;\n        fixed_point_t biased_signal = amplified_signal + offset;\n        output_signal[i] = biased_signal;\n    }\n}\n\n// Top function name: mixed_signal_processor\n"
      }
    ],
    "code_length": 532,
    "token_count": 136,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mixup/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 162,
    "DSP": 2,
    "FF": 191,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mixup",
    "ResourceMetric": 0.0001047873,
    "design_id": "project",
    "algo_name": "mixup",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mixup.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid mixup(ap_uint<16> data1[SIZE], ap_uint<16> data2[SIZE], ap_uint<16> output[SIZE], ap_uint<16> alpha) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (alpha * data1[i] + (65535 - alpha) * data2[i]) >> 16;\n    }\n}\n\n// Top function name: mixup\n"
      }
    ],
    "code_length": 297,
    "token_count": 107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mlp/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1321474,
    "Worst-caseLatency": 1346818.0,
    "BRAM_18K": 6,
    "LUT": 5645,
    "DSP": 40,
    "FF": 3001,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mlp",
    "ResourceMetric": 0.0028504356,
    "design_id": "project",
    "algo_name": "mlp",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mlp.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 256\n\nvoid mlp(float input[INPUT_SIZE], float hidden_weights[HIDDEN_SIZE][INPUT_SIZE], float hidden_bias[HIDDEN_SIZE], float output_weights[OUTPUT_SIZE][HIDDEN_SIZE], float output_bias[OUTPUT_SIZE], float output[OUTPUT_SIZE]) {\n    float hidden_layer[HIDDEN_SIZE];\n    float sum;\n\n    // Compute hidden layer activations\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        sum = hidden_bias[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            sum += input[j] * hidden_weights[i][j];\n        }\n        hidden_layer[i] = tanh(sum); // Activation function\n    }\n\n    // Compute output layer activations\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        sum = output_bias[i];\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            sum += hidden_layer[j] * output_weights[i][j];\n        }\n        output[i] = tanh(sum); // Activation function\n    }\n}\n\n// Top function name: mlp\n"
      }
    ],
    "code_length": 976,
    "token_count": 256,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/model_checkpointing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "model_checkpointing",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "model_checkpointing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "model_checkpointing.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid model_checkpointing(ap_int<32> input_data[ARRAY_SIZE], ap_int<32> checkpoint[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        checkpoint[i] = input_data[i];\n    }\n}\n\n// Top function name: model_checkpointing\n"
      }
    ],
    "code_length": 276,
    "token_count": 77,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/model_compression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 239,
    "DSP": 0,
    "FF": 258,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "model_compression",
    "ResourceMetric": 7.05695e-05,
    "design_id": "project",
    "algo_name": "model_compression",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "model_compression.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid model_compression(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (std::abs(input[i]) < threshold) {\n            output[i] = 0.0f;\n        } else {\n            output[i] = input[i];\n        }\n    }\n}\n\n// Top function name: model_compression\n"
      }
    ],
    "code_length": 365,
    "token_count": 98,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/model_ensemble/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1034,
    "Worst-caseLatency": 1034.0,
    "BRAM_18K": 0,
    "LUT": 792,
    "DSP": 13,
    "FF": 1003,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "model_ensemble",
    "ResourceMetric": 0.0006081985,
    "design_id": "project",
    "algo_name": "model_ensemble",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "model_ensemble.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid model_ensemble(float input1[ARRAY_SIZE], float input2[ARRAY_SIZE], float input3[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float model1 = input1[i] * 0.3f;\n        float model2 = input2[i] * 0.5f;\n        float model3 = input3[i] * 0.2f;\n        output[i] = model1 + model2 + model3;\n    }\n}\n\n// Top function name: model_ensemble\n"
      }
    ],
    "code_length": 430,
    "token_count": 134,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/model_personalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 702,
    "DSP": 7,
    "FF": 909,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "model_personalization",
    "ResourceMetric": 0.0004157034,
    "design_id": "project",
    "algo_name": "model_personalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "model_personalization.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid model_personalization(float global_model[ARRAY_SIZE], float local_model[ARRAY_SIZE], float personalized_model[ARRAY_SIZE], float learning_rate) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        personalized_model[i] = global_model[i] + learning_rate * (local_model[i] - global_model[i]);\n    }\n}\n\n// Top function name: model_personalization\n"
      }
    ],
    "code_length": 395,
    "token_count": 94,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/modified/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 133,
    "Worst-caseLatency": 133.0,
    "BRAM_18K": 0,
    "LUT": 211,
    "DSP": 0,
    "FF": 67,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mem_bottleneck_resolved",
    "ResourceMetric": 4.68865e-05,
    "design_id": "project",
    "algo_name": "modified",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _ARRAY_MEM_PERFORM_H_\n#define _ARRAY_MEM_PERFORM_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 128\n\ntypedef ap_int<8> din_t;\ntypedef ap_int<16> dout_t;\n\ndout_t mem_bottleneck_resolved(din_t mem[N]);\n\n#endif\n\ndout_t mem_bottleneck_resolved(din_t mem[N]) {\n\n    din_t tmp0, tmp1, tmp2;\n    dout_t sum = 0;\n    int i;\n\n    tmp0 = mem[0];\n    tmp1 = mem[1];\nSUM_LOOP:\n    for (i = 2; i < N; i++) {\n        tmp2 = mem[i];\n        sum += tmp2 + tmp1 + tmp0;\n        tmp0 = tmp1;\n        tmp1 = tmp2;\n    }\n\n    return sum;\n}\n"
      }
    ],
    "code_length": 1964,
    "token_count": 502,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/momentum_contrastive_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 131082,
    "Worst-caseLatency": 131082.0,
    "BRAM_18K": 0,
    "LUT": 863,
    "DSP": 10,
    "FF": 875,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "momentum_contrastive_learning",
    "ResourceMetric": 0.0005264292,
    "design_id": "project",
    "algo_name": "momentum_contrastive_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "momentum_contrastive_learning.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid momentum_contrastive_learning(\n    float query_embeddings[ARRAY_SIZE][128], \n    float key_embeddings[ARRAY_SIZE][128], \n    float momentum, \n    float updated_key_embeddings[ARRAY_SIZE][128])\n{\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        for (int j = 0; j < 128; j++) {\n            updated_key_embeddings[i][j] = momentum * key_embeddings[i][j] + (1 - momentum) * query_embeddings[i][j];\n        }\n    }\n}\n\n// Top function name: momentum_contrastive_learning\n"
      }
    ],
    "code_length": 515,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/momentum_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1040,
    "Worst-caseLatency": 1040.0,
    "BRAM_18K": 0,
    "LUT": 904,
    "DSP": 13,
    "FF": 1150,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "momentum_optimization",
    "ResourceMetric": 0.0006437709,
    "design_id": "project",
    "algo_name": "momentum_optimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "momentum_optimization.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid momentum_optimization(float learning_rate, float beta, float params[ARRAY_SIZE], float grads[ARRAY_SIZE], float velocity[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        velocity[i] = beta * velocity[i] + (1 - beta) * grads[i];\n        params[i] -= learning_rate * velocity[i];\n    }\n}\n\n// Top function name: momentum_optimization\n"
      }
    ],
    "code_length": 396,
    "token_count": 101,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/morphological_operations/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5227530,
    "Worst-caseLatency": 5227530.0,
    "BRAM_18K": 0,
    "LUT": 793,
    "DSP": 0,
    "FF": 187,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "morphological_operations",
    "ResourceMetric": 0.0001699995,
    "design_id": "project",
    "algo_name": "morphological_operations",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "morphological_operations.cpp",
        "file_content": "#include <cstdint>\n\n#define IMG_SIZE 1024\n\nvoid morphological_operations(uint8_t input_image[IMG_SIZE][IMG_SIZE], uint8_t output_image[IMG_SIZE][IMG_SIZE], bool is_dilation) {\n    int i, j, m, n;\n    uint8_t structuring_element[3][3] = {\n        {1, 1, 1},\n        {1, 1, 1},\n        {1, 1, 1}\n    };\n\n    for (i = 1; i < IMG_SIZE - 1; i++) {\n        for (j = 1; j < IMG_SIZE - 1; j++) {\n            uint8_t result = is_dilation ? 0 : 255;\n            for (m = -1; m <= 1; m++) {\n                for (n = -1; n <= 1; n++) {\n                    if (structuring_element[m + 1][n + 1]) {\n                        if (is_dilation) {\n                            result = result > input_image[i + m][j + n] ? result : input_image[i + m][j + n];\n                        } else {\n                            result = result < input_image[i + m][j + n] ? result : input_image[i + m][j + n];\n                        }\n                    }\n                }\n            }\n            output_image[i][j] = result;\n        }\n    }\n}\n\n// Top function name: morphological_operations\n"
      }
    ],
    "code_length": 1068,
    "token_count": 303,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/motion_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "motion_processor",
    "ResourceMetric": 2.90524e-05,
    "design_id": "project",
    "algo_name": "motion_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "motion_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid motion_processor(ap_int<16> input1[SIZE], ap_int<16> input2[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<16> diff = input1[i] - input2[i];\n        if (diff < 0) {\n            output[i] = -diff;\n        } else {\n            output[i] = diff;\n        }\n    }\n}\n// Top function name: motion_processor\n"
      }
    ],
    "code_length": 384,
    "token_count": 119,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/motor_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2056,
    "Worst-caseLatency": 2056.0,
    "BRAM_18K": 4,
    "LUT": 593,
    "DSP": 9,
    "FF": 145,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "motor_controller",
    "ResourceMetric": 0.0006249705,
    "design_id": "project",
    "algo_name": "motor_controller",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "motor_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid motor_controller(int32_t speed[ARRAY_SIZE], int32_t position[ARRAY_SIZE], int32_t control_signal[ARRAY_SIZE], int32_t Kp, int32_t Ki, int32_t Kd) {\n    int32_t error[ARRAY_SIZE];\n    int32_t integral[ARRAY_SIZE] = {0};\n    int32_t derivative[ARRAY_SIZE];\n    int32_t previous_error[ARRAY_SIZE] = {0};\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        error[i] = speed[i] - position[i];\n        integral[i] += error[i];\n        derivative[i] = error[i] - previous_error[i];\n        control_signal[i] = Kp * error[i] + Ki * integral[i] + Kd * derivative[i];\n        previous_error[i] = error[i];\n    }\n}\n\n// Top function name: motor_controller\n"
      }
    ],
    "code_length": 695,
    "token_count": 198,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/mpc/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 0,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mpc",
    "ResourceMetric": 0.0,
    "design_id": "project",
    "algo_name": "mpc",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "mpc.cpp",
        "file_content": "#include <iostream>\n\n#define N 1024\n\nvoid mpc(double state[N], double control[N], double A[N][N], double B[N][N], double Q[N][N], double R[N][N], double ref[N]) {\n    double temp1[N], temp2[N], temp3[N];\n    double new_state[N];\n\n    // Initialize new_state to zero\n    for (int i = 0; i < N; i++) {\n        new_state[i] = 0.0;\n    }\n\n    // Compute new_state = A * state + B * control\n    for (int i = 0; i < N; i++) {\n        temp1[i] = 0.0;\n        temp2[i] = 0.0;\n        for (int j = 0; j < N; j++) {\n            temp1[i] += A[i][j] * state[j];\n            temp2[i] += B[i][j] * control[j];\n        }\n        new_state[i] = temp1[i] + temp2[i];\n    }\n\n    // Compute cost function J = (new_state - ref)^T * Q * (new_state - ref) + control^T * R * control\n    double J = 0.0;\n    for (int i = 0; i < N; i++) {\n        temp3[i] = new_state[i] - ref[i];\n    }\n\n    for (int i = 0; i < N; i++) {\n        double sum1 = 0.0;\n        double sum2 = 0.0;\n        for (int j = 0; j < N; j++) {\n            sum1 += temp3[j] * Q[j][i];\n            sum2 += control[j] * R[j][i];\n        }\n        J += sum1 * temp3[i] + sum2 * control[i];\n    }\n\n    // Output the cost function value\n    std::cout << \"Cost function value: \" << J << std::endl;\n}\n\n// Top function name: mpc\n"
      }
    ],
    "code_length": 1265,
    "token_count": 432,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/multi_function_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 337,
    "DSP": 0,
    "FF": 115,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multi_function_counter",
    "ResourceMetric": 7.56512e-05,
    "design_id": "project",
    "algo_name": "multi_function_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "multi_function_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid multi_function_counter(ap_uint<32> input[ARRAY_SIZE], ap_uint<32> output[3]) {\n    ap_uint<32> sum = 0;\n    ap_uint<32> max_val = 0;\n    ap_uint<32> min_val = 0xFFFFFFFF;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += input[i];\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n        if (input[i] < min_val) {\n            min_val = input[i];\n        }\n    }\n\n    output[0] = sum;\n    output[1] = max_val;\n    output[2] = min_val;\n}\n\n// Top function name: multi_function_counter\n"
      }
    ],
    "code_length": 569,
    "token_count": 174,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/multi_head_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2820698139,
    "Worst-caseLatency": 2820698139.0,
    "BRAM_18K": 4544,
    "LUT": 3702,
    "DSP": 7,
    "FF": 2264,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multi_head_attention",
    "ResourceMetric": 0.2828669503,
    "design_id": "project",
    "algo_name": "multi_head_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "multi_head_attention.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define PATCH_SIZE 16\n#define EMBED_DIM 768\n#define NUM_HEADS 12\n#define HEAD_DIM (EMBED_DIM / NUM_HEADS)\n#define SEQ_LEN 1024\n\ntypedef ap_fixed<16, 6> data_t;\n\nvoid multi_head_attention(data_t input[SEQ_LEN][EMBED_DIM], \n                          data_t output[SEQ_LEN][EMBED_DIM], \n                          data_t weights_q[EMBED_DIM][EMBED_DIM], \n                          data_t weights_k[EMBED_DIM][EMBED_DIM], \n                          data_t weights_v[EMBED_DIM][EMBED_DIM], \n                          data_t weights_o[EMBED_DIM][EMBED_DIM]) {\n    data_t q[SEQ_LEN][EMBED_DIM];\n    data_t k[SEQ_LEN][EMBED_DIM];\n    data_t v[SEQ_LEN][EMBED_DIM];\n    data_t scores[SEQ_LEN][SEQ_LEN];\n    data_t attention[SEQ_LEN][SEQ_LEN];\n    data_t context[SEQ_LEN][EMBED_DIM];\n\n    // Linear transformations for Q, K, V\n    for (int i = 0; i < SEQ_LEN; i++) {\n        for (int j = 0; j < EMBED_DIM; j++) {\n            q[i][j] = 0;\n            k[i][j] = 0;\n            v[i][j] = 0;\n            for (int d = 0; d < EMBED_DIM; d++) {\n                q[i][j] += input[i][d] * weights_q[d][j];\n                k[i][j] += input[i][d] * weights_k[d][j];\n                v[i][j] += input[i][d] * weights_v[d][j];\n            }\n        }\n    }\n\n    // Scaled dot-product attention\n    for (int i = 0; i < SEQ_LEN; i++) {\n        for (int j = 0; j < SEQ_LEN; j++) {\n            scores[i][j] = 0;\n            for (int d = 0; d < EMBED_DIM; d++) {\n                scores[i][j] += q[i][d] * k[j][d];\n            }\n            scores[i][j] /= EMBED_DIM;\n        }\n    }\n\n    // Softmax (simplified for synthesis)\n    for (int i = 0; i < SEQ_LEN; i++) {\n        data_t sum = 0;\n        for (int j = 0; j < SEQ_LEN; j++) {\n            sum += scores[i][j];\n        }\n        for (int j = 0; j < SEQ_LEN; j++) {\n            attention[i][j] = scores[i][j] / sum;\n        }\n    }\n\n    // Compute context vectors\n    for (int i = 0; i < SEQ_LEN; i++) {\n        for (int j = 0; j < EMBED_DIM; j++) {\n            context[i][j] = 0;\n            for (int d = 0; d < SEQ_LEN; d++) {\n                context[i][j] += attention[i][d] * v[d][j];\n            }\n        }\n    }\n\n    // Output linear transformation\n    for (int i = 0; i < SEQ_LEN; i++) {\n        for (int j = 0; j < EMBED_DIM; j++) {\n            output[i][j] = 0;\n            for (int d = 0; d < EMBED_DIM; d++) {\n                output[i][j] += context[i][d] * weights_o[d][j];\n            }\n        }\n    }\n}\n\n// Top function name: multi_head_attention\n"
      }
    ],
    "code_length": 2509,
    "token_count": 772,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/multi_label_classification/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 20811,
    "Worst-caseLatency": 20811.0,
    "BRAM_18K": 0,
    "LUT": 3158,
    "DSP": 34,
    "FF": 1791,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multi_label_classification",
    "ResourceMetric": 0.0017192514,
    "design_id": "project",
    "algo_name": "multi_label_classification",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "multi_label_classification.cpp",
        "file_content": "#include <cmath>\n\n#define NUM_FEATURES 1024\n#define NUM_CLASSES 10\n\nvoid multi_label_classification(float input[NUM_FEATURES], float weights[NUM_CLASSES][NUM_FEATURES], float biases[NUM_CLASSES], float output[NUM_CLASSES]) {\n    for (int i = 0; i < NUM_CLASSES; i++) {\n        output[i] = biases[i];\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            output[i] += input[j] * weights[i][j];\n        }\n        output[i] = 1 / (1 + exp(-output[i])); // Sigmoid activation function\n    }\n}\n\n// Top function name: multi_label_classification\n"
      }
    ],
    "code_length": 546,
    "token_count": 141,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/multi_purpose_audio_video_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 225,
    "DSP": 3,
    "FF": 54,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multi_purpose_audio_video_processor",
    "ResourceMetric": 0.0001314364,
    "design_id": "project",
    "algo_name": "multi_purpose_audio_video_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "multi_purpose_audio_video_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid multi_purpose_audio_video_processor(\n    int32_t input_audio[ARRAY_SIZE], \n    int32_t input_video[ARRAY_SIZE], \n    int32_t output_audio[ARRAY_SIZE], \n    int32_t output_video[ARRAY_SIZE], \n    int32_t audio_gain, \n    int32_t video_brightness)\n{\n    // Audio processing: simple gain adjustment\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_audio[i] = input_audio[i] * audio_gain;\n    }\n\n    // Video processing: simple brightness adjustment\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_video[i] = input_video[i] + video_brightness;\n    }\n}\n\n// Top function name: multi_purpose_audio_video_processor\n"
      }
    ],
    "code_length": 676,
    "token_count": 176,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/multi_scale_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2151698470,
    "Worst-caseLatency": 2151698470.0,
    "BRAM_18K": 2050,
    "LUT": 4131,
    "DSP": 31,
    "FF": 2335,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multi_scale_attention",
    "ResourceMetric": 0.1289830219,
    "design_id": "project",
    "algo_name": "multi_scale_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "multi_scale_attention.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid multi_scale_attention(float input[SIZE][SIZE], float output[SIZE][SIZE], float weights[SIZE][SIZE], float bias[SIZE]) {\n    float intermediate[SIZE][SIZE];\n\n    // Step 1: Linear Transformation\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            intermediate[i][j] = 0;\n            for (int k = 0; k < SIZE; k++) {\n                intermediate[i][j] += input[i][k] * weights[k][j];\n            }\n            intermediate[i][j] += bias[j];\n        }\n    }\n\n    // Step 2: Non-linear Activation (ReLU)\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (intermediate[i][j] < 0) {\n                intermediate[i][j] = 0;\n            }\n        }\n    }\n\n    // Step 3: Attention Mechanism\n    float attention_weights[SIZE];\n    for (int i = 0; i < SIZE; i++) {\n        attention_weights[i] = 0;\n        for (int j = 0; j < SIZE; j++) {\n            attention_weights[i] += intermediate[i][j];\n        }\n        attention_weights[i] = exp(attention_weights[i]);\n    }\n\n    // Normalize attention weights\n    float sum_attention_weights = 0;\n    for (int i = 0; i < SIZE; i++) {\n        sum_attention_weights += attention_weights[i];\n    }\n    for (int i = 0; i < SIZE; i++) {\n        attention_weights[i] /= sum_attention_weights;\n    }\n\n    // Apply attention weights to the intermediate results\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            output[i][j] = intermediate[i][j] * attention_weights[i];\n        }\n    }\n}\n\n// Top function name: multi_scale_attention\n"
      }
    ],
    "code_length": 1623,
    "token_count": 452,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/multi_task_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 412,
    "DSP": 5,
    "FF": 508,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multi_task_learning",
    "ResourceMetric": 0.0002662349,
    "design_id": "project",
    "algo_name": "multi_task_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "multi_task_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid multi_task_learning(float input1[LARGE_SCALE], float input2[LARGE_SCALE], float output[LARGE_SCALE]) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        float task1 = input1[i] * input1[i]; // Task 1: Square of input1\n        float task2 = sqrt(input2[i]);       // Task 2: Square root of input2\n        output[i] = task1 + task2;           // Combine results of both tasks\n    }\n}\n\n// Top function name: multi_task_learning\n"
      }
    ],
    "code_length": 476,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/multicore_dsp/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 472,
    "DSP": 6,
    "FF": 564,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multicore_dsp",
    "ResourceMetric": 0.0003108141,
    "design_id": "project",
    "algo_name": "multicore_dsp",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "multicore_dsp.cpp",
        "file_content": "#include <ap_fixed.h>\n#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\ntypedef float floating_point_t;\n\nvoid multicore_dsp(fixed_point_t input_fixed[ARRAY_SIZE], floating_point_t input_float[ARRAY_SIZE], fixed_point_t output_fixed[ARRAY_SIZE], floating_point_t output_float[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Fixed-point processing\n        fixed_point_t temp_fixed = input_fixed[i] * input_fixed[i];\n        output_fixed[i] = temp_fixed + input_fixed[i];\n\n        // Floating-point processing\n        floating_point_t temp_float = input_float[i] * input_float[i];\n        output_float[i] = temp_float + input_float[i];\n    }\n}\n\n// Top function name: multicore_dsp\n"
      }
    ],
    "code_length": 734,
    "token_count": 181,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/multiplier_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 3,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multiplier_32bit",
    "ResourceMetric": 0.00010411,
    "design_id": "project",
    "algo_name": "multiplier_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "multiplier_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid multiplier_32bit(uint32_t A[ARRAY_SIZE], uint32_t B[ARRAY_SIZE], uint32_t C[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: multiplier_32bit\n"
      }
    ],
    "code_length": 261,
    "token_count": 84,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/multiply_divide_unit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1061,
    "Worst-caseLatency": 1061.0,
    "BRAM_18K": 0,
    "LUT": 1990,
    "DSP": 3,
    "FF": 3734,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "multiply_divide_unit",
    "ResourceMetric": 0.0008227487,
    "design_id": "project",
    "algo_name": "multiply_divide_unit",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "multiply_divide_unit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid multiply_divide_unit(ap_int<32> input1[SIZE], ap_int<32> input2[SIZE], ap_int<32> output_mul[SIZE], ap_int<32> output_div[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output_mul[i] = input1[i] * input2[i];\n        if (input2[i] != 0) {\n            output_div[i] = input1[i] / input2[i];\n        } else {\n            output_div[i] = 0; // Handle division by zero\n        }\n    }\n}\n\n// Top function name: multiply_divide_unit\n"
      }
    ],
    "code_length": 478,
    "token_count": 150,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/mutual_information/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8388669,
    "Worst-caseLatency": 8388669.0,
    "BRAM_18K": 3720,
    "LUT": 6106,
    "DSP": 68,
    "FF": 3565,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mutual_information",
    "ResourceMetric": 0.2340513642,
    "design_id": "project",
    "algo_name": "mutual_information",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "mutual_information.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define SIZE 1024\n\nvoid mutual_information(int hist[SIZE][SIZE], int num_samples, double &mi) {\n    double joint_prob[SIZE][SIZE];\n    double marginal_prob_x[SIZE] = {0};\n    double marginal_prob_y[SIZE] = {0};\n\n    // Calculate joint probability\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            joint_prob[i][j] = static_cast<double>(hist[i][j]) / num_samples;\n        }\n    }\n\n    // Calculate marginal probabilities\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            marginal_prob_x[i] += joint_prob[i][j];\n            marginal_prob_y[j] += joint_prob[i][j];\n        }\n    }\n\n    // Calculate mutual information\n    mi = 0.0;\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (joint_prob[i][j] > 0) {\n                mi += joint_prob[i][j] * log(joint_prob[i][j] / (marginal_prob_x[i] * marginal_prob_y[j]));\n            }\n        }\n    }\n}\n\n// Top function name: mutual_information\n"
      }
    ],
    "code_length": 1046,
    "token_count": 305,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/mux_16_to_1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 18,
    "Worst-caseLatency": 18.0,
    "BRAM_18K": 0,
    "LUT": 1285,
    "DSP": 0,
    "FF": 1249,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_16_to_1",
    "ResourceMetric": 0.000366175,
    "design_id": "project",
    "algo_name": "mux_16_to_1",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "mux_16_to_1.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_INPUTS 16\n#define DATA_WIDTH 32\n\ntypedef ap_uint<DATA_WIDTH> data_t;\ntypedef ap_uint<4> select_t;\n\nvoid mux_16_to_1(data_t inputs[NUM_INPUTS], select_t sel, data_t &output) {\n    #pragma HLS ARRAY_PARTITION variable=inputs complete dim=1\n    #pragma HLS INTERFACE ap_ctrl_none port=return\n    #pragma HLS INTERFACE s_axilite port=inputs\n    #pragma HLS INTERFACE s_axilite port=sel\n    #pragma HLS INTERFACE s_axilite port=output\n\n    for (int i = 0; i < NUM_INPUTS; i++) {\n        if (sel == i) {\n            output = inputs[i];\n        }\n    }\n}\n\n// Top function name: mux_16_to_1\n"
      },
      {
        "file_name": "xmux_16_to_1_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xmux_16_to_1.h\"\n\nextern XMux_16_to_1_Config XMux_16_to_1_ConfigTable[];\n\n#ifdef SDT\nXMux_16_to_1_Config *XMux_16_to_1_LookupConfig(UINTPTR BaseAddress) {\n\tXMux_16_to_1_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XMux_16_to_1_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XMux_16_to_1_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XMux_16_to_1_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XMux_16_to_1_Initialize(XMux_16_to_1 *InstancePtr, UINTPTR BaseAddress) {\n\tXMux_16_to_1_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XMux_16_to_1_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XMux_16_to_1_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXMux_16_to_1_Config *XMux_16_to_1_LookupConfig(u16 DeviceId) {\n\tXMux_16_to_1_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XMUX_16_TO_1_NUM_INSTANCES; Index++) {\n\t\tif (XMux_16_to_1_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XMux_16_to_1_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XMux_16_to_1_Initialize(XMux_16_to_1 *InstancePtr, u16 DeviceId) {\n\tXMux_16_to_1_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XMux_16_to_1_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XMux_16_to_1_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xmux_16_to_1_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of inputs_0\n//        bit 31~0 - inputs_0[31:0] (Read/Write)\n// 0x14 : reserved\n// 0x18 : Data signal of inputs_1\n//        bit 31~0 - inputs_1[31:0] (Read/Write)\n// 0x1c : reserved\n// 0x20 : Data signal of inputs_2\n//        bit 31~0 - inputs_2[31:0] (Read/Write)\n// 0x24 : reserved\n// 0x28 : Data signal of inputs_3\n//        bit 31~0 - inputs_3[31:0] (Read/Write)\n// 0x2c : reserved\n// 0x30 : Data signal of inputs_4\n//        bit 31~0 - inputs_4[31:0] (Read/Write)\n// 0x34 : reserved\n// 0x38 : Data signal of inputs_5\n//        bit 31~0 - inputs_5[31:0] (Read/Write)\n// 0x3c : reserved\n// 0x40 : Data signal of inputs_6\n//        bit 31~0 - inputs_6[31:0] (Read/Write)\n// 0x44 : reserved\n// 0x48 : Data signal of inputs_7\n//        bit 31~0 - inputs_7[31:0] (Read/Write)\n// 0x4c : reserved\n// 0x50 : Data signal of inputs_8\n//        bit 31~0 - inputs_8[31:0] (Read/Write)\n// 0x54 : reserved\n// 0x58 : Data signal of inputs_9\n//        bit 31~0 - inputs_9[31:0] (Read/Write)\n// 0x5c : reserved\n// 0x60 : Data signal of inputs_10\n//        bit 31~0 - inputs_10[31:0] (Read/Write)\n// 0x64 : reserved\n// 0x68 : Data signal of inputs_11\n//        bit 31~0 - inputs_11[31:0] (Read/Write)\n// 0x6c : reserved\n// 0x70 : Data signal of inputs_12\n//        bit 31~0 - inputs_12[31:0] (Read/Write)\n// 0x74 : reserved\n// 0x78 : Data signal of inputs_13\n//        bit 31~0 - inputs_13[31:0] (Read/Write)\n// 0x7c : reserved\n// 0x80 : Data signal of inputs_14\n//        bit 31~0 - inputs_14[31:0] (Read/Write)\n// 0x84 : reserved\n// 0x88 : Data signal of inputs_15\n//        bit 31~0 - inputs_15[31:0] (Read/Write)\n// 0x8c : reserved\n// 0x90 : Data signal of sel\n//        bit 3~0 - sel[3:0] (Read/Write)\n//        others  - reserved\n// 0x94 : reserved\n// 0x98 : Data signal of output_r\n//        bit 31~0 - output_r[31:0] (Read)\n// 0x9c : Control signal of output_r\n//        bit 0  - output_r_ap_vld (Read/COR)\n//        others - reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_0_DATA  0x10\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_0_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_1_DATA  0x18\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_1_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_2_DATA  0x20\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_2_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_3_DATA  0x28\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_3_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_4_DATA  0x30\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_4_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_5_DATA  0x38\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_5_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_6_DATA  0x40\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_6_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_7_DATA  0x48\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_7_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_8_DATA  0x50\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_8_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_9_DATA  0x58\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_9_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_10_DATA 0x60\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_10_DATA 32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_11_DATA 0x68\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_11_DATA 32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_12_DATA 0x70\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_12_DATA 32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_13_DATA 0x78\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_13_DATA 32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_14_DATA 0x80\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_14_DATA 32\n#define XMUX_16_TO_1_CONTROL_ADDR_INPUTS_15_DATA 0x88\n#define XMUX_16_TO_1_CONTROL_BITS_INPUTS_15_DATA 32\n#define XMUX_16_TO_1_CONTROL_ADDR_SEL_DATA       0x90\n#define XMUX_16_TO_1_CONTROL_BITS_SEL_DATA       4\n#define XMUX_16_TO_1_CONTROL_ADDR_OUTPUT_R_DATA  0x98\n#define XMUX_16_TO_1_CONTROL_BITS_OUTPUT_R_DATA  32\n#define XMUX_16_TO_1_CONTROL_ADDR_OUTPUT_R_CTRL  0x9c\n\n"
      },
      {
        "file_name": "xmux_16_to_1_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xmux_16_to_1.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XMux_16_to_1_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XMux_16_to_1_uio_map maps[ MAX_UIO_MAPS ];\n} XMux_16_to_1_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XMux_16_to_1_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XMux_16_to_1_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XMux_16_to_1_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XMux_16_to_1_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XMux_16_to_1_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XMux_16_to_1_Initialize(XMux_16_to_1 *InstancePtr, const char* InstanceName) {\n\tXMux_16_to_1_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XMux_16_to_1_Release(XMux_16_to_1 *InstancePtr) {\n\tXMux_16_to_1_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xmux_16_to_1.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xmux_16_to_1.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XMux_16_to_1_CfgInitialize(XMux_16_to_1 *InstancePtr, XMux_16_to_1_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XMux_16_to_1_Set_inputs_0(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_0_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_0(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_0_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_1(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_1_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_1(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_1_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_2(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_2_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_2(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_2_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_3(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_3_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_3(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_3_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_4(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_4_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_4(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_4_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_5(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_5_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_5(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_5_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_6(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_6_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_6(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_6_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_7(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_7_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_7(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_7_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_8(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_8_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_8(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_8_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_9(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_9_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_9(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_9_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_10(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_10_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_10(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_10_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_11(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_11_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_11(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_11_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_12(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_12_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_12(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_12_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_13(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_13_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_13(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_13_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_14(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_14_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_14(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_14_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_inputs_15(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_15_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_inputs_15(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_INPUTS_15_DATA);\n    return Data;\n}\n\nvoid XMux_16_to_1_Set_sel(XMux_16_to_1 *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XMux_16_to_1_WriteReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_SEL_DATA, Data);\n}\n\nu32 XMux_16_to_1_Get_sel(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_SEL_DATA);\n    return Data;\n}\n\nu32 XMux_16_to_1_Get_output_r(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_OUTPUT_R_DATA);\n    return Data;\n}\n\nu32 XMux_16_to_1_Get_output_r_vld(XMux_16_to_1 *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XMux_16_to_1_ReadReg(InstancePtr->Control_BaseAddress, XMUX_16_TO_1_CONTROL_ADDR_OUTPUT_R_CTRL);\n    return Data & 0x1;\n}\n\n"
      },
      {
        "file_name": "xmux_16_to_1.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XMUX_16_TO_1_H\n#define XMUX_16_TO_1_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xmux_16_to_1_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XMux_16_to_1_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XMux_16_to_1;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XMux_16_to_1_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XMux_16_to_1_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XMux_16_to_1_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XMux_16_to_1_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XMux_16_to_1_Initialize(XMux_16_to_1 *InstancePtr, UINTPTR BaseAddress);\nXMux_16_to_1_Config* XMux_16_to_1_LookupConfig(UINTPTR BaseAddress);\n#else\nint XMux_16_to_1_Initialize(XMux_16_to_1 *InstancePtr, u16 DeviceId);\nXMux_16_to_1_Config* XMux_16_to_1_LookupConfig(u16 DeviceId);\n#endif\nint XMux_16_to_1_CfgInitialize(XMux_16_to_1 *InstancePtr, XMux_16_to_1_Config *ConfigPtr);\n#else\nint XMux_16_to_1_Initialize(XMux_16_to_1 *InstancePtr, const char* InstanceName);\nint XMux_16_to_1_Release(XMux_16_to_1 *InstancePtr);\n#endif\n\n\nvoid XMux_16_to_1_Set_inputs_0(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_0(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_1(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_1(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_2(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_2(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_3(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_3(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_4(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_4(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_5(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_5(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_6(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_6(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_7(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_7(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_8(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_8(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_9(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_9(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_10(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_10(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_11(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_11(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_12(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_12(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_13(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_13(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_14(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_14(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_inputs_15(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_inputs_15(XMux_16_to_1 *InstancePtr);\nvoid XMux_16_to_1_Set_sel(XMux_16_to_1 *InstancePtr, u32 Data);\nu32 XMux_16_to_1_Get_sel(XMux_16_to_1 *InstancePtr);\nu32 XMux_16_to_1_Get_output_r(XMux_16_to_1 *InstancePtr);\nu32 XMux_16_to_1_Get_output_r_vld(XMux_16_to_1 *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      }
    ],
    "code_length": 19235,
    "token_count": 5984,
    "pragma_number": 5,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/mux_2to1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_2to1",
    "ResourceMetric": 2.33953e-05,
    "design_id": "project",
    "algo_name": "mux_2to1",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "mux_2to1.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid mux_2to1(ap_uint<1> sel, ap_uint<32> in0[ARRAY_SIZE], ap_uint<32> in1[ARRAY_SIZE], ap_uint<32> out[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (sel == 0) {\n            out[i] = in0[i];\n        } else {\n            out[i] = in1[i];\n        }\n    }\n}\n\n// Top function name: mux_2to1\n"
      }
    ],
    "code_length": 357,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/mux_32_to_1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 37,
    "Worst-caseLatency": 37.0,
    "BRAM_18K": 0,
    "LUT": 127,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_32_to_1",
    "ResourceMetric": 2.86688e-05,
    "design_id": "project",
    "algo_name": "mux_32_to_1",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "mux_32_to_1.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_INPUTS 32\n#define DATA_WIDTH 16\n\nvoid mux_32_to_1(ap_uint<5> sel, ap_uint<DATA_WIDTH> inputs[NUM_INPUTS], ap_uint<DATA_WIDTH> &output) {\n    output = 0;\n    for (int i = 0; i < NUM_INPUTS; i++) {\n        if (sel == i) {\n            output = inputs[i];\n        }\n    }\n}\n\n// Top function name: mux_32_to_1\n"
      }
    ],
    "code_length": 338,
    "token_count": 109,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/mux_4_to_1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 103,
    "DSP": 0,
    "FF": 39,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_4_to_1",
    "ResourceMetric": 2.34912e-05,
    "design_id": "project",
    "algo_name": "mux_4_to_1",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "mux_4_to_1.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid mux_4_to_1(ap_uint<2> sel[ARRAY_SIZE], ap_uint<8> in0[ARRAY_SIZE], ap_uint<8> in1[ARRAY_SIZE], ap_uint<8> in2[ARRAY_SIZE], ap_uint<8> in3[ARRAY_SIZE], ap_uint<8> out[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (sel[i]) {\n            case 0:\n                out[i] = in0[i];\n                break;\n            case 1:\n                out[i] = in1[i];\n                break;\n            case 2:\n                out[i] = in2[i];\n                break;\n            case 3:\n                out[i] = in3[i];\n                break;\n            default:\n                out[i] = 0; // Default case, should not occur\n                break;\n        }\n    }\n}\n\n// Top function name: mux_4_to_1\n"
      }
    ],
    "code_length": 763,
    "token_count": 216,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/mux_8_to_1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 160,
    "DSP": 0,
    "FF": 27,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_8_to_1",
    "ResourceMetric": 3.32712e-05,
    "design_id": "project",
    "algo_name": "mux_8_to_1",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "mux_8_to_1.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid mux_8_to_1(ap_uint<3> sel, ap_uint<32> inputs[8][ARRAY_SIZE], ap_uint<32> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        switch (sel) {\n            case 0: output[i] = inputs[0][i]; break;\n            case 1: output[i] = inputs[1][i]; break;\n            case 2: output[i] = inputs[2][i]; break;\n            case 3: output[i] = inputs[3][i]; break;\n            case 4: output[i] = inputs[4][i]; break;\n            case 5: output[i] = inputs[5][i]; break;\n            case 6: output[i] = inputs[6][i]; break;\n            case 7: output[i] = inputs[7][i]; break;\n            default: output[i] = 0; break;\n        }\n    }\n}\n\n// Top function name: mux_8_to_1\n"
      }
    ],
    "code_length": 732,
    "token_count": 238,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/mux_demux/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 141,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_demux",
    "ResourceMetric": 2.95318e-05,
    "design_id": "project",
    "algo_name": "mux_demux",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "mux_demux.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid mux_demux(ap_uint<1> select, ap_uint<32> input1[SIZE], ap_uint<32> input2[SIZE], ap_uint<32> output1[SIZE], ap_uint<32> output2[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (select == 0) {\n            output1[i] = input1[i];\n            output2[i] = input2[i];\n        } else {\n            output1[i] = input2[i];\n            output2[i] = input1[i];\n        }\n    }\n}\n\n// Top function name: mux_demux\n"
      }
    ],
    "code_length": 458,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/mux_latch/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_latch",
    "ResourceMetric": 2.33953e-05,
    "design_id": "project",
    "algo_name": "mux_latch",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "mux_latch.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid mux_latch(ap_uint<1> sel, ap_uint<32> in0[SIZE], ap_uint<32> in1[SIZE], ap_uint<32> out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (sel == 0) {\n            out[i] = in0[i];\n        } else {\n            out[i] = in1[i];\n        }\n    }\n}\n\n// Top function name: mux_latch\n"
      }
    ],
    "code_length": 329,
    "token_count": 114,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/mux_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "mux_register",
    "ResourceMetric": 2.33953e-05,
    "design_id": "project",
    "algo_name": "mux_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "mux_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid mux_register(ap_uint<1> sel, ap_uint<32> in1[SIZE], ap_uint<32> in2[SIZE], ap_uint<32> out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (sel == 0) {\n            out[i] = in1[i];\n        } else {\n            out[i] = in2[i];\n        }\n    }\n}\n\n// Top function name: mux_register\n"
      }
    ],
    "code_length": 335,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/naive_bayes_classifier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8389,
    "Worst-caseLatency": 8389.0,
    "BRAM_18K": 0,
    "LUT": 7309,
    "DSP": 49,
    "FF": 9402,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "naive_bayes_classifier",
    "ResourceMetric": 0.003660587,
    "design_id": "project",
    "algo_name": "naive_bayes_classifier",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "naive_bayes_classifier.cpp",
        "file_content": "#include <cmath>\n#include <cfloat>\n\n#define NUM_FEATURES 16\n#define NUM_CLASSES 4\n#define NUM_SAMPLES 1024\n\nvoid naive_bayes_classifier(\n    float training_data[NUM_SAMPLES][NUM_FEATURES],\n    int training_labels[NUM_SAMPLES],\n    float test_data[NUM_FEATURES],\n    int &predicted_label)\n{\n    float class_probabilities[NUM_CLASSES] = {0};\n    float feature_probabilities[NUM_CLASSES][NUM_FEATURES] = {0};\n    int class_counts[NUM_CLASSES] = {0};\n\n    // Calculate class probabilities and feature probabilities\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        int label = training_labels[i];\n        class_counts[label]++;\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            feature_probabilities[label][j] += training_data[i][j];\n        }\n    }\n\n    for (int c = 0; c < NUM_CLASSES; c++) {\n        class_probabilities[c] = (float)class_counts[c] / NUM_SAMPLES;\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            feature_probabilities[c][j] /= class_counts[c];\n        }\n    }\n\n    // Calculate the posterior probabilities for each class\n    float max_prob = -FLT_MAX;\n    for (int c = 0; c < NUM_CLASSES; c++) {\n        float log_prob = logf(class_probabilities[c]);\n        for (int j = 0; j < NUM_FEATURES; j++) {\n            log_prob += logf(feature_probabilities[c][j]) * test_data[j];\n        }\n        if (log_prob > max_prob) {\n            max_prob = log_prob;\n            predicted_label = c;\n        }\n    }\n}\n\n// Top function name: naive_bayes_classifier\n"
      }
    ],
    "code_length": 1489,
    "token_count": 379,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/nand_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 81,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nand_gate",
    "ResourceMetric": 1.793e-05,
    "design_id": "project",
    "algo_name": "nand_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "nand_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid nand_gate(ap_uint<1> A[SIZE], ap_uint<1> B[SIZE], ap_uint<1> C[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        C[i] = ~(A[i] & B[i]);\n    }\n}\n\n// Top function name: nand_gate\n"
      }
    ],
    "code_length": 226,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/nat/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nat",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "nat",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "nat.cpp",
        "file_content": "#include <stdint.h>\n\n#define LARGE_SCALE 1024\n\nvoid nat(uint32_t src_ip[LARGE_SCALE], uint32_t dst_ip[LARGE_SCALE], uint32_t translated_ip[LARGE_SCALE]) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        // Simple NAT translation: add a fixed offset to the source IP\n        translated_ip[i] = src_ip[i] + 0x01000000; // Example offset for translation\n    }\n}\n// Top function name: nat\n"
      }
    ],
    "code_length": 389,
    "token_count": 108,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/native_casts/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 410,
    "Worst-caseLatency": 410.0,
    "BRAM_18K": 0,
    "LUT": 230,
    "DSP": 0,
    "FF": 31,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pointer_cast_native",
    "ResourceMetric": 4.70783e-05,
    "design_id": "project",
    "algo_name": "native_casts",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.c",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*******************************************************************************\nVendor: Xilinx\nAssociated Filename: pointer_cast_native.c\nPurpose:Vivado HLS Coding Style example\nDevice: All\nRevision History: May 30, 2008 - initial release\n\n*******************************************************************************\n#-  (c) Copyright 2011-2019 Xilinx, Inc. All rights reserved.\n#-\n#-  This file contains confidential and proprietary information\n#-  of Xilinx, Inc. and is protected under U.S. and\n#-  international copyright and other intellectual property\n#-  laws.\n#-\n#-  DISCLAIMER\n#-  This disclaimer is not a license and does not grant any\n#-  rights to the materials distributed herewith. Except as\n#-  otherwise provided in a valid license issued to you by\n#-  Xilinx, and to the maximum extent permitted by applicable\n#-  law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n#-  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n#-  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n#-  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n#-  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n#-  (2) Xilinx shall not be liable (whether in contract or tort,\n#-  including negligence, or under any other theory of\n#-  liability) for any loss or damage of any kind or nature\n#-  related to, arising under or in connection with these\n#-  materials, including for any direct, or any indirect,\n#-  special, incidental, or consequential loss or damage\n#-  (including loss of data, profits, goodwill, or any type of\n#-  loss or damage suffered as a result of any action brought\n#-  by a third party) even if such damage or loss was\n#-  reasonably foreseeable or Xilinx had been advised of the\n#-  possibility of the same.\n#-\n#-  CRITICAL APPLICATIONS\n#-  Xilinx products are not designed or intended to be fail-\n#-  safe, or for use in any application requiring fail-safe\n#-  performance, such as life-support or safety devices or\n#-  systems, Class III medical devices, nuclear facilities,\n#-  applications related to the deployment of airbags, or any\n#-  other applications that could lead to death, personal\n#-  injury, or severe property or environmental damage\n#-  (individually and collectively, \"Critical\n#-  Applications\"). Customer assumes the sole risk and\n#-  liability of any use of Xilinx products in Critical\n#-  Applications, subject only to applicable laws and\n#-  regulations governing limitations on product liability.\n#-\n#-  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n#-  PART OF THIS FILE AT ALL TIMES.\n#- ************************************************************************\n\n\nThis file contains confidential and proprietary information of Xilinx, Inc. and\nis protected under U.S. and international copyright and other intellectual\nproperty laws.\n\nDISCLAIMER\nThis disclaimer is not a license and does not grant any rights to the materials\ndistributed herewith. Except as otherwise provided in a valid license issued to\nyou by Xilinx, and to the maximum extent permitted by applicable law:\n(1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND WITH ALL FAULTS, AND XILINX\nHEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,\nINCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT, OR\nFITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable (whether\nin contract or tort, including negligence, or under any other theory of\nliability) for any loss or damage of any kind or nature related to, arising\nunder or in connection with these materials, including for any direct, or any\nindirect, special, incidental, or consequential loss or damage (including loss\nof data, profits, goodwill, or any type of loss or damage suffered as a result\nof any action brought by a third party) even if such damage or loss was\nreasonably foreseeable or Xilinx had been advised of the possibility of the\nsame.\n\nCRITICAL APPLICATIONS\nXilinx products are not designed or intended to be fail-safe, or for use in any\napplication requiring fail-safe performance, such as life-support or safety\ndevices or systems, Class III medical devices, nuclear facilities, applications\nrelated to the deployment of airbags, or any other applications that could lead\nto death, personal injury, or severe property or environmental damage\n(individually and collectively, \"Critical Applications\"). Customer assumes the\nsole risk and liability of any use of Xilinx products in Critical Applications,\nsubject only to applicable laws and regulations governing limitations on product\nliability.\n\nTHIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT\nALL TIMES.\n\n*******************************************************************************/\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _POINTER_CAST_NATIVE_H_\n#define _POINTER_CAST_NATIVE_H_\n\n// Missing include: #include <stdio.h>\n\n#define N 1024\n\ntypedef int data_t;\ntypedef char dint_t;\n\ndata_t pointer_cast_native(data_t index, data_t A[N]);\n\n#endif\n\ndata_t pointer_cast_native(data_t index, data_t A[N]) {\n  dint_t *ptr;\n  data_t i = 0, result = 0;\n  ptr = (dint_t *)(&A[index]);\n\n  // Sum from the indexed value as a different type\n  for (i = 0; i < 4 * (N / 10); ++i) {\n    result += *ptr;\n    ptr += 1;\n  }\n  return result;\n}\n"
      }
    ],
    "code_length": 6549,
    "token_count": 1489,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/navigator_motion_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "navigator_motion_processor",
    "ResourceMetric": 2.32994e-05,
    "design_id": "project",
    "algo_name": "navigator_motion_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "navigator_motion_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid navigator_motion_processor(ap_int<16> input_positions[ARRAY_SIZE], ap_int<16> input_velocities[ARRAY_SIZE], ap_int<16> output_positions[ARRAY_SIZE]) {\n    ap_int<16> acceleration = 2; // Fixed acceleration value\n    ap_int<16> time_step = 1; // Fixed time step\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Calculate new position based on velocity and acceleration\n        ap_int<16> new_position = input_positions[i] + input_velocities[i] * time_step + (acceleration * time_step * time_step) / 2;\n        output_positions[i] = new_position;\n    }\n}\n\n// Top function name: navigator_motion_processor\n"
      }
    ],
    "code_length": 660,
    "token_count": 171,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/nearest_neighbor_interpolation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2050,
    "Worst-caseLatency": 2050.0,
    "BRAM_18K": 0,
    "LUT": 79,
    "DSP": 0,
    "FF": 27,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nearest_neighbor_interpolation",
    "ResourceMetric": 1.77382e-05,
    "design_id": "project",
    "algo_name": "nearest_neighbor_interpolation",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "nearest_neighbor_interpolation.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 2048\n\nvoid nearest_neighbor_interpolation(float input[INPUT_SIZE], float output[OUTPUT_SIZE]) {\n    int scale_factor = OUTPUT_SIZE / INPUT_SIZE;\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        int nearest_index = i / scale_factor;\n        output[i] = input[nearest_index];\n    }\n}\n\n// Top function name: nearest_neighbor_interpolation\n"
      }
    ],
    "code_length": 401,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/nested_cross_validation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 0,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nested_cross_validation",
    "ResourceMetric": 0.0,
    "design_id": "project",
    "algo_name": "nested_cross_validation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "nested_cross_validation.cpp",
        "file_content": "#include <iostream>\n\n#define DATA_SIZE 1024\n\nvoid nested_cross_validation(float data[DATA_SIZE], float labels[DATA_SIZE], int k_folds, float results[DATA_SIZE]) {\n    int fold_size = DATA_SIZE / k_folds;\n    for (int i = 0; i < k_folds; i++) {\n        // Split data into training and validation sets\n        float train_data[DATA_SIZE - fold_size];\n        float train_labels[DATA_SIZE - fold_size];\n        float val_data[fold_size];\n        float val_labels[fold_size];\n\n        int train_idx = 0;\n        int val_idx = 0;\n        for (int j = 0; j < DATA_SIZE; j++) {\n            if (j >= i * fold_size && j < (i + 1) * fold_size) {\n                val_data[val_idx] = data[j];\n                val_labels[val_idx] = labels[j];\n                val_idx++;\n            } else {\n                train_data[train_idx] = data[j];\n                train_labels[train_idx] = labels[j];\n                train_idx++;\n            }\n        }\n\n        // Inner cross-validation\n        for (int m = 0; m < k_folds; m++) {\n            float inner_train_data[DATA_SIZE - 2 * fold_size];\n            float inner_train_labels[DATA_SIZE - 2 * fold_size];\n            float inner_val_data[fold_size];\n            float inner_val_labels[fold_size];\n\n            int inner_train_idx = 0;\n            int inner_val_idx = 0;\n            for (int n = 0; n < DATA_SIZE - fold_size; n++) {\n                if (n >= m * fold_size && n < (m + 1) * fold_size) {\n                    inner_val_data[inner_val_idx] = train_data[n];\n                    inner_val_labels[inner_val_idx] = train_labels[n];\n                    inner_val_idx++;\n                } else {\n                    inner_train_data[inner_train_idx] = train_data[n];\n                    inner_train_labels[inner_train_idx] = train_labels[n];\n                    inner_train_idx++;\n                }\n            }\n\n            // Train model on inner_train_data and inner_train_labels\n            // Validate model on inner_val_data and inner_val_labels\n            // Store the result\n        }\n\n        // Train final model on train_data and train_labels\n        // Validate final model on val_data and val_labels\n        // Store the result\n    }\n}\n\n// Top function name: nested_cross_validation\n"
      }
    ],
    "code_length": 2238,
    "token_count": 512,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/nesterov_momentum/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2069,
    "Worst-caseLatency": 2069.0,
    "BRAM_18K": 2,
    "LUT": 1149,
    "DSP": 10,
    "FF": 1150,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nesterov_momentum",
    "ResourceMetric": 0.0007316495,
    "design_id": "project",
    "algo_name": "nesterov_momentum",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "nesterov_momentum.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid nesterov_momentum(float learning_rate, float momentum, float weights[ARRAY_SIZE], float gradients[ARRAY_SIZE], float velocity[ARRAY_SIZE]) {\n    float temp_velocity[ARRAY_SIZE];\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp_velocity[i] = momentum * velocity[i] - learning_rate * gradients[i];\n    }\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        weights[i] += -momentum * velocity[i] + (1 + momentum) * temp_velocity[i];\n        velocity[i] = temp_velocity[i];\n    }\n}\n\n// Top function name: nesterov_momentum\n"
      }
    ],
    "code_length": 574,
    "token_count": 151,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/neural_architecture_modules/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1572881,
    "Worst-caseLatency": 1572881.0,
    "BRAM_18K": 1539,
    "LUT": 1427,
    "DSP": 5,
    "FF": 1145,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "neural_architecture_modules",
    "ResourceMetric": 0.0959460605,
    "design_id": "project",
    "algo_name": "neural_architecture_modules",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "neural_architecture_modules.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 512\n\nvoid neural_architecture_modules(float input[INPUT_SIZE], float output[OUTPUT_SIZE]) {\n    float weights1[INPUT_SIZE][OUTPUT_SIZE];\n    float biases1[OUTPUT_SIZE];\n    float weights2[OUTPUT_SIZE][OUTPUT_SIZE];\n    float biases2[OUTPUT_SIZE];\n    float intermediate[OUTPUT_SIZE];\n\n    // Initialize weights and biases (for demonstration purposes, using fixed values)\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            weights1[i][j] = 0.01f * (i + j);\n        }\n    }\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        biases1[i] = 0.1f * i;\n        biases2[i] = 0.1f * i;\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            weights2[i][j] = 0.01f * (i + j);\n        }\n    }\n\n    // First layer: Fully connected layer with ReLU activation\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        intermediate[i] = biases1[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            intermediate[i] += input[j] * weights1[j][i];\n        }\n        if (intermediate[i] < 0) {\n            intermediate[i] = 0;\n        }\n    }\n\n    // Second layer: Fully connected layer with ReLU activation\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output[i] = biases2[i];\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            output[i] += intermediate[j] * weights2[j][i];\n        }\n        if (output[i] < 0) {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: neural_architecture_modules\n"
      }
    ],
    "code_length": 1530,
    "token_count": 441,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/neural_architecture_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 525329,
    "Worst-caseLatency": 525329.0,
    "BRAM_18K": 2,
    "LUT": 894,
    "DSP": 2,
    "FF": 570,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "neural_architecture_search",
    "ResourceMetric": 0.0004055065,
    "design_id": "project",
    "algo_name": "neural_architecture_search",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "neural_architecture_search.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 1024\n#define LAYER_SIZE 256\n\nvoid neural_architecture_search(ap_int<16> input[INPUT_SIZE], ap_int<16> output[OUTPUT_SIZE], ap_int<16> weights1[LAYER_SIZE][INPUT_SIZE], ap_int<16> weights2[OUTPUT_SIZE][LAYER_SIZE]) {\n    ap_int<16> layer1[LAYER_SIZE];\n    ap_int<16> layer2[OUTPUT_SIZE];\n\n    // First layer computation\n    for (int i = 0; i < LAYER_SIZE; i++) {\n        layer1[i] = 0;\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            layer1[i] += input[j] * weights1[i][j];\n        }\n    }\n\n    // Second layer computation\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        layer2[i] = 0;\n        for (int j = 0; j < LAYER_SIZE; j++) {\n            layer2[i] += layer1[j] * weights2[i][j];\n        }\n    }\n\n    // Output assignment\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output[i] = layer2[i];\n    }\n}\n\n// Top function name: neural_architecture_search\n"
      }
    ],
    "code_length": 940,
    "token_count": 291,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/neuron_chip_network_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048581,
    "Worst-caseLatency": 1048581.0,
    "BRAM_18K": 0,
    "LUT": 375,
    "DSP": 1,
    "FF": 278,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "neuron_chip_network_processor",
    "ResourceMetric": 0.000126271,
    "design_id": "project",
    "algo_name": "neuron_chip_network_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "neuron_chip_network_processor.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 1024\n#define WEIGHT_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid neuron_chip_network_processor(fixed_point_t input[INPUT_SIZE], \n                                   fixed_point_t weights[WEIGHT_SIZE], \n                                   fixed_point_t bias, \n                                   fixed_point_t output[OUTPUT_SIZE]) {\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        fixed_point_t sum = 0;\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            sum += input[j] * weights[j];\n        }\n        output[i] = sum + bias;\n    }\n}\n// Top function name: neuron_chip_network_processor\n"
      }
    ],
    "code_length": 673,
    "token_count": 160,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/newton_raphson/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 26625,
    "Worst-caseLatency": 2178049.0,
    "BRAM_18K": 0,
    "LUT": 1323,
    "DSP": 11,
    "FF": 1269,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "newton_raphson",
    "ResourceMetric": 0.0006801226,
    "design_id": "project",
    "algo_name": "newton_raphson",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "newton_raphson.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n#define MAX_ITER 100\n#define TOLERANCE 1e-6\n\nvoid newton_raphson(double input[ARRAY_SIZE], double output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        double x = input[i];\n        for (int iter = 0; iter < MAX_ITER; iter++) {\n            double f_x = x * x - input[i];  // Function: f(x) = x^2 - input[i]\n            double f_prime_x = 2 * x;       // Derivative: f'(x) = 2x\n            double delta = f_x / f_prime_x;\n            x -= delta;\n            if (std::abs(delta) < TOLERANCE) {\n                break;\n            }\n        }\n        output[i] = x;\n    }\n}\n\n// Top function name: newton_raphson\n"
      }
    ],
    "code_length": 668,
    "token_count": 197,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/nmf/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 214748634348,
    "Worst-caseLatency": 214748634348.0,
    "BRAM_18K": 1856,
    "LUT": 5971,
    "DSP": 11,
    "FF": 4691,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nmf",
    "ResourceMetric": 0.1169789204,
    "design_id": "project",
    "algo_name": "nmf",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "nmf.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define M 512\n#define K 256\n#define MAX_ITER 100\n\nvoid nmf(double V[N][M], double W[N][K], double H[K][M], double W_out[N][K], double H_out[K][M]) {\n    double WH[N][M];\n    double Ht[K][M];\n    double Wt[N][K];\n    double Vt[N][M];\n\n    // Initialize W_out and H_out with W and H\n    for (int i = 0; i < N; i++) {\n        for (int k = 0; k < K; k++) {\n            W_out[i][k] = W[i][k];\n        }\n    }\n    for (int k = 0; k < K; k++) {\n        for (int j = 0; j < M; j++) {\n            H_out[k][j] = H[k][j];\n        }\n    }\n\n    for (int iter = 0; iter < MAX_ITER; iter++) {\n        // Compute WH = W_out * H_out\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                WH[i][j] = 0;\n                for (int k = 0; k < K; k++) {\n                    WH[i][j] += W_out[i][k] * H_out[k][j];\n                }\n            }\n        }\n\n        // Update H_out\n        for (int k = 0; k < K; k++) {\n            for (int j = 0; j < M; j++) {\n                double numerator = 0;\n                double denominator = 0;\n                for (int i = 0; i < N; i++) {\n                    numerator += W_out[i][k] * V[i][j];\n                    denominator += W_out[i][k] * WH[i][j];\n                }\n                H_out[k][j] *= numerator / (denominator + 1e-9);\n            }\n        }\n\n        // Compute WH = W_out * H_out\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                WH[i][j] = 0;\n                for (int k = 0; k < K; k++) {\n                    WH[i][j] += W_out[i][k] * H_out[k][j];\n                }\n            }\n        }\n\n        // Update W_out\n        for (int i = 0; i < N; i++) {\n            for (int k = 0; k < K; k++) {\n                double numerator = 0;\n                double denominator = 0;\n                for (int j = 0; j < M; j++) {\n                    numerator += H_out[k][j] * V[i][j];\n                    denominator += H_out[k][j] * WH[i][j];\n                }\n                W_out[i][k] *= numerator / (denominator + 1e-9);\n            }\n        }\n    }\n}\n\n// Top function name: nmf\n"
      }
    ],
    "code_length": 2139,
    "token_count": 670,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/noise_suppression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 179,
    "DSP": 0,
    "FF": 42,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "noise_suppression",
    "ResourceMetric": 3.8353e-05,
    "design_id": "project",
    "algo_name": "noise_suppression",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "noise_suppression.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define SIZE 1024\n\nvoid noise_suppression(int16_t input[SIZE], int16_t output[SIZE], int16_t threshold) {\n    for (int i = 0; i < SIZE; i++) {\n        if (std::abs(input[i]) < threshold) {\n            output[i] = 0;\n        } else {\n            output[i] = input[i];\n        }\n    }\n}\n\n// Top function name: noise_suppression\n"
      }
    ],
    "code_length": 363,
    "token_count": 101,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/non_restoring_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 36,
    "Worst-caseLatency": 36.0,
    "BRAM_18K": 0,
    "LUT": 242,
    "DSP": 0,
    "FF": 143,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "non_restoring_divider",
    "ResourceMetric": 6.01183e-05,
    "design_id": "project",
    "algo_name": "non_restoring_divider",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "non_restoring_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid non_restoring_divider(ap_uint<32> dividend, ap_uint<32> divisor, ap_uint<32> &quotient, ap_uint<32> &remainder) {\n    ap_uint<33> A = 0;\n    ap_uint<33> M = divisor;\n    ap_uint<33> Q = dividend;\n    ap_uint<33> temp;\n\n    for (int i = 0; i < 32; i++) {\n        A = (A << 1) | (Q >> 31);\n        Q = Q << 1;\n\n        temp = A - M;\n        if (temp[32] == 0) {\n            A = temp;\n            Q = Q | 1;\n        } else {\n            A = A;\n        }\n    }\n\n    if (A[32] == 1) {\n        A = A + M;\n    }\n\n    quotient = Q;\n    remainder = A.range(31, 0);\n}\n\n// Top function name: non_restoring_divider\n"
      }
    ],
    "code_length": 645,
    "token_count": 224,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/nonvolatile_safety_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 125,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nonvolatile_safety_counter",
    "ResourceMetric": 2.94359e-05,
    "design_id": "project",
    "algo_name": "nonvolatile_safety_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "nonvolatile_safety_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid nonvolatile_safety_counter(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    ap_uint<32> counter = 0;\n    for (int i = 0; i < SIZE; i++) {\n        counter += input[i];\n        output[i] = counter;\n    }\n}\n\n// Top function name: nonvolatile_safety_counter\n"
      }
    ],
    "code_length": 307,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/nor_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 81,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nor_gate",
    "ResourceMetric": 1.793e-05,
    "design_id": "project",
    "algo_name": "nor_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "nor_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid nor_gate(ap_uint<1> A[SIZE], ap_uint<1> B[SIZE], ap_uint<1> C[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        C[i] = ~(A[i] | B[i]);\n    }\n}\n\n// Top function name: nor_gate\n"
      }
    ],
    "code_length": 224,
    "token_count": 83,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2071,
    "Worst-caseLatency": 2071.0,
    "BRAM_18K": 0,
    "LUT": 788,
    "DSP": 2,
    "FF": 671,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "normalization",
    "ResourceMetric": 0.0002708556,
    "design_id": "project",
    "algo_name": "normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "normalization.cpp",
        "file_content": "#include <hls_stream.h>\n#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid normalization(float input[SIZE], float output[SIZE]) {\n    float max_val = input[0];\n    float min_val = input[0];\n\n    // Find the maximum and minimum values in the input array\n    for (int i = 1; i < SIZE; i++) {\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n        if (input[i] < min_val) {\n            min_val = input[i];\n        }\n    }\n\n    // Normalize the input array\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (input[i] - min_val) / (max_val - min_val);\n    }\n}\n\n// Top function name: normalization\n"
      }
    ],
    "code_length": 622,
    "token_count": 175,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/normalized_mutual_information/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6303850,
    "Worst-caseLatency": 6303850.0,
    "BRAM_18K": 0,
    "LUT": 9115,
    "DSP": 46,
    "FF": 6849,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "normalized_mutual_information",
    "ResourceMetric": 0.0036790148,
    "design_id": "project",
    "algo_name": "normalized_mutual_information",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "normalized_mutual_information.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define SIZE 1024\n\nvoid normalized_mutual_information(int32_t hist_joint[SIZE][SIZE], int32_t hist_marginal_x[SIZE], int32_t hist_marginal_y[SIZE], int32_t total_samples, float &nmi) {\n    float joint_entropy = 0.0f;\n    float marginal_entropy_x = 0.0f;\n    float marginal_entropy_y = 0.0f;\n\n    // Calculate joint entropy\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (hist_joint[i][j] > 0) {\n                float p = static_cast<float>(hist_joint[i][j]) / total_samples;\n                joint_entropy -= p * log2(p);\n            }\n        }\n    }\n\n    // Calculate marginal entropy for X\n    for (int i = 0; i < SIZE; i++) {\n        if (hist_marginal_x[i] > 0) {\n            float p = static_cast<float>(hist_marginal_x[i]) / total_samples;\n            marginal_entropy_x -= p * log2(p);\n        }\n    }\n\n    // Calculate marginal entropy for Y\n    for (int i = 0; i < SIZE; i++) {\n        if (hist_marginal_y[i] > 0) {\n            float p = static_cast<float>(hist_marginal_y[i]) / total_samples;\n            marginal_entropy_y -= p * log2(p);\n        }\n    }\n\n    // Calculate NMI\n    nmi = (marginal_entropy_x + marginal_entropy_y) / joint_entropy;\n}\n\n// Top function name: normalized_mutual_information\n"
      }
    ],
    "code_length": 1294,
    "token_count": 366,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/PolyBench/nussinov/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 37501,
    "Worst-caseLatency": 31312507501.0,
    "BRAM_18K": 0,
    "LUT": 1214,
    "DSP": 3,
    "FF": 495,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "kernel_nussinov",
    "ResourceMetric": 0.000363376,
    "design_id": "project",
    "algo_name": "nussinov",
    "source_name": "PolyBench",
    "source_code": [
      {
        "file_name": "nussinov.c",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/* nussinov.c: this file is part of PolyBench/C */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <math.h>\n\n/* Include polybench common header. */\n#include \"polybench.h\"\n\n/* Include benchmark-specific header. */\n#include \"nussinov.h\"\n\n/* RNA bases represented as chars, range is [0,3] */\ntypedef char base;\n\n#define match(b1, b2) (((b1)+(b2)) == 3 ? 1 : 0)\n#define max_score(s1, s2) ((s1 >= s2) ? s1 : s2)\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/*\n  Original version by Dave Wonnacott at Haverford College <davew@cs.haverford.edu>,\n  with help from Allison Lake, Ting Zhou, and Tian Jin,\n  based on algorithm by Nussinov, described in Allison Lake's senior thesis.\n*/\nvoid kernel_nussinov(int n, base POLYBENCH_1D(seq,N,n),\n\t\t\t   DATA_TYPE POLYBENCH_2D(table,N,N,n,n))\n{\n  int i, j, k;\n\n#pragma scop\n for (i = _PB_N-1; i >= 0; i--) {\n  for (j=i+1; j<_PB_N; j++) {\n   #pragma HLS loop_tripcount min=1 max=_PB_N\n   if (j-1>=0)\n      table[i][j] = max_score(table[i][j], table[i][j-1]);\n   if (i+1<_PB_N)\n      table[i][j] = max_score(table[i][j], table[i+1][j]);\n\n   if (j-1>=0 && i+1<_PB_N) {\n     /* don't allow adjacent elements to bond */\n     if (i<j-1)\n        table[i][j] = max_score(table[i][j], table[i+1][j-1]+match(seq[i], seq[j]));\n     else\n        table[i][j] = max_score(table[i][j], table[i+1][j-1]);\n   }\n\n   for (k=i+1; k<j; k++) {\n      #pragma HLS loop_tripcount min=1 max=_PB_N\n      table[i][j] = max_score(table[i][j], table[i][k] + table[k+1][j]);\n   }\n  }\n }\n#pragma endscop\n\n}\n\n"
      },
      {
        "file_name": "nussinov.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n#ifndef _NUSSINOV_H\n# define _NUSSINOV_H\n\n/* Default to LARGE_DATASET. */\n# if !defined(MINI_DATASET) && !defined(SMALL_DATASET) && !defined(MEDIUM_DATASET) && !defined(LARGE_DATASET) && !defined(EXTRALARGE_DATASET)\n#  define LARGE_DATASET\n# endif\n\n# if !defined(N)\n/* Define sample dataset sizes. */\n#  ifdef MINI_DATASET\n#   define N 60\n#  endif\n\n#  ifdef SMALL_DATASET\n#   define N 180\n#  endif\n\n#  ifdef MEDIUM_DATASET\n#   define N 500\n#  endif\n\n#  ifdef LARGE_DATASET\n#   define N 2500\n#  endif\n\n#  ifdef EXTRALARGE_DATASET\n#   define N 5500\n#  endif\n\n\n#endif /* !(N) */\n\n# define _PB_N POLYBENCH_LOOP_BOUND(N,n)\n\n\n/* Default data type */\n# if !defined(DATA_TYPE_IS_INT) && !defined(DATA_TYPE_IS_FLOAT) && !defined(DATA_TYPE_IS_DOUBLE)\n#  define DATA_TYPE_IS_INT\n# endif\n\n#ifdef DATA_TYPE_IS_INT\n#  define DATA_TYPE int\n#  define DATA_PRINTF_MODIFIER \"%d \"\n#endif\n\n#ifdef DATA_TYPE_IS_FLOAT\n#  define DATA_TYPE float\n#  define DATA_PRINTF_MODIFIER \"%0.2f \"\n#  define SCALAR_VAL(x) x##f\n#  define SQRT_FUN(x) sqrtf(x)\n#  define EXP_FUN(x) expf(x)\n#  define POW_FUN(x,y) powf(x,y)\n# endif\n\n#ifdef DATA_TYPE_IS_DOUBLE\n#  define DATA_TYPE double\n#  define DATA_PRINTF_MODIFIER \"%0.2lf \"\n#  define SCALAR_VAL(x) x\n#  define SQRT_FUN(x) sqrt(x)\n#  define EXP_FUN(x) exp(x)\n#  define POW_FUN(x,y) pow(x,y)\n# endif\n\n#endif /* !_NUSSINOV_H */\n"
      },
      {
        "file_name": "polybench.h",
        "file_content": "/**\n * This version is stamped on May 10, 2016\n *\n * Contact:\n *   Louis-Noel Pouchet <pouchet.ohio-state.edu>\n *   Tomofumi Yuki <tomofumi.yuki.fr>\n *\n * Web address: http://polybench.sourceforge.net\n */\n/*\n * polybench.h: this file is part of PolyBench/C\n *\n * Polybench header for instrumentation.\n *\n * Programs must be compiled with `-I utilities utilities/polybench.c'\n *\n * Optionally, one can define:\n *\n * -DPOLYBENCH_TIME, to report the execution time,\n *   OR (exclusive):\n * -DPOLYBENCH_PAPI, to use PAPI H/W counters (defined in polybench.c)\n *\n *\n * See README or utilities/polybench.c for additional options.\n *\n */\n#ifndef POLYBENCH_H\n# define POLYBENCH_H\n\n# include <stdlib.h>\n\n/* Array padding. By default, none is used. */\n# ifndef POLYBENCH_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_PADDING_FACTOR 0\n# endif\n\n/* Inter-array padding, for use with . By default, none is used. */\n# ifndef POLYBENCH_INTER_ARRAY_PADDING_FACTOR\n/* default: */\n#  define POLYBENCH_INTER_ARRAY_PADDING_FACTOR 0\n#  undef POLYBENCH_ENABLE_INTARRAY_PAD\n# else\n#  define POLYBENCH_ENABLE_INTARRAY_PAD\n# endif\n\n\n/* C99 arrays in function prototype. By default, do not use. */\n# ifdef POLYBENCH_USE_C99_PROTO\n#  define POLYBENCH_C99_SELECT(x,y) y\n# else\n/* default: */\n#  define POLYBENCH_C99_SELECT(x,y) x\n# endif\n\n\n/* Scalar loop bounds in SCoPs. By default, use parametric loop bounds. */\n# define POLYBENCH_USE_SCALAR_LB\n# ifdef POLYBENCH_USE_SCALAR_LB\n#  define POLYBENCH_LOOP_BOUND(x,y) x\n# else\n/* default: */\n#  define POLYBENCH_LOOP_BOUND(x,y) y\n# endif\n\n/* Use the 'restrict' keyword to declare that the different arrays do not\n * alias. By default, we do not use it as it is only supported in C99 and\n * even here several compilers do not properly get it.\n */\n# ifdef POLYBENCH_USE_RESTRICT\n#  define POLYBENCH_RESTRICT restrict\n# else\n/* default: */\n#  define POLYBENCH_RESTRICT\n# endif\n\n/* Macros to reference an array. Generic for heap and stack arrays\n   (C99).  Each array dimensionality has his own macro, to be used at\n   declaration or as a function argument.\n   Example:\n   int b[x] => POLYBENCH_1D_ARRAY(b, x)\n   int A[N][N] => POLYBENCH_2D_ARRAY(A, N, N)\n*/\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_ARRAY(x) *x\n#  ifdef POLYBENCH_ENABLE_INTARRAY_PAD\n#   define POLYBENCH_FREE_ARRAY(x) polybench_free_data((void*)x);\n#  else\n#   define POLYBENCH_FREE_ARRAY(x) free((void*)x);\n#  endif\n#  define POLYBENCH_DECL_VAR(x) (*x)\n# else\n#  define POLYBENCH_ARRAY(x) x\n#  define POLYBENCH_FREE_ARRAY(x)\n#  define POLYBENCH_DECL_VAR(x) x\n# endif\n/* Macros for using arrays in the function prototypes. */\n# define POLYBENCH_1D(var, dim1,ddim1) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_RESTRICT POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n/* Macros for using arrays within the functions. */\n# define POLYBENCH_1D_F(var, dim1,ddim1) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_2D_F(var, dim1, dim2, ddim1, ddim2) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_3D_F(var, dim1, dim2, dim3, ddim1, ddim2, ddim3) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_4D_F(var, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR]\n# define POLYBENCH_5D_F(var, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) var[POLYBENCH_C99_SELECT(dim1,ddim1) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim2,ddim2) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim3,ddim3) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim4,ddim4) + POLYBENCH_PADDING_FACTOR][POLYBENCH_C99_SELECT(dim5,ddim5) + POLYBENCH_PADDING_FACTOR]\n\n\n/* Macros to allocate heap arrays.\n   Example:\n   polybench_alloc_2d_array(N, M, double) => allocates N x M x sizeof(double)\n\t\t\t\t\t  and returns a pointer to the 2d array\n */\n# define POLYBENCH_ALLOC_1D_ARRAY(n1, type)\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data (n1 + POLYBENCH_PADDING_FACTOR, sizeof(type))\n# define POLYBENCH_ALLOC_2D_ARRAY(n1, n2, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_3D_ARRAY(n1, n2, n3, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_4D_ARRAY(n1, n2, n3, n4, type)\t\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n# define POLYBENCH_ALLOC_5D_ARRAY(n1, n2, n3, n4, n5, type)\t\t\\\n  (type(*)[n1 + POLYBENCH_PADDING_FACTOR][n2 + POLYBENCH_PADDING_FACTOR][n3 + POLYBENCH_PADDING_FACTOR][n4 + POLYBENCH_PADDING_FACTOR][n5 + POLYBENCH_PADDING_FACTOR])polybench_alloc_data ((n1 + POLYBENCH_PADDING_FACTOR) * (n2 + POLYBENCH_PADDING_FACTOR) * (n3 + POLYBENCH_PADDING_FACTOR) * (n4 + POLYBENCH_PADDING_FACTOR) * (n5 + POLYBENCH_PADDING_FACTOR), sizeof(type))\n\n/* Macros for array declaration. */\n# ifndef POLYBENCH_STACK_ARRAYS\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1); \\\n  var = POLYBENCH_ALLOC_1D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), type);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2); \\\n  var = POLYBENCH_ALLOC_2D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), type);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3); \\\n  var = POLYBENCH_ALLOC_3D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), type);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4); \\\n  var = POLYBENCH_ALLOC_4D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), type);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5); \\\n  var = POLYBENCH_ALLOC_5D_ARRAY(POLYBENCH_C99_SELECT(dim1, ddim1), POLYBENCH_C99_SELECT(dim2, ddim2), POLYBENCH_C99_SELECT(dim3, ddim3), POLYBENCH_C99_SELECT(dim4, ddim4), POLYBENCH_C99_SELECT(dim5, ddim5), type);\n# else\n#  define POLYBENCH_1D_ARRAY_DECL(var, type, dim1, ddim1)\t\t\\\n  type POLYBENCH_1D_F(POLYBENCH_DECL_VAR(var), dim1, ddim1);\n#  define POLYBENCH_2D_ARRAY_DECL(var, type, dim1, dim2, ddim1, ddim2)\t\\\n  type POLYBENCH_2D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, ddim1, ddim2);\n#  define POLYBENCH_3D_ARRAY_DECL(var, type, dim1, dim2, dim3, ddim1, ddim2, ddim3) \\\n  type POLYBENCH_3D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, ddim1, ddim2, ddim3);\n#  define POLYBENCH_4D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4) \\\n  type POLYBENCH_4D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, ddim1, ddim2, ddim3, ddim4);\n#  define POLYBENCH_5D_ARRAY_DECL(var, type, dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5) \\\n  type POLYBENCH_5D_F(POLYBENCH_DECL_VAR(var), dim1, dim2, dim3, dim4, dim5, ddim1, ddim2, ddim3, ddim4, ddim5);\n# endif\n\n\n/* Dead-code elimination macros. Use argc/argv for the run-time check. */\n# ifndef POLYBENCH_DUMP_ARRAYS\n#  define POLYBENCH_DCE_ONLY_CODE    if (argc > 42 && ! strcmp(argv[0], \"\"))\n# else\n#  define POLYBENCH_DCE_ONLY_CODE\n# endif\n\n#define POLYBENCH_DUMP_TARGET stderr\n#define POLYBENCH_DUMP_START    fprintf(POLYBENCH_DUMP_TARGET, \"==BEGIN DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_FINISH   fprintf(POLYBENCH_DUMP_TARGET, \"==END   DUMP_ARRAYS==\\n\")\n#define POLYBENCH_DUMP_BEGIN(s) fprintf(POLYBENCH_DUMP_TARGET, \"begin dump: %s\", s)\n#define POLYBENCH_DUMP_END(s)   fprintf(POLYBENCH_DUMP_TARGET, \"\\nend   dump: %s\\n\", s)\n\n# define polybench_prevent_dce(func)\t\t\\\n  POLYBENCH_DCE_ONLY_CODE\t\t\t\\\n  func\n\n\n/* Performance-related instrumentation. See polybench.c */\n# define polybench_start_instruments\n# define polybench_stop_instruments\n# define polybench_print_instruments\n\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern const unsigned int polybench_papi_eventlist[];\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_set_papi_thread_report(x)\t\\\n   polybench_papi_counters_threadid = x;\n#  define polybench_start_instruments\t\t\t\t\\\n  polybench_prepare_instruments();\t\t\t\t\\\n  polybench_papi_init();\t\t\t\t\t\\\n  int evid;\t\t\t\t\t\t\t\\\n  for (evid = 0; polybench_papi_eventlist[evid] != 0; evid++)\t\\\n    {\t\t\t\t\t\t\t\t\\\n      if (polybench_papi_start_counter(evid))\t\t\t\\\n\tcontinue;\t\t\t\t\t\t\\\n\n#  define polybench_stop_instruments\t\t\\\n      polybench_papi_stop_counter(evid);\t\\\n    }\t\t\t\t\t\t\\\n  polybench_papi_close();\t\t\t\\\n\n#  define polybench_print_instruments polybench_papi_print();\n# endif\n\n\n/* Timing support. */\n# if defined(POLYBENCH_TIME) || defined(POLYBENCH_GFLOPS)\n#  undef polybench_start_instruments\n#  undef polybench_stop_instruments\n#  undef polybench_print_instruments\n#  define polybench_start_instruments polybench_timer_start();\n#  define polybench_stop_instruments polybench_timer_stop();\n#  define polybench_print_instruments polybench_timer_print();\nextern double polybench_program_total_flops;\nextern void polybench_timer_start();\nextern void polybench_timer_stop();\nextern void polybench_timer_print();\n# endif\n\n/* PAPI support. */\n# ifdef POLYBENCH_PAPI\nextern int polybench_papi_start_counter(int evid);\nextern void polybench_papi_stop_counter(int evid);\nextern void polybench_papi_init();\nextern void polybench_papi_close();\nextern void polybench_papi_print();\n# endif\n\n/* Function prototypes. */\nextern void* polybench_alloc_data(unsigned long long int n, int elt_size);\nextern void polybench_free_data(void* ptr);\n\n/* PolyBench internal functions that should not be directly called by */\n/* the user, unless when designing customized execution profiling */\n/* approaches. */\nextern void polybench_flush_cache();\nextern void polybench_prepare_instruments();\n\n\n#endif /* !POLYBENCH_H */\n"
      }
    ],
    "code_length": 1792,
    "token_count": 596,
    "pragma_number": 4,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/nvme_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 0,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "nvme_controller",
    "ResourceMetric": 0.0,
    "design_id": "project",
    "algo_name": "nvme_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "nvme_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid nvme_controller(uint32_t cmd[DATA_SIZE], uint32_t data_in[DATA_SIZE], uint32_t data_out[DATA_SIZE]) {\n    uint32_t cmd_code;\n    uint32_t lba;\n    uint32_t length;\n    uint32_t buffer[DATA_SIZE];\n\n    for (int i = 0; i < DATA_SIZE; i++) {\n        cmd_code = cmd[i] & 0xFF;\n        lba = (cmd[i] >> 8) & 0xFFFFFF;\n        length = (cmd[i] >> 32) & 0xFFFFFFFF;\n\n        if (cmd_code == 0x01) { // Read command\n            for (uint32_t j = 0; j < length; j++) {\n                data_out[lba + j] = buffer[lba + j];\n            }\n        } else if (cmd_code == 0x02) { // Write command\n            for (uint32_t j = 0; j < length; j++) {\n                buffer[lba + j] = data_in[lba + j];\n            }\n        }\n    }\n}\n\n// Top function name: nvme_controller\n"
      }
    ],
    "code_length": 808,
    "token_count": 252,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/nw/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 33173,
    "Worst-caseLatency": 33303.0,
    "BRAM_18K": 0,
    "LUT": 2101,
    "DSP": 0,
    "FF": 686,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "needwun",
    "ResourceMetric": 0.0004686733,
    "design_id": "project",
    "algo_name": "nw",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "nw.c",
        "file_content": "#include \"nw.h\"\n\n#define MATCH_SCORE 1\n#define MISMATCH_SCORE -1\n#define GAP_SCORE -1\n\n#define ALIGN '\\\\'\n#define SKIPA '^'\n#define SKIPB '<'\n\n#define MAX(A,B) ( ((A)>(B))?(A):(B) )\n\nvoid needwun(char SEQA[ALEN], char SEQB[BLEN],\n             char alignedA[ALEN+BLEN], char alignedB[ALEN+BLEN],\n             int M[(ALEN+1)*(BLEN+1)], char ptr[(ALEN+1)*(BLEN+1)]){\n\n    int score, up_left, up, left, max;\n    int row, row_up, r;\n    int a_idx, b_idx;\n    int a_str_idx, b_str_idx;\n\n    init_row: for(a_idx=0; a_idx<(ALEN+1); a_idx++){\n        M[a_idx] = a_idx * GAP_SCORE;\n    }\n    init_col: for(b_idx=0; b_idx<(BLEN+1); b_idx++){\n        M[b_idx*(ALEN+1)] = b_idx * GAP_SCORE;\n    }\n\n    // Matrix filling loop\n    fill_out: for(b_idx=1; b_idx<(BLEN+1); b_idx++){\n        fill_in: for(a_idx=1; a_idx<(ALEN+1); a_idx++){\n            if(SEQA[a_idx-1] == SEQB[b_idx-1]){\n                score = MATCH_SCORE;\n            } else {\n                score = MISMATCH_SCORE;\n            }\n\n            row_up = (b_idx-1)*(ALEN+1);\n            row = (b_idx)*(ALEN+1);\n\n            up_left = M[row_up + (a_idx-1)] + score;\n            up      = M[row_up + (a_idx  )] + GAP_SCORE;\n            left    = M[row    + (a_idx-1)] + GAP_SCORE;\n\n            max = MAX(up_left, MAX(up, left));\n\n            M[row + a_idx] = max;\n            if(max == left){\n                ptr[row + a_idx] = SKIPB;\n            } else if(max == up){\n                ptr[row + a_idx] = SKIPA;\n            } else{\n                ptr[row + a_idx] = ALIGN;\n            }\n        }\n    }\n\n    // TraceBack (n.b. aligned sequences are backwards to avoid string appending)\n    a_idx = ALEN;\n    b_idx = BLEN;\n    a_str_idx = 0;\n    b_str_idx = 0;\n\n    trace: while(a_idx>0 || b_idx>0) {\n        #pragma HLS loop_tripcount min=128 max=128\n        r = b_idx*(ALEN+1);\n        if (ptr[r + a_idx] == ALIGN){\n            alignedA[a_str_idx++] = SEQA[a_idx-1];\n            alignedB[b_str_idx++] = SEQB[b_idx-1];\n            a_idx--;\n            b_idx--;\n        }\n        else if (ptr[r + a_idx] == SKIPB){\n            alignedA[a_str_idx++] = SEQA[a_idx-1];\n            alignedB[b_str_idx++] = '-';\n            a_idx--;\n        }\n        else{ // SKIPA\n            alignedA[a_str_idx++] = '-';\n            alignedB[b_str_idx++] = SEQB[b_idx-1];\n            b_idx--;\n        }\n    }\n\n    // Pad the result\n    pad_a: for( ; a_str_idx<ALEN+BLEN; a_str_idx++ ) {\n     #pragma HLS loop_tripcount min=0 max=128\n      alignedA[a_str_idx] = '_';\n    }\n    pad_b: for( ; b_str_idx<ALEN+BLEN; b_str_idx++ ) {\n     #pragma HLS loop_tripcount min=0 max=128\n      alignedB[b_str_idx] = '_';\n    }\n}\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "nw.h",
        "file_content": "#include <stdio.h>\n#include <stdlib.h>\n#include \"support.h\"\n\n#define ALEN 128\n#define BLEN 128\n\nvoid needwun(char SEQA[ALEN], char SEQB[BLEN],\n             char alignedA[ALEN+BLEN], char alignedB[ALEN+BLEN],\n             int M[(ALEN+1)*(BLEN+1)], char ptr[(ALEN+1)*(BLEN+1)]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  char seqA[ALEN];\n  char seqB[BLEN];\n  char alignedA[ALEN+BLEN];\n  char alignedB[ALEN+BLEN];\n  int M[(ALEN+1)*(BLEN+1)];\n  char ptr[(ALEN+1)*(BLEN+1)];\n};\n"
      }
    ],
    "code_length": 2640,
    "token_count": 800,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/octal_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 87,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "octal_counter",
    "ResourceMetric": 1.90806e-05,
    "design_id": "project",
    "algo_name": "octal_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "octal_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid octal_counter(ap_uint<3> input_array[ARRAY_SIZE], ap_uint<3> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<3> count = input_array[i];\n        output_array[i] = count + 1;\n        if (output_array[i] == 8) {\n            output_array[i] = 0;\n        }\n    }\n}\n\n// Top function name: octal_counter\n"
      }
    ],
    "code_length": 387,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/octal_differential_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 89,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "octal_differential_comparator",
    "ResourceMetric": 1.94641e-05,
    "design_id": "project",
    "algo_name": "octal_differential_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "octal_differential_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid octal_differential_comparator(ap_uint<3> input1[ARRAY_SIZE], ap_uint<3> input2[ARRAY_SIZE], ap_uint<3> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<3> diff = input1[i] - input2[i];\n        if (diff[2] == 1) { // Check if the result is negative\n            output[i] = 0;  // Set output to 0 if negative\n        } else {\n            output[i] = diff;\n        }\n    }\n}\n\n// Top function name: octal_differential_comparator\n"
      }
    ],
    "code_length": 508,
    "token_count": 153,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/odd_parity_generator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "odd_parity_generator",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "odd_parity_generator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "odd_parity_generator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid odd_parity_generator(ap_uint<1> input[ARRAY_SIZE], ap_uint<1> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<1> parity = 0;\n        for (int j = 0; j < 8; j++) {\n            parity ^= (input[i] >> j) & 1;\n        }\n        output[i] = parity;\n    }\n}\n\n// Top function name: odd_parity_generator\n"
      }
    ],
    "code_length": 380,
    "token_count": 120,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/one_hot_encoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5122,
    "Worst-caseLatency": 5122.0,
    "BRAM_18K": 0,
    "LUT": 623,
    "DSP": 0,
    "FF": 52,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "one_hot_encoding",
    "ResourceMetric": 0.0001244554,
    "design_id": "project",
    "algo_name": "one_hot_encoding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "one_hot_encoding.cpp",
        "file_content": "#include <ap_int.h>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 10\n\nvoid one_hot_encoding(ap_uint<10> input[INPUT_SIZE], ap_uint<1> output[INPUT_SIZE][OUTPUT_SIZE]) {\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            output[i][j] = (input[i] == j) ? 1 : 0;\n        }\n    }\n}\n\n// Top function name: one_hot_encoding\n"
      }
    ],
    "code_length": 369,
    "token_count": 116,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/online_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3169281,
    "Worst-caseLatency": 3169281.0,
    "BRAM_18K": 0,
    "LUT": 851,
    "DSP": 5,
    "FF": 715,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "online_learning",
    "ResourceMetric": 0.0003702673,
    "design_id": "project",
    "algo_name": "online_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "online_learning.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n\nvoid online_learning(float data[N], float weights[N], float learning_rate, float output[N]) {\n    for (int i = 0; i < N; i++) {\n        float prediction = 0.0;\n        for (int j = 0; j < N; j++) {\n            prediction += data[j] * weights[j];\n        }\n        float error = data[i] - prediction;\n        for (int j = 0; j < N; j++) {\n            weights[j] += learning_rate * error * data[j];\n        }\n        output[i] = prediction;\n    }\n}\n\n// Top function name: online_learning\n"
      }
    ],
    "code_length": 540,
    "token_count": 146,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/optical-flow/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 30429237,
    "Worst-caseLatency": 30429237.0,
    "BRAM_18K": 132,
    "LUT": 27479,
    "DSP": 64,
    "FF": 34472,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "optical_flow",
    "ResourceMetric": 0.0185323387,
    "design_id": "project",
    "algo_name": "optical-flow",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "xf_video_mem.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * HLS Video Memory Partition Header File\n */\n\n#ifndef ___XF__VIDEO_MEM__\n#define ___XF__VIDEO_MEM__\n\n//#define __DEBUG__\n\n#ifdef AESL_SYN\n#undef __DEBUG__\n#endif\n\n#include \"string.h\"\n#include \"xf_params.hpp\"\n\ntypedef ap_uint<32> XF_SIZE_T;\n\nnamespace xf {\nnamespace cv {\n\n//--------------------------------------------------------------------------------------\n// Template class of Window\n//--------------------------------------------------------------------------------------\ntemplate <int ROWS, int COLS, typename T>\nclass Window {\n   public:\n    Window(){\n// clang-format off\n\t#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=2\n        // clang-format on\n    };\n\n    /* Window main APIs */\n    void shift_pixels_left();\n    void shift_pixels_right();\n    void shift_pixels_up();\n    void shift_pixels_down();\n    void insert_pixel(T value, int row, int col);\n    void insert_row(T value[COLS], int row);\n    void insert_top_row(T value[COLS]);\n    void insert_bottom_row(T value[COLS]);\n    void insert_col(T value[ROWS], int col);\n    void insert_left_col(T value[ROWS]);\n    void insert_right_col(T value[ROWS]);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_left();\n    void shift_right();\n    void shift_up();\n    void shift_down();\n    void insert(T value, int row, int col);\n    void insert_top(T value[COLS]);\n    void insert_bottom(T value[COLS]);\n    void insert_left(T value[ROWS]);\n    void insert_right(T value[ROWS]);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void window_print();\n    T val_t[ROWS][COLS];\n#endif\n};\n\n/* Member functions of Window class */\n/* Origin in upper-left point */\n/*       0   1        C-2 C-1\n *     +---+---+-...-+---+---+\n *  0  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *  1  |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *       ...     ...    ...\n *     +---+---+-...-+---+---+\n * R-2 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n * R-1 |   |   |     |   |   |\n *     +---+---+-...-+---+---+\n *\n */\n\n/*\n * Window content shift left\n * Assumes new values will be placed in right column = COLS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_left() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS - 1; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j + 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n            else\n                assert(val_t[i][j + 1] == val[i][j] && \"*** window shift_pixels_left mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift right\n * Assumes new values will be placed in left column = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_right() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = COLS - 1; j > 0; j--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i][j - 1];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n            else\n                assert(val_t[i][j - 1] == val[i][j] && \"*** window shift_pixels_right mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift up\n * Assumes new values will be placed in bottom row = ROWS-1\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_up() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i + 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * Window content shift down\n * Assumes new values will be placed in top row = 0\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_pixels_down() {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i, j;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n            // clang-format on\n            val[i][j] = val[i - 1][j];\n        }\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i == 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert pixel\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_pixel(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    val[row][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row && j != col) assert(val_t[i][j] == val[i][j] && \"*** window insert_pixel mismatch! ***\");\n        }\n    }\n    val_t[row][col] = value;\n    assert(val_t[row][col] == val[row][col] && \"*** window insert_pixel mismatch! ***\");\n#endif\n}\n\n/* Window insert row\n * Inserts a set of values in any row of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_row(T value[COLS], int row) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T j;\n    for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[row][j] = value[j];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != row)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert top row\n * Inserts a set of values in top row = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert bottom row\n * Inserts a set of values in bottom row = ROWS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom_row(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_row(value, ROWS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (i != ROWS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val[i][j] == value[j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert column\n * Inserts a set of values in any column of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = value[i];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != col)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert left column\n * Inserts a set of values in left column = 0 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, 0);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != 0)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_left_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_left_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window insert right column\n * Inserts a set of values in right column = COLS-1 of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right_col(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n// clang-format on\n\n#ifdef __DEBUG__\n    std::cout << \"Window Elements: \";\n    window_print();\n    restore_val();\n#endif\n\n    insert_col(value, COLS - 1);\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"Window Elements Update: \";\n    window_print();\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j != COLS - 1)\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_right_col mismatch! ***\");\n            else\n                assert(val[i][j] == value[i] && \"*** window insert_right_col mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Window getval\n * Returns the data value in the window at position (row,col)\n */\ntemplate <int ROWS, int COLS, typename T>\nT& Window<ROWS, COLS, T>::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n#ifdef __DEBUG__\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::window_print() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            std::cout << std::setw(20) << val[i][j];\n        }\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift left, while contents shift right\n * Assumes new values will be placed in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_left() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_left(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift right, while contents shift left\n * Assumes new values will be placed in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_right() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_right(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_up() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::shift_down() {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(); // take upper-left point as origin\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert\n * Inserts a new value at any location of the window\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert(T value, int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_pixel(value, row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert top\n * Inserts a set of values in top row(=ROWS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_top(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert bottom\n * Inserts a set of values in bottom row(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_bottom(T value[COLS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert left\n * Inserts a set of values in left column(=COLS-1)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_left(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_right_col(value);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-right point as the origin\n * Window insert right\n * Inserts a set of values in right column(=0)\n */\ntemplate <int ROWS, int COLS, typename T>\nvoid Window<ROWS, COLS, T>::insert_right(T value[ROWS]) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_left_col(value);\n}\n\n//--------------------------------------------------------------------------------------\n// Template class of Line Buffer\n//--------------------------------------------------------------------------------------\n#define _LB_TPLT_DEC \\\n    template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE = RAM_S2P_BRAM, int RESHAPE_FACTOR = 1>\n#define _LB_TPLT template <int ROWS, int COLS, typename T, XF_ramtype_e MEM_TYPE, int RESHAPE_FACTOR>\n#define _LB_ LineBuffer<ROWS, COLS, T, MEM_TYPE, RESHAPE_FACTOR>\n\n_LB_TPLT_DEC class LineBuffer {\n   public:\n    LineBuffer() {\n// clang-format off\n\t#pragma HLS INLINE\n        #pragma HLS dependence variable=val inter false\n        #pragma HLS dependence variable=val intra false\n        // clang-format on\n\n        // #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n        //#pragma HLS array_reshape variable=val factor=RESHAPE_FACTOR  dim=1\n\n        switch (MEM_TYPE) {\n            case RAM_1P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_1P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_1P impl=URAM\n                // clang-format on\n                break;\n            case RAM_2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_S2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_S2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_S2P impl=URAM\n                // clang-format on\n                break;\n            case RAM_T2P_BRAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=BRAM\n                // clang-format on\n                break;\n            case RAM_T2P_URAM:\n// clang-format off\n                #pragma HLS bind_storage variable=val type=RAM_T2P impl=URAM\n                // clang-format on\n                break;\n            default:\n                assert(\"MEM_TYPE should be one of RAM_*_BRAM or RAM_*_URAM (*: 1P, 2P, S2P, T2P)\");\n        }\n\n        if (RESHAPE_FACTOR == 1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n            // clang-format on\n        } else {\n// clang-format off\n            #pragma HLS ARRAY_RESHAPE variable=val factor=RESHAPE_FACTOR  dim=1\n            // clang-format on\n        }\n    };\n\n    /* LineBuffer main APIs */\n    void shift_pixels_up(int col);\n    void shift_pixels_down(int col);\n    void insert_bottom_row(T value, int col);\n    void insert_top_row(T value, int col);\n    void get_col(T value[ROWS], int col);\n    T& getval(int row, int col);\n    T& operator()(int row, int col);\n\n    /* Back compatible APIs */\n    void shift_up(int col);\n    void shift_down(int col);\n    void insert_bottom(T value, int col);\n    void insert_top(T value, int col);\n    // T& getval(int row, int col);\n    // T& operator ()(int row, int col);\n\n    T val[ROWS][COLS];\n#ifdef __DEBUG__\n    void restore_val();\n    void linebuffer_print(int col);\n    T val_t[ROWS][COLS];\n#endif\n};\n/* Member functions of LineBuffer class */\n/* Origin in upper-left point */\n/*       0   1            C-2 C-1\n *     +---+---+-... ...-+---+---+\n *  0  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *  1  |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *       ...     ... ...    ...\n *     +---+---+-... ...-+---+---+\n * R-2 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n * R-1 |   |   |         |   |   |\n *     +---+---+-... ...-+---+---+\n *\n */\n\n/* Member functions of LineBuffer class */\n\n/*\n * LineBuffer content shift down\n * Assumes new values will be placed in top row = 0\n */\n_LB_TPLT void _LB_::shift_pixels_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = ROWS - 1; i > 0; i--) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i - 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == 0)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n                else\n                    assert(val_t[i - 1][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_down mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/*\n * LineBuffer content shift up\n * Assumes new values will be placed in top row = ROWS-1\n */\n_LB_TPLT void _LB_::shift_pixels_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS - 1; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[i][col] = val[i + 1][col];\n    }\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col)\n                if (i == ROWS - 1)\n                    assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n                else\n                    assert(val_t[i + 1][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window shift_pixels_up mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert bottom row\n * Inserts a new value in bottom row= ROWS-1 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_bottom_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[ROWS - 1][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == ROWS - 1)\n                assert(val[i][j] == value && \"*** window insert_bottom_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_bottom_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer insert top row\n * Inserts a new value in top row=0 of the linebuffer\n */\n_LB_TPLT void _LB_::insert_top_row(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n\n#ifdef __DEBUG__\n    std::cout << \"LineBuffer Elements in col=\" << col << \":\";\n    linebuffer_print(col);\n    restore_val();\n#endif\n\n    val[0][col] = value;\n\n#ifdef __DEBUG__\n    std::cout << \"===  After \" << __FUNCTION__ << \":  ===\\n\\n\";\n    std::cout << \"LineBuffer Elements Update in col=\" << col << \":\";\n    linebuffer_print(col);\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            if (j == col && i == 0)\n                assert(val[i][j] == value && \"*** window insert_top_row mismatch! ***\");\n            else\n                assert(val_t[i][j] == val[i][j] && \"*** window insert_top_row mismatch! ***\");\n        }\n    }\n#endif\n}\n\n/* LineBuffer get a column\n * Get a column value of the linebuffer\n */\n_LB_TPLT void _LB_::get_col(T value[ROWS], int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(col >= 0 && col < COLS);\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        value[i] = val[i][col];\n    }\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::getval(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    assert(row >= 0 && row < ROWS && col >= 0 && col < COLS);\n    return val[row][col];\n}\n\n/* Line buffer getval\n * Returns the data value in the line buffer at position row, col\n */\n_LB_TPLT T& _LB_::operator()(int row, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    return getval(row, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift down, while contents shift up\n * Assumes new values will be placed in bottom row(=0)\n */\n_LB_TPLT void _LB_::shift_down(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_down(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer shift up, while contents shift down\n * Assumes new values will be placed in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::shift_up(int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    shift_pixels_up(col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in bottom row(=0)\n */\n_LB_TPLT void _LB_::insert_bottom(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_top_row(value, col);\n}\n\n/* NOTE:\n * Back compatible APIs, take bottom-left point as the origin\n * LineBuffer insert\n * Inserts a new value in top row(=ROWS-1)\n */\n_LB_TPLT void _LB_::insert_top(T value, int col) {\n// clang-format off\n    #pragma HLS inline\n    // clang-format on\n    insert_bottom_row(value, col);\n}\n\n#ifdef __DEBUG__\n_LB_TPLT void _LB_::restore_val() {\n    XF_SIZE_T i, j;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (j = 0; j < COLS; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            val_t[i][j] = val[i][j];\n        }\n    }\n}\n\n_LB_TPLT void _LB_::linebuffer_print(int col) {\n    XF_SIZE_T i;\n    for (i = 0; i < ROWS; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        std::cout << \"\\n\";\n        std::cout << std::setw(20) << val[i][col];\n    }\n    std::cout << \"\\n\\n\";\n}\n#endif\n\n#undef _LB_TPLT_DEC\n#undef _LB_TPLT\n#undef _LB_\n\n} // namespace cv\n} // namespace xf\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "optical_flow.cpp",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                      optical_flow.cpp                         */\n/*                                                               */\n/*             Hardware function for optical flow                */\n/*                                                               */\n/*===============================================================*/\n\n#include \"optical_flow.h\"\n// use HLS video library\n// #include <hls_video.h>\n\n// use HLS fixed point\n#include \"ap_fixed.h\"\n\n#include \"xf_utility.hpp\"\n#include \"xf_common.hpp\"\n\n// define these constants so they can be used in pragma\nconst int max_width = MAX_WIDTH; \nconst int default_depth = MAX_WIDTH;\n// calculate gradient in x and y directions\nvoid gradient_xy_calc(input_t frame[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  // our own line buffer\n  static pixel_t buf[5][MAX_WIDTH];\n  #pragma HLS array_partition variable=buf complete dim=1\n\n  // small buffer\n  pixel_t smallbuf[5];\n  #pragma HLS array_partition variable=smallbuf complete dim=0\n  \n  // window buffer\n  xf::cv::Window<5,5,input_t> window;\n\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n\n  GRAD_XY_OUTER: for(int r=0; r<MAX_HEIGHT+2; r++)\n  {\n    GRAD_XY_INNER: for(int c=0; c<MAX_WIDTH+2; c++)\n    {\n      \n      // read out values from current line buffer\n      for (int i = 0; i < 4; i ++ )\n        smallbuf[i] = buf[i+1][c];\n      // the new value is either 0 or read from frame\n      if (r<MAX_HEIGHT && c<MAX_WIDTH)\n        smallbuf[4] = (pixel_t)(frame[r][c]);\n      else if (c < MAX_WIDTH)\n        smallbuf[4] = 0;\n      // update line buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n      else if(c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n\n      // manage window buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        window.shift_pixels_left();\n        \n        for (int i = 0; i < 5; i ++ )\n          window.insert_pixel(smallbuf[i],i,4);\n      }\n      else\n      {\n        window.shift_pixels_left();\n        window.insert_pixel(0,0,4);\n        window.insert_pixel(0,1,4);\n        window.insert_pixel(0,2,4);\n        window.insert_pixel(0,3,4);\n        window.insert_pixel(0,4,4);\n      }\n\n      // compute gradient\n      pixel_t x_grad = 0;\n      pixel_t y_grad = 0;\n      if(r>=4 && r<MAX_HEIGHT && c>=4 && c<MAX_WIDTH)\n      {\n        GRAD_XY_XYGRAD: for(int i=0; i<5; i++)\n        {\n          x_grad += window.getval(2,i)*GRAD_WEIGHTS[i];\n          y_grad += window.getval(i,2)*GRAD_WEIGHTS[i];\n        }\n        gradient_x[r-2][c-2] = x_grad/12;\n        gradient_y[r-2][c-2] = y_grad/12;\n      }\n      else if(r>=2 && c>=2)\n      {\n        gradient_x[r-2][c-2] = 0;\n        gradient_y[r-2][c-2] = 0;\n      }\n    }\n  }\n}\n\n// calculate gradient in the z direction\nvoid gradient_z_calc(input_t frame1[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame2[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame3[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame4[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame5[MAX_HEIGHT][MAX_WIDTH], \n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])\n{\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n  GRAD_Z_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_Z_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      gradient_z[r][c] =((pixel_t)(frame1[r][c]*GRAD_WEIGHTS[0] \n                        + frame2[r][c]*GRAD_WEIGHTS[1]\n                        + frame3[r][c]*GRAD_WEIGHTS[2]\n                        + frame4[r][c]*GRAD_WEIGHTS[3]\n                        + frame5[r][c]*GRAD_WEIGHTS[4]))/12;\n    }\n  }\n}\n\n// average the gradient in y direction\nvoid gradient_weight_y(pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH],\n    gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::LineBuffer<7,MAX_WIDTH,gradient_t> buf;\n\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+3; r++)\n  {\n    GRAD_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      #pragma HLS dependence variable=buf inter false\n\n      if(r<MAX_HEIGHT)\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = gradient_x[r][c];\n        tmp.y = gradient_y[r][c];\n        tmp.z = gradient_z[r][c];\n        buf.insert_bottom_row(tmp,c);\n      }\n      else\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;\n        buf.insert_bottom_row(tmp,c);\n      }     \n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(r >= 6 && r<MAX_HEIGHT)\n      { \n        GRAD_WEIGHT_Y_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(i,c).x*GRAD_FILTER[i];\n          acc.y += buf.getval(i,c).y*GRAD_FILTER[i];\n          acc.z += buf.getval(i,c).z*GRAD_FILTER[i];\n        }\n        filt_grad[r-3][c] = acc;\n      }\n      else if(r>=3)\n      {\n        filt_grad[r-3][c] = acc;\n      }\n    }\n  }\n}\n\n// average gradient in the x direction\nvoid gradient_weight_x(gradient_t y_filt[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::Window<1,7,gradient_t> buf;\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+3; c++)\n    {\n      \n      buf.shift_pixels_left();\n      gradient_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = y_filt[r][c];\n      }\n      else\n      {\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;  \n      }\n      buf.insert_pixel(tmp,0,6);\n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(c >= 6 && c<MAX_WIDTH) \n      {\n        GRAD_WEIGHT_X_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(0,i).x*GRAD_FILTER[i];\n          acc.y += buf.getval(0,i).y*GRAD_FILTER[i];\n          acc.z += buf.getval(0,i).z*GRAD_FILTER[i];\n        }\n        filt_grad[r][c-3] = acc;\n      }\n      else if(c>=3)\n      {\n        filt_grad[r][c-3] = acc;\n      }\n    }\n  }\n}\n\n// outer product \nvoid outer_product(gradient_t gradient[MAX_HEIGHT][MAX_WIDTH],\n     outer_t outer_product[MAX_HEIGHT][MAX_WIDTH])\n{\n  OUTER_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    OUTER_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      gradient_t grad = gradient[r][c];\n      outer_pixel_t x = (outer_pixel_t) grad.x;\n      outer_pixel_t y = (outer_pixel_t) grad.y;\n      outer_pixel_t z = (outer_pixel_t) grad.z;\n      outer_t out;\n      out.val[0] = (x*x);\n      out.val[1] = (y*y);\n      out.val[2] = (z*z);\n      out.val[3] = (x*y);\n      out.val[4] = (x*z);\n      out.val[5] = (y*z);\n      outer_product[r][c] = out;\n    }\n  }\n}\n\n// tensor weight\nvoid tensor_weight_y(outer_t outer[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::LineBuffer<3,MAX_WIDTH,outer_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+1; r++)\n  {\n    TENSOR_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      \n      outer_t tmp;\n      #pragma HLS data_pack variable=tmp\n      #pragma HLS data_pack variable=buf.val[0]\n      buf.shift_pixels_up(c);\n      if(r<MAX_HEIGHT)\n      {\n        tmp = outer[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_Y_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }   \n      buf.insert_bottom_row(tmp,c);\n\n      tensor_t acc;\n       v: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n     \n      if (r >= 2 && r < MAX_HEIGHT) \n      {\n        TENSOR_WEIGHT_Y_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(i,c);\n          pixel_t k = TENSOR_FILTER[i];\n          TENSOR_WEIGHT_Y_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*k;\n          }\n        }\n      }\n      if(r >= 1)\n      { \n        tensor_y[r-1][c] = acc;      \n      }\n    }\n  }\n}\n\nvoid tensor_weight_x(tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])\n{\n  xf::cv::Window<1,3,tensor_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  //const float TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    TENSOR_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+1; c++)\n    {\n      \n      buf.shift_pixels_left();\n      tensor_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = tensor_y[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_X_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }\n      buf.insert_pixel(tmp,0,2);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_X_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n      if (c >= 2 && c < MAX_WIDTH) \n      {\n        TENSOR_WEIGHT_X_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(0,i);\n          TENSOR_WEIGHT_X_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*TENSOR_FILTER[i];\n          }\n        }\n      }\n      if(c>=1)\n      {\n        tensor[r][c-1] = acc;\n      }\n    }\n  }\n}\n\n// compute output flow\nvoid flow_calc(tensor_t tensors[MAX_HEIGHT][MAX_WIDTH],\n               velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  static outer_pixel_t buf[2];\n  FLOW_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    FLOW_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      \n      tensor_t tmp_tensor = tensors[r][c];\n      if(r>=2 && r<MAX_HEIGHT-2 && c>=2 && c<MAX_WIDTH-2)\n      {\n\t      calc_pixel_t t1 = (calc_pixel_t) tmp_tensor.val[0];\n\t      calc_pixel_t t2 = (calc_pixel_t) tmp_tensor.val[1];\n\t      calc_pixel_t t3 = (calc_pixel_t) tmp_tensor.val[2];\n\t      calc_pixel_t t4 = (calc_pixel_t) tmp_tensor.val[3];\n\t      calc_pixel_t t5 = (calc_pixel_t) tmp_tensor.val[4];\n\t      calc_pixel_t t6 = (calc_pixel_t) tmp_tensor.val[5];\n\n        calc_pixel_t denom = t1*t2-t4*t4;\n\t      calc_pixel_t numer0 = t6*t4-t5*t2;\n\t      calc_pixel_t numer1 = t5*t4-t6*t1;\n\n\t      if(denom != 0)\n        {\n          buf[0] = numer0 / denom;\n          buf[1] = numer1 / denom;\n\t      } \n\t      else\n\t      {\n\t\t      buf[0] = 0;\n\t\t      buf[1] = 0;\n\t      }\n      }\n      else\n      {\n        buf[0] = buf[1] = 0;\n      }\n\n      outputs[r][c].x = (vel_pixel_t)buf[0];\n      outputs[r][c].y = (vel_pixel_t)buf[1];\n\n    }\n  }\n}\n\n// top-level kernel function\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  #pragma HLS data_pack variable=outputs\n\n  #pragma HLS DATAFLOW\n\n  // FIFOs connecting the stages\n  static pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_x depth=default_depth\n  static pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_y depth=default_depth\n  static pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_z depth=max_width*4\n  static gradient_t y_filtered[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=y_filtered depth=default_depth\n  static gradient_t filtered_gradient[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=filtered_gradient depth=default_depth\n  static outer_t out_product[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=out_product depth=default_depth\n  #pragma HLS data_pack variable=out_product\n  static tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=tensor_y depth=default_depth\n  #pragma HLS data_pack variable=tensor_y\n  static tensor_t tensor[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=tensor depth=default_depth\n  #pragma HLS data_pack variable=tensor\n\n  // FIFOs for streaming in, just for clarity\n  static input_t frame1_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame1_a depth=default_depth\n  static input_t frame2_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame2_a depth=default_depth\n  static input_t frame4_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame4_a depth=default_depth\n  static input_t frame5_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame5_a depth=default_depth\n\n  //Need to duplicate frame3 for the two calculations\n  static input_t frame3_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame3_a depth=default_depth\n  static input_t frame3_b[MAX_HEIGHT][MAX_WIDTH];\n  // #pragma HLS STREAM variable=frame3_b depth=default_depth\n  // Cannot stream  'frame3_b.V': the stream channel does not have data consumer function.\n\n  // stream in and organize the inputs\n  static frames_t buf;\n  FRAMES_CP_OUTER: for (int r=0; r<MAX_HEIGHT; r++) \n  {\n    FRAMES_CP_INNER: for (int c=0; c<MAX_WIDTH; c++) \n    {\n      \n\n      // one wide read\n      buf = frames[r][c];\n      // assign values to the FIFOs\n      frame1_a[r][c] = ((input_t)(buf(7 ,  0)) >> 8);\n      frame2_a[r][c] = ((input_t)(buf(15,  8)) >> 8);\n      frame3_a[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame3_b[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame4_a[r][c] = ((input_t)(buf(31, 24)) >> 8);\n      frame5_a[r][c] = ((input_t)(buf(39, 32)) >> 8);\n    }\n  }\n  //\n  // compute\n  gradient_xy_calc(frame3_a, gradient_x, gradient_y);\n  gradient_z_calc(frame1_a, frame2_a, frame3_b, frame4_a, frame5_a, gradient_z);\n  gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);\n  gradient_weight_x(y_filtered, filtered_gradient);\n  outer_product(filtered_gradient, out_product);\n  tensor_weight_y(out_product, tensor_y);\n  tensor_weight_x(tensor_y, tensor);\n  flow_calc(tensor, outputs);\n\n}\n"
      },
      {
        "file_name": "optical_flow.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                       optical_flow.h                          */\n/*                                                               */\n/*             Hardware function for optical flow                */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __OPTICAL_FLOW_H__\n#define __OPTICAL_FLOW_H__\n\n#include \"typedefs.h\"\n\n// convolution filters\nconst int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\nconst pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\nconst pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n\n// top-level function \n#pragma SDS data access_pattern(frames:SEQUENTIAL, outputs:SEQUENTIAL)\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH]);\n\n#endif\n"
      },
      {
        "file_name": "typedefs.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                        typedefs.h                             */\n/*                                                               */\n/*        Defines types and constants for host function          */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\nconst int MAX_HEIGHT = 436;\nconst int MAX_WIDTH = 1024;\n\n// basic typedefs\n#ifndef SW\n\t#include \"ap_fixed.h\"\n\ttypedef ap_fixed<17,9> input_t;\n\ttypedef ap_fixed<32,13> pixel_t;\n\ttypedef ap_fixed<32,27> outer_pixel_t;\n\ttypedef ap_fixed<64,56> calc_pixel_t;\n\ttypedef ap_fixed<32,13> vel_pixel_t;\n#else\n\ttypedef float pixel_t;\n  typedef float outer_pixel_t;\n  typedef float vel_pixel_t;\n#endif\ntypedef struct{\n\tpixel_t x;\n\tpixel_t y;\n\tpixel_t z;\n}gradient_t;\n\ntypedef struct{\n    outer_pixel_t val[6];\n}outer_t; \n\ntypedef struct{\n    outer_pixel_t val[6];\n}tensor_t;\n\ntypedef struct{\n    vel_pixel_t x;\n    vel_pixel_t y;\n}velocity_t;\n\n#ifndef SW\n  #include \"ap_int.h\"\n  // for data packing\n  typedef ap_uint<64> frames_t;\n#endif\n\n#ifdef OCL\n  #include <string>\n  // change the target device here\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xf_types.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_TYPES_H_\n#define _XF_TYPES_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n#include \"xf_params.hpp\"\n#include <stdint.h>\n\ntemplate <int N>\nstruct floatn {\n    float f[N];\n    float& operator[](int idx) { return f[idx]; }\n    const float& operator[](int idx) const { return f[idx]; }\n};\ntypedef floatn<3> float3;\n\ntemplate <int T>\nstruct StreamType {};\ntemplate <>\nstruct StreamType<XF_2UW> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct StreamType<XF_8UW> {\n    typedef ap_uint<8> name;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct StreamType<XF_9UW> {\n    typedef ap_uint<9> name;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct StreamType<XF_10UW> {\n    typedef ap_uint<10> name;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct StreamType<XF_12UW> {\n    typedef ap_uint<12> name;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct StreamType<XF_14UW> {\n    typedef ap_uint<14> name;\n    static const int bitdepth = 14;\n};\ntemplate <>\nstruct StreamType<XF_16UW> {\n    typedef ap_uint<16> name;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct StreamType<XF_19SW> {\n    typedef ap_int<19> name;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct StreamType<XF_20UW> {\n    typedef ap_uint<20> name;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct StreamType<XF_22UW> {\n    typedef ap_uint<22> name;\n    static const int bitdepth = 22;\n};\ntemplate <>\nstruct StreamType<XF_24UW> {\n    typedef ap_uint<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_24SW> {\n    typedef ap_int<24> name;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct StreamType<XF_28UW> {\n    typedef ap_uint<28> name;\n    static const int bitdepth = 28;\n};\ntemplate <>\nstruct StreamType<XF_30UW> {\n    typedef ap_uint<30> name;\n    static const int bitdepth = 30;\n};\ntemplate <>\nstruct StreamType<XF_32UW> {\n    typedef ap_uint<32> name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_32FW> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct StreamType<XF_96FW> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_192FW> {\n    typedef floatn<6> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_384FW> {\n    typedef floatn<12> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_768FW> {\n    typedef floatn<24> name;\n    static const int bitdepth = 768;\n};\ntemplate <>\nstruct StreamType<XF_1536FW> {\n    typedef floatn<48> name;\n    static const int bitdepth = 1536;\n};\ntemplate <>\nstruct StreamType<XF_35SW> {\n    typedef ap_int<35> name;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct StreamType<XF_36UW> {\n    typedef ap_uint<36> name;\n    static const int bitdepth = 36;\n};\ntemplate <>\nstruct StreamType<XF_40UW> {\n    typedef ap_uint<40> name;\n    static const int bitdepth = 40;\n};\ntemplate <>\nstruct StreamType<XF_42UW> {\n    typedef ap_uint<42> name;\n    static const int bitdepth = 42;\n};\ntemplate <>\nstruct StreamType<XF_48UW> {\n    typedef ap_uint<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_48SW> {\n    typedef ap_int<48> name;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct StreamType<XF_56UW> {\n    typedef ap_uint<56> name;\n    static const int bitdepth = 56;\n};\ntemplate <>\nstruct StreamType<XF_60UW> {\n    typedef ap_uint<60> name;\n    static const int bitdepth = 60;\n};\ntemplate <>\nstruct StreamType<XF_64UW> {\n    typedef ap_uint<64> name;\n    static const int bitdepth = 64;\n};\ntemplate <>\nstruct StreamType<XF_72UW> {\n    typedef ap_uint<72> name;\n    static const int bitdepth = 72;\n};\ntemplate <>\nstruct StreamType<XF_80UW> {\n    typedef ap_uint<80> name;\n    static const int bitdepth = 80;\n};\ntemplate <>\nstruct StreamType<XF_84UW> {\n    typedef ap_uint<84> name;\n    static const int bitdepth = 84;\n};\ntemplate <>\nstruct StreamType<XF_96UW> {\n    typedef ap_uint<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_96SW> {\n    typedef ap_int<96> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct StreamType<XF_112UW> {\n    typedef ap_uint<112> name;\n    static const int bitdepth = 112;\n};\ntemplate <>\nstruct StreamType<XF_120UW> {\n    typedef ap_uint<120> name;\n    static const int bitdepth = 120;\n};\ntemplate <>\nstruct StreamType<XF_128UW> {\n    typedef ap_uint<128> name;\n    static const int bitdepth = 128;\n};\ntemplate <>\nstruct StreamType<XF_144UW> {\n    typedef ap_uint<144> name;\n    static const int bitdepth = 144;\n};\ntemplate <>\nstruct StreamType<XF_152SW> {\n    typedef ap_int<152> name;\n    static const int bitdepth = 152;\n};\ntemplate <>\nstruct StreamType<XF_160UW> {\n    typedef ap_uint<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_160SW> {\n    typedef ap_int<160> name;\n    static const int bitdepth = 160;\n};\ntemplate <>\nstruct StreamType<XF_168UW> {\n    typedef ap_int<168> name;\n    static const int bitdepth = 168;\n};\ntemplate <>\nstruct StreamType<XF_176UW> {\n    typedef ap_uint<176> name;\n    static const int bitdepth = 176;\n};\ntemplate <>\nstruct StreamType<XF_192UW> {\n    typedef ap_uint<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_192SW> {\n    typedef ap_int<192> name;\n    static const int bitdepth = 192;\n};\ntemplate <>\nstruct StreamType<XF_256UW> {\n    typedef ap_uint<256> name;\n    static const int bitdepth = 256;\n};\ntemplate <>\nstruct StreamType<XF_280SW> {\n    typedef ap_int<280> name;\n    static const int bitdepth = 280;\n};\ntemplate <>\nstruct StreamType<XF_288UW> {\n    typedef ap_uint<288> name;\n    static const int bitdepth = 288;\n};\ntemplate <>\nstruct StreamType<XF_304SW> {\n    typedef ap_int<304> name;\n    static const int bitdepth = 304;\n};\ntemplate <>\nstruct StreamType<XF_320UW> {\n    typedef ap_int<320> name;\n    static const int bitdepth = 320;\n};\ntemplate <>\nstruct StreamType<XF_336UW> {\n    typedef ap_int<336> name;\n    static const int bitdepth = 336;\n};\ntemplate <>\nstruct StreamType<XF_352UW> {\n    typedef ap_uint<352> name;\n    static const int bitdepth = 352;\n};\ntemplate <>\nstruct StreamType<XF_384UW> {\n    typedef ap_uint<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_384SW> {\n    typedef ap_int<384> name;\n    static const int bitdepth = 384;\n};\ntemplate <>\nstruct StreamType<XF_512UW> {\n    typedef ap_uint<512> name;\n    static const int bitdepth = 512;\n};\ntemplate <>\nstruct StreamType<XF_560SW> {\n    typedef ap_int<560> name;\n    static const int bitdepth = 560;\n};\ntemplate <>\nstruct StreamType<XF_576UW> {\n    typedef ap_uint<576> name;\n    static const int bitdepth = 576;\n};\n\ntemplate <int T>\nstruct PixelType {};\ntemplate <>\nstruct PixelType<XF_8UP> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef unsigned char name2;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_8SP> {\n    typedef ap_int<8> name;\n    typedef ap_uint<8> uname;\n    static const int bitdepth = 8;\n};\ntemplate <>\nstruct PixelType<XF_9UP> {\n    typedef ap_uint<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_9SP> {\n    typedef ap_int<9> name;\n    typedef ap_uint<9> uname;\n    static const int bitdepth = 9;\n};\ntemplate <>\nstruct PixelType<XF_16UP> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_16SP> {\n    typedef ap_int<16> name;\n    typedef ap_uint<16> uname;\n    static const int bitdepth = 16;\n};\ntemplate <>\nstruct PixelType<XF_32UP> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_32SP> {\n    typedef ap_int<32> name;\n    typedef ap_uint<32> uname;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_19SP> {\n    typedef ap_int<19> name;\n    typedef ap_uint<19> uname;\n    static const int bitdepth = 19;\n};\ntemplate <>\nstruct PixelType<XF_35SP> {\n    typedef ap_int<35> name;\n    typedef ap_uint<35> uname;\n    static const int bitdepth = 35;\n};\ntemplate <>\nstruct PixelType<XF_32FP> {\n    typedef float name;\n    static const int bitdepth = 32;\n};\ntemplate <>\nstruct PixelType<XF_96FP> {\n    typedef floatn<3> name;\n    static const int bitdepth = 96;\n};\ntemplate <>\nstruct PixelType<XF_24SP> {\n    typedef ap_int<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\ntemplate <>\nstruct PixelType<XF_20SP> {\n    typedef ap_int<20> name;\n    typedef ap_uint<20> uname;\n    static const int bitdepth = 20;\n};\ntemplate <>\nstruct PixelType<XF_48SP> {\n    typedef ap_int<48> name;\n    typedef ap_uint<48> uname;\n    static const int bitdepth = 48;\n};\ntemplate <>\nstruct PixelType<XF_2UP> {\n    typedef ap_uint<2> name;\n    static const int bitdepth = 2;\n};\ntemplate <>\nstruct PixelType<XF_24UP> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    static const int bitdepth = 24;\n};\n\ntemplate <>\nstruct PixelType<XF_10UP> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    static const int bitdepth = 10;\n};\ntemplate <>\nstruct PixelType<XF_12UP> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    static const int bitdepth = 12;\n};\ntemplate <>\nstruct PixelType<XF_14UP> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    static const int bitdepth = 14;\n};\n#define XF_NPIXPERCYCLE(flags) xfNPixelsPerCycle<flags>::nppc\n\n#define XF_BITSHIFT(flags) xfNPixelsPerCycle<flags>::datashift\n\ntemplate <int T>\nstruct xfNPixelsPerCycle {};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC1> {\n    static const int datashift = 0;\n    static const int nppc = 1;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC2> {\n    static const int datashift = 1;\n    static const int nppc = 2;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC4> {\n    static const int datashift = 2;\n    static const int nppc = 4;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC8> {\n    static const int datashift = 3;\n    static const int nppc = 8;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC16> {\n    static const int datashift = 4;\n    static const int nppc = 16;\n};\ntemplate <>\nstruct xfNPixelsPerCycle<XF_NPPC32> {\n    static const int datashift = 5;\n    static const int nppc = 32;\n};\n\ntemplate <int T, int M>\nstruct DataType {};\n\n// One channel data types\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC1> {\n    typedef ap_uint<2> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_2UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC32> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC4> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_2UC1, XF_NPPC8> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<2> uname;\n    typedef ap_uint<2> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 2;\n    static const int pixelwidth = 2;\n    static const int pixeldepth = XF_2UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC1> {\n    typedef ap_uint<8> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned char wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_8UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC2> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC4> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC8> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC16> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC32> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_8UC1, XF_NPPC64> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<8> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 8;\n    static const int pixeldepth = XF_8UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC1> {\n    typedef ap_uint<10> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_10UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC2> {\n    typedef ap_uint<20> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_20UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC4> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC8> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_10UC1, XF_NPPC16> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<10> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 10;\n    static const int pixeldepth = XF_10UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC1> {\n    typedef ap_uint<12> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_12UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC2> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC4> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC8> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_12UC1, XF_NPPC16> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<12> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned short wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 12;\n    static const int pixeldepth = XF_12UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16SC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_int<16> cname;\n    typedef short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_16UC1, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short sname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_24UC1, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<24> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 24;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC1> {\n    typedef ap_uint<14> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_14UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC2> {\n    typedef ap_uint<28> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_28UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC4> {\n    typedef ap_uint<56> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_56UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_14UC1, XF_NPPC8> {\n    typedef ap_uint<112> name;\n    typedef ap_uint<14> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 14;\n    static const int pixeldepth = XF_14UP;\n    static const int wordwidth = XF_112UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_64UC1, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<64> cname;\n    typedef unsigned int sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 64;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32UC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef unsigned int sname;\n    typedef unsigned long long wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_32FW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32FC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32FP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC1> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<3> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_96FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC2> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<6> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_192FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC4> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<12> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_384FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC8> {\n    typedef ap_uint<768> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<24> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_768FW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_32FC3, XF_NPPC16> {\n    typedef ap_uint<1536> name;\n    typedef ap_uint<96> uname;\n    typedef ap_uint<32> cname;\n    typedef float sname;\n    typedef floatn<48> wname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 96;\n    static const int pixeldepth = XF_96FP;\n    static const int wordwidth = XF_1536FW;\n    static const int channel = 3;\n};\n\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 1;\n};\ntemplate <>\nstruct DataType<XF_32SC1, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_int<32> cname;\n    typedef int sname;\n    static const int bitdepth = 32;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32SP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 1;\n};\n\n// Two channels data types\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC1> {\n    typedef ap_uint<16> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_16UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC2> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned short int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC4> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC8> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 2;\n};\ntemplate <>\nstruct DataType<XF_8UC2, XF_NPPC16> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<16> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 16;\n    static const int pixeldepth = XF_16UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 2;\n};\n\n// template<> struct DataType <XF_10UC2, XF_NPPC1>   { typedef ap_uint<40>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; typedef unsigned  short int sname; typedef unsigned long long int wname; static const int\n// bitdepth = 10; static const int pixeldepth = XF_40UP;static const int wordwidth = XF_40UW; static const int channel =\n// 4;}; template<> struct DataType <XF_10UC2, XF_NPPC2>   { typedef ap_uint<80>      name; typedef ap_uint<40>  uname;\n// typedef ap_uint<10>  cname; static const int bitdepth = 10; static const int pixeldepth = XF_40UP;static const int\n// wordwidth = XF_80UW; static const int channel = 4;};\n\n// Three channels data types (TODO: Pixeldepth of XF_16U3 needs correction)\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC1> {\n    typedef ap_uint<24> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_24UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC2> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC4> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC8> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_8UC3, XF_NPPC16> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<24> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 24;\n    static const int pixeldepth = XF_24UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC1> {\n    typedef ap_uint<30> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_30UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC2> {\n    typedef ap_uint<60> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_60UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC4> {\n    typedef ap_uint<120> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_120UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_10UC3, XF_NPPC8> {\n    typedef ap_uint<240> name;\n    typedef ap_uint<30> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 30;\n    static const int pixeldepth = XF_30UP;\n    static const int wordwidth = XF_240UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC1> {\n    typedef ap_uint<36> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_36UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC2> {\n    typedef ap_uint<72> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_72UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC4> {\n    typedef ap_uint<144> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_144UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_12UC3, XF_NPPC8> {\n    typedef ap_uint<288> name;\n    typedef ap_uint<36> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 36;\n    static const int pixeldepth = XF_36UP;\n    static const int wordwidth = XF_288UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC1> {\n    typedef ap_uint<42> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_42UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC2> {\n    typedef ap_uint<84> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_84UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC4> {\n    typedef ap_uint<168> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_168UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_14UC3, XF_NPPC8> {\n    typedef ap_uint<336> name;\n    typedef ap_uint<42> uname;\n    typedef ap_uint<14> cname;\n    typedef unsigned short sname;\n    typedef unsigned long int wname;\n    static const int bitdepth = 14;\n    static const int pixelwidth = 42;\n    static const int pixeldepth = XF_42UP;\n    static const int wordwidth = XF_336UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16UC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_48SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_96SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_192SW;\n    static const int channel = 3;\n};\ntemplate <>\nstruct DataType<XF_16SC3, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_int<16> cname;\n    typedef short int sname;\n    typedef short int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48SP;\n    static const int wordwidth = XF_384SW;\n    static const int channel = 3;\n};\n// Four channels data types\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC1> {\n    typedef ap_uint<32> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_32UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC2> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC4> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC8> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_8UC4, XF_NPPC16> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<32> uname;\n    typedef ap_uint<8> cname;\n    typedef unsigned char sname;\n    static const int bitdepth = 8;\n    static const int pixelwidth = 32;\n    static const int pixeldepth = XF_32UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC1> {\n    typedef ap_uint<40> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_40UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC2> {\n    typedef ap_uint<80> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_80UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC4> {\n    typedef ap_uint<160> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_160UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_10UC4, XF_NPPC8> {\n    typedef ap_uint<320> name;\n    typedef ap_uint<40> uname;\n    typedef ap_uint<10> cname;\n    static const int bitdepth = 10;\n    static const int pixelwidth = 40;\n    static const int pixeldepth = XF_40UP;\n    static const int wordwidth = XF_320UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC1> {\n    typedef ap_uint<48> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_48UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC2> {\n    typedef ap_uint<96> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_96UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC4> {\n    typedef ap_uint<192> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_192UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_12UC4, XF_NPPC8> {\n    typedef ap_uint<384> name;\n    typedef ap_uint<48> uname;\n    typedef ap_uint<12> cname;\n    static const int bitdepth = 12;\n    static const int pixelwidth = 48;\n    static const int pixeldepth = XF_48UP;\n    static const int wordwidth = XF_384UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC1> {\n    typedef ap_uint<64> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_64UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC2> {\n    typedef ap_uint<128> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_128UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC4> {\n    typedef ap_uint<256> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_256UW;\n    static const int channel = 4;\n};\ntemplate <>\nstruct DataType<XF_16UC4, XF_NPPC8> {\n    typedef ap_uint<512> name;\n    typedef ap_uint<64> uname;\n    typedef ap_uint<16> cname;\n    typedef unsigned short int sname;\n    typedef unsigned long long int wname;\n    static const int bitdepth = 16;\n    static const int pixelwidth = 64;\n    static const int pixeldepth = XF_64UP;\n    static const int wordwidth = XF_512UW;\n    static const int channel = 4;\n};\n\n#define TC(TYPE) TC##TYPE\n\n#define XF_TNAME(flags, npc) typename DataType<flags, npc>::name\n\n#define XF_DTUNAME(flags, npc) typename DataType<flags, npc>::uname\n\n#define XF_CTUNAME(flags, npc) typename DataType<flags, npc>::cname\n\n#define XF_PTSNAME(flags, npc) typename DataType<flags, npc>::sname\n\n#define XF_WTNAME(flags, npc) typename DataType<flags, npc>::wname\n\n#define XF_DTPIXELDEPTH(flags, npc) DataType<flags, npc>::bitdepth\n\n#define XF_DEPTH(flags, npc) DataType<flags, npc>::pixeldepth\n\n#define XF_WORDWIDTH(flags, npc) DataType<flags, npc>::wordwidth\n\n#define XF_CHANNELS(flags, npc) DataType<flags, npc>::channel\n\n#define XF_PIXELWIDTH(flags, npc) DataType<flags, npc>::pixelwidth\n\n#define XF_PTNAME(flags) typename PixelType<flags>::name\n\n#define XF_PIXELDEPTH(flags) PixelType<flags>::bitdepth\n\n#define XF_PTUNAME(flags) typename PixelType<flags>::uname\n\n#define XF_PTNAME2(flags) typename PixelType<flags>::name2\n\n#define XF_SNAME(flags) typename StreamType<flags>::name\n#define XF_WORDDEPTH(flags) StreamType<flags>::bitdepth\n\n#define XF_NAME(flags, npc) ap_uint<(XF_DTPIXELDEPTH(flags, npc) / XF_CHANNELS(flags, npc)) * XF_NPIXPERCYCLE(npc)>\n\n// find image width in terms of the number of words used to represent the data\n//#define IM_WIDTH(W,S) ((W)>>(S))\n\n// Xilinx headers\n#include <ap_int.h>\n#include <ap_fixed.h>\n#include <stdint.h>\n// Native types\n// typedef unsigned long     uint64_t;\ntypedef unsigned int uint32_t;\ntypedef unsigned short uint16_t;\n// typedef long int        int64_t;\ntypedef int int32_t;\ntypedef short int int16_t;\ntypedef unsigned char uchar_t;\ntypedef unsigned char uint8_t;\ntypedef signed char int8_t;\n\n// Arbitrary Precision integer types\ntypedef ap_uint<1> ap_uint1_t;\ntypedef ap_uint<2> ap_uint2_t;\ntypedef ap_uint<4> ap_uint4_t;\ntypedef ap_uint<5> ap_uint5_t;\ntypedef ap_uint<8> ap_uint8_t;\ntypedef ap_uint<9> ap_uint9_t;\ntypedef ap_uint<16> ap_uint16_t;\ntypedef ap_uint<17> ap_uint17_t;\ntypedef ap_uint<18> ap_uint18_t;\ntypedef ap_uint<20> ap_uint20_t;\ntypedef ap_uint<22> ap_uint22_t;\ntypedef ap_uint<23> ap_uint23_t;\ntypedef ap_uint<24> ap_uint24_t;\ntypedef ap_uint<32> ap_uint32_t;\ntypedef ap_uint<33> ap_uint33_t;\ntypedef ap_uint<34> ap_uint34_t;\ntypedef ap_uint<35> ap_uint35_t;\ntypedef ap_uint<38> ap_uint38_t;\ntypedef ap_uint<45> ap_uint45_t;\ntypedef ap_uint<48> ap_uint48_t;\ntypedef ap_uint<51> ap_uint51_t;\ntypedef ap_uint<64> ap_uint64_t;\ntypedef ap_uint<66> ap_uint66_t;\ntypedef ap_uint<72> ap_uint72_t;\ntypedef ap_uint<97> ap_uint97_t;\ntypedef ap_uint<101> ap_uint101_t;\ntypedef ap_uint<128> ap_uint128_t;\ntypedef ap_uint<144> ap_uint144_t;\ntypedef ap_uint<176> ap_uint176_t;\ntypedef ap_uint<192> ap_uint192_t;\ntypedef ap_uint<256> ap_uint256_t;\ntypedef ap_uint<352> ap_uint352_t;\ntypedef ap_uint<384> ap_uint384_t;\ntypedef ap_uint<512> ap_uint512_t;\ntypedef ap_uint<576> ap_uint576_t;\n\ntypedef ap_int<8> ap_int8_t;\ntypedef ap_int<9> ap_int9_t;\ntypedef ap_int<12> ap_int12_t;\ntypedef ap_int<15> ap_int15_t;\ntypedef ap_int<16> ap_int16_t;\ntypedef ap_int<18> ap_int18_t;\ntypedef ap_int<19> ap_int19_t;\ntypedef ap_int<20> ap_int20_t;\ntypedef ap_int<24> ap_int24_t;\ntypedef ap_int<32> ap_int32_t;\ntypedef ap_int<35> ap_int35_t;\ntypedef ap_int<36> ap_int36_t;\ntypedef ap_int<42> ap_int42_t;\ntypedef ap_int<48> ap_int48_t;\ntypedef ap_int<64> ap_int64_t;\ntypedef ap_int<152> ap_int152_t;\ntypedef ap_int<304> ap_int304_t;\ntypedef ap_int<280> ap_int280_t;\ntypedef ap_int<560> ap_int560_t;\n\n// Arbitrary Precision fixed-point types\ntypedef ap_ufixed<12, 12> uint12_q0;\ntypedef ap_ufixed<16, 16> uint16_q0; // 16-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<32, 32> uint32_q0; // 32-bit unsigned with 0 fractional bits\ntypedef ap_ufixed<8, 8> uint8_q0;    // 8-bit unsigned with 0 fractional bits\n\n#endif //_XF_TYPES_H_\n"
      },
      {
        "file_name": "xf_utility.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_UTILITY_H_\n#define _XF_UTILITY_H_\n\n#include \"ap_axi_sdata.h\"\n#include \"xf_common.hpp\"\n#include \"xf_video_mem.hpp\"\n#include <assert.h>\n#include <string.h>\n\nnamespace xf {\nnamespace cv {\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid Ptr2xfMat(ap_uint<BUS_WIDTH>* in_ptr, xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_mat.write(i, (XF_TNAME(TYPE, NPPC))in_ptr[i]);\n    }\n\n} // End of Ptr2xfMat()\n\n// ======================================================================================\n// Function to read from DDR and copy to xf::cv::Mat\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xfMat2Ptr(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat, ap_uint<BUS_WIDTH>* out_ptr) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        out_ptr[i] = in_mat.read(i);\n    }\n\n} // End of xfMat2Ptr()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                           ap_uint<BUS_WIDTH>* out_ptr,\n                           xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat.write(i, tmp);\n    }\n\n} // End of xFDuplicateMat_PTRMAT()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR and 2 for xf::cv::Mat)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_1 = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT_2 = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTRMAT2(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_1>& out_mat1,\n                            xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT_2>& out_mat2) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = (ap_uint<BUS_WIDTH>)tmp;\n        out_mat1.write(i, tmp);\n        out_mat2.write(i, tmp);\n        // out_mat2.write(i, (XF_TNAME(XF_16SC1, NPPC))tmp); // TODO: Remove me as I am for experiment\n    }\n\n} // End of xFDuplicateMat_PTRMAT2()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 3 streams (1 for DDR PTR, 1 for xf::cv::Mat and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH,\n          int TYPE,\n          int ROWS,\n          int COLS,\n          int NPPC,\n          int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT,\n          int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_MAT_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                                ap_uint<BUS_WIDTH>* out_ptr,\n                                xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat,\n                                hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n        out_mat.write(i, tmp);\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_MAT_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to stream out xf::cv::Mat on AXI bus for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFMat2AXI_Strm(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                    hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n\n        v.data = in_mat.read(i);\n        out_axi.write(v);\n    }\n\n} // End of xFMat2AXI_Strm()\n// ======================================================================================\n\n// ======================================================================================\n// Function to read AXI stream into xf::cv::Mat for K2K streaming\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid AXI_Strm2xFMat(hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& in_axi,\n                    xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_OUT>& out_mat) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = out_mat.rows * (out_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v = in_axi.read();\n\n        out_mat.write(i, v.data);\n    }\n\n} // End of AXI_Strm2xFMat()\n// ======================================================================================\n\n// ======================================================================================\n// Function to split xf::cv::Mat into 2 streams (1 for DDR PTR and 1 for AXI stream)\n// ======================================================================================\ntemplate <int BUS_WIDTH, int TYPE, int ROWS, int COLS, int NPPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\nvoid xFDuplicateMat_PTR_AXI(xf::cv::Mat<TYPE, ROWS, COLS, NPPC, XFCVDEPTH_IN>& in_mat,\n                            ap_uint<BUS_WIDTH>* out_ptr,\n                            hls::stream<ap_axiu<BUS_WIDTH, 0, 0, 0> >& out_axi) {\n#pragma HLS INLINE OFF\n\n    const int c_TRIP_COUNT = ROWS * COLS;\n    int loopcount = in_mat.rows * (in_mat.cols >> XF_BITSHIFT(NPPC));\n\n    for (int i = 0; i < loopcount; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS pipeline\n#pragma HLS LOOP_TRIPCOUNT min = c_TRIP_COUNT max = c_TRIP_COUNT\n        ap_axiu<BUS_WIDTH, 0, 0, 0> v;\n        XF_TNAME(TYPE, NPPC) tmp = in_mat.read(i);\n\n        out_ptr[i] = tmp;\n\n        v.data = tmp;\n        out_axi.write(v);\n    }\n\n} // End of xFDuplicateMat_PTR_AXI()\n// ======================================================================================\n\n// ======================================================================================\n// Function to set border in the extracted kernel sized block\n// ======================================================================================\ntemplate <int K_ROWS, int K_COLS, typename SRC_T, int BORDER_T>\nvoid xFSetBorder(xf::cv::Window<K_ROWS, K_COLS, SRC_T>& src_blk,\n                 uint16_t _row,\n                 uint16_t _col,\n                 uint16_t _src_rows,\n                 uint16_t _src_cols) {\n#pragma HLS INLINE OFF\n\n    uint16_t blk_t_idx, blk_b_idx;\n    uint16_t blk_l_idx, blk_r_idx;\n\n    blk_t_idx = (K_ROWS - _row - 1);\n    blk_b_idx = (K_ROWS - (_row - _src_rows + 1) - 1);\n\n    blk_l_idx = (K_COLS - _col - 1);\n    blk_r_idx = (K_COLS - (_col - _src_cols + 1) - 1);\n\n    for (uint16_t r = 0; r < K_ROWS; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n        for (uint16_t c = 0; c < K_COLS; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n#pragma HLS unroll factor=1\n\n            bool top_border = ((r < blk_t_idx) && (_row < K_ROWS - 1)) ? true : false;\n            bool bottom_border = ((r > blk_b_idx) && (_row >= _src_rows)) ? true : false;\n            bool left_border = ((c < blk_l_idx) && (_col < K_COLS - 1)) ? true : false;\n            bool right_border = ((c > blk_r_idx) && (_col >= _src_cols)) ? true : false;\n\n            uint16_t r_idx = r, c_idx = c;\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                r_idx = top_border ? blk_t_idx : bottom_border ? blk_b_idx : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                r_idx = top_border ? (2 * blk_t_idx - r) : bottom_border ? (2 * blk_b_idx - r) : r;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                r_idx = top_border ? (2 * blk_t_idx - r - 1) : bottom_border ? (2 * blk_b_idx - r + 1) : r;\n\n            } else { // TODO: Need to add other modes support\n                r_idx = r;\n            }\n\n            if (BORDER_T == XF_BORDER_REPLICATE) {\n                c_idx = left_border ? blk_l_idx : right_border ? blk_r_idx : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT_101) {\n                c_idx = left_border ? (2 * blk_l_idx - c) : right_border ? (2 * blk_r_idx - c) : c;\n\n            } else if (BORDER_T == XF_BORDER_REFLECT) {\n                c_idx = left_border ? (2 * blk_l_idx - c - 1) : right_border ? (2 * blk_r_idx - c + 1) : c;\n\n            } else { // TODO: Need to add other modes support\n                c_idx = c;\n            }\n\n            if ((top_border | bottom_border | left_border | right_border) && (BORDER_T == XF_BORDER_CONSTANT)) {\n                src_blk.val[r][c] = 0;\n            } else {\n                src_blk.val[r][c] = src_blk.val[r_idx][c_idx];\n            }\n        }\n    }\n\n} // End of xFSetBorder()\n// ======================================================================================\n\n/**\n * Extract Pixels from a packed word into an array from the index pos.\n * The number of pixels to be extracted is determined by the NPC.\n */\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfPackPixels(\n    XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val, uint16_t pos, int16_t loopIter, uint16_t& shift) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<8> STEP = XF_PIXELDEPTH(PIXELDEPTH);\n\n    for (ap_int<9> i = 0; i < loopIter; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        XF_PTUNAME(PIXELDEPTH) tmp = tmp_buf[pos];\n        val = val | (((XF_SNAME(WORDWIDTH))tmp) << (shift * STEP));\n        pos++;\n        shift++;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH, int PIXELDEPTH>\nvoid xfExtractPixels(XF_PTNAME(PIXELDEPTH) * tmp_buf, XF_SNAME(WORDWIDTH) & val1, int pos) {\n// clang-format off\n    #pragma HLS inline off\n    // clang-format on\n    XF_SNAME(WORDWIDTH) v = val1;\n\n    int shift = 0;\n    int STEP = XF_PIXELDEPTH(PIXELDEPTH);\nExtract_pixels_loop:\n    for (int i = 0; i < (1 << (XF_BITSHIFT(NPC))); i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        tmp_buf[pos + i] = v.range(shift + STEP - 1, shift);\n        shift = shift + STEP;\n    }\n}\n\ntemplate <int NPC, int WORDWIDTH_SRC, int DEPTH_SRC>\nvoid xfExtractData(XF_PTNAME(DEPTH_SRC) * src_buf1,\n                   XF_PTNAME(DEPTH_SRC) * src_buf2,\n                   XF_PTNAME(DEPTH_SRC) * src_buf3,\n                   XF_PTNAME(DEPTH_SRC) * src_buf4,\n                   XF_PTNAME(DEPTH_SRC) * src_buf5,\n                   XF_PTNAME(DEPTH_SRC) * src_buf6,\n                   XF_PTNAME(DEPTH_SRC) * src_buf7,\n                   XF_SNAME(WORDWIDTH_SRC) buf0,\n                   XF_SNAME(WORDWIDTH_SRC) buf1,\n                   XF_SNAME(WORDWIDTH_SRC) buf2,\n                   XF_SNAME(WORDWIDTH_SRC) buf3,\n                   XF_SNAME(WORDWIDTH_SRC) buf4,\n                   XF_SNAME(WORDWIDTH_SRC) buf5,\n                   XF_SNAME(WORDWIDTH_SRC) buf6) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf1[6], buf0, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf2[6], buf1, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf3[6], buf2, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf4[6], buf3, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf5[6], buf4, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf6[6], buf5, 0);\n    xfExtractPixels<NPC, WORDWIDTH_SRC, DEPTH_SRC>(&src_buf7[6], buf6, 0);\n}\n\ntemplate <int NPC, int DEPTH_SRC>\nvoid xfCopyData(XF_PTNAME(DEPTH_SRC) src_buf1[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf2[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf3[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf4[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf5[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf6[XF_NPIXPERCYCLE(NPC) + 6],\n                XF_PTNAME(DEPTH_SRC) src_buf7[XF_NPIXPERCYCLE(NPC) + 6]) {\n// clang-format off\n    #pragma HLS INLINE\n    // clang-format on\n    ap_uint<5> buf_size = (XF_NPIXPERCYCLE(NPC) + 6);\n    ap_uint<4> i = 0;\n    ap_uint<4> ind = buf_size - 6;\n\n    for (i = 0; i < 6; i++, ind++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=6 max=6\n#pragma HLS unroll factor=1\n        // clang-format on\n        src_buf1[i] = src_buf1[ind];\n        src_buf2[i] = src_buf2[ind];\n        src_buf3[i] = src_buf3[ind];\n        src_buf4[i] = src_buf4[ind];\n        src_buf5[i] = src_buf5[ind];\n        src_buf6[i] = src_buf6[ind];\n        src_buf7[i] = src_buf7[ind];\n    }\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut1(XF_SNAME(WORDWIDTH) * _src, unsigned long long int* _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, SIZE);\n#else\n    if (nbytes) memcpy((unsigned long long int*)_dst, (unsigned long long int*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn1(unsigned long long int* _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryIn: Copies memory from DDR to BRAM if y_offset and x_offset is\n * provided\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryIn(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((AU_TNAME(WORDWIDTH)*)_dst, (AU_TNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\n/**\n * CopyMemoryOut: Copies memory from BRAM to DDR\n */\ntemplate <int SIZE, int WORDWIDTH>\nvoid xFCopyBlockMemoryOut(XF_SNAME(WORDWIDTH) * _src, XF_SNAME(WORDWIDTH) * _dst, int nbytes) {\n#if _XF_SYNTHESIS_\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, SIZE);\n#else\n    memcpy((XF_SNAME(WORDWIDTH)*)_dst, (XF_SNAME(WORDWIDTH)*)_src, nbytes);\n#endif\n}\n\ntemplate <int WORDWIDTH, int NPC, int IN_BH, int IN_BW>\nvoid xFDuplicateStream(hls::stream<XF_SNAME(WORDWIDTH)>& in_strm,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm1,\n                       hls::stream<XF_SNAME(WORDWIDTH)>& out_strm2,\n                       int imwidth,\n                       int imheight) {\n    for (int i = 0; i < imheight; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n        #pragma HLS LOOP_TRIPCOUNT min=IN_BH max=IN_BH\n        #pragma HLS LOOP_FLATTEN off\n        // clang-format on\n        for (int j = 0; j < (imwidth >> NPC); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS pipeline\n            #pragma HLS LOOP_TRIPCOUNT min=IN_BW max=IN_BW\n            // clang-format on\n            XF_SNAME(WORDWIDTH) tmp = in_strm.read();\n            out_strm1.write(tmp);\n            out_strm2.write(tmp);\n        }\n    }\n}\n\n// ==============================================================================\n// Class contains funcitons requried for accel file (top wrapper file)\n// ==============================================================================\nclass accel_utils {\n   public:\n    // ==============================================================================\n    // Read module(s) to handle data transfer from AXI/HLS stream to xfMat\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void Array2hlsStrm(ap_uint<PTR_WIDTH>* srcPtr, hls::stream<ap_uint<PTR_WIDTH> >& dstStrm, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstStrm.write(srcPtr[i]);\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void hlsStrm2xfMat(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat,\n                       int dstMat_cols_align_npc) {\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int loop_count = (rows * dstMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = dstMat_cols_align_npc - cols;\n        int in_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * dstMat_cols_align_npc; // channels\n        int ddr_read_cycles = (((in_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_read_cnt = 0;\n\n        int valid_bits = 0;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        int K_size;\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) out;\n        int ncpr = dstMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n        int strm_cnt_disply = 0;\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            int valid_bits_update;\n            int valid_bits_tmp = valid_bits - K_size;\n            XF_TNAME(MAT_T, NPC) out = 0;\n\n            if (valid_bits < K_size) {\n                if (valid_bits != 0) {\n                    out.range(valid_bits - 1, 0) = r.range(PTR_WIDTH - 1, PTR_WIDTH - valid_bits);\n                }\n                if (ddr_read_cnt < ddr_read_cycles) {\n                    r = srcStrm.read();\n                    ddr_read_cnt++;\n                } else {\n                    r = 0;\n                }\n                out.range(K_size - 1, valid_bits) = r.range(K_size - valid_bits - 1, 0);\n                valid_bits = PTR_WIDTH_min_Ksize + valid_bits;\n            } else {\n                out = r.range(PTR_WIDTH_plus_Ksize - valid_bits - 1, PTR_WIDTH - valid_bits);\n                valid_bits = valid_bits - K_size;\n            }\n\n            dstMat.write(i, out);\n        }\n        int stop = 0;\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\n    void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                     xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        Array2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH>(strm, dstMat,\n                                                                                         dstMat_cols_align_npc);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void axiStrm2hlsStrm(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                         hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = srcPtr.read();\n            dstStrm.write(v.data);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                       xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = dstMat.rows;\n        int cols = dstMat.cols;\n        int dstMat_cols_align_npc = ((dstMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n        axiStrm2hlsStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(srcPtr, strm, rows, cols);\n        hlsStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, (ROWS * COLS) / NPC, XFCVDEPTH_OUT>(strm, dstMat,\n                                                                                             dstMat_cols_align_npc);\n    }\n\n    // ==============================================================================\n    // Write module(s) to handle data transfer from xfMat to AXI/HLS stream\n    // ------------------------------------------------------------------------------\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int TRIPCOUNT,\n              int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\n    void xfMat2hlsStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& srcMat,\n                       hls::stream<ap_uint<PTR_WIDTH> >& dstStrm,\n                       int srcMat_cols_align_npc) {\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int loop_count = (rows * srcMat_cols_align_npc) / XF_NPIXPERCYCLE(NPC);\n        int pad = srcMat_cols_align_npc - cols;\n        int out_size_bits = XF_PIXELWIDTH(MAT_T, NPC) * rows * srcMat_cols_align_npc; // channels\n        int ddr_write_cycles = (((out_size_bits) + (PTR_WIDTH)-1) / (PTR_WIDTH));\n        int ddr_write_cnt = 0;\n\n        int bits_to_add = PTR_WIDTH;\n        const int N_size = XF_PIXELWIDTH(MAT_T, NPC) * XF_NPIXPERCYCLE(NPC);\n        const int last_N_size = XF_PIXELWIDTH(MAT_T, NPC) * (XF_NPIXPERCYCLE(NPC) - pad);\n        const int PTR_WIDTH_min_N = PTR_WIDTH - N_size;\n        const int PTR_WIDTH_min_last_N = PTR_WIDTH - last_N_size;\n        const int PTR_WIDTH_plus_N = PTR_WIDTH + N_size;\n        const int PTR_WIDTH_plus_last_N = PTR_WIDTH + last_N_size;\n\n        ap_uint<PTR_WIDTH> r;\n        XF_TNAME(MAT_T, NPC) in;\n        int ncpr = srcMat_cols_align_npc / XF_NPIXPERCYCLE(NPC); // number of clock per row\n        int clk_cnt = 0;                                         // clock counter. reset at the start of every row\n\n    L1:\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            int K_size;\n            int PTR_WIDTH_min_Ksize;\n            int PTR_WIDTH_plus_Ksize;\n            if (clk_cnt == ncpr - 1) {\n                clk_cnt = 0;\n                K_size = last_N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_last_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_last_N;\n            } else {\n                clk_cnt++;\n                K_size = N_size;\n                PTR_WIDTH_min_Ksize = PTR_WIDTH_min_N;\n                PTR_WIDTH_plus_Ksize = PTR_WIDTH_plus_N;\n            }\n\n            in = srcMat.read(i);\n\n            if (bits_to_add <= K_size) {\n                r.range(PTR_WIDTH - 1, PTR_WIDTH - bits_to_add) = in.range(bits_to_add - 1, 0);\n                dstStrm.write(r);\n\n                if (bits_to_add != K_size) {\n                    r.range(K_size - bits_to_add - 1, 0) = in.range(K_size - 1, bits_to_add);\n                }\n                bits_to_add = PTR_WIDTH_min_Ksize + bits_to_add;\n            } else {\n                r.range(PTR_WIDTH_plus_Ksize - bits_to_add - 1, PTR_WIDTH - bits_to_add) = in;\n                bits_to_add -= K_size;\n            }\n        }\n\n        if (bits_to_add != PTR_WIDTH) {\n            dstStrm.write(r);\n        }\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2Array(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            dstPtr[i] = srcStrm.read();\n        }\n    }\n\n    template <int PTR_WIDTH,\n              int MAT_T,\n              int ROWS,\n              int COLS,\n              int NPC,\n              int XFCVDEPTH = _XFCVDEPTH_DEFAULT,\n              int FILLZERO = 1>\n    void xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                     ap_uint<PTR_WIDTH>* dstPtr,\n                     int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n        MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2Array<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                      ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n#endif\n    }\n\n    template <int PTR_WIDTH, int ROWS, int COLS, int NPC, int COLOR_T, int CH_WIDTH, int TRIPCOUNT>\n    void hlsStrm2axiStrm(hls::stream<ap_uint<PTR_WIDTH> >& srcStrm,\n                         hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr,\n                         int rows,\n                         int cols) {\n        int pixel_width = COLOR_T * CH_WIDTH;\n        int loop_count = (((rows * cols * pixel_width) + PTR_WIDTH - 1) / PTR_WIDTH);\n\n        for (int i = 0; i < loop_count; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n            #pragma HLS LOOP_TRIPCOUNT min=1 max=TRIPCOUNT\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = srcStrm.read();\n            dstPtr.write(v);\n        }\n    }\n\n    template <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_IN = _XFCVDEPTH_DEFAULT>\n    void xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_IN>& srcMat,\n                       hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n// clang-format off\n        #pragma HLS DATAFLOW\n        // clang-format on\n        assert((PTR_WIDTH >= XF_WORDDEPTH(XF_WORDWIDTH(MAT_T, NPC))) &&\n               \"The PTR_WIDTH must be always greater than or equal to the minimum \"\n               \"width for the corresponding \"\n               \"configuration\");\n        const int ch_width = XF_DTPIXELDEPTH(MAT_T, NPC);\n\n        hls::stream<ap_uint<PTR_WIDTH> > strm;\n        int rows = srcMat.rows;\n        int cols = srcMat.cols;\n        int srcMat_cols_align_npc = ((srcMat.cols + (NPC - 1)) >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC);\n\n        xfMat2hlsStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, ROWS*((COLS + NPC - 1) / NPC), XFCVDEPTH_IN>(\n            srcMat, strm, srcMat_cols_align_npc);\n        hlsStrm2axiStrm<PTR_WIDTH, ROWS, COLS, NPC, XF_CHANNELS(MAT_T, NPC), ch_width,\n                        ((ROWS * COLS * XF_CHANNELS(MAT_T, NPC) * ch_width) / PTR_WIDTH)>(strm, dstPtr, rows, cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT, int FILLZERO = 1>\nvoid xfMat2Array(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat, ap_uint<PTR_WIDTH>* dstPtr, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterOut<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, FILLZERO, XFCVDEPTH>::xfMat2Array(srcMat, dstPtr, stride);\n#else\n    accel_utils au;\n    au.xfMat2Array<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcMat, dstPtr);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr, xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat, int stride = -1) {\n#if !defined(__XF_USE_OLD_IMPL__)\n    MMIterIn<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>::Array2xfMat(srcPtr, dstMat, stride);\n#else\n    accel_utils au;\n    au.Array2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC>(srcPtr, dstMat);\n#endif\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nvoid xfMat2axiStrm(xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                   hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dstPtr) {\n    accel_utils au;\n    au.xfMat2axiStrm<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH>(srcMat, dstPtr);\n}\n\ntemplate <int PTR_WIDTH, int MAT_T, int ROWS, int COLS, int NPC, int XFCVDEPTH_OUT = _XFCVDEPTH_DEFAULT>\nvoid axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                   xf::cv::Mat<MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>& dstMat) {\n    accel_utils au;\n    au.axiStrm2xfMat<PTR_WIDTH, MAT_T, ROWS, COLS, NPC, XFCVDEPTH_OUT>(srcPtr, dstMat);\n}\n\n} // namespace cv\n} // namespace xf\n\n#endif //_XF_UTILITY_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "xf_structs.hpp",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_STRUCTS_H_\n#define _XF_STRUCTS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#ifndef __SYNTHESIS__\n#include <iostream>\n#endif\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include \"xf_types.hpp\"\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <type_traits>\n\nnamespace xf {\nnamespace cv {\n\ntemplate <int T>\nap_uint<T> xf_satcast(int in_val) {\n    if (in_val > ((1 << T) - 1)) {\n        return ((1 << T) - 1);\n    } else if (in_val < 0) {\n        return 0;\n    } else {\n        return in_val;\n    }\n}\n\ntemplate <typename T>\nT float2ap_uint(float val) {\n    T* val_out = (T*)(&val);\n    return *val_out;\n}\n\ntemplate <typename T>\nfloat ap_uint2float(T val) {\n    float* val_out = (float*)(&val);\n    return *val_out;\n}\n\n//----------------------------------------------------------------------------------------------------//\n//  LOCAL STEREO BLOCK MATCHING UTILITY\n//----------------------------------------------------------------------------------------------------//\ntemplate <int WSIZE, int NDISP, int NDISP_UNIT>\nclass xFSBMState {\n   public:\n    // pre-filtering (normalization of input images)\n    int preFilterType; // =HLS_STEREO_BM_XSOBEL_TEST\n    int preFilterSize; // averaging window size: ~5x5..21x21\n    int preFilterCap;  // the output of pre-filtering is clipped by\n                       // [-preFilterCap,preFilterCap]\n\n    // correspondence using Sum of Absolute Difference (SAD)\n    int SADWindowSize;       // ~5x5..21x21 // defined in macro\n    int minDisparity;        // minimum disparity (can be negative)\n    int numberOfDisparities; // maximum disparity - minimum disparity (> 0)\n\n    // post-filtering\n    int textureThreshold; // the disparity is only computed for pixels\n\n    // with textured enough neighborhood\n    int uniquenessRatio; // accept the computed disparity d* only if\n    // SAD(d) >= SAD(d*)*(1 + uniquenessRatio/100.)\n    // for any d != d*+/-1 within the search range.\n\n    // int speckleWindowSize; // disparity variation window\n    // int speckleRange;      // acceptable range of variation in window\n\n    int ndisp_unit;\n    int sweepFactor;\n    int remainder;\n\n    xFSBMState() {\n        preFilterType = XF_STEREO_PREFILTER_SOBEL_TYPE; // Default Sobel filter\n        preFilterSize = WSIZE;\n        preFilterCap = 31;\n        SADWindowSize = WSIZE;\n        minDisparity = 0;\n        numberOfDisparities = NDISP;\n        textureThreshold = 10;\n        uniquenessRatio = 15;\n        sweepFactor = (NDISP / NDISP_UNIT) + ((NDISP % NDISP_UNIT) != 0);\n        ndisp_unit = NDISP_UNIT;\n        remainder = NDISP_UNIT * sweepFactor - NDISP;\n    }\n};\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Point_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Point_ {\n   public:\n    Point_();\n    Point_(T _x, T _y);\n    Point_(const Point_& pt);\n    ~Point_();\n\n    T x, y;\n};\n\n/* Member functions of Point_ class */\ntemplate <typename T>\ninline Point_<T>::Point_() {}\ntemplate <typename T>\ninline Point_<T>::Point_(T _x, T _y) : x(_x), y(_y) {}\ntemplate <typename T>\ninline Point_<T>::Point_(const Point_<T>& pt) : x(pt.x), y(pt.y) {}\ntemplate <typename T>\ninline Point_<T>::~Point_() {}\n\ntypedef Point_<int> Point;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Size_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Size_ {\n   public:\n    Size_();\n    Size_(T _width, T _height);\n    Size_(const Size_<T>& sz);\n    Size_(const Point_<T>& pt);\n    T area();\n    ~Size_();\n\n    T width, height;\n};\n\n/* Member functions of Size_ class */\ntemplate <typename T>\ninline Size_<T>::Size_() {}\ntemplate <typename T>\ninline Size_<T>::Size_(T _width, T _height) : width(_width), height(_height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Size_<T>& sz) : width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline Size_<T>::Size_(const Point_<T>& pt) : width(pt.x), height(pt.y) {}\ntemplate <typename T>\ninline T Size_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T>::~Size_() {}\n\ntypedef Size_<int> Size;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Rect_\n//----------------------------------------------------------------------------------------------------//\ntemplate <typename T>\nclass Rect_ {\n   public:\n    Rect_();\n    Rect_(T _x, T _y, T _width, T _height);\n    Rect_(const Rect_& rect);\n    Rect_(const Point_<T>& pt, const Size_<T>& sz);\n    T area();\n    Size_<T> size();\n    Point_<T> tl(); // top-left point(inside);\n    Point_<T> tr(); // top-right point(outside);\n    Point_<T> bl(); // bottom-left point(outside);\n    Point_<T> br(); // bottom-right point(outside);\n    bool bContains(const Point_<T>& pt);\n    ~Rect_();\n\n    T x, y, width, height;\n};\n\n/* Member functions of Rect_ class */\ntemplate <typename T>\ninline Rect_<T>::Rect_() {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(T _x, T _y, T _width, T _height) : x(_x), y(_y), width(_width), height(_height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Rect_<T>& rect) : x(rect.x), y(rect.y), width(rect.width), height(rect.height) {}\ntemplate <typename T>\ninline Rect_<T>::Rect_(const Point_<T>& pt, const Size_<T>& sz)\n    : x(pt.x), y(pt.y), width(sz.width), height(sz.height) {}\ntemplate <typename T>\ninline T Rect_<T>::area() {\n    return width * height;\n}\ntemplate <typename T>\ninline Size_<T> Rect_<T>::size() {\n    return Size_<T>(width, height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tl() {\n    return Point_<T>(x, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::tr() {\n    return Point_<T>(x + width, y);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::bl() {\n    return Point_<T>(x, y + height);\n}\ntemplate <typename T>\ninline Point_<T> Rect_<T>::br() {\n    return Point_<T>(x + width, y + height);\n}\ntemplate <typename T>\ninline bool Rect_<T>::bContains(const Point_<T>& pt) {\n    return (pt.x >= x && pt.x < x + width && pt.y >= y && pt.y < y + height);\n}\ntemplate <typename T>\ninline Rect_<T>::~Rect_() {}\n\ntypedef Rect_<int> Rect;\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Scalar\n//----------------------------------------------------------------------------------------------------//\ntemplate <int N, typename T>\nclass Scalar {\n   public:\n    Scalar() {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N > 0);\n    }\n    Scalar(T v0) {\n// clang-format off\n#pragma HLS INLINE\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n        // clang-format on\n        assert(N >= 1 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n    }\n    Scalar(T v0, T v1) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 2 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n    }\n    Scalar(T v0, T v1, T v2) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 3 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n    }\n    Scalar(T v0, T v1, T v2, T v3) {\n// clang-format off\n#pragma HLS array_partition variable=val type=cyclic factor=8 dim=1\n#pragma HLS INLINE\n        // clang-format on\n        assert(N >= 4 && \"Scalar must have enough channels for constructor.\");\n        val[0] = v0;\n        val[1] = v1;\n        val[2] = v2;\n        val[3] = v3;\n    }\n\n    void operator=(T value);\n    Scalar<N, T> operator+(T value);\n    Scalar<N, T> operator+(Scalar<N, T> s);\n    Scalar<N, T> operator-(T value);\n    Scalar<N, T> operator-(Scalar<N, T> s);\n    Scalar<N, T> operator*(T value);\n    Scalar<N, T> operator*(Scalar<N, T> s);\n    Scalar<N, T> operator/(T value);\n    Scalar<N, T> operator/(Scalar<N, T> s);\n\n    T val[N];\n};\n\ntemplate <int N, typename T>\nvoid Scalar<N, T>::operator=(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        val[k] = value;\n    }\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator+(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] + s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator-(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] - s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator*(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] * s.val[k];\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(T value) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / value;\n    }\n    return res;\n}\n\ntemplate <int N, typename T>\nScalar<N, T> Scalar<N, T>::operator/(Scalar<N, T> s) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    Scalar<N, T> res;\n    for (int k = 0; k < N; k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS unroll factor=1\n        // clang-format on\n        res.val[k] = val[k] / s.val[k];\n    }\n    return res;\n}\n//----------------------------------------------------------------------------------------------------//\n\n//----------------------------------------------------------------------------------------------------//\n// Template class of Mat\n//----------------------------------------------------------------------------------------------------//\n#if defined(__SYNTHESIS__) && !defined(__SDA_MEM_MAP__)\nstatic constexpr int _XFCVDEPTH_DEFAULT = 2;\n#else\nstatic constexpr int _XFCVDEPTH_DEFAULT = -1;\n#endif\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass Mat {\n   public:\n    unsigned char allocatedFlag; // flag to mark memory allocation in this class\n    int rows, cols, size;        // actual image size\n    //\tint cols_align_npc;\t\t\t\t\t\t// cols\n    // multiple\n    // of\n    // NPC\n\n    typedef XF_TNAME(T, NPC) DATATYPE;\n    using _DATATTYPE = typename std::conditional<\n        (XFCVDEPTH < 0),\n        DATATYPE*,                 // Case of Memory Mapped pointer\n        typename std::conditional< // Case of Stream\n            (XFCVDEPTH == 0),\n            hls::stream<DATATYPE>,           // Case of default Dtream depth or user can override outside\n            hls::stream<DATATYPE, XFCVDEPTH> // Case of Stream depth specified\n            >::type>::type;\n    _DATATTYPE data;\n\n    Mat(); // default constructor\n    Mat(Size _sz);\n    Mat(int _rows, int _cols);\n    Mat(int _size, int _rows, int _cols);\n    Mat(int _rows, int _cols, void* _data);\n    Mat(const Mat&); // copy constructor\n\n    ~Mat();\n\n    Mat& operator=(const Mat&); // Assignment operator\n    //  XF_TNAME(T, XF_NPPC1) operator() (unsigned int r, unsigned int c);\n    //  XF_CTUNAME(T, NPC) operator() (unsigned int r, unsigned int c, unsigned\n    //  int ch);\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void alloc_data() {\n#ifndef __SYNTHESIS__\n        data = (DATATYPE*)malloc(size * sizeof(DATATYPE));\n\n        if (data == NULL) {\n            fprintf(stderr, \"\\nFailed to allocate memory\\n\");\n        } else {\n            allocatedFlag = 1;\n        }\n#endif\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void alloc_data() {\n        // This is a stream\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void free_data() {\n        if (data != NULL) {\n#ifndef __SYNTHESIS__\n            free(data);\n#endif\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void free_data() {}\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        for (int i = 0; i < (rows * ((cols + NPC - 1) >> XF_BITSHIFT(NPC))); ++i) {\n#pragma HLS loop_tripcount min=1 max=1024\n            data[i] = src.data[i];\n        }\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void copyData(const Mat& src) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        data = (DATATYPE*)_data;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void assignDataPtr(void* _data) {\n        // This is a stream\n        assert(0);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data[index];\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    XF_TNAME(T, NPC)\n    read(int index) {\n        return data.read();\n    }\n    float read_float(int index);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data[index] = val;\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void write(int index, XF_TNAME(T, NPC) val) {\n        data.write(val);\n    }\n    void write_float(int index, float val);\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D >= 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols);\n        copyTo(_data);\n    }\n\n    template <int D = XFCVDEPTH, typename std::enable_if<(D < 0)>::type* = nullptr>\n    void init(int _rows, int _cols, void* _data) {\n        init(_rows, _cols, false);\n        assignDataPtr(_data);\n    }\n\n    void init(int _rows, int _cols, bool allocate = true);\n    void copyTo(void* fromData);\n    unsigned char* copyFrom();\n\n    const int type() const;\n    const int depth() const;\n    const int channels() const;\n\n    template <int DST_T>\n    void convertTo(Mat<DST_T, ROWS, COLS, NPC, XFCVDEPTH>& dst, int otype, double alpha = 1, double beta = 0);\n};\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::type() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return (T);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::depth() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_DTPIXELDEPTH(T, NPC);\n}\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nconst int Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::channels() const {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n    return XF_CHANNELS(T, NPC);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::init(int _rows, int _cols, bool allocate) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    assert((_rows > 0) && (_rows <= ROWS) && (_cols > 0) && (_cols <= COLS) &&\n           \"The number of rows and columns must be less than the template \"\n           \"arguments.\");\n\n    rows = _rows;\n    cols = _cols;\n    allocatedFlag = 0;\n    size = _rows * ((_cols + NPPC - 1) >> XF_BITSHIFT(NPPC));\n\n    if (allocate) {\n        alloc_data();\n    }\n}\n\n/*Copy constructor definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::Mat(const Mat& src) {\n    init(src.rows, src.cols);\n\n#ifndef __SYNTHESIS__\n    copyData(src);\n#endif\n}\n\n/*Assignment operator definition*/\ntemplate <int T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::operator=(const Mat& src) {\n    if (this == &src) {\n        return *this; // For self-assignment cases\n    }\n\n    // Cleaning up old data memory if any\n    free_data();\n    allocatedFlag = 0;\n\n    init(src.rows, src.cols);\n    copyData(src);\n\n    return *this;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(ROWS, COLS);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols, void* _data) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols, _data);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(int _rows, int _cols) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_rows, _cols);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::Mat(Size _sz) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    init(_sz.height, _sz.width);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline float Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::read_float(int index) {\n    union int2float {\n        unsigned I;\n        float F;\n    };\n    int2float val;\n    val.I = read(index).to_uint();\n    return val.F;\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::write_float(int index, float float_val) {\n    float val = float_val;\n    ap_uint<32>* val_out = (ap_uint<32>*)(&val);\n    write(index, *val_out);\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyTo(void* _input) {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    XF_PTSNAME(T, NPPC)* input = (XF_PTSNAME(T, NPPC)*)_input;\n    XF_CTUNAME(T, NPPC) in_val;\n\n    int packcols = cols >> XF_BITSHIFT(NPPC);       // Total columns after considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < packcols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            for (int p = 0; p < nppc; p++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                DATATYPE out_val;\n                for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    if (T == XF_32FC1) {\n                        in_val = float2ap_uint<ap_uint<32> >(\n                            input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch]);\n                    } else {\n                        in_val = input[XF_CHANNELS(T, NPPC) * ((r * packcols + c) * nppc + p) + ch];\n                    }\n\n                    out_val.range((p * pixdepth) + (ch + 1) * bitdepth - 1, (p * pixdepth) + ch * bitdepth) = in_val;\n                }\n                write((r * packcols + c), out_val);\n            }\n        }\n    }\n}\n\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ninline unsigned char* Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::copyFrom() {\n// clang-format off\n#pragma HLS inline\n    // clang-format on\n\n    //\tint packcols  = cols >> XF_BITSHIFT(NPPC); //Total columns after\n    // considering parallelism\n    int pixdepth = XF_PIXELWIDTH(T, NPPC);          // Total bits that make up the pixel\n    int bitdepth = pixdepth / XF_CHANNELS(T, NPPC); // Total bits that make up each channel of the pixel\n    int nppc = XF_NPIXPERCYCLE(NPPC);\n\n    int cv_nbytes = bitdepth / 8;\n\n    unsigned char* value =\n        (unsigned char*)malloc(rows * cols * (XF_CHANNELS(T, NPPC)) * (sizeof(unsigned char)) * cv_nbytes);\n\n    int xf_npc_idx = 0;\n    int diff_ptr = 0;\n    int xf_ptr = 0;\n    int cv_ptr = 0;\n\n    for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int c = 0; c < cols; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            DATATYPE in_val = read(xf_ptr);\n            for (int ch = 0; ch < XF_CHANNELS(T, NPPC); ch++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                for (int b = 0; b < cv_nbytes; ++b) {\n#pragma HLS loop_tripcount min=1 max=1024\n                    value[cv_ptr++] = in_val.range((xf_npc_idx * pixdepth) + (ch * bitdepth) + (b + 1) * 8 - 1,\n                                                   (xf_npc_idx * pixdepth) + (ch * bitdepth) + b * 8);\n                }\n            }\n            if (xf_npc_idx == nppc - 1) {\n                xf_npc_idx = 0;\n                xf_ptr++;\n            } else {\n                xf_npc_idx++;\n            }\n        }\n    }\n\n    return (unsigned char*)value;\n}\n\n/* Member functions of Mat class */\ntemplate <int T, int ROWS, int COLS, int NPPC, int XFCVDEPTH>\ntemplate <int DST_T>\ninline void Mat<T, ROWS, COLS, NPPC, XFCVDEPTH>::convertTo(Mat<DST_T, ROWS, COLS, NPPC, XFCVDEPTH>& dst,\n                                                           int otype,\n                                                           double alpha,\n                                                           double beta) {\n    assert((XF_CHANNELS(T, NPPC) == 1) && \"Multi-channel images not supported\");\n\n    XF_TNAME(T, NPPC) tmp_in_pix;\n    XF_TNAME(DST_T, NPPC) tmp_out_pix;\n\n    XF_CTUNAME(T, NPPC) in_pix;\n    XF_CTUNAME(DST_T, NPPC) out_pix;\n\n    int min, max;\n\n    if (DST_T == XF_8UC1) {\n        min = 0;\n        max = 255;\n    } else if (DST_T == XF_16UC1) {\n        min = 0;\n        max = 65535;\n    } else if (DST_T == XF_16SC1) {\n        min = -32768;\n        max = 32767;\n    } else if (DST_T == XF_32SC1) {\n        min = -2147483648;\n        max = 2147483647;\n    } else {\n        assert(1 &&\n               \"Output image type not supoorted. XF_8UC1, XF_16UC1, XF_16SC1 \"\n               \"and XF_32SC1 are valid\");\n    }\n\n#define __SATCAST(X) (X >= max ? max : (X < 0 ? 0 : lround(X)))\n\n    for (int i = 0; i < rows; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n        for (int j = 0; j<cols>> (XF_BITSHIFT(NPPC)); j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n            int IN_STEP = XF_PIXELDEPTH(XF_DEPTH(T, NPPC));\n            int OUT_STEP = XF_PIXELDEPTH(XF_DEPTH(DST_T, NPPC));\n            int in_shift = 0;\n            int out_shift = 0;\n            DATATYPE in_val = read((i * cols >> (XF_BITSHIFT(NPPC))) + j);\n            DATATYPE out_val;\n\n            for (int k = 0; k < (1 << (XF_BITSHIFT(NPPC))); k++) {\n#pragma HLS loop_tripcount min=1 max=1024\n                in_pix = in_val.range(in_shift + IN_STEP - 1, in_shift);\n\n                if (otype == XF_CONVERT_16U_TO_8U || otype == XF_CONVERT_16S_TO_8U || otype == XF_CONVERT_32S_TO_8U ||\n                    otype == XF_CONVERT_32S_TO_16U || otype == XF_CONVERT_32S_TO_16S) {\n                    float tmp = (float)(in_pix * alpha + beta);\n                    in_pix = __SATCAST(tmp);\n\n                    if (in_pix < min) in_pix = min;\n                    if (in_pix > max) in_pix = max;\n\n                    tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = in_pix;\n                } else {\n                    if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) > max) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = max;\n\n                    } else if ((((XF_PTNAME(XF_DEPTH(DST_T, NPPC)))in_pix * alpha) + beta) < min) {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = min;\n\n                    } else {\n                        tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift) = __SATCAST(in_pix * alpha + beta);\n                    }\n                }\n\n                out_pix = tmp_out_pix.range(out_shift + OUT_STEP - 1, out_shift);\n\n                out_val.range(out_shift + OUT_STEP - 1, out_shift) = out_pix;\n\n                in_shift = in_shift + IN_STEP;\n                out_shift = out_shift + OUT_STEP;\n            }\n            dst.write(((i * cols >> (XF_BITSHIFT(NPPC))) + j), out_val);\n        }\n    }\n}\n\ntemplate <int SRC_T, int ROWS, int COLS, int NPC, int XFCVDEPTH>\nMat<SRC_T, ROWS, COLS, NPC, XFCVDEPTH>::~Mat() {\n#ifndef __SYNTHESIS__\n    if (allocatedFlag == 1) {\n        free_data();\n    }\n#endif\n}\n//----------------------------------------------------------------------------------------------------//\n\n// Template metaprogramming implementation of floor log2 [[\ntemplate <int N>\nstruct log2 {\n   public:\n    static constexpr int fvalue = 1 + (log2<N / 2>::fvalue);                   // floor value\n    static constexpr int cvalue = (N > (1 << fvalue)) ? (fvalue + 1) : fvalue; // ceiling value\n};\n\ntemplate <>\nstruct log2<1> {\n   public:\n    static constexpr int fvalue = 0;\n    static constexpr int cvalue = 0;\n};\n\nstruct bgr2y8_params {\n    int black_Vmax = 20;\n    int black_Smax = 70;\n    int brown_Hmax = 15;\n    int brown_Vmax = 40;\n    int Smin = 60;\n    int Smax = 90;\n    int darkgreen_Vmax = 35;\n    int darkgreen_Hmin = 30;\n    int darkgreen_Hmax = 45;\n    int green_Hmax = 90;\n    int green_Hmin = 50;\n    int green_Vmax = 45;\n};\n//]]\n\n/*\n * The purpose of this class is to provide an interator over ap_uint<PTR_WIDTH>\n * object array such\n * that at each iter step one can get data bits corresponding to data to be\n * processed per cycle.\n *\n */\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIter : public Mat<T, ROWS, COLS, NPC, XFCVDEPTH> {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    static constexpr int XF_BITS_PER_CLOCK = XF_PIXELWIDTH(T, NPC) * XF_NPIXPERCYCLE(NPC);\n    static constexpr int COLS_BOUND_PER_NPC = ((COLS + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC));\n    static constexpr int LOOPBOUND = ROWS * COLS_BOUND_PER_NPC;\n    static constexpr int ADDRBOUND = ((ROWS * COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                     (log2<PTR_WIDTH>::cvalue);\n    static constexpr int LAST_BLK_PXL_WIDTH =\n        ((COLS >> XF_BITSHIFT(NPC)) == COLS_BOUND_PER_NPC)\n            ? XF_BITS_PER_CLOCK\n            : XF_PIXELWIDTH(T, NPC) * (COLS - ((COLS >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    static constexpr int COLS_ADDRBOUND = ((COLS * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >>\n                                          (log2<PTR_WIDTH>::cvalue);\n    static int cols_npc_aligned(int cols) { return ((cols + (XF_NPIXPERCYCLE(NPC) - 1)) >> XF_BITSHIFT(NPC)); }\n\n    static int last_blk_pxl_width(int cols, int cols_bound_per_npc) {\n        return ((cols >> XF_BITSHIFT(NPC)) == cols_bound_per_npc)\n                   ? XF_BITS_PER_CLOCK\n                   : XF_PIXELWIDTH(T, NPC) * (cols - ((cols >> XF_BITSHIFT(NPC)) << XF_BITSHIFT(NPC)));\n    }\n\n    static int loopbound(int rows, int cols) { return rows * cols_npc_aligned(cols); }\n\n    int loopbound() { return rows * cols_npc_aligned(cols); }\n\n    static int addrbound(int rows, int cols) {\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> cols_int16 = cols;\n\n        ap_uint<32> mul_rows_cols;\n\n// clang-format off\n#pragma HLS BIND_OP variable=mul_rows_cols op=mul impl=dsp latency=2\n        // clang-format on\n\n        mul_rows_cols = rows_int16 * cols_int16;\n\n        return ((mul_rows_cols * XF_PIXELWIDTH(T, NPC)) + (PTR_WIDTH - 1)) >> (log2<PTR_WIDTH>::cvalue);\n    }\n    MMIter() : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>() {}\n\n    MMIter(int _rows, int _cols) : Mat<T, ROWS, COLS, NPC, XFCVDEPTH>(_rows, _cols) {}\n};\n\n#define _MMITER MMIter<PTR_WIDTH, T, ROWS, COLS, NPC, XFCVDEPTH>\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterIn : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n    using _MMITER::COLS_ADDRBOUND;\n\n   private:\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop1:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    static void Axi2AxiStream(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n    MMIterInLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v = din.read();\n            dout.write(v.data);\n        }\n    }\n\n    static void Axi2AxiStream(ap_uint<PTR_WIDTH>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows_burst,\n                              int rows,\n                              int cols,\n                              int stride = -1) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> cols_addrbound = _MMITER::addrbound(rows_burst, cols);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> stride_addrbound = _MMITER::addrbound(rows_burst, stride);\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> addrbound = (stride == -1) ? cols_addrbound : stride_addrbound;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> c;\n    MMIterInLoop1:\n        for (int r = 0; r < rows; r++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n            // clang-format on\n            for (c = 0; c < cols_addrbound; c++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n\t#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_ADDRBOUND\n#pragma HLS pipeline\n                // clang-format on\n                dout.write(din[c + r * addrbound]);\n            }\n        }\n    }\n    template <int DEPTH>\n    static void AxiStream2MatStream(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                                    hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        int stride_bound_per_npc, strideBased_last_blk_width;\n\n        // if (stride == -1) {\n        stride_bound_per_npc = cols_bound_per_npc;\n        strideBased_last_blk_width = last_blk_width;\n        //} else {\n        //  stride_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        //  strideBased_last_blk_width = _MMITER::last_blk_pxl_width(stride, stride_bound_per_npc);\n        //}\n        int rd_cnt = 0;\n\n        int rem = 0;\n        ap_uint<PTR_WIDTH> val = 0;\n        int i;\n        int j = 0;\n        int bound = rows * stride_bound_per_npc;\n    MMIterInLoopRow:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            bool bLast = (j == (stride_bound_per_npc - 1));\n            int xf_bits_per_clock = bLast ? strideBased_last_blk_width : XF_BITS_PER_CLOCK;\n            int ptr_width_minus = bLast ? (PTR_WIDTH - strideBased_last_blk_width) : (PTR_WIDTH - XF_BITS_PER_CLOCK);\n            int ptr_width_plus = bLast ? (PTR_WIDTH + strideBased_last_blk_width) : (PTR_WIDTH + XF_BITS_PER_CLOCK);\n\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer = 0;\n            if (rem < xf_bits_per_clock) {\n                if (rem != 0) {\n                    localbuffer.range(rem - 1, 0) = val.range(PTR_WIDTH - 1, (PTR_WIDTH - rem));\n                }\n                val = din.read();\n                rd_cnt++;\n                localbuffer.range((xf_bits_per_clock - 1), rem) = val.range(((xf_bits_per_clock - 1) - rem), 0);\n                rem = ptr_width_minus + rem;\n            } else {\n                localbuffer = val.range(((ptr_width_plus - 1) - rem), (PTR_WIDTH - rem));\n                rem = rem - xf_bits_per_clock;\n            }\n            bool bLast_width = (j == (cols_bound_per_npc - 1));\n            ap_uint<XF_BITS_PER_CLOCK> localbuffer2 = 0;\n            if (bLast_width == 0)\n                localbuffer2 = localbuffer;\n            else\n                localbuffer2 = localbuffer.range(last_blk_width - 1, 0);\n\n            if (j < cols_bound_per_npc) dout.write(localbuffer2);\n\n            j = (bLast) ? 0 : (j + 1);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2Mat(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterInLoop2:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Mat(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<XF_BITS_PER_CLOCK>* dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        AxiStream2MatStream(din, ldata, rows, cols_bound_per_npc, last_blk_width, stride);\n        MatStream2Mat(ldata, dout, rows, cols_bound_per_npc);\n    }\n\n    static void Axi2Mat(ap_uint<PTR_WIDTH>* din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n    static void Axi2Mat(\n        ap_uint<PTR_WIDTH>* din, ap_uint<XF_BITS_PER_CLOCK>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n\n        int rows_burst, rows_stride;\n\n        if (stride == -1) {\n            rows_burst = rows;\n            rows_stride = 1;\n        } else {\n            rows_burst = 1;\n            rows_stride = rows;\n        }\n\n        Axi2AxiStream(din, ldata, rows_burst, rows_stride, cols, stride);\n        AxiStream2Mat(ldata, dout, rows, cols, stride);\n    }\n\n    static void Axi2Mat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& din,\n                        ap_uint<XF_BITS_PER_CLOCK>* dout,\n                        int rows = ROWS,\n                        int cols = COLS) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols);\n        Axi2AxiStream(din, ldata, axibound);\n        AxiStream2Mat(ldata, dout, rows, cols);\n    }\n\n   public:\n    MMIterIn(ap_uint<PTR_WIDTH>* d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(ap_uint<PTR_WIDTH>* d, int _rows, int _cols) : _MMITER(_rows, _cols) { Axi2Mat(d, data, rows, cols); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d) : _MMITER() { Axi2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        Axi2Mat(d, data, rows, cols);\n    }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d) : _MMITER() { AxiStream2Mat(d, data); }\n\n    MMIterIn(hls::stream<ap_uint<PTR_WIDTH> >& d, int _rows, int _cols) : _MMITER(_rows, _cols) {\n        AxiStream2Mat(d, data, rows, cols);\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& din, int index) {\n        return din.read();\n    }\n\n    inline static ap_uint<XF_BITS_PER_CLOCK> read(ap_uint<XF_BITS_PER_CLOCK>* din, int index) { return din[index]; }\n\n    ap_uint<XF_BITS_PER_CLOCK> read(int index) { return read(data, index); }\n\n    static void Array2xfMat(ap_uint<PTR_WIDTH>* srcPtr,\n                            xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat,\n                            int stride = -1) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols, stride);\n    }\n\n    static void Array2xfMat(\n        ap_uint<PTR_WIDTH>* srcPtr, ap_uint<XF_BITS_PER_CLOCK>* dstPtr, int rows, int cols, int stride = -1) {\n        Axi2Mat(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void axiStrm2xfMat(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& srcPtr,\n                              xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& dstMat) {\n        Axi2Mat(srcPtr, dstMat.data, dstMat.rows, dstMat.cols);\n    }\n};\n\ntemplate <int PTR_WIDTH, int T, int ROWS, int COLS, int NPC, int FILLZERO = 1, int XFCVDEPTH = _XFCVDEPTH_DEFAULT>\nclass MMIterOut : public _MMITER {\n   public:\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::data;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::rows;\n    using Mat<T, ROWS, COLS, NPC, XFCVDEPTH>::cols;\n\n    using _MMITER::XF_BITS_PER_CLOCK;\n    using _MMITER::ADDRBOUND;\n    using _MMITER::COLS_BOUND_PER_NPC;\n    using _MMITER::LAST_BLK_PXL_WIDTH;\n    using _MMITER::LOOPBOUND;\n\n   private:\n    template <int DEPTH>\n    static void Mat2MatStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& dout,\n                              int rows,\n                              int cols_bound_per_npc) {\n        int i;\n        int bound = rows * cols_bound_per_npc;\n    MMIterOutLoop1:\n        for (i = 0; i < bound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=LOOPBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout.write(din[i]);\n        }\n    }\n\n    template <int DEPTH>\n    static void MatStream2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, DEPTH>& din,\n                                    hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                                    int rows,\n                                    int cols_bound_per_npc,\n                                    int last_blk_width,\n                                    int stride = -1) {\n        ap_uint<16> strideBased_cols_bound_per_npc;\n        if (stride == -1 || FILLZERO == 0) {\n            strideBased_cols_bound_per_npc = cols_bound_per_npc;\n        } else {\n            strideBased_cols_bound_per_npc = _MMITER::cols_npc_aligned(stride);\n        }\n\n        ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled = 0; // valid bits remaining in current buffer\n        ap_uint<PTR_WIDTH> localbuffer = 0;\n        ap_uint<16> i;\n        ap_uint<16> rows_int16 = rows;\n        ap_uint<16> j;\n\n    MMIterOutRow:\n        for (i = 0; i < rows_int16; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ROWS\n        // clang-format on\n        MMIterOutCol:\n            for (j = 0; j < strideBased_cols_bound_per_npc; j++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=COLS_BOUND_PER_NPC\n#pragma HLS pipeline\n                // clang-format on\n\n                bool bLast = (j == (cols_bound_per_npc - 1));\n                int xf_bits_per_clock = bLast ? last_blk_width : XF_BITS_PER_CLOCK;\n                ap_uint<PTR_WIDTH> val;\n                if (j < cols_bound_per_npc || FILLZERO == 0)\n                    val = din.read();\n                else\n                    val = 0;\n\n                ap_uint<PTR_WIDTH> tempval = (val << filled);\n                localbuffer = (localbuffer | tempval);\n                ap_uint<log2<PTR_WIDTH>::cvalue + 1> filled_next;\n\n                if (filled < (PTR_WIDTH - xf_bits_per_clock)) {\n                    filled_next = filled + xf_bits_per_clock;\n                } else if (j == cols_bound_per_npc - 1 && FILLZERO == 0) {\n                    dout.write(localbuffer);\n                    localbuffer = 0;\n                    filled_next = 0;\n                } else {\n                    dout.write(localbuffer);\n                    localbuffer = (val >> (PTR_WIDTH - filled));\n                    filled_next = filled + (xf_bits_per_clock - PTR_WIDTH);\n                }\n\n                filled = filled_next;\n            }\n        }\n\n        if (filled != 0) {\n            dout.write(localbuffer);\n        }\n    }\n\n    static void Mat2AxiStream(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        MatStream2AxiStream(din, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void Mat2AxiStream(ap_uint<XF_BITS_PER_CLOCK>* din,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dout,\n                              int rows = ROWS,\n                              int cols = COLS,\n                              int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n        hls::stream<ap_uint<XF_BITS_PER_CLOCK> > ldata;\n        int cols_bound_per_npc = _MMITER::cols_npc_aligned(cols);\n        int last_blk_width = _MMITER::last_blk_pxl_width(cols, cols_bound_per_npc);\n        Mat2MatStream(din, ldata, rows, cols_bound_per_npc);\n        MatStream2AxiStream(ldata, dout, rows, cols_bound_per_npc, last_blk_width, stride);\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              ap_uint<PTR_WIDTH>* dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop2:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            dout[i] = din.read();\n        }\n    }\n\n    static void AxiStream2Axi(hls::stream<ap_uint<PTR_WIDTH> >& din,\n                              hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                              ap_uint<log2<ADDRBOUND>::cvalue + 1>& addrbound) {\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> i;\n\n    MMIterOutLoop3:\n        for (i = 0; i < addrbound; i++) {\n#pragma HLS loop_tripcount min=1 max=1024\n// clang-format off\n#pragma HLS LOOP_TRIPCOUNT min=1 max=ADDRBOUND\n#pragma HLS pipeline\n            // clang-format on\n            ap_axiu<PTR_WIDTH, 0, 0, 0> v;\n            v.data = din.read();\n            dout.write(v);\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        ap_uint<PTR_WIDTH>* dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(\n        ap_uint<XF_BITS_PER_CLOCK>* din, ap_uint<PTR_WIDTH>* dout, int rows = ROWS, int cols = COLS, int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(hls::stream<ap_uint<XF_BITS_PER_CLOCK>, XFCVDEPTH>& din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n    static void Mat2Axi(ap_uint<XF_BITS_PER_CLOCK>* din,\n                        hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout,\n                        int rows = ROWS,\n                        int cols = COLS,\n                        int stride = -1) {\n// clang-format off\n#pragma HLS DATAFLOW\n        // clang-format on\n\n        int cols_tmp;\n        if (stride == -1)\n            cols_tmp = cols;\n        else\n            cols_tmp = stride;\n\n        hls::stream<ap_uint<PTR_WIDTH> > ldata;\n        ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound = _MMITER::addrbound(rows, cols_tmp);\n        Mat2AxiStream(din, ldata, rows, cols, stride);\n\n        if (FILLZERO == 1)\n            AxiStream2Axi(ldata, dout, axibound);\n        else {\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> axibound_1row = _MMITER::addrbound(1, cols);\n            ap_uint<log2<ADDRBOUND>::cvalue + 1> offset_1row = _MMITER::addrbound(1, stride);\n            for (int rowIdx = 0, offset = 0; rowIdx < rows; rowIdx++, offset += offset_1row) {\n#pragma HLS loop_tripcount min=1 max=1024\n                AxiStream2Axi(ldata, dout + offset, axibound_1row);\n            }\n        }\n    }\n\n   public:\n    MMIterOut() : _MMITER() {}\n\n    MMIterOut(int _rows, int _cols) : _MMITER(_rows, _cols) {}\n\n    inline static void write(hls::stream<ap_uint<XF_BITS_PER_CLOCK> >& dout,\n                             ap_uint<XF_BITS_PER_CLOCK>& val,\n                             int index) {\n        dout.write(val);\n    }\n\n    inline static void write(ap_uint<XF_BITS_PER_CLOCK>* dout, ap_uint<XF_BITS_PER_CLOCK>& val, int index) {\n        dout[index] = val;\n    }\n\n    void write(ap_uint<XF_BITS_PER_CLOCK>& val, int index) { write(data, val, index); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout) { Mat2Axi(data, dout); }\n\n    void transfer(ap_uint<PTR_WIDTH>* dout, int rows, int cols) { Mat2Axi(data, dout, rows, cols); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout) { Mat2Axi(data, dout); }\n\n    void transfer(hls::stream<ap_axiu<PTR_WIDTH, 0, 0, 0> >& dout, int rows, int cols) {\n        Mat2Axi(data, dout, rows, cols);\n    }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout) { Mat2AxiStream(data, dout); }\n\n    void transfer(hls::stream<ap_uint<PTR_WIDTH> >& dout, int rows, int cols) { Mat2AxiStream(data, dout, rows, cols); }\n\n    static void xfMat2Array(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                            ap_uint<PTR_WIDTH>* dstPtr,\n                            int stride = -1) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols, stride);\n    }\n\n    static void xfMat2Array(\n        ap_uint<XF_BITS_PER_CLOCK>* srcPtr, ap_uint<PTR_WIDTH>* dstPtr, int rows, int cols, int stride = -1) {\n        Mat2Axi(srcPtr, dstPtr, rows, cols, stride);\n    }\n\n    static void xfMat2axiStrm(xf::cv::Mat<T, ROWS, COLS, NPC, XFCVDEPTH>& srcMat,\n                              hls::stream<ap_uint<PTR_WIDTH> >& dstPtr) {\n        Mat2Axi(srcMat.data, dstPtr, srcMat.rows, srcMat.cols);\n    }\n};\n\n} // namespace cv\n} // namespace xf\n\n#endif // _XF_STRUCTS_H_\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
      },
      {
        "file_name": "xf_common.hpp",
        "file_content": "/*\n * Copyright 2019 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_COMMON_H_\n#define _XF_COMMON_H_\n\n#include \"xf_structs.hpp\"\n#include \"xf_params.hpp\"\n#include \"xf_types.hpp\"\n\nusing namespace xf::cv;\n#endif\n"
      },
      {
        "file_name": "xf_params.hpp",
        "file_content": "/*\n * Copyright (C) 2019-2022, Xilinx, Inc.\n * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _XF_PARAMS_H_\n#define _XF_PARAMS_H_\n\n#ifndef __cplusplus\n#error C++ is needed to use this file!\n#endif\n\n#include \"ap_int.h\"\n\n#define __ABS(X) ((X) < 0 ? (-(X)) : (X))\n\n// Channels of an image\nenum _channel_extract {\n    XF_EXTRACT_CH_0, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_1, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_2, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_3, // Used by formats with unknown channel types\n    XF_EXTRACT_CH_R, // Used to extract the RED channel\n    XF_EXTRACT_CH_G, // Used to extract the GREEN channel\n    XF_EXTRACT_CH_B, // Used to extract the BLUE channel\n    XF_EXTRACT_CH_A, // Used to extract the ALPHA channel\n    XF_EXTRACT_CH_Y, // Used to extract the LUMA channel\n    XF_EXTRACT_CH_U, // Used to extract the Cb/U channel\n    XF_EXTRACT_CH_V  // Used to extract the Cr/V/Value channel\n};\ntypedef _channel_extract XF_channel_extract_e;\n\n// Conversion Policy for fixed point arithmetic\nenum _convert_policy { XF_CONVERT_POLICY_SATURATE, XF_CONVERT_POLICY_TRUNCATE };\ntypedef _convert_policy XF_convert_policy_e;\n\n// Bit-depth conversion types\nenum _convert_bit_depth {\n    // Down-convert\n    XF_CONVERT_16U_TO_8U,\n    XF_CONVERT_16S_TO_8U,\n    XF_CONVERT_32S_TO_8U,\n    XF_CONVERT_32S_TO_16U,\n    XF_CONVERT_32S_TO_16S,\n    // Up-convert\n    XF_CONVERT_8U_TO_16U,\n    XF_CONVERT_8U_TO_16S,\n    XF_CONVERT_8U_TO_32S,\n    XF_CONVERT_16U_TO_32S,\n    XF_CONVERT_16S_TO_32S\n};\ntypedef _convert_bit_depth XF_convert_bit_depth_e;\n\n// Thresholding types\nenum _threshold_type {\n    XF_THRESHOLD_TYPE_BINARY = 0,\n    XF_THRESHOLD_TYPE_BINARY_INV = 1,\n    XF_THRESHOLD_TYPE_TRUNC = 2,\n    XF_THRESHOLD_TYPE_TOZERO = 3,\n    XF_THRESHOLD_TYPE_TOZERO_INV = 4,\n};\ntypedef _threshold_type XF_threshold_type_e;\n\n// Thresholding types\nenum _ccm_type {\n    XF_CCM_bt2020_bt709 = 0,\n    XF_CCM_bt709_bt2020 = 1,\n    XF_CCM_rgb_yuv_601 = 2,\n    XF_CCM_rgb_yuv_709 = 3,\n    XF_CCM_rgb_yuv_2020 = 4,\n    XF_CCM_yuv_rgb_601 = 5,\n    XF_CCM_yuv_rgb_709 = 6,\n    XF_CCM_yuv_rgb_2020 = 7,\n    XF_CCM_full_from_16_235 = 8,\n    XF_CCM_full_to_16_235 = 9,\n\n};\ntypedef _ccm_type XF_ccm_type_e;\n\n// Comparision types\nenum _comparison_op { XF_CMP_EQ = 0, XF_CMP_GT = 1, XF_CMP_GE = 2, XF_CMP_LT = 3, XF_CMP_LE = 4, XF_CMP_NE = 5 };\ntypedef _comparison_op _comparison_op_e;\n\n// Comparision types\nenum _reduction_op { REDUCE_SUM = 0, REDUCE_AVG = 1, REDUCE_MAX = 2, REDUCE_MIN = 3 };\ntypedef _reduction_op _reduction_op_e;\n\n// Pixel Per Cycle\nenum _pixel_per_cycle {\n    XF_NPPC1 = 1,\n    XF_NPPC2 = 2,\n    XF_NPPC4 = 4,\n    XF_NPPC8 = 8,\n    XF_NPPC16 = 16,\n    XF_NPPC32 = 32,\n    XF_NPPC64 = 64\n};\ntypedef _pixel_per_cycle XF_nppc_e;\n\n// Pixel types\nenum _pixel_type {\n    XF_8UP = 0,\n    XF_8SP = 1,\n    XF_14UP = 2,\n    XF_16UP = 3,\n    XF_16SP = 4,\n    XF_32UP = 5,\n    XF_32SP = 6,\n    XF_19SP = 7,\n    XF_32FP = 8,\n    XF_35SP = 9,\n    XF_24SP = 10,\n    XF_20SP = 11,\n    XF_48SP = 12,\n    XF_2UP = 13,\n    XF_9SP = 14,\n    XF_9UP = 15,\n    XF_24UP = 16,\n    XF_64UP = 17,\n    XF_10UP = 18,\n    XF_12UP = 19,\n    XF_40UP = 20,\n    XF_42UP = 20,\n    XF_48UP = 21,\n    XF_30UP = 22,\n    XF_36UP = 23,\n    XF_96FP = 24\n};\ntypedef _pixel_type XF_pixel_type_e;\n\n// Word width\nenum _word_width {\n    XF_2UW = 0,\n    XF_8UW = 1,\n    XF_9UW = 2,\n    XF_10UW = 3,\n    XF_12UW = 4,\n    XF_14UW = 5,\n    XF_16UW = 6,\n    XF_19SW = 7,\n    XF_20UW = 8,\n    XF_22UW = 9,\n    XF_24UW = 10,\n    XF_24SW = 11,\n    XF_28UW = 12,\n    XF_30UW = 13,\n    XF_32UW = 14,\n    XF_32FW = 15,\n    XF_35SW = 16,\n    XF_36UW = 17,\n    XF_40UW = 18,\n    XF_42UW = 19,\n    XF_48UW = 20,\n    XF_48SW = 21,\n    XF_56UW = 22,\n    XF_60UW = 23,\n    XF_64UW = 24,\n    XF_72UW = 25,\n    XF_80UW = 26,\n    XF_84UW = 27,\n    XF_96UW = 28,\n    XF_96SW = 29,\n    XF_112UW = 30,\n    XF_120UW = 31,\n    XF_128UW = 32,\n    XF_144UW = 33,\n    XF_152SW = 34,\n    XF_160UW = 35,\n    XF_160SW = 36,\n    XF_168UW = 37,\n    XF_176UW = 38,\n    XF_192UW = 39,\n    XF_192SW = 40,\n    XF_240UW = 41,\n    XF_256UW = 42,\n    XF_280SW = 43,\n    XF_288UW = 44,\n    XF_304SW = 45,\n    XF_320UW = 46,\n    XF_336UW = 47,\n    XF_352UW = 48,\n    XF_384UW = 49,\n    XF_384SW = 50,\n    XF_512UW = 51,\n    XF_560SW = 52,\n    XF_576UW = 53,\n    XF_96FW = 54,\n    XF_192FW = 55,\n    XF_384FW = 56,\n    XF_768FW = 57,\n    XF_1536FW = 58\n};\ntypedef _word_width XF_word_width_e;\n\n// Filter size\nenum _filter_size { XF_FILTER_3X3 = 3, XF_FILTER_5X5 = 5, XF_FILTER_7X7 = 7 };\ntypedef _filter_size XF_filter_size_e;\n\n// Radius size for Non Maximum Suppression\nenum _nms_radius { XF_NMS_RADIUS_1 = 1, XF_NMS_RADIUS_2 = 2, XF_NMS_RADIUS_3 = 3 };\ntypedef _nms_radius XF_nms_radius_e;\n\n// Image Pyramid Parameters\nenum _image_pyramid_params {\n    XF_PYRAMID_TYPE_GXFSSIAN = 0,\n    XF_PYRAMID_TYPE_LAPLACIAN = 1,\n    XF_PYRAMID_SCALE_HALF = 2,\n    XF_PYRAMID_SCALE_ORB = 3,\n    XF_PYRAMID_SCALE_DOUBLE = 4\n};\ntypedef _image_pyramid_params XF_image_pyramid_params_e;\n\n// Magnitude computation\nenum _normalisation_params { XF_L1NORM = 0, XF_L2NORM = 1 };\ntypedef _normalisation_params XF_normalisation_params_e;\n\nenum _border_type {\n    XF_BORDER_CONSTANT = 0,\n    XF_BORDER_REPLICATE = 1,\n    XF_BORDER_REFLECT = 2,\n    XF_BORDER_WRAP = 3,\n    XF_BORDER_REFLECT_101 = 4,\n    XF_BORDER_TRANSPARENT = 5,\n    XF_BORDER_REFLECT101 = XF_BORDER_REFLECT_101,\n    XF_BORDER_DEFAULT = XF_BORDER_REFLECT_101,\n    XF_BORDER_ISOLATED = 16,\n};\ntypedef _border_type XF_border_type_e;\n\nenum _structuring_element_shape {\n    XF_SHAPE_RECT = 0,\n    XF_SHAPE_ELLIPSE = 1,\n    XF_SHAPE_CROSS = 2,\n\n};\nenum _wb_type {\n    XF_WB_GRAY = 0,\n    XF_WB_SIMPLE = 1,\n};\n\nenum multistream {\n    SLICES_DEFAULT = 1,\n};\n// Phase computation\nenum _phase_params { XF_RADIANS = 0, XF_DEGREES = 1 };\ntypedef _phase_params XF_phase_params_e;\n\n// Types of Interpolaton techniques used in resize, affine and perspective\nenum _interpolation_types { XF_INTERPOLATION_NN = 0, XF_INTERPOLATION_BILINEAR = 1, XF_INTERPOLATION_AREA = 2 };\ntypedef _interpolation_types _interpolation_types_e;\n\n// loop dependent variables used in image pyramid\nenum _loop_dependent_vars { XF_GXFSSIANLOOP = 8, XF_BUFSIZE = 12 };\ntypedef _loop_dependent_vars loop_dependent_vars_e;\n\n// loop dependent variables used in image pyramid\nenum _image_size { XF_SDIMAGE = 0, XF_HDIMAGE = 1 };\ntypedef _image_size image_size_e;\n\n// enumerations for HOG feature descriptor\nenum _input_image_type { XF_GRAY = 1, XF_RGB = 3 };\ntypedef _input_image_type input_image_type_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_output_type { XF_HOG_RB = 0, XF_HOG_NRB = 1 };\ntypedef _HOG_output_type HOG_output_type_e;\n\nenum use_model { XF_STANDALONE = 0, XF_PIPELINE = 1 };\ntypedef use_model use_model_e;\n\n// enumerations for HOG feature descriptor\nenum _HOG_type { XF_DHOG = 0, XF_SHOG = 1 };\ntypedef _HOG_type HOG_type_e;\n\n// enumerations for Stereo BM\nenum XF_stereo_prefilter_type { XF_STEREO_PREFILTER_SOBEL_TYPE, XF_STEREO_PREFILTER_NORM_TYPE };\n/****************************new************************/\n// enumerations for Demosaicing\nenum XF_demosaicing {\n    XF_BAYER_BG,\n    XF_BAYER_GB,\n    XF_BAYER_GR,\n    XF_BAYER_RG,\n};\n// typedef XF_stereo_prefilter_type XF_stereo_pre_filter_type_e;\n// enum _pixel_percycle\n//{\n//\tXF_NPPC1  = 0,\n//\tXF_NPPC8  = 3,\n//\tXF_NPPC16 = 4\n//};\n// typedef _pixel_percycle XF_nppc_e;\n\n// enumerations for Architecture\nenum _ARCH_type {\n    XF_STREAM = 0,\n    XF_MEMORYMAPPED = 1\n\n};\ntypedef _ARCH_type _ARCH_type_e;\n\nenum _pixeltype {\n    XF_8UC1 = 0,\n    XF_14UC1 = 1,\n    XF_16UC1 = 2,\n    XF_16SC1 = 3,\n    XF_24UC1 = 4,\n    XF_24SC1 = 5,\n    XF_32UC1 = 6,\n    XF_32FC1 = 7,\n    XF_32SC1 = 8,\n    XF_8UC2 = 9,\n    XF_8UC4 = 10,\n    XF_2UC1 = 11,\n    XF_8UC3 = 16,\n    XF_16UC3 = 13,\n    XF_16SC3 = 14,\n    XF_16UC4 = 15,\n    XF_10UC1 = 12,\n    XF_10UC4 = 17,\n    XF_12UC1 = 18,\n    XF_12UC4 = 19,\n    XF_10UC3 = 20,\n    XF_12UC3 = 21,\n    XF_14UC3 = 22,\n    XF_32FC3 = 23,\n    XF_64UC1 = 24\n};\ntypedef _pixeltype XF_npt_e;\n\nenum _ramtype {\n    RAM_1P_BRAM = 0,\n    RAM_1P_LUTRAM = 1,\n    RAM_1P_URAM = 2,\n    RAM_2P_BRAM = 3,\n    RAM_2P_LUTRAM = 4,\n    RAM_2P_URAM = 5,\n    RAM_S2P_BRAM = 6,\n    RAM_S2P_LUTRAM = 7,\n    RAM_S2P_URAM = 8,\n    RAM_T2P_BRAM = 9,\n    RAM_T2P_URAM = 10\n};\ntypedef _ramtype XF_ramtype_e;\n\n#endif //_XF_PARAMS_H_\n"
      }
    ],
    "code_length": 13996,
    "token_count": 4115,
    "pragma_number": 322,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/option_pricing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1182,
    "Worst-caseLatency": 1182.0,
    "BRAM_18K": 0,
    "LUT": 92799,
    "DSP": 1250,
    "FF": 95246,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "option_pricing",
    "ResourceMetric": 0.0615578797,
    "design_id": "project",
    "algo_name": "option_pricing",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "option_pricing.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid option_pricing(double S[N], double K[N], double T[N], double r, double sigma, double option_price[N]) {\n    const double pi = 3.14159265358979323846;\n    for (int i = 0; i < N; i++) {\n        double d1 = (log(S[i] / K[i]) + (r + 0.5 * sigma * sigma) * T[i]) / (sigma * sqrt(T[i]));\n        double d2 = d1 - sigma * sqrt(T[i]);\n        double Nd1 = 0.5 * (1.0 + erf(d1 / sqrt(2.0)));\n        double Nd2 = 0.5 * (1.0 + erf(d2 / sqrt(2.0)));\n        option_price[i] = S[i] * Nd1 - K[i] * exp(-r * T[i]) * Nd2;\n    }\n}\n\n// Top function name: option_pricing\n"
      }
    ],
    "code_length": 592,
    "token_count": 213,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/or_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 79,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "or_gate",
    "ResourceMetric": 1.75465e-05,
    "design_id": "project",
    "algo_name": "or_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "or_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid or_gate(ap_uint<1> input1[SIZE], ap_uint<1> input2[SIZE], ap_uint<1> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] | input2[i];\n    }\n}\n\n// Top function name: or_gate\n"
      }
    ],
    "code_length": 249,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/ordinal_feature_scaling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2091,
    "Worst-caseLatency": 2091.0,
    "BRAM_18K": 0,
    "LUT": 2255,
    "DSP": 2,
    "FF": 2592,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ordinal_feature_scaling",
    "ResourceMetric": 0.0007363648,
    "design_id": "project",
    "algo_name": "ordinal_feature_scaling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "ordinal_feature_scaling.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid ordinal_feature_scaling(int input[ARRAY_SIZE], int output[ARRAY_SIZE]) {\n    int min_val = input[0];\n    int max_val = input[0];\n\n    // Find the minimum and maximum values in the input array\n    for (int i = 1; i < ARRAY_SIZE; i++) {\n        if (input[i] < min_val) {\n            min_val = input[i];\n        }\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n    }\n\n    // Scale the input array to ordinal values\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] - min_val) * 100 / (max_val - min_val);\n    }\n}\n\n// Top function name: ordinal_feature_scaling\n"
      }
    ],
    "code_length": 660,
    "token_count": 183,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/original/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 254,
    "Worst-caseLatency": 254.0,
    "BRAM_18K": 0,
    "LUT": 216,
    "DSP": 0,
    "FF": 38,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "array_mem_bottleneck",
    "ResourceMetric": 4.50647e-05,
    "design_id": "project",
    "algo_name": "original",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _ARRAY_MEM_BOTTLENECK_H_\n#define _ARRAY_MEM_BOTTLENECK_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 128\n\ntypedef ap_int<7> din_t;\ntypedef ap_int<10> dout_t;\n\ndout_t array_mem_bottleneck(din_t mem[N]);\n\n#endif\n\ndout_t array_mem_bottleneck(din_t mem[N]) {\n\n    dout_t sum = 0;\n    int i;\n\nSUM_LOOP:\n    for (i = 2; i < N; ++i)\n        sum += mem[i] + mem[i - 1] + mem[i - 2];\n\n    return sum;\n}\n"
      }
    ],
    "code_length": 1839,
    "token_count": 463,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/osd_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 574,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "osd_processor",
    "ResourceMetric": 0.0001124701,
    "design_id": "project",
    "algo_name": "osd_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "osd_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid osd_processor(ap_int<16> input[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<16> temp = input[i];\n        ap_int<16> result = 0;\n\n        // Example processing: simple bitwise operations\n        for (int j = 0; j < 16; j++) {\n            if (temp[j] == 1) {\n                result |= (1 << (15 - j));\n            }\n        }\n\n        output[i] = result;\n    }\n}\n\n// Top function name: osd_processor\n"
      }
    ],
    "code_length": 484,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/otsu_thresholding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2580,
    "Worst-caseLatency": 3128.0,
    "BRAM_18K": 1,
    "LUT": 5116,
    "DSP": 10,
    "FF": 5731,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "otsu_thresholding",
    "ResourceMetric": 0.0018696141,
    "design_id": "project",
    "algo_name": "otsu_thresholding",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "otsu_thresholding.cpp",
        "file_content": "#include <ap_int.h>\n\n#define IMG_SIZE 1024\n\nvoid otsu_thresholding(ap_uint<8> image[IMG_SIZE], ap_uint<8> thresholded_image[IMG_SIZE]) {\n    ap_uint<32> histogram[256] = {0};\n    ap_uint<32> total_pixels = IMG_SIZE;\n    ap_uint<32> sum = 0;\n    ap_uint<32> sumB = 0;\n    ap_uint<32> wB = 0;\n    ap_uint<32> wF = 0;\n    ap_uint<8> threshold = 0;\n    ap_uint<32> max_variance = 0;\n\n    // Compute histogram\n    for (int i = 0; i < IMG_SIZE; i++) {\n        histogram[image[i]]++;\n    }\n\n    // Compute sum of all pixel values\n    for (int t = 0; t < 256; t++) {\n        sum += t * histogram[t];\n    }\n\n    // Find optimal threshold\n    for (int t = 0; t < 256; t++) {\n        wB += histogram[t];\n        if (wB == 0) continue;\n        wF = total_pixels - wB;\n        if (wF == 0) break;\n\n        sumB += t * histogram[t];\n        ap_uint<32> mB = sumB / wB;\n        ap_uint<32> mF = (sum - sumB) / wF;\n\n        ap_uint<32> variance = wB * wF * (mB - mF) * (mB - mF);\n        if (variance > max_variance) {\n            max_variance = variance;\n            threshold = t;\n        }\n    }\n\n    // Apply threshold to the image\n    for (int i = 0; i < IMG_SIZE; i++) {\n        thresholded_image[i] = (image[i] > threshold) ? 255 : 0;\n    }\n}\n\n// Top function name: otsu_thresholding\n"
      }
    ],
    "code_length": 1275,
    "token_count": 423,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/packet_filtering/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 32866,
    "Worst-caseLatency": 32866.0,
    "BRAM_18K": 0,
    "LUT": 5467,
    "DSP": 0,
    "FF": 4926,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "packet_filtering",
    "ResourceMetric": 0.0015206953,
    "design_id": "project",
    "algo_name": "packet_filtering",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "packet_filtering.cpp",
        "file_content": "#include <stdint.h>\n\n#define PACKET_COUNT 1024\n#define PACKET_SIZE 64\n\nvoid packet_filtering(uint8_t packets[PACKET_COUNT][PACKET_SIZE], uint8_t filtered_packets[PACKET_COUNT][PACKET_SIZE], uint8_t filter_criteria[PACKET_SIZE]) {\n    int i, j;\n    int match;\n    for (i = 0; i < PACKET_COUNT; i++) {\n        match = 1;\n        for (j = 0; j < PACKET_SIZE; j++) {\n            if (packets[i][j] != filter_criteria[j]) {\n                match = 0;\n                break;\n            }\n        }\n        if (match) {\n            for (j = 0; j < PACKET_SIZE; j++) {\n                filtered_packets[i][j] = packets[i][j];\n            }\n        } else {\n            for (j = 0; j < PACKET_SIZE; j++) {\n                filtered_packets[i][j] = 0;\n            }\n        }\n    }\n}\n\n// Top function name: packet_filtering\n"
      }
    ],
    "code_length": 812,
    "token_count": 220,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/parallel_cmos_mac/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 138,
    "DSP": 1,
    "FF": 117,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parallel_cmos_mac",
    "ResourceMetric": 6.53857e-05,
    "design_id": "project",
    "algo_name": "parallel_cmos_mac",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "parallel_cmos_mac.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid parallel_cmos_mac(ap_int<16> A[SIZE], ap_int<16> B[SIZE], ap_int<32> &accumulator) {\n    ap_int<32> local_acc = 0;\n    for (int i = 0; i < SIZE; i++) {\n        local_acc += A[i] * B[i];\n    }\n    accumulator = local_acc;\n}\n\n// Top function name: parallel_cmos_mac\n"
      }
    ],
    "code_length": 309,
    "token_count": 100,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/parallel_computing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parallel_computing",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "parallel_computing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "parallel_computing.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid parallel_computing(ap_int<16> input1[SIZE], ap_int<16> input2[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input1[i] + input2[i];\n    }\n}\n\n// Top function name: parallel_computing\n"
      }
    ],
    "code_length": 271,
    "token_count": 90,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/parallel_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 117,
    "DSP": 0,
    "FF": 24,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parallel_counter",
    "ResourceMetric": 2.47377e-05,
    "design_id": "project",
    "algo_name": "parallel_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "parallel_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid parallel_counter(ap_uint<1> input[SIZE], ap_uint<10> &count) {\n    ap_uint<10> local_count = 0;\n    for (int i = 0; i < SIZE; i++) {\n        local_count += input[i];\n    }\n    count = local_count;\n}\n\n// Top function name: parallel_counter\n"
      }
    ],
    "code_length": 284,
    "token_count": 85,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/parallel_load_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 194,
    "DSP": 0,
    "FF": 63,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parallel_load_shift_register",
    "ResourceMetric": 4.3243e-05,
    "design_id": "project",
    "algo_name": "parallel_load_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "parallel_load_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid parallel_load_shift_register(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE], ap_uint<32> load_value, bool load) {\n    for (int i = 0; i < SIZE; i++) {\n        if (load) {\n            output[i] = load_value;\n        } else {\n            if (i == 0) {\n                output[i] = input[SIZE-1];\n            } else {\n                output[i] = input[i-1];\n            }\n        }\n    }\n}\n\n// Top function name: parallel_load_shift_register\n"
      }
    ],
    "code_length": 486,
    "token_count": 132,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/parallel_load_shift_registers/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3083,
    "Worst-caseLatency": 3083.0,
    "BRAM_18K": 0,
    "LUT": 402,
    "DSP": 0,
    "FF": 85,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parallel_load_shift_registers",
    "ResourceMetric": 8.52395e-05,
    "design_id": "project",
    "algo_name": "parallel_load_shift_registers",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "parallel_load_shift_registers.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid parallel_load_shift_registers(ap_uint<1> input[SIZE], ap_uint<1> output[SIZE]) {\n    ap_uint<1> shift_registers[SIZE];\n\n    // Parallel load\n    for (int i = 0; i < SIZE; i++) {\n        shift_registers[i] = input[i];\n    }\n\n    // Shift operation\n    for (int i = 0; i < SIZE - 1; i++) {\n        shift_registers[i] = shift_registers[i + 1];\n    }\n    shift_registers[SIZE - 1] = 0; // Open-drain output\n\n    // Output assignment\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = shift_registers[i];\n    }\n}\n\n// Top function name: parallel_load_shift_registers\n"
      }
    ],
    "code_length": 612,
    "token_count": 180,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/parameter_server/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 136,
    "DSP": 3,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parameter_server",
    "ResourceMetric": 0.0001145611,
    "design_id": "project",
    "algo_name": "parameter_server",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "parameter_server.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid parameter_server(ap_int<32> weights[ARRAY_SIZE], ap_int<32> gradients[ARRAY_SIZE], ap_int<32> learning_rate) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        weights[i] -= learning_rate * gradients[i];\n    }\n}\n\n// Top function name: parameter_server\n"
      }
    ],
    "code_length": 305,
    "token_count": 84,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/parity_checker/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 64,
    "DSP": 0,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "parity_checker",
    "ResourceMetric": 1.35194e-05,
    "design_id": "project",
    "algo_name": "parity_checker",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "parity_checker.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid parity_checker(ap_uint<1> input[ARRAY_SIZE], ap_uint<1> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<1> parity = 0;\n        for (int j = 0; j < 8; j++) {\n            parity ^= input[i][j];\n        }\n        output[i] = parity;\n    }\n}\n\n// Top function name: parity_checker\n"
      }
    ],
    "code_length": 360,
    "token_count": 110,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/particle_swarm_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 47104011,
    "Worst-caseLatency": 47104011.0,
    "BRAM_18K": 0,
    "LUT": 2776,
    "DSP": 10,
    "FF": 3054,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "particle_swarm_optimization",
    "ResourceMetric": 0.0011022032,
    "design_id": "project",
    "algo_name": "particle_swarm_optimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "particle_swarm_optimization.cpp",
        "file_content": "#include <cmath>\n\n#define NUM_PARTICLES 1024\n#define NUM_DIMENSIONS 10\n#define MAX_ITERATIONS 1000\n\nvoid particle_swarm_optimization(float positions[NUM_PARTICLES][NUM_DIMENSIONS], \n                                 float velocities[NUM_PARTICLES][NUM_DIMENSIONS], \n                                 float pbest_positions[NUM_PARTICLES][NUM_DIMENSIONS], \n                                 float gbest_position[NUM_DIMENSIONS], \n                                 float fitness[NUM_PARTICLES], \n                                 float pbest_fitness[NUM_PARTICLES], \n                                 float &gbest_fitness) {\n    const float w = 0.5;  // inertia weight\n    const float c1 = 1.5; // cognitive (particle) weight\n    const float c2 = 1.5; // social (swarm) weight\n\n    for (int iter = 0; iter < MAX_ITERATIONS; iter++) {\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            // Update velocity and position\n            for (int d = 0; d < NUM_DIMENSIONS; d++) {\n                float r1 = 0.5; // fixed random number for synthesis\n                float r2 = 0.5; // fixed random number for synthesis\n                velocities[i][d] = w * velocities[i][d] + c1 * r1 * (pbest_positions[i][d] - positions[i][d]) + c2 * r2 * (gbest_position[d] - positions[i][d]);\n                positions[i][d] += velocities[i][d];\n            }\n\n            // Evaluate fitness\n            float new_fitness = 0.0;\n            for (int d = 0; d < NUM_DIMENSIONS; d++) {\n                new_fitness += positions[i][d] * positions[i][d]; // Sphere function\n            }\n            fitness[i] = new_fitness;\n\n            // Update personal best\n            if (fitness[i] < pbest_fitness[i]) {\n                pbest_fitness[i] = fitness[i];\n                for (int d = 0; d < NUM_DIMENSIONS; d++) {\n                    pbest_positions[i][d] = positions[i][d];\n                }\n            }\n\n            // Update global best\n            if (fitness[i] < gbest_fitness) {\n                gbest_fitness = fitness[i];\n                for (int d = 0; d < NUM_DIMENSIONS; d++) {\n                    gbest_position[d] = positions[i][d];\n                }\n            }\n        }\n    }\n}\n\n// Top function name: particle_swarm_optimization\n"
      }
    ],
    "code_length": 2229,
    "token_count": 524,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/pca/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2151677985,
    "Worst-caseLatency": 2151677985.0,
    "BRAM_18K": 2048,
    "LUT": 2120,
    "DSP": 5,
    "FF": 1324,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pca",
    "ResourceMetric": 0.1276561363,
    "design_id": "project",
    "algo_name": "pca",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "pca.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024 // Large scale size\n\nvoid pca(float data[N][N], float mean[N], float cov[N][N], float eigvec[N][N], float eigval[N]) {\n    // Step 1: Calculate the mean of each column\n    for (int j = 0; j < N; j++) {\n        mean[j] = 0.0;\n        for (int i = 0; i < N; i++) {\n            mean[j] += data[i][j];\n        }\n        mean[j] /= N;\n    }\n\n    // Step 2: Subtract the mean from each column\n    float centered_data[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            centered_data[i][j] = data[i][j] - mean[j];\n        }\n    }\n\n    // Step 3: Calculate the covariance matrix\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cov[i][j] = 0.0;\n            for (int k = 0; k < N; k++) {\n                cov[i][j] += centered_data[k][i] * centered_data[k][j];\n            }\n            cov[i][j] /= (N - 1);\n        }\n    }\n\n    // Step 4: Calculate eigenvalues and eigenvectors (simplified for synthesis)\n    // Note: This is a placeholder for actual eigenvalue/eigenvector computation\n    for (int i = 0; i < N; i++) {\n        eigval[i] = cov[i][i]; // Simplified assumption\n        for (int j = 0; j < N; j++) {\n            eigvec[i][j] = (i == j) ? 1.0 : 0.0; // Simplified assumption\n        }\n    }\n}\n\n// Top function name: pca\n"
      }
    ],
    "code_length": 1332,
    "token_count": 431,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/pcie_endpoint_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pcie_endpoint_controller",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "pcie_endpoint_controller",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "pcie_endpoint_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_WIDTH 32\n#define ARRAY_SIZE (1 << 10)\n\nvoid pcie_endpoint_controller(ap_uint<DATA_WIDTH> input_data[ARRAY_SIZE], ap_uint<DATA_WIDTH> output_data[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = input_data[i] + 1; // Simple operation for demonstration\n    }\n}\n\n// Top function name: pcie_endpoint_controller\n"
      }
    ],
    "code_length": 375,
    "token_count": 101,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/pcie_interface/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pcie_interface",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "pcie_interface",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "pcie_interface.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid pcie_interface(uint32_t input_data[ARRAY_SIZE], uint32_t output_data[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = input_data[i] * 2;\n    }\n}\n\n// Top function name: pcie_interface\n"
      }
    ],
    "code_length": 268,
    "token_count": 78,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/perceptron/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 223,
    "DSP": 1,
    "FF": 121,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "perceptron",
    "ResourceMetric": 8.20692e-05,
    "design_id": "project",
    "algo_name": "perceptron",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "perceptron.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid perceptron(ap_int<16> input[N], ap_int<16> weights[N], ap_int<16> bias, ap_int<1> &output) {\n    ap_int<32> sum = 0;\n    for (int i = 0; i < N; i++) {\n        sum += input[i] * weights[i];\n    }\n    sum += bias;\n    output = (sum > 0) ? 1 : 0;\n}\n\n// Top function name: perceptron\n"
      }
    ],
    "code_length": 322,
    "token_count": 116,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/perfect_loop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 405,
    "Worst-caseLatency": 405.0,
    "BRAM_18K": 0,
    "LUT": 322,
    "DSP": 2,
    "FF": 183,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "loop_perfect",
    "ResourceMetric": 0.0001347026,
    "design_id": "project",
    "algo_name": "perfect_loop",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _LOOP_PERFECT_H_\n#define _LOOP_PERFECT_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 20\n\ntypedef ap_int<5> din_t;\ntypedef ap_int<12> dint_t;\ntypedef ap_int<6> dout_t;\n\nvoid loop_perfect(din_t A[N], dout_t B[N]);\n\n#endif\n\nvoid loop_perfect(din_t A[N], dout_t B[N]) {\n    int i, j;\n    dint_t acc;\n\nLOOP_I:\n    for (i = 0; i < 20; i++) {\n    LOOP_J:\n        for (j = 0; j < 20; j++) {\n            if (j == 0)\n                acc = 0;\n            acc += A[j] * j;\n            if (j == 19) {\n                if (i % 2 == 0)\n                    B[i] = acc / 20;\n                else\n                    B[i] = 0;\n            }\n        }\n    }\n}\n"
      }
    ],
    "code_length": 2085,
    "token_count": 534,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/peripheral_interface/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "peripheral_interface",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "peripheral_interface",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "peripheral_interface.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid peripheral_interface(ap_int<32> input_data[ARRAY_SIZE], ap_int<32> output_data[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = input_data[i] + 1;\n    }\n}\n\n// Top function name: peripheral_interface\n"
      }
    ],
    "code_length": 284,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/permutation_testing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1049607,
    "Worst-caseLatency": 1049607.0,
    "BRAM_18K": 2,
    "LUT": 486,
    "DSP": 0,
    "FF": 122,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "permutation_testing",
    "ResourceMetric": 0.0002289033,
    "design_id": "project",
    "algo_name": "permutation_testing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "permutation_testing.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid permutation_testing(int input[SIZE], int output[SIZE]) {\n    int i, j;\n    int temp[SIZE];\n\n    // Copy input to temp\n    for (i = 0; i < SIZE; i++) {\n        temp[i] = input[i];\n    }\n\n    // Perform permutation testing\n    for (i = 0; i < SIZE; i++) {\n        int sum = 0;\n        for (j = 0; j < SIZE; j++) {\n            if (i != j) {\n                sum += temp[j];\n            }\n        }\n        output[i] = sum;\n    }\n}\n\n// Top function name: permutation_testing\n"
      }
    ],
    "code_length": 515,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/phase_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "phase_comparator",
    "ResourceMetric": 2.90524e-05,
    "design_id": "project",
    "algo_name": "phase_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "phase_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid phase_comparator(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> phase_diff = input1[i] - input2[i];\n        if (phase_diff < 0) {\n            phase_diff = -phase_diff;\n        }\n        output[i] = phase_diff;\n    }\n}\n\n// Top function name: phase_comparator\n"
      }
    ],
    "code_length": 419,
    "token_count": 125,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/phase_detector/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "phase_detector",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "phase_detector",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "phase_detector.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid phase_detector(ap_int<16> input_signal[ARRAY_SIZE], ap_int<16> reference_signal[ARRAY_SIZE], ap_int<16> phase_difference[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        phase_difference[i] = input_signal[i] - reference_signal[i];\n    }\n}\n\n// Top function name: phase_detector\n"
      }
    ],
    "code_length": 345,
    "token_count": 93,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/pid_control/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1030,
    "Worst-caseLatency": 1030.0,
    "BRAM_18K": 0,
    "LUT": 235,
    "DSP": 3,
    "FF": 321,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pid_control",
    "ResourceMetric": 0.0001589547,
    "design_id": "project",
    "algo_name": "pid_control",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "pid_control.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define N 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid pid_control(fixed_point_t setpoint[N], fixed_point_t measured_value[N], fixed_point_t Kp, fixed_point_t Ki, fixed_point_t Kd, fixed_point_t output[N]) {\n    fixed_point_t integral = 0;\n    fixed_point_t previous_error = 0;\n\n    for (int i = 0; i < N; i++) {\n        fixed_point_t error = setpoint[i] - measured_value[i];\n        integral += error;\n        fixed_point_t derivative = error - previous_error;\n        output[i] = Kp * error + Ki * integral + Kd * derivative;\n        previous_error = error;\n    }\n}\n\n// Top function name: pid_control\n"
      }
    ],
    "code_length": 632,
    "token_count": 169,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/pipeline_5_stage/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5139,
    "Worst-caseLatency": 5139.0,
    "BRAM_18K": 8,
    "LUT": 806,
    "DSP": 0,
    "FF": 140,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pipeline_5_stage",
    "ResourceMetric": 0.0006640178,
    "design_id": "project",
    "algo_name": "pipeline_5_stage",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "pipeline_5_stage.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid stage1(int in[SIZE], int out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        out[i] = in[i] + 1;\n    }\n}\n\nvoid stage2(int in[SIZE], int out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        out[i] = in[i] * 2;\n    }\n}\n\nvoid stage3(int in[SIZE], int out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        out[i] = in[i] - 3;\n    }\n}\n\nvoid stage4(int in[SIZE], int out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        out[i] = in[i] / 4;\n    }\n}\n\nvoid stage5(int in[SIZE], int out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        out[i] = in[i] + 5;\n    }\n}\n\nvoid pipeline_5_stage(int in[SIZE], int out[SIZE]) {\n    int stage1_out[SIZE];\n    int stage2_out[SIZE];\n    int stage3_out[SIZE];\n    int stage4_out[SIZE];\n\n    stage1(in, stage1_out);\n    stage2(stage1_out, stage2_out);\n    stage3(stage2_out, stage3_out);\n    stage4(stage3_out, stage4_out);\n    stage5(stage4_out, out);\n}\n\n// Top function name: pipeline_5_stage\n"
      }
    ],
    "code_length": 990,
    "token_count": 347,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/pipelined_loop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 405,
    "Worst-caseLatency": 405.0,
    "BRAM_18K": 0,
    "LUT": 165,
    "DSP": 1,
    "FF": 68,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "loop_pipeline",
    "ResourceMetric": 6.58651e-05,
    "design_id": "project",
    "algo_name": "pipelined_loop",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _LOOP_PIPELINE_H_\n#define _LOOP_PIPELINE_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 20\n#define NUM_TRANS 20\n\ntypedef ap_int<5> din_t;\ntypedef ap_int<20> dout_t;\n\ndout_t loop_pipeline(din_t A[N]);\n\n#endif\n\ndout_t loop_pipeline(din_t A[N]) {\n\n    int i, j;\n    static dout_t acc;\n\nLOOP_I:\n    for (i = 0; i < 20; i++) {\n    LOOP_J:\n        for (j = 0; j < 20; j++) {\n            acc += A[j] * i;\n        }\n    }\n\n    return acc;\n}\n"
      }
    ],
    "code_length": 1877,
    "token_count": 467,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/piso_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 15,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "piso_shift_register",
    "ResourceMetric": 2.80936e-05,
    "design_id": "project",
    "algo_name": "piso_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "piso_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_WIDTH 32\n#define ARRAY_SIZE 1024\n\nvoid piso_shift_register(ap_uint<DATA_WIDTH> parallel_in[ARRAY_SIZE], ap_uint<1> &serial_out) {\n    static ap_uint<DATA_WIDTH> shift_register = 0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        shift_register = parallel_in[i];\n        for (int j = 0; j < DATA_WIDTH; j++) {\n            serial_out = shift_register[DATA_WIDTH - 1];\n            shift_register = shift_register << 1;\n        }\n    }\n}\n\n// Top function name: piso_shift_register\n"
      }
    ],
    "code_length": 515,
    "token_count": 140,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/piso_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 165,
    "DSP": 0,
    "FF": 32,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "piso_shift_register",
    "ResourceMetric": 3.47094e-05,
    "design_id": "project",
    "algo_name": "piso_shift_register",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "piso_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid piso_shift_register(ap_uint<1> parallel_in[SIZE], ap_uint<1> &serial_out) {\n    static ap_uint<1> shift_reg[SIZE];\n    int i;\n\n    // Load parallel input into shift register\n    for (i = 0; i < SIZE; i++) {\n        shift_reg[i] = parallel_in[i];\n    }\n\n    // Shift out the bits serially\n    for (i = 0; i < SIZE; i++) {\n        serial_out = shift_reg[i];\n    }\n}\n\n// Top function name: piso_shift_register\n"
      }
    ],
    "code_length": 452,
    "token_count": 134,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/hls_algorithms/pitch_detection/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 13332,
    "Worst-caseLatency": 2108436.0,
    "BRAM_18K": 2,
    "LUT": 1152,
    "DSP": 5,
    "FF": 809,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pitch_detection",
    "ResourceMetric": 0.0005610094,
    "design_id": "project",
    "algo_name": "pitch_detection",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "pitch_detection.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid pitch_detection(float signal[N], float pitch[N]) {\n    float autocorrelation[N] = {0};\n\n    // Compute autocorrelation\n    for (int lag = 0; lag < N; lag++) {\n        float sum = 0;\n        for (int i = 0; i < N - lag; i++) {\n            sum += signal[i] * signal[i + lag];\n        }\n        autocorrelation[lag] = sum;\n    }\n\n    // Find the peak in the autocorrelation\n    int peak_index = 0;\n    float peak_value = 0;\n    for (int i = 1; i < N; i++) {\n        if (autocorrelation[i] > peak_value) {\n            peak_value = autocorrelation[i];\n            peak_index = i;\n        }\n    }\n\n    // Calculate pitch\n    for (int i = 0; i < N; i++) {\n        pitch[i] = (peak_index != 0) ? (44100.0f / peak_index) : 0;\n    }\n}\n\n// Top function name: pitch_detection\n"
      }
    ],
    "code_length": 822,
    "token_count": 246,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/pll/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4129,
    "Worst-caseLatency": 4129.0,
    "BRAM_18K": 4,
    "LUT": 8231,
    "DSP": 105,
    "FF": 3846,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pll",
    "ResourceMetric": 0.0051041057,
    "design_id": "project",
    "algo_name": "pll",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "pll.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid pll(float input_signal[N], float output_signal[N], float ref_frequency, float loop_bandwidth, float damping_factor) {\n    float phase_error[N] = {0};\n    float vco_phase[N] = {0};\n    float vco_frequency[N] = {0};\n    float integrator[N] = {0};\n    float proportional_gain = 2.0f * damping_factor * loop_bandwidth;\n    float integrator_gain = loop_bandwidth * loop_bandwidth;\n\n    for (int i = 0; i < N; i++) {\n        // Phase detector\n        phase_error[i] = input_signal[i] - vco_phase[i];\n\n        // Loop filter\n        integrator[i] = integrator[i] + integrator_gain * phase_error[i];\n        float control_signal = proportional_gain * phase_error[i] + integrator[i];\n\n        // Voltage Controlled Oscillator (VCO)\n        vco_frequency[i] = ref_frequency + control_signal;\n        if (i > 0) {\n            vco_phase[i] = vco_phase[i-1] + vco_frequency[i];\n        } else {\n            vco_phase[i] = vco_frequency[i];\n        }\n\n        // Output signal\n        output_signal[i] = sin(vco_phase[i]);\n    }\n}\n\n// Top function name: pll\n"
      }
    ],
    "code_length": 1102,
    "token_count": 289,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/pll_2x/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pll_2x",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "pll_2x",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "pll_2x.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid pll_2x(ap_int<16> input[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] * 2;\n    }\n}\n\n// Top function name: pll_2x\n"
      }
    ],
    "code_length": 212,
    "token_count": 77,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/pll_8x/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pll_8x",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "pll_8x",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "pll_8x.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid pll_8x(int input[SIZE], int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] * 8;\n    }\n}\n\n// Top function name: pll_8x\n"
      }
    ],
    "code_length": 198,
    "token_count": 67,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/pll_clock/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1093,
    "Worst-caseLatency": 1093.0,
    "BRAM_18K": 0,
    "LUT": 6736,
    "DSP": 4,
    "FF": 8938,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pll_clock",
    "ResourceMetric": 0.0022595408,
    "design_id": "project",
    "algo_name": "pll_clock",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "pll_clock.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid pll_clock(ap_uint<32> input_signal[ARRAY_SIZE], ap_uint<32> output_signal[ARRAY_SIZE], ap_uint<32> multiplier, ap_uint<32> divider) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<64> temp = input_signal[i];\n        temp = (temp * multiplier) / divider;\n        output_signal[i] = temp;\n    }\n}\n\n// Top function name: pll_clock\n"
      }
    ],
    "code_length": 392,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/pneumatic_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6145,
    "Worst-caseLatency": 1053697.0,
    "BRAM_18K": 0,
    "LUT": 205,
    "DSP": 0,
    "FF": 79,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pneumatic_counter",
    "ResourceMetric": 4.68865e-05,
    "design_id": "project",
    "algo_name": "pneumatic_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "pneumatic_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid pneumatic_counter(ap_int<16> input_array[ARRAY_SIZE], ap_int<16> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> count = 0;\n        for (int j = 0; j <= i; j++) {\n            count += input_array[j];\n        }\n        output_array[i] = count;\n    }\n}\n\n// Top function name: pneumatic_counter\n"
      }
    ],
    "code_length": 385,
    "token_count": 113,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/png_compression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2095108,
    "Worst-caseLatency": 2095108.0,
    "BRAM_18K": 0,
    "LUT": 758,
    "DSP": 0,
    "FF": 172,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "png_compression",
    "ResourceMetric": 0.0001618495,
    "design_id": "project",
    "algo_name": "png_compression",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "png_compression.cpp",
        "file_content": "#include <cstdint>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n#define MAX_COLOR_VALUE 255\n\nvoid png_compression(uint8_t input_image[IMG_HEIGHT][IMG_WIDTH], uint8_t compressed_image[IMG_HEIGHT][IMG_WIDTH]) {\n    // Simple RLE (Run-Length Encoding) compression for demonstration\n    for (int i = 0; i < IMG_HEIGHT; i++) {\n        int run_length = 1;\n        uint8_t current_pixel = input_image[i][0];\n        int compressed_index = 0;\n\n        for (int j = 1; j < IMG_WIDTH; j++) {\n            if (input_image[i][j] == current_pixel && run_length < MAX_COLOR_VALUE) {\n                run_length++;\n            } else {\n                compressed_image[i][compressed_index++] = current_pixel;\n                compressed_image[i][compressed_index++] = run_length;\n                current_pixel = input_image[i][j];\n                run_length = 1;\n            }\n        }\n        compressed_image[i][compressed_index++] = current_pixel;\n        compressed_image[i][compressed_index++] = run_length;\n    }\n}\n\n// Top function name: png_compression\n"
      }
    ],
    "code_length": 1046,
    "token_count": 241,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/policy_gradient_methods/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3093,
    "Worst-caseLatency": 3093.0,
    "BRAM_18K": 4,
    "LUT": 850,
    "DSP": 5,
    "FF": 729,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "policy_gradient_methods",
    "ResourceMetric": 0.0006194338,
    "design_id": "project",
    "algo_name": "policy_gradient_methods",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "policy_gradient_methods.cpp",
        "file_content": "#include <cmath>\n#include <iostream>\n\n#define N 1024\n\nvoid policy_gradient_methods(float state[N], float action[N], float reward[N], float policy[N], float learning_rate) {\n    float gradient[N];\n    float policy_update[N];\n\n    // Compute the gradient\n    for (int i = 0; i < N; i++) {\n        gradient[i] = reward[i] * (action[i] - policy[i]);\n    }\n\n    // Update the policy\n    for (int i = 0; i < N; i++) {\n        policy_update[i] = policy[i] + learning_rate * gradient[i];\n    }\n\n    // Apply the updated policy\n    for (int i = 0; i < N; i++) {\n        policy[i] = policy_update[i];\n    }\n}\n\n// Top function name: policy_gradient_methods\n"
      }
    ],
    "code_length": 646,
    "token_count": 175,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/polynomial_evaluation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": null,
    "BRAM_18K": 0,
    "LUT": 1120,
    "DSP": 11,
    "FF": 1083,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "polynomial_evaluation",
    "ResourceMetric": 0.0006233602,
    "design_id": "project",
    "algo_name": "polynomial_evaluation",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "polynomial_evaluation.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid polynomial_evaluation(int degree, double coefficients[ARRAY_SIZE], double x, double &result) {\n    result = 0.0;\n    double x_power = 1.0;\n    for (int i = 0; i <= degree; i++) {\n        result += coefficients[i] * x_power;\n        x_power *= x;\n    }\n}\n\n// Top function name: polynomial_evaluation\n"
      }
    ],
    "code_length": 350,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/polynomial_regression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3244,
    "Worst-caseLatency": 3244.0,
    "BRAM_18K": 0,
    "LUT": 5881,
    "DSP": 44,
    "FF": 6080,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "polynomial_regression",
    "ResourceMetric": 0.0029297059,
    "design_id": "project",
    "algo_name": "polynomial_regression",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "polynomial_regression.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid polynomial_regression(double x[N], double y[N], double coeffs[3]) {\n    double X[5] = {0, 0, 0, 0, 0};\n    double Y[3] = {0, 0, 0};\n    double B[3][3] = {0};\n    double A[3][3] = {0};\n\n    for (int i = 0; i < N; i++) {\n        double xi = x[i];\n        double yi = y[i];\n        double xi2 = xi * xi;\n        double xi3 = xi2 * xi;\n        double xi4 = xi3 * xi;\n\n        X[0] += 1;\n        X[1] += xi;\n        X[2] += xi2;\n        X[3] += xi3;\n        X[4] += xi4;\n\n        Y[0] += yi;\n        Y[1] += xi * yi;\n        Y[2] += xi2 * yi;\n    }\n\n    A[0][0] = X[0];\n    A[0][1] = X[1];\n    A[0][2] = X[2];\n    A[1][0] = X[1];\n    A[1][1] = X[2];\n    A[1][2] = X[3];\n    A[2][0] = X[2];\n    A[2][1] = X[3];\n    A[2][2] = X[4];\n\n    B[0][0] = Y[0];\n    B[1][0] = Y[1];\n    B[2][0] = Y[2];\n\n    for (int i = 0; i < 3; i++) {\n        double pivot = A[i][i];\n        for (int j = 0; j < 3; j++) {\n            A[i][j] /= pivot;\n        }\n        B[i][0] /= pivot;\n\n        for (int k = 0; k < 3; k++) {\n            if (k != i) {\n                double factor = A[k][i];\n                for (int j = 0; j < 3; j++) {\n                    A[k][j] -= factor * A[i][j];\n                }\n                B[k][0] -= factor * B[i][0];\n            }\n        }\n    }\n\n    for (int i = 0; i < 3; i++) {\n        coeffs[i] = B[i][0];\n    }\n}\n\n// Top function name: polynomial_regression\n"
      }
    ],
    "code_length": 1407,
    "token_count": 555,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/pooling_layer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 517,
    "Worst-caseLatency": 517.0,
    "BRAM_18K": 0,
    "LUT": 610,
    "DSP": 0,
    "FF": 311,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pooling_layer",
    "ResourceMetric": 0.000146796,
    "design_id": "project",
    "algo_name": "pooling_layer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "pooling_layer.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 256\n#define POOL_SIZE 4\n\nvoid pooling_layer(float input[INPUT_SIZE], float output[OUTPUT_SIZE]) {\n    int output_index = 0;\n    for (int i = 0; i < INPUT_SIZE; i += POOL_SIZE) {\n        float max_val = input[i];\n        for (int j = 1; j < POOL_SIZE; ++j) {\n            if (input[i + j] > max_val) {\n                max_val = input[i + j];\n            }\n        }\n        output[output_index++] = max_val;\n    }\n}\n\n// Top function name: pooling_layer\n"
      }
    ],
    "code_length": 533,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/port_multiplier_chip/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "port_multiplier_chip",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "port_multiplier_chip",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "port_multiplier_chip.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid port_multiplier_chip(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<32> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input1[i] * input2[i];\n    }\n}\n\n// Top function name: port_multiplier_chip\n"
      }
    ],
    "code_length": 305,
    "token_count": 93,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/portfolio_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 16784423065.0,
    "BRAM_18K": 0,
    "LUT": 2295,
    "DSP": 11,
    "FF": 1962,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "portfolio_optimization",
    "ResourceMetric": 0.0009329646,
    "design_id": "project",
    "algo_name": "portfolio_optimization",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "portfolio_optimization.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid portfolio_optimization(double returns[N], double cov_matrix[N][N], double weights[N], double risk_free_rate, double target_return, double optimized_weights[N]) {\n    double sum_weights = 0.0;\n    double portfolio_return = 0.0;\n    double portfolio_variance = 0.0;\n\n    // Initialize weights\n    for (int i = 0; i < N; i++) {\n        weights[i] = 1.0 / N;\n    }\n\n    // Calculate initial portfolio return and variance\n    for (int i = 0; i < N; i++) {\n        portfolio_return += weights[i] * returns[i];\n        for (int j = 0; j < N; j++) {\n            portfolio_variance += weights[i] * weights[j] * cov_matrix[i][j];\n        }\n    }\n\n    // Optimization loop (simplified for demonstration purposes)\n    for (int iter = 0; iter < 1000; iter++) {\n        for (int i = 0; i < N; i++) {\n            double gradient = returns[i] - risk_free_rate;\n            for (int j = 0; j < N; j++) {\n                gradient -= cov_matrix[i][j] * weights[j];\n            }\n            weights[i] += 0.01 * gradient;\n        }\n\n        // Normalize weights to sum to 1\n        sum_weights = 0.0;\n        for (int i = 0; i < N; i++) {\n            sum_weights += weights[i];\n        }\n        for (int i = 0; i < N; i++) {\n            weights[i] /= sum_weights;\n        }\n\n        // Calculate portfolio return and variance\n        portfolio_return = 0.0;\n        portfolio_variance = 0.0;\n        for (int i = 0; i < N; i++) {\n            portfolio_return += weights[i] * returns[i];\n            for (int j = 0; j < N; j++) {\n                portfolio_variance += weights[i] * weights[j] * cov_matrix[i][j];\n            }\n        }\n\n        // Check if target return is met\n        if (portfolio_return >= target_return) {\n            break;\n        }\n    }\n\n    // Copy optimized weights to output\n    for (int i = 0; i < N; i++) {\n        optimized_weights[i] = weights[i];\n    }\n}\n\n// Top function name: portfolio_optimization\n"
      }
    ],
    "code_length": 1954,
    "token_count": 517,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/power_gating/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 148,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "power_gating",
    "ResourceMetric": 3.38465e-05,
    "design_id": "project",
    "algo_name": "power_gating",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "power_gating.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid power_gating(int input[ARRAY_SIZE], int output[ARRAY_SIZE], int threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] > threshold) {\n            output[i] = input[i];\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: power_gating\n"
      }
    ],
    "code_length": 339,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/power_transformation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1047,
    "Worst-caseLatency": 1047.0,
    "BRAM_18K": 5,
    "LUT": 11513,
    "DSP": 78,
    "FF": 4846,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "power_transformation",
    "ResourceMetric": 0.005143359,
    "design_id": "project",
    "algo_name": "power_transformation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "power_transformation.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid power_transformation(float input[SIZE], float output[SIZE], float exponent) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = pow(input[i], exponent);\n    }\n}\n\n// Top function name: power_transformation\n"
      }
    ],
    "code_length": 254,
    "token_count": 67,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/precision/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1034,
    "Worst-caseLatency": 1034.0,
    "BRAM_18K": 0,
    "LUT": 2813,
    "DSP": 18,
    "FF": 1154,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "precision",
    "ResourceMetric": 0.0011487531,
    "design_id": "project",
    "algo_name": "precision",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "precision.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid precision(float input[SIZE], float output[SIZE], float factor) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] * factor + std::sin(input[i]);\n    }\n}\n\n// Top function name: precision\n"
      }
    ],
    "code_length": 245,
    "token_count": 69,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/predetermining_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 196,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "predetermining_counter",
    "ResourceMetric": 4.30512e-05,
    "design_id": "project",
    "algo_name": "predetermining_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "predetermining_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid predetermining_counter(ap_int<32> input_array[ARRAY_SIZE], ap_int<32> output_array[ARRAY_SIZE]) {\n    ap_int<32> counter = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_array[i] > 0) {\n            counter++;\n        }\n        output_array[i] = counter;\n    }\n}\n\n// Top function name: predetermining_counter\n"
      }
    ],
    "code_length": 376,
    "token_count": 107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/primMST/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2107386,
    "Worst-caseLatency": 2107386.0,
    "BRAM_18K": 2,
    "LUT": 860,
    "DSP": 0,
    "FF": 273,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "primMST",
    "ResourceMetric": 0.0003151016,
    "design_id": "project",
    "algo_name": "primMST",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "primMST.cpp",
        "file_content": "#include <limits.h>\n\n#define V 1024\n\nvoid primMST(int graph[V][V], int parent[V]) {\n    int key[V];\n    bool mstSet[V];\n\n    for (int i = 0; i < V; i++) {\n        key[i] = INT_MAX;\n        mstSet[i] = false;\n    }\n\n    key[0] = 0;\n    parent[0] = -1;\n\n    for (int count = 0; count < V - 1; count++) {\n        int min = INT_MAX, min_index;\n\n        for (int v = 0; v < V; v++) {\n            if (mstSet[v] == false && key[v] < min) {\n                min = key[v];\n                min_index = v;\n            }\n        }\n\n        int u = min_index;\n        mstSet[u] = true;\n\n        for (int v = 0; v < V; v++) {\n            if (graph[u][v] && mstSet[v] == false && graph[u][v] < key[v]) {\n                parent[v] = u;\n                key[v] = graph[u][v];\n            }\n        }\n    }\n}\n\n// Top function name: primMST\n"
      }
    ],
    "code_length": 820,
    "token_count": 262,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/priority_encoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 291,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "priority_encoder",
    "ResourceMetric": 5.82965e-05,
    "design_id": "project",
    "algo_name": "priority_encoder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "priority_encoder.cpp",
        "file_content": "#include <cstdint>\n\n#define INPUT_SIZE 1024\n\nvoid priority_encoder(uint32_t input[INPUT_SIZE], uint32_t output[INPUT_SIZE]) {\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        uint32_t in_val = input[i];\n        uint32_t out_val = 0;\n        for (int j = 0; j < 32; j++) {\n            if (in_val & (1 << j)) {\n                out_val = j;\n                break;\n            }\n        }\n        output[i] = out_val;\n    }\n}\n\n// Top function name: priority_encoder\n"
      }
    ],
    "code_length": 464,
    "token_count": 129,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/privacy_preserving_ml/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 3,
    "LUT": 304,
    "DSP": 2,
    "FF": 56,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "privacy_preserving_ml",
    "ResourceMetric": 0.0003050856,
    "design_id": "project",
    "algo_name": "privacy_preserving_ml",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "privacy_preserving_ml.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid privacy_preserving_ml(ap_uint<32> input_data[DATA_SIZE], ap_uint<32> output_data[DATA_SIZE]) {\n    ap_uint<32> intermediate_data[DATA_SIZE];\n\n    // Step 1: Data Transformation\n    for (int i = 0; i < DATA_SIZE; i++) {\n        intermediate_data[i] = input_data[i] ^ 0x5A5A5A5A; // Simple XOR transformation for privacy\n    }\n\n    // Step 2: Simple Machine Learning Inference (e.g., Linear Transformation)\n    ap_uint<32> weights[DATA_SIZE];\n    ap_uint<32> bias = 0x12345678;\n\n    // Initialize weights (for demonstration purposes, using a fixed pattern)\n    for (int i = 0; i < DATA_SIZE; i++) {\n        weights[i] = i;\n    }\n\n    // Perform the inference\n    for (int i = 0; i < DATA_SIZE; i++) {\n        output_data[i] = intermediate_data[i] * weights[i] + bias;\n    }\n}\n\n// Top function name: privacy_preserving_ml\n"
      }
    ],
    "code_length": 869,
    "token_count": 248,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/product_of_array_except_self/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3082,
    "Worst-caseLatency": 3082.0,
    "BRAM_18K": 4,
    "LUT": 646,
    "DSP": 9,
    "FF": 215,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "product_of_array_except_self",
    "ResourceMetric": 0.0006418458,
    "design_id": "project",
    "algo_name": "product_of_array_except_self",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "product_of_array_except_self.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid product_of_array_except_self(int input[ARRAY_SIZE], int output[ARRAY_SIZE]) {\n    int left_products[ARRAY_SIZE];\n    int right_products[ARRAY_SIZE];\n\n    left_products[0] = 1;\n    for (int i = 1; i < ARRAY_SIZE; i++) {\n        left_products[i] = left_products[i - 1] * input[i - 1];\n    }\n\n    right_products[ARRAY_SIZE - 1] = 1;\n    for (int i = ARRAY_SIZE - 2; i >= 0; i--) {\n        right_products[i] = right_products[i + 1] * input[i + 1];\n    }\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = left_products[i] * right_products[i];\n    }\n}\n\n// Top function name: product_of_array_except_self\n"
      }
    ],
    "code_length": 663,
    "token_count": 196,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/programmable_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 123,
    "DSP": 2,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "programmable_counter",
    "ResourceMetric": 8.02413e-05,
    "design_id": "project",
    "algo_name": "programmable_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "programmable_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid programmable_counter(ap_uint<32> start_value, ap_uint<32> step, ap_uint<32> count, ap_uint<32> result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        result[i] = start_value + i * step;\n    }\n}\n\n// Top function name: programmable_counter\n"
      }
    ],
    "code_length": 289,
    "token_count": 88,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/programmable_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1061,
    "Worst-caseLatency": 1061.0,
    "BRAM_18K": 0,
    "LUT": 3740,
    "DSP": 0,
    "FF": 6080,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "programmable_divider",
    "ResourceMetric": 0.0013001657,
    "design_id": "project",
    "algo_name": "programmable_divider",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "programmable_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid programmable_divider(ap_int<32> dividend[ARRAY_SIZE], ap_int<32> divisor[ARRAY_SIZE], ap_int<32> quotient[ARRAY_SIZE], ap_int<32> remainder[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (divisor[i] != 0) {\n            quotient[i] = dividend[i] / divisor[i];\n            remainder[i] = dividend[i] % divisor[i];\n        } else {\n            quotient[i] = 0;\n            remainder[i] = dividend[i];\n        }\n    }\n}\n\n// Top function name: programmable_divider\n"
      }
    ],
    "code_length": 533,
    "token_count": 147,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/proximal_gradient_method/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2149582884,
    "Worst-caseLatency": 2149582884.0,
    "BRAM_18K": 4,
    "LUT": 2749,
    "DSP": 9,
    "FF": 2214,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "proximal_gradient_method",
    "ResourceMetric": 0.0012367962,
    "design_id": "project",
    "algo_name": "proximal_gradient_method",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "proximal_gradient_method.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid proximal_gradient_method(float alpha, float beta, float gamma, float x[N], float y[N], float A[N][N], float B[N][N], float C[N][N]) {\n    float grad[N];\n    float prox[N];\n    \n    // Compute gradient\n    for (int i = 0; i < N; i++) {\n        grad[i] = 0.0;\n        for (int j = 0; j < N; j++) {\n            grad[i] += A[i][j] * x[j];\n        }\n        grad[i] += beta * (x[i] - y[i]);\n    }\n    \n    // Proximal operator\n    for (int i = 0; i < N; i++) {\n        prox[i] = x[i] - alpha * grad[i];\n        if (prox[i] > gamma) {\n            prox[i] -= gamma;\n        } else if (prox[i] < -gamma) {\n            prox[i] += gamma;\n        } else {\n            prox[i] = 0.0;\n        }\n    }\n    \n    // Update x\n    for (int i = 0; i < N; i++) {\n        x[i] = prox[i];\n    }\n    \n    // Compute output matrix C\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            C[i][j] = 0.0;\n            for (int k = 0; k < N; k++) {\n                C[i][j] += B[i][k] * x[k];\n            }\n        }\n    }\n}\n\n// Top function name: proximal_gradient_method\n"
      }
    ],
    "code_length": 1112,
    "token_count": 368,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/pruning_aware_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 380,
    "DSP": 3,
    "FF": 483,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pruning_aware_training",
    "ResourceMetric": 0.0002022936,
    "design_id": "project",
    "algo_name": "pruning_aware_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "pruning_aware_training.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid pruning_aware_training(float input[ARRAY_SIZE], float weights[ARRAY_SIZE], float output[ARRAY_SIZE], float threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (std::abs(weights[i]) > threshold) {\n            output[i] = input[i] * weights[i];\n        } else {\n            output[i] = 0.0f;\n        }\n    }\n}\n\n// Top function name: pruning_aware_training\n"
      }
    ],
    "code_length": 417,
    "token_count": 110,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_ip/public_key_acceleration/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 524291,
    "Worst-caseLatency": 524291.0,
    "BRAM_18K": 0,
    "LUT": 3351,
    "DSP": 0,
    "FF": 581,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "public_key_acceleration",
    "ResourceMetric": 0.0006983117,
    "design_id": "project",
    "algo_name": "public_key_acceleration",
    "source_name": "rtl_ip",
    "source_code": [
      {
        "file_name": "public_key_acceleration.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid public_key_acceleration(ap_uint<512> input[SIZE], ap_uint<512> output[SIZE], ap_uint<512> key) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_uint<512> temp = input[i];\n        for (int j = 0; j < 512; j++) {\n            if (key[j] == 1) {\n                temp ^= (ap_uint<512>(1) << j);\n            }\n        }\n        output[i] = temp;\n    }\n}\n\n// Top function name: public_key_acceleration\n"
      }
    ],
    "code_length": 441,
    "token_count": 136,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/pulse_generator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1039,
    "Worst-caseLatency": 1039.0,
    "BRAM_18K": 0,
    "LUT": 1918,
    "DSP": 0,
    "FF": 2494,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pulse_generator",
    "ResourceMetric": 0.0006069358,
    "design_id": "project",
    "algo_name": "pulse_generator",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "pulse_generator.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid pulse_generator(int threshold, int pulse_width, int output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (i % pulse_width < threshold) {\n            output[i] = 1;\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: pulse_generator\n"
      }
    ],
    "code_length": 321,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/pulse_width_modulator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 0,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pulse_width_modulator",
    "ResourceMetric": 1.69712e-05,
    "design_id": "project",
    "algo_name": "pulse_width_modulator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "pulse_width_modulator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid pulse_width_modulator(ap_uint<10> duty_cycle, ap_uint<1> pwm_signal[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (i < duty_cycle) {\n            pwm_signal[i] = 1;\n        } else {\n            pwm_signal[i] = 0;\n        }\n    }\n}\n\n// Top function name: pulse_width_modulator\n"
      }
    ],
    "code_length": 349,
    "token_count": 101,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/purity_score/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2064,
    "Worst-caseLatency": null,
    "BRAM_18K": 6,
    "LUT": 1338,
    "DSP": 0,
    "FF": 499,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "purity_score",
    "ResourceMetric": 0.0006764505,
    "design_id": "project",
    "algo_name": "purity_score",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "purity_score.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid purity_score(int n, int labels[ARRAY_SIZE], int clusters[ARRAY_SIZE], float &purity) {\n    int cluster_count[ARRAY_SIZE] = {0};\n    int label_count[ARRAY_SIZE] = {0};\n    int max_label_in_cluster[ARRAY_SIZE] = {0};\n\n    for (int i = 0; i < n; i++) {\n        cluster_count[clusters[i]]++;\n        label_count[labels[i]]++;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int cluster_id = clusters[i];\n        int label_id = labels[i];\n        if (label_count[label_id] > max_label_in_cluster[cluster_id]) {\n            max_label_in_cluster[cluster_id] = label_count[label_id];\n        }\n    }\n\n    int sum_max_labels = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum_max_labels += max_label_in_cluster[i];\n    }\n\n    purity = static_cast<float>(sum_max_labels) / n;\n}\n\n// Top function name: purity_score\n"
      }
    ],
    "code_length": 881,
    "token_count": 242,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/pwm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 92,
    "DSP": 0,
    "FF": 33,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pwm",
    "ResourceMetric": 2.08065e-05,
    "design_id": "project",
    "algo_name": "pwm",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "pwm.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid pwm(ap_uint<8> duty_cycle[ARRAY_SIZE], ap_uint<1> pwm_output[ARRAY_SIZE], ap_uint<8> threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (duty_cycle[i] > threshold) {\n            pwm_output[i] = 1;\n        } else {\n            pwm_output[i] = 0;\n        }\n    }\n}\n\n// Top function name: pwm\n"
      }
    ],
    "code_length": 357,
    "token_count": 108,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/pythagoras_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1036,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 489,
    "DSP": 8,
    "FF": 638,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pythagoras_processor",
    "ResourceMetric": 0.0003765772,
    "design_id": "project",
    "algo_name": "pythagoras_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "pythagoras_processor.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid pythagoras_processor(float a[ARRAY_SIZE], float b[ARRAY_SIZE], float c[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        c[i] = std::sqrt(a[i] * a[i] + b[i] * b[i]);\n    }\n}\n\n// Top function name: pythagoras_processor\n"
      }
    ],
    "code_length": 282,
    "token_count": 88,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/q_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 29,
    "Worst-caseLatency": 29.0,
    "BRAM_18K": 0,
    "LUT": 1299,
    "DSP": 11,
    "FF": 1061,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "q_learning",
    "ResourceMetric": 0.0006555767,
    "design_id": "project",
    "algo_name": "q_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "q_learning.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define NUM_STATES 1024\n#define NUM_ACTIONS 4\n#define ALPHA 0.1\n#define GAMMA 0.9\n#define EPSILON 0.1\n\nvoid q_learning(float q_table[NUM_STATES][NUM_ACTIONS], int state, int action, int reward, int next_state) {\n    float max_q_next = -INFINITY;\n    for (int a = 0; a < NUM_ACTIONS; a++) {\n        if (q_table[next_state][a] > max_q_next) {\n            max_q_next = q_table[next_state][a];\n        }\n    }\n    q_table[state][action] = q_table[state][action] + ALPHA * (reward + GAMMA * max_q_next - q_table[state][action]);\n}\n\n// Top function name: q_learning\n"
      }
    ],
    "code_length": 598,
    "token_count": 171,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/qda/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8592105528,
    "Worst-caseLatency": 8592105528.0,
    "BRAM_18K": 4,
    "LUT": 4117,
    "DSP": 76,
    "FF": 4550,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "qda",
    "ResourceMetric": 0.0035792732,
    "design_id": "project",
    "algo_name": "qda",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "qda.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid qda(double X[N][N], double means[2][N], double cov_inv[2][N][N], double priors[2], int labels[N]) {\n    double log_priors[2];\n    double log_dets[2];\n    double quad_forms[2];\n    double diff[N];\n\n    for (int i = 0; i < 2; i++) {\n        log_priors[i] = log(priors[i]);\n        log_dets[i] = 0.0;\n        for (int j = 0; j < N; j++) {\n            log_dets[i] += log(cov_inv[i][j][j]);\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        double max_log_prob = -1e9;\n        int best_class = -1;\n\n        for (int c = 0; c < 2; c++) {\n            for (int j = 0; j < N; j++) {\n                diff[j] = X[i][j] - means[c][j];\n            }\n\n            quad_forms[c] = 0.0;\n            for (int j = 0; j < N; j++) {\n                double sum = 0.0;\n                for (int k = 0; k < N; k++) {\n                    sum += diff[k] * cov_inv[c][k][j];\n                }\n                quad_forms[c] += sum * diff[j];\n            }\n\n            double log_prob = log_priors[c] - 0.5 * log_dets[c] - 0.5 * quad_forms[c];\n            if (log_prob > max_log_prob) {\n                max_log_prob = log_prob;\n                best_class = c;\n            }\n        }\n\n        labels[i] = best_class;\n    }\n}\n\n// Top function name: qda\n"
      }
    ],
    "code_length": 1272,
    "token_count": 400,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/qr_decomposition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5281796,
    "Worst-caseLatency": 4319100932.0,
    "BRAM_18K": 0,
    "LUT": 2479,
    "DSP": 11,
    "FF": 2232,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "qr_decomposition",
    "ResourceMetric": 0.0009941375,
    "design_id": "project",
    "algo_name": "qr_decomposition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "qr_decomposition.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid qr_decomposition(double A[N][N], double Q[N][N], double R[N][N]) {\n    int i, j, k;\n    double norm;\n\n    // Initialize R to zero\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            R[i][j] = 0.0;\n        }\n    }\n\n    // Initialize Q to zero\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < N; j++) {\n            Q[i][j] = 0.0;\n        }\n    }\n\n    // QR Decomposition\n    for (k = 0; k < N; k++) {\n        // Compute the norm of column k\n        norm = 0.0;\n        for (i = 0; i < N; i++) {\n            norm += A[i][k] * A[i][k];\n        }\n        norm = sqrt(norm);\n\n        // Form k-th Householder vector\n        R[k][k] = norm;\n        for (i = 0; i < N; i++) {\n            Q[i][k] = A[i][k] / norm;\n        }\n\n        // Update the remaining columns\n        for (j = k + 1; j < N; j++) {\n            double dot_product = 0.0;\n            for (i = 0; i < N; i++) {\n                dot_product += Q[i][k] * A[i][j];\n            }\n            R[k][j] = dot_product;\n            for (i = 0; i < N; i++) {\n                A[i][j] -= Q[i][k] * dot_product;\n            }\n        }\n    }\n}\n\n// Top function name: qr_decomposition\n"
      }
    ],
    "code_length": 1198,
    "token_count": 399,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/quad_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 194,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "quad_comparator",
    "ResourceMetric": 3.95994e-05,
    "design_id": "project",
    "algo_name": "quad_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "quad_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid quad_comparator(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<16> input3[ARRAY_SIZE], ap_int<16> input4[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> max_val = input1[i];\n        if (input2[i] > max_val) max_val = input2[i];\n        if (input3[i] > max_val) max_val = input3[i];\n        if (input4[i] > max_val) max_val = input4[i];\n        output[i] = max_val;\n    }\n}\n\n// Top function name: quad_comparator\n"
      }
    ],
    "code_length": 545,
    "token_count": 176,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/quad_differential_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 173,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "quad_differential_comparator",
    "ResourceMetric": 3.55724e-05,
    "design_id": "project",
    "algo_name": "quad_differential_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "quad_differential_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid quad_differential_comparator(ap_int<16> input1[SIZE], ap_int<16> input2[SIZE], ap_int<16> input3[SIZE], ap_int<16> input4[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<16> diff1 = input1[i] - input2[i];\n        ap_int<16> diff2 = input3[i] - input4[i];\n        if (diff1 > diff2) {\n            output[i] = 1;\n        } else if (diff1 < diff2) {\n            output[i] = -1;\n        } else {\n            output[i] = 0;\n        }\n    }\n}\n\n// Top function name: quad_differential_comparator\n"
      }
    ],
    "code_length": 572,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/quad_serial_subtractor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 132,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "quad_serial_subtractor",
    "ResourceMetric": 2.771e-05,
    "design_id": "project",
    "algo_name": "quad_serial_subtractor",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "quad_serial_subtractor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid quad_serial_subtractor(ap_int<16> input1[ARRAY_SIZE], ap_int<16> input2[ARRAY_SIZE], ap_int<16> input3[ARRAY_SIZE], ap_int<16> input4[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input1[i] - input2[i] - input3[i] - input4[i];\n    }\n}\n\n// Top function name: quad_serial_subtractor\n"
      }
    ],
    "code_length": 395,
    "token_count": 127,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/quantization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 220,
    "DSP": 1,
    "FF": 191,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "quantization",
    "ResourceMetric": 8.82057e-05,
    "design_id": "project",
    "algo_name": "quantization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "quantization.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid quantization(ap_int<16> input[ARRAY_SIZE], ap_int<8> output[ARRAY_SIZE], ap_int<16> scale, ap_int<8> zero_point) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_int<16> temp = input[i] * scale;\n        temp = temp + zero_point;\n        if (temp > 127) {\n            output[i] = 127;\n        } else if (temp < -128) {\n            output[i] = -128;\n        } else {\n            output[i] = temp;\n        }\n    }\n}\n\n// Top function name: quantization\n"
      }
    ],
    "code_length": 507,
    "token_count": 151,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/quantization_aware_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1059,
    "Worst-caseLatency": 1059.0,
    "BRAM_18K": 0,
    "LUT": 1325,
    "DSP": 4,
    "FF": 1863,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "quantization_aware_training",
    "ResourceMetric": 0.000543533,
    "design_id": "project",
    "algo_name": "quantization_aware_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "quantization_aware_training.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid quantization_aware_training(fixed_point_t input[ARRAY_SIZE], fixed_point_t weights[ARRAY_SIZE], fixed_point_t bias[ARRAY_SIZE], fixed_point_t output[ARRAY_SIZE], fixed_point_t scale, fixed_point_t zero_point) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        fixed_point_t quantized_input = (input[i] - zero_point) * scale;\n        fixed_point_t quantized_weight = (weights[i] - zero_point) * scale;\n        fixed_point_t quantized_bias = (bias[i] - zero_point) * scale;\n        \n        fixed_point_t quantized_output = quantized_input * quantized_weight + quantized_bias;\n        output[i] = quantized_output / scale + zero_point;\n    }\n}\n\n// Top function name: quantization_aware_training\n"
      }
    ],
    "code_length": 788,
    "token_count": 200,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/r_squared/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6181,
    "Worst-caseLatency": 6181.0,
    "BRAM_18K": 0,
    "LUT": 2188,
    "DSP": 14,
    "FF": 1987,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "r_squared",
    "ResourceMetric": 0.0009979545,
    "design_id": "project",
    "algo_name": "r_squared",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "r_squared.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid r_squared(double y_true[N], double y_pred[N], double &r2) {\n    double mean_y_true = 0.0;\n    double ss_tot = 0.0;\n    double ss_res = 0.0;\n\n    // Calculate mean of y_true\n    for (int i = 0; i < N; i++) {\n        mean_y_true += y_true[i];\n    }\n    mean_y_true /= N;\n\n    // Calculate ss_tot and ss_res\n    for (int i = 0; i < N; i++) {\n        double diff_true = y_true[i] - mean_y_true;\n        double diff_pred = y_true[i] - y_pred[i];\n        ss_tot += diff_true * diff_true;\n        ss_res += diff_pred * diff_pred;\n    }\n\n    // Calculate R-squared\n    r2 = 1.0 - (ss_res / ss_tot);\n}\n\n// Top function name: r_squared\n"
      }
    ],
    "code_length": 665,
    "token_count": 209,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/radar_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 412,
    "DSP": 3,
    "FF": 557,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "radar_processor",
    "ResourceMetric": 0.0002155253,
    "design_id": "project",
    "algo_name": "radar_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "radar_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N (1 << 10) // Large scale size\n\nvoid radar_processor(float input_signal[N], float output_signal[N], float threshold) {\n    for (int i = 0; i < N; i++) {\n        float magnitude = std::sqrt(input_signal[i] * input_signal[i]);\n        if (magnitude > threshold) {\n            output_signal[i] = magnitude;\n        } else {\n            output_signal[i] = 0.0f;\n        }\n    }\n}\n\n// Top function name: radar_processor\n"
      }
    ],
    "code_length": 461,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/radio_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3101,
    "Worst-caseLatency": 3101.0,
    "BRAM_18K": 5,
    "LUT": 1528,
    "DSP": 6,
    "FF": 587,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "radio_processor",
    "ResourceMetric": 0.0008255429,
    "design_id": "project",
    "algo_name": "radio_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "radio_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid radio_processor(ap_int<16> input_signal[SIZE], ap_int<16> output_signal[SIZE]) {\n    ap_int<16> filter_coefficients[5] = {1, -1, 2, -2, 1};\n    ap_int<16> temp_signal[SIZE + 4] = {0};\n\n    // Copy input signal to temp_signal with padding\n    for (int i = 0; i < SIZE; i++) {\n        temp_signal[i + 2] = input_signal[i];\n    }\n\n    // Apply filter\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<16> result = 0;\n        for (int j = 0; j < 5; j++) {\n            result += temp_signal[i + j] * filter_coefficients[j];\n        }\n        output_signal[i] = result;\n    }\n}\n\n// Top function name: radio_processor\n"
      }
    ],
    "code_length": 658,
    "token_count": 209,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/ram_uram/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 276,
    "DSP": 0,
    "FF": 6,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "resource_uram",
    "ResourceMetric": 5.35024e-05,
    "design_id": "project",
    "algo_name": "ram_uram",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <fstream>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\n\n#define ADDRBITS 14\n#define NWORDS 1 << ADDRBITS\n\n// Switch between regular and hw data types\n#if 0\ntypedef int data_t;\ntypedef int addr_t;\n#else\n#include \"ap_int.h\"\n#define DATAWIDTH 128\ntypedef ap_uint<DATAWIDTH> data_t;\ntypedef ap_uint<ADDRBITS> addr_t;\n#endif\n\nvoid resource_uram(bool wren, bool rden, addr_t addrW, data_t datain,\n                   addr_t AddrR, data_t* dataout);\n\nvoid resource_uram(bool wren, bool rden, addr_t addrW, data_t datain,\n                   addr_t AddrR, data_t* dataout) {\n\n    static data_t buffer[NWORDS];\n#pragma HLS DEPENDENCE variable = buffer inter WAR false\n#pragma HLS BIND_STORAGE variable = buffer type = ram_2p impl = uram\n\n    if (rden)\n        *dataout = buffer[AddrR];\n\n    if (wren)\n        buffer[addrW] = datain;\n}\n"
      }
    ],
    "code_length": 2236,
    "token_count": 546,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/random_erasing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3145731,
    "Worst-caseLatency": 3145731.0,
    "BRAM_18K": 0,
    "LUT": 619,
    "DSP": 0,
    "FF": 156,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "random_erasing",
    "ResourceMetric": 0.0001336601,
    "design_id": "project",
    "algo_name": "random_erasing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "random_erasing.cpp",
        "file_content": "#include <ap_int.h>\n\n#define IMG_HEIGHT 1024\n#define IMG_WIDTH 1024\n#define CHANNELS 3\n\nvoid random_erasing(ap_uint<8> image[IMG_HEIGHT][IMG_WIDTH][CHANNELS], \n                    ap_uint<8> output[IMG_HEIGHT][IMG_WIDTH][CHANNELS], \n                    int x, int y, int erase_width, int erase_height, ap_uint<8> erase_value) {\n    for (int i = 0; i < IMG_HEIGHT; i++) {\n        for (int j = 0; j < IMG_WIDTH; j++) {\n            for (int c = 0; c < CHANNELS; c++) {\n                if (i >= y && i < y + erase_height && j >= x && j < x + erase_width) {\n                    output[i][j][c] = erase_value;\n                } else {\n                    output[i][j][c] = image[i][j][c];\n                }\n            }\n        }\n    }\n}\n\n// Top function name: random_erasing\n"
      }
    ],
    "code_length": 771,
    "token_count": 216,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/random_search/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5,
    "Worst-caseLatency": 2054.0,
    "BRAM_18K": 0,
    "LUT": 168,
    "DSP": 0,
    "FF": 55,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "random_search",
    "ResourceMetric": 3.749e-05,
    "design_id": "project",
    "algo_name": "random_search",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "random_search.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid random_search(int input_array[ARRAY_SIZE], int target, int &index) {\n    index = -1; // Initialize index to -1 indicating target not found\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_array[i] == target) {\n            index = i;\n            break;\n        }\n    }\n}\n\n// Top function name: random_search\n"
      }
    ],
    "code_length": 370,
    "token_count": 95,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/rbf_network/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5244929,
    "Worst-caseLatency": 5244929.0,
    "BRAM_18K": 0,
    "LUT": 1573,
    "DSP": 12,
    "FF": 867,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rbf_network",
    "ResourceMetric": 0.000717223,
    "design_id": "project",
    "algo_name": "rbf_network",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "rbf_network.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define D 10\n#define M 128\n\nvoid rbf_network(float input[N][D], float centers[M][D], float weights[M], float output[N]) {\n    float gamma = 1.0f;\n    for (int i = 0; i < N; i++) {\n        float sum = 0.0f;\n        for (int j = 0; j < M; j++) {\n            float dist = 0.0f;\n            for (int k = 0; k < D; k++) {\n                float diff = input[i][k] - centers[j][k];\n                dist += diff * diff;\n            }\n            float rbf = expf(-gamma * dist);\n            sum += weights[j] * rbf;\n        }\n        output[i] = sum;\n    }\n}\n\n// Top function name: rbf_network\n"
      }
    ],
    "code_length": 619,
    "token_count": 190,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/rc_oscillator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3075,
    "Worst-caseLatency": 3075.0,
    "BRAM_18K": 0,
    "LUT": 138,
    "DSP": 2,
    "FF": 104,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rc_oscillator",
    "ResourceMetric": 9.18431e-05,
    "design_id": "project",
    "algo_name": "rc_oscillator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "rc_oscillator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid rc_oscillator(ap_int<16> input_signal[N], ap_int<16> output_signal[N], ap_int<16> R, ap_int<16> C) {\n    ap_int<16> Vout = 0;\n    for (int i = 0; i < N; i++) {\n        ap_int<16> Vin = input_signal[i];\n        Vout = (Vin - Vout) * R * C + Vout;\n        output_signal[i] = Vout;\n    }\n}\n\n// Top function name: rc_oscillator\n"
      }
    ],
    "code_length": 366,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/rds_rbds_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3146767,
    "Worst-caseLatency": 3146767.0,
    "BRAM_18K": 128,
    "LUT": 1158,
    "DSP": 0,
    "FF": 237,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rds_rbds_processor",
    "ResourceMetric": 0.0081812958,
    "design_id": "project",
    "algo_name": "rds_rbds_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "rds_rbds_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define BLOCK_SIZE 1024\n\nvoid rds_rbds_processor(ap_uint<16> input[BLOCK_SIZE], ap_uint<16> output[BLOCK_SIZE]) {\n    ap_uint<16> syndrome[BLOCK_SIZE];\n    ap_uint<16> corrected[BLOCK_SIZE];\n    ap_uint<16> parity_check_matrix[BLOCK_SIZE][BLOCK_SIZE];\n    ap_uint<16> generator_matrix[BLOCK_SIZE][BLOCK_SIZE];\n\n    // Initialize parity check and generator matrices\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        for (int j = 0; j < BLOCK_SIZE; j++) {\n            parity_check_matrix[i][j] = (i == j) ? 1 : 0;\n            generator_matrix[i][j] = (i == j) ? 1 : 0;\n        }\n    }\n\n    // Syndrome calculation\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        syndrome[i] = 0;\n        for (int j = 0; j < BLOCK_SIZE; j++) {\n            syndrome[i] ^= input[j] & parity_check_matrix[i][j];\n        }\n    }\n\n    // Error correction (simple example, not a real error correction)\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        corrected[i] = input[i] ^ syndrome[i];\n    }\n\n    // Output generation\n    for (int i = 0; i < BLOCK_SIZE; i++) {\n        output[i] = 0;\n        for (int j = 0; j < BLOCK_SIZE; j++) {\n            output[i] ^= corrected[j] & generator_matrix[i][j];\n        }\n    }\n}\n\n// Top function name: rds_rbds_processor\n"
      }
    ],
    "code_length": 1260,
    "token_count": 371,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/recall/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 324,
    "DSP": 0,
    "FF": 78,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "recall",
    "ResourceMetric": 6.96106e-05,
    "design_id": "project",
    "algo_name": "recall",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "recall.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid recall(ap_int<16> actual[N], ap_int<16> predicted[N], ap_int<16> &true_positive, ap_int<16> &false_negative) {\n    true_positive = 0;\n    false_negative = 0;\n\n    for (int i = 0; i < N; i++) {\n        if (actual[i] == 1 && predicted[i] == 1) {\n            true_positive++;\n        } else if (actual[i] == 1 && predicted[i] == 0) {\n            false_negative++;\n        }\n    }\n}\n// Top function name: recall\n"
      }
    ],
    "code_length": 450,
    "token_count": 137,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/reinforcement_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 55398401,
    "Worst-caseLatency": 55398401.0,
    "BRAM_18K": 0,
    "LUT": 1303,
    "DSP": 5,
    "FF": 1077,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "reinforcement_learning",
    "ResourceMetric": 0.0004916545,
    "design_id": "project",
    "algo_name": "reinforcement_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "reinforcement_learning.cpp",
        "file_content": "#include <iostream>\n\n#define STATE_SIZE 1024\n#define ACTION_SIZE 256\n#define EPISODES 100\n\nvoid reinforcement_learning(float state[STATE_SIZE], float q_table[STATE_SIZE][ACTION_SIZE], float rewards[STATE_SIZE], float learning_rate, float discount_factor) {\n    for (int episode = 0; episode < EPISODES; episode++) {\n        for (int s = 0; s < STATE_SIZE; s++) {\n            int action = 0;\n            float max_q = q_table[s][0];\n            for (int a = 1; a < ACTION_SIZE; a++) {\n                if (q_table[s][a] > max_q) {\n                    max_q = q_table[s][a];\n                    action = a;\n                }\n            }\n            \n            int next_state = (s + action) % STATE_SIZE;\n            float reward = rewards[next_state];\n            \n            float max_next_q = q_table[next_state][0];\n            for (int a = 1; a < ACTION_SIZE; a++) {\n                if (q_table[next_state][a] > max_next_q) {\n                    max_next_q = q_table[next_state][a];\n                }\n            }\n            \n            q_table[s][action] = q_table[s][action] + learning_rate * (reward + discount_factor * max_next_q - q_table[s][action]);\n        }\n    }\n}\n\n// Top function name: reinforcement_learning\n"
      }
    ],
    "code_length": 1230,
    "token_count": 295,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/relative_position_representations/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 320,
    "DSP": 0,
    "FF": 75,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "relative_position_representations",
    "ResourceMetric": 6.85559e-05,
    "design_id": "project",
    "algo_name": "relative_position_representations",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "relative_position_representations.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid relative_position_representations(ap_int<16> input[SIZE], ap_int<16> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        ap_int<16> sum = 0;\n        for (int j = 0; j < SIZE; j++) {\n            if (i != j) {\n                sum += input[j] - input[i];\n            }\n        }\n        output[i] = sum;\n    }\n}\n\n// Top function name: relative_position_representations\n"
      }
    ],
    "code_length": 420,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/representation_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2101,
    "Worst-caseLatency": 2101.0,
    "BRAM_18K": 11,
    "LUT": 8944,
    "DSP": 55,
    "FF": 8980,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "representation_learning",
    "ResourceMetric": 0.0047819272,
    "design_id": "project",
    "algo_name": "representation_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "representation_learning.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid representation_learning(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float weights[ARRAY_SIZE];\n    float biases[ARRAY_SIZE];\n    float hidden_layer[ARRAY_SIZE];\n\n    // Initialize weights and biases\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        weights[i] = 0.01 * i;\n        biases[i] = 0.1 * i;\n    }\n\n    // Forward pass: input to hidden layer\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        hidden_layer[i] = input[i] * weights[i] + biases[i];\n        hidden_layer[i] = tanh(hidden_layer[i]); // Activation function\n    }\n\n    // Forward pass: hidden layer to output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = hidden_layer[i] * weights[i] + biases[i];\n    }\n}\n\n// Top function name: representation_learning\n"
      }
    ],
    "code_length": 800,
    "token_count": 216,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/reset_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "reset_controller",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "reset_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "reset_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid reset_controller(ap_int<32> input_array[ARRAY_SIZE], ap_int<32> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_array[i] = input_array[i] == 0 ? 1 : 0;\n    }\n}\n\n// Top function name: reset_controller\n"
      }
    ],
    "code_length": 289,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/residual_block/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4128,
    "Worst-caseLatency": 4128.0,
    "BRAM_18K": 2,
    "LUT": 1360,
    "DSP": 5,
    "FF": 1102,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "residual_block",
    "ResourceMetric": 0.0006289901,
    "design_id": "project",
    "algo_name": "residual_block",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "residual_block.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid residual_block(float input[SIZE], float weight1[SIZE], float bias1[SIZE], float weight2[SIZE], float bias2[SIZE], float output[SIZE]) {\n    float intermediate[SIZE];\n\n    // First layer: weight1 * input + bias1\n    for (int i = 0; i < SIZE; i++) {\n        intermediate[i] = weight1[i] * input[i] + bias1[i];\n    }\n\n    // Activation function (ReLU)\n    for (int i = 0; i < SIZE; i++) {\n        intermediate[i] = fmax(0.0f, intermediate[i]);\n    }\n\n    // Second layer: weight2 * intermediate + bias2\n    for (int i = 0; i < SIZE; i++) {\n        intermediate[i] = weight2[i] * intermediate[i] + bias2[i];\n    }\n\n    // Residual connection and output\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = input[i] + intermediate[i];\n    }\n}\n\n// Top function name: residual_block\n"
      }
    ],
    "code_length": 822,
    "token_count": 240,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/restoring_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 175,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "restoring_divider",
    "ResourceMetric": 3.59559e-05,
    "design_id": "project",
    "algo_name": "restoring_divider",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "restoring_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid restoring_divider(ap_uint<32> dividend[N], ap_uint<32> divisor[N], ap_uint<32> quotient[N], ap_uint<32> remainder[N]) {\n    for (int idx = 0; idx < N; idx++) {\n        ap_uint<64> dividend_ext = dividend[idx];\n        ap_uint<32> divisor_ext = divisor[idx];\n        ap_uint<32> quotient_temp = 0;\n        ap_uint<32> remainder_temp = 0;\n\n        for (int i = 31; i >= 0; i--) {\n            remainder_temp = (remainder_temp << 1) | ((dividend_ext >> (31 + i)) & 1);\n            if (remainder_temp >= divisor_ext) {\n                remainder_temp -= divisor_ext;\n                quotient_temp |= (1 << i);\n            }\n        }\n\n        quotient[idx] = quotient_temp;\n        remainder[idx] = remainder_temp;\n    }\n}\n\n// Top function name: restoring_divider\n"
      }
    ],
    "code_length": 800,
    "token_count": 214,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/reversible_jump_mcmc/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1060,
    "Worst-caseLatency": 1060.0,
    "BRAM_18K": 0,
    "LUT": 4862,
    "DSP": 75,
    "FF": 4504,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "reversible_jump_mcmc",
    "ResourceMetric": 0.0034420077,
    "design_id": "project",
    "algo_name": "reversible_jump_mcmc",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "reversible_jump_mcmc.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid reversible_jump_mcmc(double input[N], double output[N], double alpha, double beta, double gamma) {\n    int i;\n    for (i = 0; i < N; i++) {\n        double proposal = input[i] + alpha * (beta - gamma * input[i]);\n        double acceptance_ratio = exp(-0.5 * (proposal * proposal - input[i] * input[i]));\n        if (acceptance_ratio > 1.0) {\n            output[i] = proposal;\n        } else {\n            output[i] = input[i];\n        }\n    }\n}\n\n// Top function name: reversible_jump_mcmc\n"
      }
    ],
    "code_length": 527,
    "token_count": 140,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/rgb_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2097158,
    "Worst-caseLatency": 2097158.0,
    "BRAM_18K": 0,
    "LUT": 530,
    "DSP": 1,
    "FF": 358,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rgb_processor",
    "ResourceMetric": 0.0001636652,
    "design_id": "project",
    "algo_name": "rgb_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "rgb_processor.cpp",
        "file_content": "#include <stdint.h>\n\n#define IMG_SIZE 1024\n\nvoid rgb_processor(uint8_t input_image[IMG_SIZE][IMG_SIZE][3], uint8_t output_image[IMG_SIZE][IMG_SIZE][3]) {\n    for (int i = 0; i < IMG_SIZE; i++) {\n        for (int j = 0; j < IMG_SIZE; j++) {\n            uint8_t r = input_image[i][j][0];\n            uint8_t g = input_image[i][j][1];\n            uint8_t b = input_image[i][j][2];\n\n            // Example processing: convert to grayscale\n            uint8_t gray = (r + g + b) / 3;\n\n            output_image[i][j][0] = gray;\n            output_image[i][j][1] = gray;\n            output_image[i][j][2] = gray;\n        }\n    }\n}\n\n// Top function name: rgb_processor\n"
      }
    ],
    "code_length": 661,
    "token_count": 195,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/rgb_to_yuv/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048593,
    "Worst-caseLatency": 1048593.0,
    "BRAM_18K": 0,
    "LUT": 8171,
    "DSP": 96,
    "FF": 6659,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rgb_to_yuv",
    "ResourceMetric": 0.0048649661,
    "design_id": "project",
    "algo_name": "rgb_to_yuv",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "rgb_to_yuv.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid rgb_to_yuv(ap_uint<8> R[HEIGHT][WIDTH], ap_uint<8> G[HEIGHT][WIDTH], ap_uint<8> B[HEIGHT][WIDTH], ap_uint<8> Y[HEIGHT][WIDTH], ap_uint<8> U[HEIGHT][WIDTH], ap_uint<8> V[HEIGHT][WIDTH]) {\n    for (int i = 0; i < HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            ap_uint<8> r = R[i][j];\n            ap_uint<8> g = G[i][j];\n            ap_uint<8> b = B[i][j];\n\n            ap_uint<8> y = (ap_uint<8>)(0.299 * r + 0.587 * g + 0.114 * b);\n            ap_uint<8> u = (ap_uint<8>)(-0.14713 * r - 0.28886 * g + 0.436 * b + 128);\n            ap_uint<8> v = (ap_uint<8>)(0.615 * r - 0.51499 * g - 0.10001 * b + 128);\n\n            Y[i][j] = y;\n            U[i][j] = u;\n            V[i][j] = v;\n        }\n    }\n}\n\n// Top function name: rgb_to_yuv\n"
      }
    ],
    "code_length": 820,
    "token_count": 319,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/ridge_regression/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 17447391,
    "Worst-caseLatency": 17447391.0,
    "BRAM_18K": 232,
    "LUT": 77977,
    "DSP": 704,
    "FF": 97565,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ridge_regression",
    "ResourceMetric": 0.0581964833,
    "design_id": "project",
    "algo_name": "ridge_regression",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "ridge_regression.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define D 64\n\nvoid ridge_regression(double X[N][D], double y[N], double lambda, double w[D]) {\n    double XT[D][N];\n    double XTX[D][D];\n    double XTy[D];\n    double I[D][D];\n    double XTX_lambdaI[D][D];\n    double XTX_lambdaI_inv[D][D];\n\n    // Transpose X to XT\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < D; j++) {\n            XT[j][i] = X[i][j];\n        }\n    }\n\n    // Compute XT * X\n    for (int i = 0; i < D; i++) {\n        for (int j = 0; j < D; j++) {\n            XTX[i][j] = 0;\n            for (int k = 0; k < N; k++) {\n                XTX[i][j] += XT[i][k] * X[k][j];\n            }\n        }\n    }\n\n    // Compute XT * y\n    for (int i = 0; i < D; i++) {\n        XTy[i] = 0;\n        for (int j = 0; j < N; j++) {\n            XTy[i] += XT[i][j] * y[j];\n        }\n    }\n\n    // Create identity matrix I\n    for (int i = 0; i < D; i++) {\n        for (int j = 0; j < D; j++) {\n            if (i == j) {\n                I[i][j] = 1;\n            } else {\n                I[i][j] = 0;\n            }\n        }\n    }\n\n    // Compute XTX + lambda * I\n    for (int i = 0; i < D; i++) {\n        for (int j = 0; j < D; j++) {\n            XTX_lambdaI[i][j] = XTX[i][j] + lambda * I[i][j];\n        }\n    }\n\n    // Invert XTX_lambdaI (assuming it's invertible)\n    // This is a simple Gauss-Jordan elimination for matrix inversion\n    for (int i = 0; i < D; i++) {\n        for (int j = 0; j < D; j++) {\n            if (i == j) {\n                XTX_lambdaI_inv[i][j] = 1;\n            } else {\n                XTX_lambdaI_inv[i][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i < D; i++) {\n        double diag = XTX_lambdaI[i][i];\n        for (int j = 0; j < D; j++) {\n            XTX_lambdaI[i][j] /= diag;\n            XTX_lambdaI_inv[i][j] /= diag;\n        }\n        for (int k = 0; k < D; k++) {\n            if (k != i) {\n                double factor = XTX_lambdaI[k][i];\n                for (int j = 0; j < D; j++) {\n                    XTX_lambdaI[k][j] -= factor * XTX_lambdaI[i][j];\n                    XTX_lambdaI_inv[k][j] -= factor * XTX_lambdaI_inv[i][j];\n                }\n            }\n        }\n    }\n\n    // Compute w = (XTX + lambda * I)^-1 * XTy\n    for (int i = 0; i < D; i++) {\n        w[i] = 0;\n        for (int j = 0; j < D; j++) {\n            w[i] += XTX_lambdaI_inv[i][j] * XTy[j];\n        }\n    }\n}\n\n// Top function name: ridge_regression\n"
      }
    ],
    "code_length": 2424,
    "token_count": 817,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/ring_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 194,
    "DSP": 0,
    "FF": 63,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ring_counter",
    "ResourceMetric": 4.3243e-05,
    "design_id": "project",
    "algo_name": "ring_counter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "ring_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define RING_SIZE 1024\n\nvoid ring_counter(ap_uint<32> counter[RING_SIZE], ap_uint<32> output[RING_SIZE]) {\n    for (int i = 0; i < RING_SIZE; i++) {\n        if (i == 0) {\n            output[i] = counter[RING_SIZE - 1];\n        } else {\n            output[i] = counter[i - 1];\n        }\n    }\n}\n\n// Top function name: ring_counter\n"
      }
    ],
    "code_length": 351,
    "token_count": 106,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/ripple_carry_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 172,
    "DSP": 0,
    "FF": 31,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ripple_carry_adder",
    "ResourceMetric": 3.59559e-05,
    "design_id": "project",
    "algo_name": "ripple_carry_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "ripple_carry_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid ripple_carry_adder(ap_uint<1> A[N], ap_uint<1> B[N], ap_uint<1> C[N+1]) {\n    ap_uint<1> carry = 0;\n    for (int i = 0; i < N; i++) {\n        ap_uint<1> sum = A[i] ^ B[i] ^ carry;\n        carry = (A[i] & B[i]) | (carry & (A[i] ^ B[i]));\n        C[i] = sum;\n    }\n    C[N] = carry;\n}\n\n// Top function name: ripple_carry_adder\n"
      }
    ],
    "code_length": 367,
    "token_count": 141,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/rmse/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2066,
    "Worst-caseLatency": 2066.0,
    "BRAM_18K": 0,
    "LUT": 589,
    "DSP": 5,
    "FF": 595,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rmse",
    "ResourceMetric": 0.000308519,
    "design_id": "project",
    "algo_name": "rmse",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "rmse.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid rmse(const float actual[ARRAY_SIZE], const float predicted[ARRAY_SIZE], float &result) {\n    float sum = 0.0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float diff = actual[i] - predicted[i];\n        sum += diff * diff;\n    }\n    result = std::sqrt(sum / ARRAY_SIZE);\n}\n\n// Top function name: rmse\n"
      }
    ],
    "code_length": 373,
    "token_count": 103,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/rmsprop_optimizer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1055,
    "Worst-caseLatency": 1055.0,
    "BRAM_18K": 0,
    "LUT": 1271,
    "DSP": 18,
    "FF": 1773,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rmsprop_optimizer",
    "ResourceMetric": 0.0009124029,
    "design_id": "project",
    "algo_name": "rmsprop_optimizer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "rmsprop_optimizer.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid rmsprop_optimizer(\n    float learning_rate,\n    float decay_rate,\n    float epsilon,\n    float gradient[ARRAY_SIZE],\n    float cache[ARRAY_SIZE],\n    float weights[ARRAY_SIZE])\n{\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        cache[i] = decay_rate * cache[i] + (1 - decay_rate) * gradient[i] * gradient[i];\n        weights[i] -= learning_rate * gradient[i] / (std::sqrt(cache[i]) + epsilon);\n    }\n}\n\n// Top function name: rmsprop_optimizer\n"
      }
    ],
    "code_length": 493,
    "token_count": 129,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/rnn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 236522372,
    "Worst-caseLatency": 238685060.0,
    "BRAM_18K": 7,
    "LUT": 6479,
    "DSP": 40,
    "FF": 3495,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rnn",
    "ResourceMetric": 0.0031197373,
    "design_id": "project",
    "algo_name": "rnn",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "rnn.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 256\n#define SEQ_LENGTH 128\n\nvoid rnn(float input[SEQ_LENGTH][INPUT_SIZE], \n         float hidden[HIDDEN_SIZE], \n         float weights_input[INPUT_SIZE][HIDDEN_SIZE], \n         float weights_hidden[HIDDEN_SIZE][HIDDEN_SIZE], \n         float bias[HIDDEN_SIZE], \n         float output[SEQ_LENGTH][OUTPUT_SIZE], \n         float weights_output[HIDDEN_SIZE][OUTPUT_SIZE], \n         float bias_output[OUTPUT_SIZE]) \n{\n    float hidden_state[HIDDEN_SIZE];\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        hidden_state[i] = hidden[i];\n    }\n\n    for (int t = 0; t < SEQ_LENGTH; t++) {\n        float new_hidden_state[HIDDEN_SIZE] = {0};\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            float sum = 0;\n            for (int j = 0; j < INPUT_SIZE; j++) {\n                sum += input[t][j] * weights_input[j][i];\n            }\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                sum += hidden_state[j] * weights_hidden[j][i];\n            }\n            sum += bias[i];\n            new_hidden_state[i] = tanh(sum);\n        }\n\n        for (int i = 0; i < HIDDEN_SIZE; i++) {\n            hidden_state[i] = new_hidden_state[i];\n        }\n\n        for (int i = 0; i < OUTPUT_SIZE; i++) {\n            float sum = 0;\n            for (int j = 0; j < HIDDEN_SIZE; j++) {\n                sum += hidden_state[j] * weights_output[j][i];\n            }\n            sum += bias_output[i];\n            output[t][i] = sum;\n        }\n    }\n}\n\n// Top function name: rnn\n"
      }
    ],
    "code_length": 1554,
    "token_count": 413,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/rnn_inference/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1846284,
    "Worst-caseLatency": 1863180.0,
    "BRAM_18K": 7,
    "LUT": 6170,
    "DSP": 40,
    "FF": 3350,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rnn_inference",
    "ResourceMetric": 0.0030465791,
    "design_id": "project",
    "algo_name": "rnn_inference",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "rnn_inference.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 256\n\nvoid rnn_inference(\n    float input[INPUT_SIZE],\n    float hidden_state[HIDDEN_SIZE],\n    float output[OUTPUT_SIZE],\n    float input_weights[INPUT_SIZE][HIDDEN_SIZE],\n    float hidden_weights[HIDDEN_SIZE][HIDDEN_SIZE],\n    float output_weights[HIDDEN_SIZE][OUTPUT_SIZE],\n    float hidden_bias[HIDDEN_SIZE],\n    float output_bias[OUTPUT_SIZE])\n{\n    float temp_hidden[HIDDEN_SIZE];\n    float temp_output[OUTPUT_SIZE];\n\n    // Compute new hidden state\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        temp_hidden[i] = hidden_bias[i];\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            temp_hidden[i] += input[j] * input_weights[j][i];\n        }\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            temp_hidden[i] += hidden_state[j] * hidden_weights[j][i];\n        }\n        temp_hidden[i] = tanh(temp_hidden[i]);\n    }\n\n    // Compute output\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        temp_output[i] = output_bias[i];\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            temp_output[i] += temp_hidden[j] * output_weights[j][i];\n        }\n    }\n\n    // Update hidden state\n    for (int i = 0; i < HIDDEN_SIZE; i++) {\n        hidden_state[i] = temp_hidden[i];\n    }\n\n    // Update output\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        output[i] = temp_output[i];\n    }\n}\n\n// Top function name: rnn_inference\n"
      }
    ],
    "code_length": 1453,
    "token_count": 394,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/robust_optimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 432,
    "DSP": 0,
    "FF": 171,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "robust_optimization",
    "ResourceMetric": 9.92383e-05,
    "design_id": "project",
    "algo_name": "robust_optimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "robust_optimization.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid robust_optimization(double input[N], double output[N], double threshold) {\n    for (int i = 0; i < N; i++) {\n        double value = input[i];\n        if (value < threshold) {\n            output[i] = std::max(0.0, value);\n        } else {\n            output[i] = std::min(1.0, value);\n        }\n    }\n}\n\n// Top function name: robust_optimization\n"
      }
    ],
    "code_length": 405,
    "token_count": 109,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/robust_scaling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1036,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 399,
    "DSP": 2,
    "FF": 574,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "robust_scaling",
    "ResourceMetric": 0.0001869585,
    "design_id": "project",
    "algo_name": "robust_scaling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "robust_scaling.cpp",
        "file_content": "#include <hls_stream.h>\n#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid robust_scaling(float input[SIZE], float output[SIZE], float median, float mad) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (input[i] - median) / mad;\n    }\n}\n\n// Top function name: robust_scaling\n"
      }
    ],
    "code_length": 280,
    "token_count": 81,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/roc_curve/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048580,
    "Worst-caseLatency": 1048580.0,
    "BRAM_18K": 0,
    "LUT": 1136,
    "DSP": 0,
    "FF": 695,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "roc_curve",
    "ResourceMetric": 0.0002844832,
    "design_id": "project",
    "algo_name": "roc_curve",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "roc_curve.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid roc_curve(float predictions[N], int labels[N], float thresholds[N], int tp[N], int fp[N], int tn[N], int fn[N]) {\n    for (int t = 0; t < N; t++) {\n        tp[t] = 0;\n        fp[t] = 0;\n        tn[t] = 0;\n        fn[t] = 0;\n        for (int i = 0; i < N; i++) {\n            if (predictions[i] >= thresholds[t]) {\n                if (labels[i] == 1) {\n                    tp[t]++;\n                } else {\n                    fp[t]++;\n                }\n            } else {\n                if (labels[i] == 1) {\n                    fn[t]++;\n                } else {\n                    tn[t]++;\n                }\n            }\n        }\n    }\n}\n\n// Top function name: roc_curve\n"
      }
    ],
    "code_length": 716,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/rotary_positional_embedding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 524304,
    "Worst-caseLatency": 524304.0,
    "BRAM_18K": 0,
    "LUT": 13901,
    "DSP": 198,
    "FF": 5937,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rotary_positional_embedding",
    "ResourceMetric": 0.0087203495,
    "design_id": "project",
    "algo_name": "rotary_positional_embedding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "rotary_positional_embedding.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024 // Large scale size\n\nvoid rotary_positional_embedding(float input[N][N], float output[N][N], float theta[N]) {\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j += 2) {\n            float cos_theta = cos(theta[j]);\n            float sin_theta = sin(theta[j]);\n\n            float x1 = input[i][j];\n            float x2 = input[i][j + 1];\n\n            output[i][j] = x1 * cos_theta - x2 * sin_theta;\n            output[i][j + 1] = x1 * sin_theta + x2 * cos_theta;\n        }\n    }\n}\n\n// Top function name: rotary_positional_embedding\n"
      }
    ],
    "code_length": 580,
    "token_count": 168,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/rotate_array/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 94,
    "DSP": 0,
    "FF": 24,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rotate_array",
    "ResourceMetric": 2.03271e-05,
    "design_id": "project",
    "algo_name": "rotate_array",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "rotate_array.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid rotate_array(int input_array[ARRAY_SIZE], int output_array[ARRAY_SIZE], int rotate_by) {\n    int i;\n    for (i = 0; i < ARRAY_SIZE; i++) {\n        int new_index = (i + rotate_by) % ARRAY_SIZE;\n        output_array[new_index] = input_array[i];\n    }\n}\n\n// Top function name: rotate_array\n"
      }
    ],
    "code_length": 338,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/round_robin_arbiter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 2054.0,
    "BRAM_18K": 0,
    "LUT": 252,
    "DSP": 0,
    "FF": 69,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "round_robin_arbiter",
    "ResourceMetric": 5.49406e-05,
    "design_id": "project",
    "algo_name": "round_robin_arbiter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "round_robin_arbiter.cpp",
        "file_content": "#include <stdint.h>\n\n#define NUM_REQUESTS 1024\n\nvoid round_robin_arbiter(uint8_t requests[NUM_REQUESTS], uint8_t grants[NUM_REQUESTS]) {\n    uint16_t last_grant = 0;\n    for (uint16_t i = 0; i < NUM_REQUESTS; i++) {\n        grants[i] = 0;\n    }\n\n    for (uint16_t i = 0; i < NUM_REQUESTS; i++) {\n        uint16_t index = (last_grant + i) % NUM_REQUESTS;\n        if (requests[index]) {\n            grants[index] = 1;\n            last_grant = index;\n            break;\n        }\n    }\n}\n\n// Top function name: round_robin_arbiter\n"
      }
    ],
    "code_length": 528,
    "token_count": 158,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/rpn/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16515113,
    "Worst-caseLatency": 16515113.0,
    "BRAM_18K": 0,
    "LUT": 4438,
    "DSP": 7,
    "FF": 2010,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rpn",
    "ResourceMetric": 0.0012377034,
    "design_id": "project",
    "algo_name": "rpn",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "rpn.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 512\n#define ANCHORS 9\n\nvoid rpn(float input_feature_map[INPUT_SIZE][INPUT_SIZE], \n         float anchor_boxes[ANCHORS][4], \n         float rpn_cls[OUTPUT_SIZE][OUTPUT_SIZE][ANCHORS * 2], \n         float rpn_reg[OUTPUT_SIZE][OUTPUT_SIZE][ANCHORS * 4]) \n{\n    // Initialize output arrays\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            for (int k = 0; k < ANCHORS * 2; k++) {\n                rpn_cls[i][j][k] = 0.0f;\n            }\n            for (int k = 0; k < ANCHORS * 4; k++) {\n                rpn_reg[i][j][k] = 0.0f;\n            }\n        }\n    }\n\n    // Compute RPN classification and regression\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            for (int a = 0; a < ANCHORS; a++) {\n                // Example feature extraction and processing\n                float sum = 0.0f;\n                for (int di = 0; di < 3; di++) {\n                    for (int dj = 0; dj < 3; dj++) {\n                        int x = std::min(std::max(i * 2 + di - 1, 0), INPUT_SIZE - 1);\n                        int y = std::min(std::max(j * 2 + dj - 1, 0), INPUT_SIZE - 1);\n                        sum += input_feature_map[x][y];\n                    }\n                }\n                float avg = sum / 9.0f;\n\n                // Example classification score and regression values\n                rpn_cls[i][j][a * 2] = avg > 0.5f ? 1.0f : 0.0f;\n                rpn_cls[i][j][a * 2 + 1] = avg <= 0.5f ? 1.0f : 0.0f;\n\n                rpn_reg[i][j][a * 4] = avg * anchor_boxes[a][0];\n                rpn_reg[i][j][a * 4 + 1] = avg * anchor_boxes[a][1];\n                rpn_reg[i][j][a * 4 + 2] = avg * anchor_boxes[a][2];\n                rpn_reg[i][j][a * 4 + 3] = avg * anchor_boxes[a][3];\n            }\n        }\n    }\n}\n\n// Top function name: rpn\n"
      }
    ],
    "code_length": 1926,
    "token_count": 606,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/rsa_encrypt/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2154823681,
    "Worst-caseLatency": 4305453057.0,
    "BRAM_18K": 0,
    "LUT": 5607,
    "DSP": 3601,
    "FF": 13549,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rsa_encrypt",
    "ResourceMetric": 0.1021360829,
    "design_id": "project",
    "algo_name": "rsa_encrypt",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "rsa_encrypt.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid rsa_encrypt(ap_uint<1024> message[N], ap_uint<1024> encrypted_message[N], ap_uint<1024> e, ap_uint<1024> n) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<1024> result = 1;\n        ap_uint<1024> base = message[i];\n        ap_uint<1024> exponent = e;\n        \n        for (int j = 0; j < 1024; j++) {\n            if (exponent[0] == 1) {\n                result = (result * base) % n;\n            }\n            base = (base * base) % n;\n            exponent = exponent >> 1;\n        }\n        \n        encrypted_message[i] = result;\n    }\n}\n\n// Top function name: rsa_encrypt\n"
      }
    ],
    "code_length": 620,
    "token_count": 188,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/rsa_mod/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2104327,
    "Worst-caseLatency": 4204551.0,
    "BRAM_18K": 0,
    "LUT": 10812,
    "DSP": 3601,
    "FF": 13224,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "rsa_mod",
    "ResourceMetric": 0.1031030572,
    "design_id": "project",
    "algo_name": "rsa_mod",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "rsa_mod.cpp",
        "file_content": "#include <ap_int.h>\n\n#define RSA_MOD_SIZE 1024\n\nvoid rsa_mod(ap_uint<1024> base, ap_uint<1024> exp, ap_uint<1024> mod, ap_uint<1024> &result) {\n    ap_uint<1024> res = 1;\n    ap_uint<1024> b = base % mod;\n\n    for (int i = 0; i < RSA_MOD_SIZE; i++) {\n        if (exp[i] == 1) {\n            res = (res * b) % mod;\n        }\n        b = (b * b) % mod;\n    }\n\n    result = res;\n}\n\n// Top function name: rsa_mod\n"
      }
    ],
    "code_length": 408,
    "token_count": 145,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/run_length_encoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 465,
    "DSP": 0,
    "FF": 85,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "run_length_encoding",
    "ResourceMetric": 9.73207e-05,
    "design_id": "project",
    "algo_name": "run_length_encoding",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "run_length_encoding.cpp",
        "file_content": "#include <iostream>\n\n#define MAX_SIZE 1024\n\nvoid run_length_encoding(int input[MAX_SIZE], int output[MAX_SIZE][2], int &output_size) {\n    int count = 1;\n    int out_index = 0;\n\n    for (int i = 1; i < MAX_SIZE; i++) {\n        if (input[i] == input[i - 1]) {\n            count++;\n        } else {\n            output[out_index][0] = input[i - 1];\n            output[out_index][1] = count;\n            out_index++;\n            count = 1;\n        }\n    }\n\n    // Handle the last sequence\n    output[out_index][0] = input[MAX_SIZE - 1];\n    output[out_index][1] = count;\n    out_index++;\n\n    output_size = out_index;\n}\n\n// Top function name: run_length_encoding\n"
      }
    ],
    "code_length": 659,
    "token_count": 177,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/sample_rate_conversion/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 522,
    "Worst-caseLatency": 522.0,
    "BRAM_18K": 0,
    "LUT": 678,
    "DSP": 7,
    "FF": 786,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sample_rate_conversion",
    "ResourceMetric": 0.0003993075,
    "design_id": "project",
    "algo_name": "sample_rate_conversion",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "sample_rate_conversion.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 512\n\nvoid sample_rate_conversion(const float input[INPUT_SIZE], float output[OUTPUT_SIZE]) {\n    int i, j;\n    const int factor = INPUT_SIZE / OUTPUT_SIZE;\n    \n    for (i = 0; i < OUTPUT_SIZE; i++) {\n        float sum = 0;\n        for (j = 0; j < factor; j++) {\n            sum += input[i * factor + j];\n        }\n        output[i] = sum / factor;\n    }\n}\n\n// Top function name: sample_rate_conversion\n"
      }
    ],
    "code_length": 468,
    "token_count": 124,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/sata_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3083,
    "Worst-caseLatency": 3083.0,
    "BRAM_18K": 2,
    "LUT": 378,
    "DSP": 0,
    "FF": 83,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sata_controller",
    "ResourceMetric": 0.0002044533,
    "design_id": "project",
    "algo_name": "sata_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "sata_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid sata_controller(ap_uint<32> input_data[DATA_SIZE], ap_uint<32> output_data[DATA_SIZE]) {\n    ap_uint<32> buffer[DATA_SIZE];\n\n    // Read data from input to buffer\n    for (int i = 0; i < DATA_SIZE; i++) {\n        buffer[i] = input_data[i];\n    }\n\n    // Process data in buffer\n    for (int i = 0; i < DATA_SIZE; i++) {\n        buffer[i] = buffer[i] + 1; // Simple processing: increment each element\n    }\n\n    // Write data from buffer to output\n    for (int i = 0; i < DATA_SIZE; i++) {\n        output_data[i] = buffer[i];\n    }\n}\n\n// Top function name: sata_controller\n"
      }
    ],
    "code_length": 621,
    "token_count": 181,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/sata_port_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 97,
    "DSP": 3,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sata_port_multiplier",
    "ResourceMetric": 0.0001071782,
    "design_id": "project",
    "algo_name": "sata_port_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "sata_port_multiplier.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid sata_port_multiplier(uint32_t input[ARRAY_SIZE], uint32_t output[ARRAY_SIZE], uint32_t multiplier) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * multiplier;\n    }\n}\n\n// Top function name: sata_port_multiplier\n"
      }
    ],
    "code_length": 290,
    "token_count": 80,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/sd_card_interface/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 92,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sd_card_interface",
    "ResourceMetric": 2.00394e-05,
    "design_id": "project",
    "algo_name": "sd_card_interface",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "sd_card_interface.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_SIZE 1024\n\nvoid sd_card_interface(ap_uint<8> input_data[DATA_SIZE], ap_uint<8> output_data[DATA_SIZE]) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        // Simulate read from SD card\n        ap_uint<8> read_data = input_data[i];\n        \n        // Process data (example: simple transformation)\n        ap_uint<8> processed_data = read_data + 1;\n        \n        // Simulate write to SD card\n        output_data[i] = processed_data;\n    }\n}\n\n// Top function name: sd_card_interface\n"
      }
    ],
    "code_length": 518,
    "token_count": 136,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sdca/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3256879127,
    "Worst-caseLatency": 3256879127.0,
    "BRAM_18K": 0,
    "LUT": 2048,
    "DSP": 10,
    "FF": 1596,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sdca",
    "ResourceMetric": 0.0008228018,
    "design_id": "project",
    "algo_name": "sdca",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sdca.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid sdca(float alpha, float lambda, float data[N][N], float labels[N], float weights[N], float dual_vars[N], float primal_vars[N]) {\n    float delta_alpha, gradient;\n    float norm_sq = 0.0f;\n\n    // Compute the norm of the weights\n    for (int i = 0; i < N; i++) {\n        norm_sq += weights[i] * weights[i];\n    }\n\n    // Main SDCA loop\n    for (int iter = 0; iter < N; iter++) {\n        for (int i = 0; i < N; i++) {\n            gradient = 0.0f;\n\n            // Compute the gradient\n            for (int j = 0; j < N; j++) {\n                gradient += data[i][j] * weights[j];\n            }\n            gradient = labels[i] * gradient - 1.0f;\n\n            // Update the dual variable\n            delta_alpha = (gradient - dual_vars[i]) / (norm_sq + 1.0f / (lambda * N));\n            dual_vars[i] += delta_alpha;\n\n            // Update the primal variables\n            for (int j = 0; j < N; j++) {\n                weights[j] += delta_alpha * labels[i] * data[i][j];\n            }\n        }\n    }\n\n    // Compute the primal variables\n    for (int i = 0; i < N; i++) {\n        primal_vars[i] = 0.0f;\n        for (int j = 0; j < N; j++) {\n            primal_vars[i] += data[i][j] * weights[j];\n        }\n    }\n}\n\n// Top function name: sdca\n"
      }
    ],
    "code_length": 1276,
    "token_count": 367,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/self_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4300238877,
    "Worst-caseLatency": 4300238877.0,
    "BRAM_18K": 12288,
    "LUT": 4874,
    "DSP": 33,
    "FF": 2931,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "self_attention",
    "ResourceMetric": 0.7640346839,
    "design_id": "project",
    "algo_name": "self_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "self_attention.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024  // Large scale size\n\nvoid self_attention(float input[N][N], float output[N][N], float weight[N][N], float bias[N]) {\n    float query[N][N];\n    float key[N][N];\n    float value[N][N];\n    float attention_scores[N][N];\n    float attention_probs[N][N];\n    float attention_output[N][N];\n\n    // Compute query, key, value matrices\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            query[i][j] = input[i][j] * weight[i][j] + bias[j];\n            key[i][j] = input[i][j] * weight[i][j] + bias[j];\n            value[i][j] = input[i][j] * weight[i][j] + bias[j];\n        }\n    }\n\n    // Compute attention scores\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            attention_scores[i][j] = 0;\n            for (int k = 0; k < N; k++) {\n                attention_scores[i][j] += query[i][k] * key[j][k];\n            }\n            attention_scores[i][j] /= sqrt(N);\n        }\n    }\n\n    // Compute attention probabilities using softmax\n    for (int i = 0; i < N; i++) {\n        float sum_exp = 0;\n        for (int j = 0; j < N; j++) {\n            attention_probs[i][j] = exp(attention_scores[i][j]);\n            sum_exp += attention_probs[i][j];\n        }\n        for (int j = 0; j < N; j++) {\n            attention_probs[i][j] /= sum_exp;\n        }\n    }\n\n    // Compute attention output\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            attention_output[i][j] = 0;\n            for (int k = 0; k < N; k++) {\n                attention_output[i][j] += attention_probs[i][k] * value[k][j];\n            }\n        }\n    }\n\n    // Write output\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            output[i][j] = attention_output[i][j];\n        }\n    }\n}\n\n// Top function name: self_attention\n"
      }
    ],
    "code_length": 1841,
    "token_count": 560,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/self_paced_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 928,
    "DSP": 7,
    "FF": 1231,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "self_paced_learning",
    "ResourceMetric": 0.0004899164,
    "design_id": "project",
    "algo_name": "self_paced_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "self_paced_learning.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n\nvoid self_paced_learning(float input[N], float output[N], float learning_rate, float threshold) {\n    for (int i = 0; i < N; i++) {\n        float error = input[i] - output[i];\n        if (std::abs(error) > threshold) {\n            output[i] += learning_rate * error;\n        }\n    }\n}\n\n// Top function name: self_paced_learning\n"
      }
    ],
    "code_length": 382,
    "token_count": 99,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/self_powered_isolated_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "self_powered_isolated_comparator",
    "ResourceMetric": 2.31077e-05,
    "design_id": "project",
    "algo_name": "self_powered_isolated_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "self_powered_isolated_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid self_powered_isolated_comparator(ap_int<16> input_array[ARRAY_SIZE], ap_int<16> threshold, ap_int<1> output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_array[i] > threshold) {\n            output_array[i] = 1;\n        } else {\n            output_array[i] = 0;\n        }\n    }\n}\n\n// Top function name: self_powered_isolated_comparator\n"
      }
    ],
    "code_length": 422,
    "token_count": 119,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/self_supervised_contrastive_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 966665,
    "Worst-caseLatency": 966665.0,
    "BRAM_18K": 512,
    "LUT": 1753,
    "DSP": 7,
    "FF": 1311,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "self_supervised_contrastive_learning",
    "ResourceMetric": 0.0324018247,
    "design_id": "project",
    "algo_name": "self_supervised_contrastive_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "self_supervised_contrastive_learning.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid self_supervised_contrastive_learning(float input1[N][128], float input2[N][128], float output[N][128]) {\n    float temp1[N][128];\n    float temp2[N][128];\n    float norm1[N];\n    float norm2[N];\n\n    // Normalize input1\n    for (int i = 0; i < N; i++) {\n        norm1[i] = 0.0;\n        for (int j = 0; j < 128; j++) {\n            norm1[i] += input1[i][j] * input1[i][j];\n        }\n        norm1[i] = std::sqrt(norm1[i]);\n        for (int j = 0; j < 128; j++) {\n            temp1[i][j] = input1[i][j] / norm1[i];\n        }\n    }\n\n    // Normalize input2\n    for (int i = 0; i < N; i++) {\n        norm2[i] = 0.0;\n        for (int j = 0; j < 128; j++) {\n            norm2[i] += input2[i][j] * input2[i][j];\n        }\n        norm2[i] = std::sqrt(norm2[i]);\n        for (int j = 0; j < 128; j++) {\n            temp2[i][j] = input2[i][j] / norm2[i];\n        }\n    }\n\n    // Compute contrastive loss\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < 128; j++) {\n            output[i][j] = temp1[i][j] - temp2[i][j];\n        }\n    }\n}\n\n// Top function name: self_supervised_contrastive_learning\n"
      }
    ],
    "code_length": 1139,
    "token_count": 393,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/self_supervised_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5159,
    "Worst-caseLatency": 5159.0,
    "BRAM_18K": 0,
    "LUT": 962,
    "DSP": 5,
    "FF": 922,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "self_supervised_learning",
    "ResourceMetric": 0.0004114009,
    "design_id": "project",
    "algo_name": "self_supervised_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "self_supervised_learning.cpp",
        "file_content": "#include <cmath>\n#include <cstring>\n\n#define ARRAY_SIZE 1024\n\nvoid self_supervised_learning(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float mean = 0.0f;\n    float variance = 0.0f;\n    float stddev = 0.0f;\n\n    // Calculate mean\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        mean += input[i];\n    }\n    mean /= ARRAY_SIZE;\n\n    // Calculate variance\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        variance += (input[i] - mean) * (input[i] - mean);\n    }\n    variance /= ARRAY_SIZE;\n\n    // Calculate standard deviation\n    stddev = std::sqrt(variance);\n\n    // Normalize input to generate output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] - mean) / stddev;\n    }\n}\n\n// Top function name: self_supervised_learning\n"
      }
    ],
    "code_length": 766,
    "token_count": 215,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/semi_supervised_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2170554376,
    "Worst-caseLatency": 2380374381.0,
    "BRAM_18K": 2052,
    "LUT": 4076,
    "DSP": 34,
    "FF": 2498,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "semi_supervised_learning",
    "ResourceMetric": 0.1291952233,
    "design_id": "project",
    "algo_name": "semi_supervised_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "semi_supervised_learning.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid semi_supervised_learning(float labeled_data[N][N], float unlabeled_data[N][N], float labels[N], float output[N]) {\n    float similarity[N][N];\n    float label_propagation[N];\n    float alpha = 0.99;\n    float epsilon = 1e-6;\n\n    // Compute similarity matrix\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            float dist = 0.0;\n            for (int k = 0; k < N; k++) {\n                dist += (labeled_data[i][k] - unlabeled_data[j][k]) * (labeled_data[i][k] - unlabeled_data[j][k]);\n            }\n            similarity[i][j] = exp(-dist);\n        }\n    }\n\n    // Initialize label propagation\n    for (int i = 0; i < N; i++) {\n        label_propagation[i] = labels[i];\n    }\n\n    // Iterative label propagation\n    for (int iter = 0; iter < 100; iter++) {\n        float new_label_propagation[N];\n        for (int i = 0; i < N; i++) {\n            new_label_propagation[i] = 0.0;\n            for (int j = 0; j < N; j++) {\n                new_label_propagation[i] += similarity[i][j] * label_propagation[j];\n            }\n            new_label_propagation[i] = alpha * new_label_propagation[i] + (1 - alpha) * labels[i];\n        }\n\n        // Check for convergence\n        float max_diff = 0.0;\n        for (int i = 0; i < N; i++) {\n            max_diff = std::max(max_diff, std::abs(new_label_propagation[i] - label_propagation[i]));\n            label_propagation[i] = new_label_propagation[i];\n        }\n        if (max_diff < epsilon) {\n            break;\n        }\n    }\n\n    // Output the final labels\n    for (int i = 0; i < N; i++) {\n        output[i] = label_propagation[i];\n    }\n}\n\n// Top function name: semi_supervised_learning\n"
      }
    ],
    "code_length": 1731,
    "token_count": 486,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/semiconductor_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3106,
    "Worst-caseLatency": 3106.0,
    "BRAM_18K": 5,
    "LUT": 1551,
    "DSP": 10,
    "FF": 806,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "semiconductor_signal_processor",
    "ResourceMetric": 0.0009617674,
    "design_id": "project",
    "algo_name": "semiconductor_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "semiconductor_signal_processor.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid semiconductor_signal_processor(fixed_point_t input_signal[ARRAY_SIZE], fixed_point_t output_signal[ARRAY_SIZE]) {\n    fixed_point_t filter_coefficients[5] = {0.1, 0.15, 0.5, 0.15, 0.1};\n    fixed_point_t temp_signal[ARRAY_SIZE + 4] = {0};\n\n    // Extend the input signal with zeros at the beginning and end\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp_signal[i + 2] = input_signal[i];\n    }\n\n    // Apply the filter\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        fixed_point_t result = 0;\n        for (int j = 0; j < 5; j++) {\n            result += temp_signal[i + j] * filter_coefficients[j];\n        }\n        output_signal[i] = result;\n    }\n}\n\n// Top function name: semiconductor_signal_processor\n"
      }
    ],
    "code_length": 809,
    "token_count": 235,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/separable_convolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3139619,
    "Worst-caseLatency": 3139619.0,
    "BRAM_18K": 2052,
    "LUT": 1738,
    "DSP": 19,
    "FF": 1519,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "separable_convolution",
    "ResourceMetric": 0.1282374497,
    "design_id": "project",
    "algo_name": "separable_convolution",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "separable_convolution.cpp",
        "file_content": "#include <iostream>\n#define SIZE 1024\n\nvoid separable_convolution(int input[SIZE][SIZE], int output[SIZE][SIZE], int kernel_x[3], int kernel_y[3]) {\n    int temp[SIZE][SIZE];\n\n    // Convolution in the x direction\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 1; j < SIZE - 1; j++) {\n            temp[i][j] = input[i][j-1] * kernel_x[0] + input[i][j] * kernel_x[1] + input[i][j+1] * kernel_x[2];\n        }\n    }\n\n    // Convolution in the y direction\n    for (int i = 1; i < SIZE - 1; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            output[i][j] = temp[i-1][j] * kernel_y[0] + temp[i][j] * kernel_y[1] + temp[i+1][j] * kernel_y[2];\n        }\n    }\n}\n\n// Top function name: separable_convolution\n"
      }
    ],
    "code_length": 719,
    "token_count": 249,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sequence_to_sequence/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 805306388,
    "Worst-caseLatency": 805306388.0,
    "BRAM_18K": 1024,
    "LUT": 1828,
    "DSP": 3,
    "FF": 966,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sequence_to_sequence",
    "ResourceMetric": 0.0640183438,
    "design_id": "project",
    "algo_name": "sequence_to_sequence",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sequence_to_sequence.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SEQ_LENGTH 1024\n#define EMBEDDING_DIM 512\n#define HIDDEN_DIM 512\n\nvoid sequence_to_sequence(ap_int<16> input_seq[SEQ_LENGTH][EMBEDDING_DIM], \n                          ap_int<16> output_seq[SEQ_LENGTH][EMBEDDING_DIM], \n                          ap_int<16> encoder_weights[EMBEDDING_DIM][HIDDEN_DIM], \n                          ap_int<16> decoder_weights[HIDDEN_DIM][EMBEDDING_DIM]) {\n    ap_int<16> encoder_hidden[SEQ_LENGTH][HIDDEN_DIM];\n    ap_int<16> decoder_hidden[SEQ_LENGTH][HIDDEN_DIM];\n\n    // Encoder\n    for (int t = 0; t < SEQ_LENGTH; t++) {\n        for (int i = 0; i < HIDDEN_DIM; i++) {\n            encoder_hidden[t][i] = 0;\n            for (int j = 0; j < EMBEDDING_DIM; j++) {\n                encoder_hidden[t][i] += input_seq[t][j] * encoder_weights[j][i];\n            }\n        }\n    }\n\n    // Decoder\n    for (int t = 0; t < SEQ_LENGTH; t++) {\n        for (int i = 0; i < HIDDEN_DIM; i++) {\n            decoder_hidden[t][i] = 0;\n            for (int j = 0; j < HIDDEN_DIM; j++) {\n                decoder_hidden[t][i] += encoder_hidden[t][j] * decoder_weights[j][i];\n            }\n        }\n    }\n\n    // Output\n    for (int t = 0; t < SEQ_LENGTH; t++) {\n        for (int i = 0; i < EMBEDDING_DIM; i++) {\n            output_seq[t][i] = 0;\n            for (int j = 0; j < HIDDEN_DIM; j++) {\n                output_seq[t][i] += decoder_hidden[t][j] * decoder_weights[j][i];\n            }\n        }\n    }\n}\n\n// Top function name: sequence_to_sequence\n"
      }
    ],
    "code_length": 1494,
    "token_count": 440,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/serializer_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 88,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "serializer_16bit",
    "ResourceMetric": 1.92724e-05,
    "design_id": "project",
    "algo_name": "serializer_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "serializer_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid serializer_16bit(uint16_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE * 2]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[2 * i] = (uint8_t)(input[i] & 0x00FF); // Lower 8 bits\n        output[2 * i + 1] = (uint8_t)((input[i] >> 8) & 0x00FF); // Upper 8 bits\n    }\n}\n\n// Top function name: serializer_16bit\n"
      }
    ],
    "code_length": 372,
    "token_count": 132,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/serializer_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2050,
    "Worst-caseLatency": 2050.0,
    "BRAM_18K": 0,
    "LUT": 201,
    "DSP": 0,
    "FF": 53,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "serializer_32bit",
    "ResourceMetric": 4.36265e-05,
    "design_id": "project",
    "algo_name": "serializer_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "serializer_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid serializer_32bit(uint32_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE * 4]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint32_t word = input[i];\n        output[i * 4 + 0] = (word >> 24) & 0xFF;\n        output[i * 4 + 1] = (word >> 16) & 0xFF;\n        output[i * 4 + 2] = (word >> 8) & 0xFF;\n        output[i * 4 + 3] = word & 0xFF;\n    }\n}\n\n// Top function name: serializer_32bit\n"
      }
    ],
    "code_length": 442,
    "token_count": 159,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/serializer_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4098,
    "Worst-caseLatency": 4098.0,
    "BRAM_18K": 0,
    "LUT": 316,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "serializer_8bit",
    "ResourceMetric": 6.49124e-05,
    "design_id": "project",
    "algo_name": "serializer_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "serializer_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid serializer_8bit(uint8_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE * 8]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t byte = input[i];\n        for (int bit = 0; bit < 8; bit++) {\n            output[i * 8 + bit] = (byte >> (7 - bit)) & 0x01;\n        }\n    }\n}\n\n// Top function name: serializer_8bit\n"
      }
    ],
    "code_length": 367,
    "token_count": 119,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/seven_stage_pipeline/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8223,
    "Worst-caseLatency": 8223.0,
    "BRAM_18K": 14,
    "LUT": 1202,
    "DSP": 0,
    "FF": 224,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "seven_stage_pipeline",
    "ResourceMetric": 0.0011200346,
    "design_id": "project",
    "algo_name": "seven_stage_pipeline",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "seven_stage_pipeline.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid seven_stage_pipeline(int input[SIZE], int output[SIZE]) {\n    int stage1[SIZE];\n    int stage2[SIZE];\n    int stage3[SIZE];\n    int stage4[SIZE];\n    int stage5[SIZE];\n    int stage6[SIZE];\n    int stage7[SIZE];\n\n    // Stage 1: Initial processing\n    for (int i = 0; i < SIZE; i++) {\n        stage1[i] = input[i] * 2;\n    }\n\n    // Stage 2: Further processing\n    for (int i = 0; i < SIZE; i++) {\n        stage2[i] = stage1[i] + 3;\n    }\n\n    // Stage 3: Further processing\n    for (int i = 0; i < SIZE; i++) {\n        stage3[i] = stage2[i] - 1;\n    }\n\n    // Stage 4: Further processing\n    for (int i = 0; i < SIZE; i++) {\n        stage4[i] = stage3[i] * 4;\n    }\n\n    // Stage 5: Further processing\n    for (int i = 0; i < SIZE; i++) {\n        stage5[i] = stage4[i] / 2;\n    }\n\n    // Stage 6: Further processing\n    for (int i = 0; i < SIZE; i++) {\n        stage6[i] = stage5[i] + 5;\n    }\n\n    // Stage 7: Final processing\n    for (int i = 0; i < SIZE; i++) {\n        stage7[i] = stage6[i] - 3;\n    }\n\n    // Output assignment\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = stage7[i];\n    }\n}\n\n// Top function name: seven_stage_pipeline\n"
      }
    ],
    "code_length": 1198,
    "token_count": 402,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/CHStone/sha/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8260,
    "Worst-caseLatency": 8260.0,
    "BRAM_18K": 128,
    "LUT": 50619,
    "DSP": 0,
    "FF": 15531,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sha_stream",
    "ResourceMetric": 0.0191326028,
    "design_id": "project",
    "algo_name": "sha",
    "source_name": "CHStone",
    "source_code": [
      {
        "file_name": "sha.c",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n/* NIST Secure Hash Algorithm */\n/* heavily modified by Uwe Hollerbach uh@alumni.caltech edu */\n/* from Peter C. Gutmann's implementation as found in */\n/* Applied Cryptography by Bruce Schneier */\n\n/* NIST's proposed modification to SHA of 7/11/94 may be */\n/* activated by defining USE_MODIFIED_SHA */\n\n\n#include \"sha.h\"\n/* SHA f()-functions */\n\n#define f1(x,y,z)\t((x & y) | (~x & z))\n#define f2(x,y,z)\t(x ^ y ^ z)\n#define f3(x,y,z)\t((x & y) | (x & z) | (y & z))\n#define f4(x,y,z)\t(x ^ y ^ z)\n\n/* SHA constants */\n\n#define CONST1\t\t0x5a827999L\n#define CONST2\t\t0x6ed9eba1L\n#define CONST3\t\t0x8f1bbcdcL\n#define CONST4\t\t0xca62c1d6L\n\n/* 32-bit rotate */\n\n#define ROT32(x,n)\t((x << n) | (x >> (32 - n)))\n\n#define FUNC(n,i)\t\t\t\t\t\t\\\n    temp = ROT32(A,5) + f##n(B,C,D) + E + W[i] + CONST##n;\t\\\n    E = D; D = C; C = ROT32(B,30); B = A; A = temp\n\nvoid\nlocal_memset (INT32 * s, int c, int n, int e)\n{\n  INT32 uc;\n  INT32 *p;\n  int m;\n\n  m = n / 4;\n  uc = c;\n  p = (INT32 *) s;\n  while (e-- > 0)\n    {\n      p++;\n    }\n  while (m-- > 0)\n    {\n      *p++ = uc;\n    }\n}\n\nvoid\nlocal_memcpy (INT32 * s1, const BYTE * s2, int n)\n{\n  INT32 *p1;\n  BYTE *p2;\n  INT32 tmp;\n  int m;\n  m = n / 4;\n  p1 = (INT32 *) s1;\n  p2 = (BYTE *) s2;\n\n  while (m-- > 0)\n    {\n      tmp = 0;\n      tmp |= 0xFF & *p2++;\n      tmp |= (0xFF & *p2++) << 8;\n      tmp |= (0xFF & *p2++) << 16;\n      tmp |= (0xFF & *p2++) << 24;\n      *p1 = tmp;\n      p1++;\n    }\n}\n\n/* do SHA transformation */\n\nstatic void\nsha_transform ()\n{\n  int i;\n  INT32 temp, A, B, C, D, E, W[80];\n\n  for (i = 0; i < 16; ++i)\n    {\n      W[i] = sha_info_data[i];\n    }\n  for (i = 16; i < 80; ++i)\n    {\n      W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n    }\n  A = sha_info_digest[0];\n  B = sha_info_digest[1];\n  C = sha_info_digest[2];\n  D = sha_info_digest[3];\n  E = sha_info_digest[4];\n\n  for (i = 0; i < 20; ++i)\n    {\n      FUNC (1, i);\n    }\n  for (i = 20; i < 40; ++i)\n    {\n      FUNC (2, i);\n    }\n  for (i = 40; i < 60; ++i)\n    {\n      FUNC (3, i);\n    }\n  for (i = 60; i < 80; ++i)\n    {\n      FUNC (4, i);\n    }\n\n  sha_info_digest[0] += A;\n  sha_info_digest[1] += B;\n  sha_info_digest[2] += C;\n  sha_info_digest[3] += D;\n  sha_info_digest[4] += E;\n}\n\n/* initialize the SHA digest */\n\nvoid\nsha_init ()\n{\n  sha_info_digest[0] = 0x67452301L;\n  sha_info_digest[1] = 0xefcdab89L;\n  sha_info_digest[2] = 0x98badcfeL;\n  sha_info_digest[3] = 0x10325476L;\n  sha_info_digest[4] = 0xc3d2e1f0L;\n  sha_info_count_lo = 0L;\n  sha_info_count_hi = 0L;\n}\n\n/* update the SHA digest */\n\nvoid\nsha_update (const BYTE * buffer, int count)\n{\n  if ((sha_info_count_lo + ((INT32) count << 3)) < sha_info_count_lo)\n    {\n      ++sha_info_count_hi;\n    }\n  sha_info_count_lo += (INT32) count << 3;\n  sha_info_count_hi += (INT32) count >> 29;\n  while (count >= SHA_BLOCKSIZE)\n    {\n      local_memcpy (sha_info_data, buffer, SHA_BLOCKSIZE);\n      sha_transform ();\n      buffer += SHA_BLOCKSIZE;\n      count -= SHA_BLOCKSIZE;\n    }\n  local_memcpy (sha_info_data, buffer, count);\n}\n\n/* finish computing the SHA digest */\n\nvoid\nsha_final ()\n{\n  int count;\n  INT32 lo_bit_count;\n  INT32 hi_bit_count;\n\n  lo_bit_count = sha_info_count_lo;\n  hi_bit_count = sha_info_count_hi;\n  count = (int) ((lo_bit_count >> 3) & 0x3f);\n  sha_info_data[count++] = 0x80;\n  if (count > 56)\n    {\n      local_memset (sha_info_data, 0, 64 - count, count);\n      sha_transform ();\n      local_memset (sha_info_data, 0, 56, 0);\n    }\n  else\n    {\n      local_memset (sha_info_data, 0, 56 - count, count);\n    }\n  sha_info_data[14] = hi_bit_count;\n  sha_info_data[15] = lo_bit_count;\n  sha_transform ();\n}\n\n/* compute the SHA digest of a FILE stream */\nvoid\nsha_stream ()\n{\n  int i, j;\n  const BYTE *p;\n\n  sha_init ();\n  for (j = 0; j < VSIZE; j++)\n    {\n      i = in_i[j];\n      p = &indata[j][0];\n      sha_update (p, i);\n    }\n  sha_final ();\n}\n"
      },
      {
        "file_name": "sha.h",
        "file_content": "/*\n+--------------------------------------------------------------------------+\n| CHStone : a suite of benchmark programs for C-based High-Level Synthesis |\n| ======================================================================== |\n|                                                                          |\n| * Collected and Modified : Y. Hara, H. Tomiyama, S. Honda,               |\n|                            H. Takada and K. Ishii                        |\n|                            Nagoya University, Japan                      |\n|                                                                          |\n| * Remark :                                                               |\n|    1. This source code is modified to unify the formats of the benchmark |\n|       programs in CHStone.                                               |\n|    2. Test vectors are added for CHStone.                                |\n|    3. If \"main_result\" is 0 at the end of the program, the program is    |\n|       correctly executed.                                                |\n|    4. Please follow the copyright of each benchmark program.             |\n+--------------------------------------------------------------------------+\n*/\n#ifndef SHA_H\n#define SHA_H\n\n/* NIST Secure Hash Algorithm */\n/* heavily modified from Peter C. Gutmann's implementation */\n\n/* Useful defines & typedefs */\n\ntypedef unsigned char BYTE;\ntypedef unsigned int INT32;\n\n#define SHA_BLOCKSIZE\t\t64\n\nINT32 sha_info_digest[5];\t/* message digest */\nINT32 sha_info_count_lo, sha_info_count_hi;\t/* 64-bit bit count */\nINT32 sha_info_data[16];\n\nvoid sha_init ();\nvoid sha_update (const BYTE *, int);\nvoid sha_final ();\n\nvoid sha_stream ();\nvoid sha_print ();\n\n#define BLOCK_SIZE 8192\n#define VSIZE 2\n\n/*\n+--------------------------------------------------------------------------+\n| * Test Vectors (added for CHStone)                                       |\n|     indata, in_i : input data                                            |\n+--------------------------------------------------------------------------+\n*/\nconst BYTE indata[VSIZE][BLOCK_SIZE] = {\n  {75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111,\n   109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101,\n   115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100,\n   103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99,\n   108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102,\n   101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112,\n   102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116,\n   84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101,\n   102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110,\n   104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98,\n   121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114,\n   101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97,\n   100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109,\n   111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110,\n   109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103,\n   101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108,\n   100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118,\n   105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101,\n   114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116,\n   117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104,\n   101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117,\n   115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111,\n   117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111,\n   116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110,\n   100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117,\n   99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119,\n   109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121,\n   108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100,\n   104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114,\n   101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97,\n   114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116,\n   111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100,\n   114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99,\n   97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109,\n   117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108,\n   97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104,\n   111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101,\n   97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114,\n   101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105,\n   109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121,\n   97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79,\n   114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104,\n   97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116,\n   115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100,\n   100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115,\n   97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116,\n   104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115,\n   117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100,\n   111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101,\n   116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98,\n   101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98,\n   101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118,\n   101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119,\n   104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102,\n   109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115,\n   105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116,\n   104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114,\n   105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119,\n   105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115,\n   97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110,\n   101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108,\n   110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104,\n   101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121,\n   111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105,\n   108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116,\n   116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114,\n   115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116,\n   112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108,\n   102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121,\n   121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119,\n   104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108,\n   105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117,\n   97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121,\n   111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89,\n   111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121,\n   111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111,\n   114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117,\n   114, 101, 79, 114, 119, 111, 114, 114, 121, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116,\n   111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100,\n   114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99,\n   97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109,\n   117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108,\n   97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104,\n   111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101,\n   97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114,\n   101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105,\n   109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121,\n   97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79,\n   114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104,\n   97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117,\n   116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65,\n   100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101,\n   115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102,\n   116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108,\n   100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110,\n   101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114,\n   101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100,\n   98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109,\n   98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111,\n   118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115,\n   119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111,\n   102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97,\n   115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101,\n   116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101,\n   114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73,\n   119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105,\n   115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121,\n   116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117,\n   116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104,\n   110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108,\n   108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116,\n   105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117,\n   116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97,\n   114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97,\n   116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101,\n   108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97,\n   121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111,\n   119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105,\n   108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111,\n   117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115,\n   121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100,\n   89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115,\n   121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119,\n   111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110,\n   111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101,\n   103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110,\n   116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100,\n   105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110,\n   111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101,\n   97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111,\n   117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121,\n   111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117,\n   108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101,\n   114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112,\n   114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115,\n   116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115,\n   116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110,\n   111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98,\n   108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110,\n   100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99,\n   101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116,\n   104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106,\n   111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101,\n   97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104,\n   79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119,\n   105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110,\n   100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97,\n   117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117,\n   110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100,\n   66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121,\n   101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99,\n   107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114,\n   115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97,\n   119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110,\n   111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98,\n   105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121,\n   111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117,\n   115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101,\n   100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97,\n   115, 121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116,\n   119, 111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107,\n   110, 111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110,\n   101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111,\n   117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116,\n   101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110,\n   112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105,\n   115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101,\n   115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115,\n   110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105,\n   97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97,\n   110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110,\n   99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101,\n   116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110,\n   106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98,\n   101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116,\n   104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117,\n   119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97,\n   110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 75, 117, 114, 116,\n   86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110,\n   99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77,\n   73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108,\n   101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111,\n   102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110,\n   73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111,\n   117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116,\n   104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101,\n   101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108,\n   111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115,\n   111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101,\n   98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105,\n   101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116,\n   104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99,\n   101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101,\n   114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111,\n   119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112,\n   101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115,\n   112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101,\n   110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101,\n   114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117,\n   114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105,\n   110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100,\n   101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118,\n   101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109,\n   101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108,\n   108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115,\n   111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101,\n   99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110,\n   116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99,\n   104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121,\n   98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119,\n   102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108,\n   108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110,\n   111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103,\n   105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111,\n   117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111,\n   114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75,\n   117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117, 114, 116, 86,\n   111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99,\n   101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73,\n   84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117},\n  {116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97,\n   100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110,\n   50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111,\n   107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121,\n   111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108,\n   108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114,\n   97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111,\n   115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102,\n   111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98,\n   117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108,\n   111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97,\n   115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105, 110,\n   101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117, 116,\n   116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114, 114,\n   121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117, 114,\n   116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101,\n   110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97,\n   116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110,\n   116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115,\n   115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101,\n   101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114,\n   121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111,\n   114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104,\n   101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105,\n   116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97,\n   118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115,\n   99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97,\n   115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118,\n   105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114,\n   101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121,\n   111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120,\n   112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105,\n   115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99,\n   101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109,\n   105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110,\n   100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101,\n   114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117,\n   114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121,\n   118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116,\n   109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108,\n   108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111,\n   115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114,\n   101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97,\n   110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117,\n   99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97,\n   121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111,\n   119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97,\n   108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101,\n   110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97,\n   103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98,\n   111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119,\n   111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116,\n   116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65,\n   100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101,\n   115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102,\n   116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108,\n   100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110,\n   101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114,\n   101, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116,\n   115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100,\n   100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115,\n   97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116,\n   104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115,\n   117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100,\n   111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101,\n   116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98,\n   101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98,\n   101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118,\n   101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119,\n   104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102,\n   109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115,\n   105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116,\n   104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114,\n   105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119,\n   105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115,\n   97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110,\n   101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108,\n   110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104,\n   101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121,\n   111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105,\n   108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116,\n   116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114,\n   115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116,\n   112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108,\n   102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121,\n   121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119,\n   104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108,\n   105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117,\n   97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121,\n   111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89,\n   111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121,\n   111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111,\n   114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117,\n   114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111,\n   119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103,\n   117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116,\n   65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105,\n   101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111,\n   102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97,\n   114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117,\n   108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111,\n   110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117,\n   114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108,\n   100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114,\n   109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114,\n   111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116,\n   115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116,\n   111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98,\n   97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108,\n   101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100,\n   101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101,\n   73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104,\n   105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111,\n   121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97,\n   117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79,\n   104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105,\n   108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100,\n   116, 104, 101, 112, 111, 119, 101, 114, 97, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 75, 117, 114, 116, 86, 111,\n   110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101,\n   109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84,\n   76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101,\n   109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102,\n   57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73,\n   102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117,\n   111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111,\n   110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111,\n   102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98,\n   101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101,\n   110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104,\n   101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101,\n   104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114,\n   101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119,\n   110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101,\n   114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112,\n   101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110,\n   111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114,\n   97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114,\n   121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110,\n   100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101,\n   114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 75, 117,\n   114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67, 111, 109, 109,\n   101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114, 101, 115, 115,\n   97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110, 100, 103, 101,\n   110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101, 99, 108, 97,\n   115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110, 115, 99, 114,\n   101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102, 102, 101,\n   114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105, 112, 102,\n   111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117, 110, 115,\n   99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84,\n   104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102,\n   105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104,\n   97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121,\n   115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101,\n   97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100,\n   118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111,\n   114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109,\n   121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101,\n   120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100,\n   105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105,\n   99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111,\n   119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121,\n   111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114,\n   109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117,\n   110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116,\n   111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100,\n   114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99,\n   97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109,\n   117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108,\n   97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104,\n   111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101,\n   97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114,\n   101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105,\n   109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121,\n   97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79,\n   114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104,\n   97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117, 116, 115, 67,\n   111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65, 100, 100, 114,\n   101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101, 115, 97, 110,\n   100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102, 116, 104, 101,\n   99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108, 100, 111, 102,\n   102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110, 101, 116, 105,\n   112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114, 101, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 75, 117, 114, 116, 86, 111, 110, 110, 101, 103, 117,\n   116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110, 116, 65,\n   100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100, 105, 101,\n   115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110, 111, 102,\n   116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101, 97, 114,\n   115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111, 117, 108,\n   100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121, 111, 110,\n   101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116, 117, 114,\n   101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100,\n   98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109,\n   98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111,\n   118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115,\n   119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111,\n   102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97,\n   115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101,\n   116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101,\n   114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73,\n   119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105,\n   115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121,\n   116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117,\n   116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104,\n   110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108,\n   108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116,\n   104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116,\n   121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116,\n   105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117,\n   116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97,\n   114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97,\n   116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101,\n   108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97,\n   121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111,\n   119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105,\n   108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111,\n   117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115,\n   121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100,\n   89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115,\n   121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119,\n   111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110,\n   111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110, 101,\n   103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101, 110,\n   116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97, 100,\n   105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101, 110,\n   111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87, 101,\n   97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99, 111,\n   117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108, 121,\n   111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117, 116,\n   117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111, 117,\n   108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116, 101,\n   114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117, 110,\n   115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110, 112,\n   114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105, 115,\n   116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101, 115,\n   116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115, 110,\n   111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105, 97, 98,\n   108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97, 110,\n   100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110, 99,\n   101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101, 116,\n   104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110, 106,\n   111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101,\n   97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104,\n   79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117, 119,\n   105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97, 110,\n   100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97,\n   117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 117,\n   110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101, 100,\n   66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48, 121,\n   101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99,\n   107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111, 117, 114,\n   115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97,\n   119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110,\n   111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98,\n   105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121,\n   111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117,\n   115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101,\n   100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97,\n   115, 121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116,\n   119, 111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107,\n   110, 111, 119, 116, 104, 97, 116, 75, 117, 114, 116, 86, 111, 110, 110,\n   101, 103, 117, 116, 115, 67, 111, 109, 109, 101, 110, 99, 101, 109, 101,\n   110, 116, 65, 100, 100, 114, 101, 115, 115, 97, 116, 77, 73, 84, 76, 97,\n   100, 105, 101, 115, 97, 110, 100, 103, 101, 110, 116, 108, 101, 109, 101,\n   110, 111, 102, 116, 104, 101, 99, 108, 97, 115, 115, 111, 102, 57, 55, 87,\n   101, 97, 114, 115, 117, 110, 115, 99, 114, 101, 101, 110, 73, 102, 73, 99,\n   111, 117, 108, 100, 111, 102, 102, 101, 114, 121, 111, 117, 111, 110, 108,\n   121, 111, 110, 101, 116, 105, 112, 102, 111, 114, 116, 104, 101, 102, 117,\n   116, 117, 114, 101, 115, 117, 110, 115, 99, 114, 101, 101, 110, 119, 111,\n   117, 108, 100, 98, 101, 105, 116, 84, 104, 101, 108, 111, 110, 103, 116,\n   101, 114, 109, 98, 101, 110, 101, 102, 105, 116, 115, 111, 102, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 104, 97, 118, 101, 98, 101, 101, 110,\n   112, 114, 111, 118, 101, 100, 98, 121, 115, 99, 105, 101, 110, 116, 105,\n   115, 116, 115, 119, 104, 101, 114, 101, 97, 115, 116, 104, 101, 114, 101,\n   115, 116, 111, 102, 109, 121, 97, 100, 118, 105, 99, 101, 104, 97, 115,\n   110, 111, 98, 97, 115, 105, 115, 109, 111, 114, 101, 114, 101, 108, 105,\n   97, 98, 108, 101, 116, 104, 97, 110, 109, 121, 111, 119, 110, 109, 101, 97,\n   110, 100, 101, 114, 105, 110, 103, 101, 120, 112, 101, 114, 105, 101, 110,\n   99, 101, 73, 119, 105, 108, 108, 100, 105, 115, 112, 101, 110, 115, 101,\n   116, 104, 105, 115, 97, 100, 118, 105, 99, 101, 110, 111, 119, 69, 110,\n   106, 111, 121, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98,\n   101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116,\n   104, 79, 104, 110, 101, 118, 101, 114, 109, 105, 110, 100, 89, 111, 117,\n   119, 105, 108, 108, 110, 111, 116, 117, 110, 100, 101, 114, 115, 116, 97,\n   110, 100, 116, 104, 101, 112, 111, 119, 101, 114, 97, 110, 100, 98, 101,\n   97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121, 111, 117, 116, 104,\n   117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101, 102, 97, 100, 101,\n   100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101, 105, 110, 50, 48,\n   121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108, 111, 111, 107, 98,\n   97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111, 102, 121, 111,\n   117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99, 97, 108, 108,\n   105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116, 103, 114, 97,\n   115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104, 112, 111, 115,\n   115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98, 101, 102, 111,\n   114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102, 97, 98, 117,\n   108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108, 121, 108, 111,\n   111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111, 116, 97, 115,\n   102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105, 110, 101, 68,\n   111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117, 116, 116, 104,\n   101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114, 114, 121, 98,\n   117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 115, 117, 110, 115, 99,\n   114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105, 116, 84, 104,\n   101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110, 101, 102, 105,\n   116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101, 110, 104, 97,\n   118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100, 98, 121, 115,\n   99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101, 114, 101, 97,\n   115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121, 97, 100, 118,\n   105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115, 109, 111, 114,\n   101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97, 110, 109, 121,\n   111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110, 103, 101, 120,\n   112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108, 108, 100, 105,\n   115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100, 118, 105, 99,\n   101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101, 112, 111, 119,\n   101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118, 101, 114, 109,\n   105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111, 116, 117, 110,\n   100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112, 111, 119, 101,\n   114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117,\n   114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121,\n   118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116,\n   109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108,\n   108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111,\n   115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114,\n   101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97,\n   110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117,\n   99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97,\n   121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111,\n   119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97,\n   108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101,\n   110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97,\n   103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98,\n   111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119,\n   111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116,\n   110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111, 117, 114, 121,\n   111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101, 121, 118, 101,\n   102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115, 116, 109, 101,\n   105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117, 108, 108, 108,\n   111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104, 111, 116, 111, 115, 111,\n   102, 121, 111, 117, 114, 115, 101, 108, 102, 97, 110, 100, 114, 101, 99,\n   97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111, 117, 99, 97, 110, 116,\n   103, 114, 97, 115, 112, 110, 111, 119, 104, 111, 119, 109, 117, 99, 104,\n   112, 111, 115, 115, 105, 98, 105, 108, 105, 116, 121, 108, 97, 121, 98,\n   101, 102, 111, 114, 101, 121, 111, 117, 97, 110, 100, 104, 111, 119, 102,\n   97, 98, 117, 108, 111, 117, 115, 121, 111, 117, 114, 101, 97, 108, 108,\n   121, 108, 111, 111, 107, 101, 100, 89, 111, 117, 97, 114, 101, 110, 111,\n   116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117, 105, 109, 97, 103, 105,\n   110, 101, 68, 111, 110, 116, 119, 111, 114, 114, 121, 97, 98, 111, 117,\n   116, 116, 104, 101, 102, 117, 116, 117, 114, 101, 79, 114, 119, 111, 114,\n   114, 121, 98, 117, 116, 107, 110, 111, 119, 116, 104, 97, 116, 115, 117,\n   110, 115, 99, 114, 101, 101, 110, 119, 111, 117, 108, 100, 98, 101, 105,\n   116, 84, 104, 101, 108, 111, 110, 103, 116, 101, 114, 109, 98, 101, 110,\n   101, 102, 105, 116, 115, 111, 102, 115, 117, 110, 115, 99, 114, 101, 101,\n   110, 104, 97, 118, 101, 98, 101, 101, 110, 112, 114, 111, 118, 101, 100,\n   98, 121, 115, 99, 105, 101, 110, 116, 105, 115, 116, 115, 119, 104, 101,\n   114, 101, 97, 115, 116, 104, 101, 114, 101, 115, 116, 111, 102, 109, 121,\n   97, 100, 118, 105, 99, 101, 104, 97, 115, 110, 111, 98, 97, 115, 105, 115,\n   109, 111, 114, 101, 114, 101, 108, 105, 97, 98, 108, 101, 116, 104, 97,\n   110, 109, 121, 111, 119, 110, 109, 101, 97, 110, 100, 101, 114, 105, 110,\n   103, 101, 120, 112, 101, 114, 105, 101, 110, 99, 101, 73, 119, 105, 108,\n   108, 100, 105, 115, 112, 101, 110, 115, 101, 116, 104, 105, 115, 97, 100,\n   118, 105, 99, 101, 110, 111, 119, 69, 110, 106, 111, 121, 116, 104, 101,\n   112, 111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111,\n   102, 121, 111, 117, 114, 121, 111, 117, 116, 104, 79, 104, 110, 101, 118,\n   101, 114, 109, 105, 110, 100, 89, 111, 117, 119, 105, 108, 108, 110, 111,\n   116, 117, 110, 100, 101, 114, 115, 116, 97, 110, 100, 116, 104, 101, 112,\n   111, 119, 101, 114, 97, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102,\n   121, 111, 117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116,\n   104, 101, 121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114,\n   117, 115, 116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121,\n   111, 117, 108, 108, 108, 111, 111, 107, 98, 97, 99, 107, 97, 116, 112, 104,\n   111, 116, 111, 115, 111, 102, 121, 111, 117, 114, 115, 101, 108, 102, 97,\n   110, 100, 114, 101, 99, 97, 108, 108, 105, 110, 97, 119, 97, 121, 121, 111,\n   117, 99, 97, 110, 116, 103, 114, 97, 115, 112, 110, 111, 119, 104, 111,\n   119, 109, 117, 99, 104, 112, 111, 115, 115, 105, 98, 105, 108, 105, 116,\n   121, 108, 97, 121, 98, 101, 102, 111, 114, 101, 121, 111, 117, 97, 110,\n   100, 104, 111, 119, 102, 97, 98, 117, 108, 111, 117, 115, 121, 111, 117,\n   114, 101, 97, 108, 108, 121, 108, 111, 111, 107, 101, 100, 89, 111, 117,\n   97, 114, 101, 110, 111, 116, 97, 115, 102, 97, 116, 97, 115, 121, 111, 117,\n   105, 109, 97, 103, 105, 110, 101, 68, 111, 110, 116, 119, 111, 114, 114,\n   121, 97, 98, 111, 117, 116, 116, 104, 101, 102, 117, 116, 117, 114, 101,\n   79, 114, 119, 111, 114, 114, 121, 98, 117, 116, 107, 110, 111, 119, 116,\n   104, 97, 116, 110, 100, 98, 101, 97, 117, 116, 121, 111, 102, 121, 111,\n   117, 114, 121, 111, 117, 116, 104, 117, 110, 116, 105, 108, 116, 104, 101,\n   121, 118, 101, 102, 97, 100, 101, 100, 66, 117, 116, 116, 114, 117, 115,\n   116, 109, 101, 105, 110, 50, 48, 121, 101, 97, 114, 115, 121, 111, 117,\n   108, 108, 108, 111, 111}\n};\nconst int in_i[VSIZE] = { 8192, 8192 };\n#endif /* SHA_H */\n"
      }
    ],
    "code_length": 5083,
    "token_count": 1592,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_ip/sha1_md5_authentication/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3050,
    "Worst-caseLatency": 3050.0,
    "BRAM_18K": 0,
    "LUT": 1931,
    "DSP": 0,
    "FF": 704,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sha1_md5_authentication",
    "ResourceMetric": 0.0004377992,
    "design_id": "project",
    "algo_name": "sha1_md5_authentication",
    "source_name": "rtl_ip",
    "source_code": [
      {
        "file_name": "sha1_md5_authentication.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid sha1_md5_authentication(uint8_t input[DATA_SIZE], uint8_t output[20]) {\n    uint32_t h0 = 0x67452301;\n    uint32_t h1 = 0xEFCDAB89;\n    uint32_t h2 = 0x98BADCFE;\n    uint32_t h3 = 0x10325476;\n    uint32_t h4 = 0xC3D2E1F0;\n\n    uint32_t w[80];\n    uint32_t a, b, c, d, e, f, k, temp;\n\n    for (int i = 0; i < DATA_SIZE; i += 64) {\n        for (int j = 0; j < 16; j++) {\n            w[j] = (input[i + 4 * j] << 24) | (input[i + 4 * j + 1] << 16) | (input[i + 4 * j + 2] << 8) | (input[i + 4 * j + 3]);\n        }\n\n        for (int j = 16; j < 80; j++) {\n            w[j] = (w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16]);\n            w[j] = (w[j] << 1) | (w[j] >> 31);\n        }\n\n        a = h0;\n        b = h1;\n        c = h2;\n        d = h3;\n        e = h4;\n\n        for (int j = 0; j < 80; j++) {\n            if (j < 20) {\n                f = (b & c) | ((~b) & d);\n                k = 0x5A827999;\n            } else if (j < 40) {\n                f = b ^ c ^ d;\n                k = 0x6ED9EBA1;\n            } else if (j < 60) {\n                f = (b & c) | (b & d) | (c & d);\n                k = 0x8F1BBCDC;\n            } else {\n                f = b ^ c ^ d;\n                k = 0xCA62C1D6;\n            }\n\n            temp = ((a << 5) | (a >> 27)) + f + e + k + w[j];\n            e = d;\n            d = c;\n            c = (b << 30) | (b >> 2);\n            b = a;\n            a = temp;\n        }\n\n        h0 += a;\n        h1 += b;\n        h2 += c;\n        h3 += d;\n        h4 += e;\n    }\n\n    output[0] = (h0 >> 24) & 0xFF;\n    output[1] = (h0 >> 16) & 0xFF;\n    output[2] = (h0 >> 8) & 0xFF;\n    output[3] = h0 & 0xFF;\n    output[4] = (h1 >> 24) & 0xFF;\n    output[5] = (h1 >> 16) & 0xFF;\n    output[6] = (h1 >> 8) & 0xFF;\n    output[7] = h1 & 0xFF;\n    output[8] = (h2 >> 24) & 0xFF;\n    output[9] = (h2 >> 16) & 0xFF;\n    output[10] = (h2 >> 8) & 0xFF;\n    output[11] = h2 & 0xFF;\n    output[12] = (h3 >> 24) & 0xFF;\n    output[13] = (h3 >> 16) & 0xFF;\n    output[14] = (h3 >> 8) & 0xFF;\n    output[15] = h3 & 0xFF;\n    output[16] = (h4 >> 24) & 0xFF;\n    output[17] = (h4 >> 16) & 0xFF;\n    output[18] = (h4 >> 8) & 0xFF;\n    output[19] = h4 & 0xFF;\n}\n\n// Top function name: sha1_md5_authentication\n"
      }
    ],
    "code_length": 2250,
    "token_count": 944,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/sha256/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1077,
    "Worst-caseLatency": 1077.0,
    "BRAM_18K": 0,
    "LUT": 55635,
    "DSP": 0,
    "FF": 10984,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sha256",
    "ResourceMetric": 0.01172201,
    "design_id": "project",
    "algo_name": "sha256",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "sha256.cpp",
        "file_content": "#include <stdint.h>\n\n#define INPUT_SIZE 1024\n\nvoid sha256_transform(uint32_t state[8], const uint8_t data[64]) {\n    uint32_t a, b, c, d, e, f, g, h, t1, t2, m[64];\n    const uint32_t k[64] = {\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n    };\n\n    for (int i = 0, j = 0; i < 16; ++i, j += 4)\n        m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);\n    for (int i = 16; i < 64; ++i)\n        m[i] = m[i - 16] + ((m[i - 15] >> 7 | m[i - 15] << (32 - 7)) ^ (m[i - 15] >> 18 | m[i - 15] << (32 - 18)) ^ (m[i - 15] >> 3)) + m[i - 7] + ((m[i - 2] >> 17 | m[i - 2] << (32 - 17)) ^ (m[i - 2] >> 19 | m[i - 2] << (32 - 19)) ^ (m[i - 2] >> 10));\n\n    a = state[0];\n    b = state[1];\n    c = state[2];\n    d = state[3];\n    e = state[4];\n    f = state[5];\n    g = state[6];\n    h = state[7];\n\n    for (int i = 0; i < 64; ++i) {\n        t1 = h + ((e >> 6 | e << (32 - 6)) ^ (e >> 11 | e << (32 - 11)) ^ (e >> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g)) + k[i] + m[i];\n        t2 = ((a >> 2 | a << (32 - 2)) ^ (a >> 13 | a << (32 - 13)) ^ (a >> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c));\n        h = g;\n        g = f;\n        f = e;\n        e = d + t1;\n        d = c;\n        c = b;\n        b = a;\n        a = t1 + t2;\n    }\n\n    state[0] += a;\n    state[1] += b;\n    state[2] += c;\n    state[3] += d;\n    state[4] += e;\n    state[5] += f;\n    state[6] += g;\n    state[7] += h;\n}\n\nvoid sha256(uint8_t hash[32], const uint8_t input[INPUT_SIZE]) {\n    uint32_t state[8] = {\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    };\n    uint8_t data[64];\n    uint32_t bitlen = INPUT_SIZE * 8;\n    int i;\n\n    for (i = 0; i < INPUT_SIZE / 64; ++i)\n        sha256_transform(state, input + i * 64);\n\n    int rem = INPUT_SIZE % 64;\n    for (i = 0; i < rem; ++i)\n        data[i] = input[INPUT_SIZE / 64 * 64 + i];\n    data[rem++] = 0x80;\n    if (rem > 56) {\n        for (i = rem; i < 64; ++i)\n            data[i] = 0;\n        sha256_transform(state, data);\n        rem = 0;\n    }\n    for (i = rem; i < 56; ++i)\n        data[i] = 0;\n    for (i = 0; i < 8; ++i)\n        data[63 - i] = bitlen >> (i * 8);\n    sha256_transform(state, data);\n\n    for (i = 0; i < 8; ++i) {\n        hash[i * 4] = (state[i] >> 24) & 0xff;\n        hash[i * 4 + 1] = (state[i] >> 16) & 0xff;\n        hash[i * 4 + 2] = (state[i] >> 8) & 0xff;\n        hash[i * 4 + 3] = state[i] & 0xff;\n    }\n}\n\n// Top function name: sha256\n"
      }
    ],
    "code_length": 3272,
    "token_count": 1626,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/sharc_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6291476,
    "Worst-caseLatency": 6291476.0,
    "BRAM_18K": 0,
    "LUT": 7557,
    "DSP": 102,
    "FF": 3275,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sharc_processor",
    "ResourceMetric": 0.0045889798,
    "design_id": "project",
    "algo_name": "sharc_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "sharc_processor.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid sharc_processor(float input[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        float temp = input[i];\n        float result = 0.0f;\n        for (int j = 0; j < SIZE; j++) {\n            result += temp * std::sin(j * M_PI / SIZE);\n        }\n        output[i] = result;\n    }\n}\n\n// Top function name: sharc_processor\n"
      }
    ],
    "code_length": 378,
    "token_count": 110,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sharpness_aware_minimization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5180,
    "Worst-caseLatency": 5180.0,
    "BRAM_18K": 8,
    "LUT": 2238,
    "DSP": 13,
    "FF": 2125,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sharpness_aware_minimization",
    "ResourceMetric": 0.0014891023,
    "design_id": "project",
    "algo_name": "sharpness_aware_minimization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sharpness_aware_minimization.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define ARRAY_SIZE 1024\n\nvoid sharpness_aware_minimization(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float epsilon) {\n    float gradient[ARRAY_SIZE];\n    float perturbation[ARRAY_SIZE];\n    float perturbed_input[ARRAY_SIZE];\n    float perturbed_gradient[ARRAY_SIZE];\n\n    // Compute gradient\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        gradient[i] = input[i] * 2; // Example gradient computation\n    }\n\n    // Compute perturbation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        perturbation[i] = epsilon * gradient[i] / (std::sqrt(gradient[i] * gradient[i]) + 1e-8);\n    }\n\n    // Apply perturbation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        perturbed_input[i] = input[i] + perturbation[i];\n    }\n\n    // Compute gradient of perturbed input\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        perturbed_gradient[i] = perturbed_input[i] * 2; // Example gradient computation\n    }\n\n    // Update output\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] - epsilon * (gradient[i] + perturbed_gradient[i]) / 2;\n    }\n}\n\n// Top function name: sharpness_aware_minimization\n"
      }
    ],
    "code_length": 1155,
    "token_count": 319,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 94,
    "DSP": 0,
    "FF": 33,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "shift_register",
    "ResourceMetric": 2.119e-05,
    "design_id": "project",
    "algo_name": "shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid shift_register(ap_uint<8> input[SIZE], ap_uint<8> output[SIZE], bool parallel_output) {\n    ap_uint<8> shift_reg = 0;\n    for (int i = 0; i < SIZE; i++) {\n        shift_reg = (shift_reg << 1) | (input[i] & 0x01);\n        if (parallel_output) {\n            output[i] = shift_reg;\n        } else {\n            output[i] = shift_reg & 0x01;\n        }\n    }\n}\n\n// Top function name: shift_register\n"
      }
    ],
    "code_length": 439,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 117,
    "DSP": 0,
    "FF": 40,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "shift_register",
    "ResourceMetric": 2.62718e-05,
    "design_id": "project",
    "algo_name": "shift_register",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid shift_register(ap_uint<16> input[SIZE], ap_uint<16> output[SIZE]) {\n    ap_uint<16> reg = 0;\n    for (int i = 0; i < SIZE; i++) {\n        reg = (reg << 1) | input[i];\n        output[i] = reg;\n    }\n}\n\n// Top function name: shift_register\n"
      }
    ],
    "code_length": 283,
    "token_count": 92,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/operators/shift_register_2bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "shift_register_2bit",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "shift_register_2bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "shift_register_2bit.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid shift_register_2bit(ap_uint<2> input[SIZE], ap_uint<2> output[SIZE]) {\n    ap_uint<2> reg = 0;\n    for (int i = 0; i < SIZE; i++) {\n        reg = input[i];\n        output[i] = reg;\n    }\n}\n\n// Top function name: shift_register_2bit\n"
      }
    ],
    "code_length": 277,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/shift_register_schmitt_trigger/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3079,
    "Worst-caseLatency": 3079.0,
    "BRAM_18K": 0,
    "LUT": 285,
    "DSP": 0,
    "FF": 111,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "shift_register_schmitt_trigger",
    "ResourceMetric": 6.52959e-05,
    "design_id": "project",
    "algo_name": "shift_register_schmitt_trigger",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "shift_register_schmitt_trigger.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid shift_register_schmitt_trigger(ap_uint<1> input[SIZE], ap_uint<1> output[SIZE]) {\n    ap_uint<1> shift_reg[SIZE];\n    ap_uint<1> schmitt_trigger_state = 0;\n\n    // Initialize shift register\n    for (int i = 0; i < SIZE; i++) {\n        shift_reg[i] = 0;\n    }\n\n    // Process input through shift register with Schmitt-trigger\n    for (int i = 0; i < SIZE; i++) {\n        // Schmitt-trigger logic\n        if (input[i] == 1 && schmitt_trigger_state == 0) {\n            schmitt_trigger_state = 1;\n        } else if (input[i] == 0 && schmitt_trigger_state == 1) {\n            schmitt_trigger_state = 0;\n        }\n\n        // Shift register operation\n        for (int j = SIZE - 1; j > 0; j--) {\n            shift_reg[j] = shift_reg[j - 1];\n        }\n        shift_reg[0] = schmitt_trigger_state;\n\n        // Output register\n        output[i] = shift_reg[SIZE - 1];\n    }\n}\n\n// Top function name: shift_register_schmitt_trigger\n"
      }
    ],
    "code_length": 967,
    "token_count": 276,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/shift_registers/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3082,
    "Worst-caseLatency": 3082.0,
    "BRAM_18K": 2,
    "LUT": 336,
    "DSP": 0,
    "FF": 82,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "shift_registers",
    "ResourceMetric": 0.0001963033,
    "design_id": "project",
    "algo_name": "shift_registers",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "shift_registers.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid shift_registers(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    ap_uint<32> shift_reg[SIZE];\n\n    // Initialize the shift register with input values\n    for (int i = 0; i < SIZE; i++) {\n        shift_reg[i] = input[i];\n    }\n\n    // Shift the values in the register\n    for (int i = 0; i < SIZE - 1; i++) {\n        shift_reg[i] = shift_reg[i + 1];\n    }\n\n    // Output the shifted values\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = shift_reg[i];\n    }\n}\n\n// Top function name: shift_registers\n"
      }
    ],
    "code_length": 560,
    "token_count": 168,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sigmoid_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1051,
    "Worst-caseLatency": 1051.0,
    "BRAM_18K": 0,
    "LUT": 2635,
    "DSP": 29,
    "FF": 1495,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sigmoid_normalization",
    "ResourceMetric": 0.0014520577,
    "design_id": "project",
    "algo_name": "sigmoid_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sigmoid_normalization.cpp",
        "file_content": "#include <cmath>\n\n#define SIZE 1024\n\nvoid sigmoid_normalization(float input[SIZE], float output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = 1.0 / (1.0 + exp(-input[i]));\n    }\n}\n\n// Top function name: sigmoid_normalization\n"
      }
    ],
    "code_length": 245,
    "token_count": 73,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/simple_data_driven/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 232,
    "DSP": 0,
    "FF": 18,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "odds_and_evens",
    "ResourceMetric": 4.62153e-05,
    "design_id": "project",
    "algo_name": "simple_data_driven",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"hls_task.h\"\n\n#define N 10\n\nvoid odds_and_evens(hls::stream<int>& in, hls::stream<int>& out1,\n                    hls::stream<int>& out2);\n\nvoid splitter(hls::stream<int>& in, hls::stream<int>& odds_buf,\n              hls::stream<int>& evens_buf) {\n    int data = in.read();\n    if (data % 2 == 0)\n        evens_buf.write(data);\n    else\n        odds_buf.write(data);\n}\n\nvoid odds(hls::stream<int>& in, hls::stream<int>& out) {\n    out.write(in.read() + 1);\n}\n\nvoid evens(hls::stream<int>& in, hls::stream<int>& out) {\n    out.write(in.read() + 2);\n}\n\nvoid odds_and_evens(hls::stream<int>& in, hls::stream<int>& out1,\n                    hls::stream<int>& out2) {\n    hls_thread_local hls::stream<int, N / 2> s1; // channel connecting t1 and t2\n    hls_thread_local hls::stream<int, N / 2> s2; // channel connecting t1 and t3\n\n    // t1 infinitely runs func1, with input in and outputs s1 and s2\n    hls_thread_local hls::task t1(splitter, in, s1, s2);\n\n    // t2 infinitely runs func2, with input s1 and output out1\n    hls_thread_local hls::task t2(odds, s1, out1);\n\n    // t3 infinitely runs func3, with input s2 and output out2\n    hls_thread_local hls::task t3(evens, s2, out2);\n}\n"
      }
    ],
    "code_length": 2581,
    "token_count": 693,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/simple_fifos/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 308,
    "Worst-caseLatency": 308.0,
    "BRAM_18K": 0,
    "LUT": 489,
    "DSP": 0,
    "FF": 102,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "diamond",
    "ResourceMetric": 0.000103553,
    "design_id": "project",
    "algo_name": "simple_fifos",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define N 100\ntypedef unsigned char data_t;\n\n// Top function\nvoid diamond(data_t vecIn[N], data_t vecOut[N]);\n\n// Sub functions\nvoid funcA(data_t f1In[N], data_t f1Out[N], data_t f1bisOut[N]);\nvoid funcB(data_t f2In[N], data_t f2Out[N]);\nvoid funcC(data_t f3In[N], data_t f3Out[N]);\nvoid funcD(data_t f4In[N], data_t f4bisIn[N], data_t f4Out[N]);\n\nvoid diamond(data_t vecIn[N], data_t vecOut[N]) {\n    data_t c1[N], c2[N], c3[N], c4[N];\n#pragma HLS dataflow\n    funcA(vecIn, c1, c2);\n    funcB(c1, c3);\n    funcC(c2, c4);\n    funcD(c3, c4, vecOut);\n}\n\nvoid funcA(data_t* in, data_t* out1, data_t* out2) {\n#pragma HLS inline off\nLoop0:\n    for (int i = 0; i < N; i++) {\n        data_t t = in[i] * 3;\n        out1[i] = t;\n        out2[i] = t;\n    }\n}\n\nvoid funcB(data_t* in, data_t* out) {\n#pragma HLS inline off\nLoop0:\n    for (int i = 0; i < N; i++) {\n        out[i] = in[i] + 25;\n    }\n}\n\nvoid funcC(data_t* in, data_t* out) {\n#pragma HLS inline off\nLoop0:\n    for (data_t i = 0; i < N; i++) {\n        out[i] = in[i] * 2;\n    }\n}\n\nvoid funcD(data_t* in1, data_t* in2, data_t* out) {\n#pragma HLS inline off\nLoop0:\n    for (int i = 0; i < N; i++) {\n        out[i] = in1[i] + in2[i] * 2;\n    }\n}\n"
      }
    ],
    "code_length": 2582,
    "token_count": 762,
    "pragma_number": 5,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/simplified_srs_3d_sound_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1073741832,
    "Worst-caseLatency": 1073741832.0,
    "BRAM_18K": 0,
    "LUT": 1546,
    "DSP": 5,
    "FF": 641,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "simplified_srs_3d_sound_processor",
    "ResourceMetric": 0.0004964486,
    "design_id": "project",
    "algo_name": "simplified_srs_3d_sound_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "simplified_srs_3d_sound_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define SIZE 1024\n\nvoid simplified_srs_3d_sound_processor(float input[SIZE][SIZE][SIZE], float output[SIZE][SIZE][SIZE], float gain, float delay) {\n    int i, j, k;\n    float delayed_sample;\n    int delay_samples = static_cast<int>(delay);\n\n    for (i = 0; i < SIZE; i++) {\n        for (j = 0; j < SIZE; j++) {\n            for (k = 0; k < SIZE; k++) {\n                if (i >= delay_samples) {\n                    delayed_sample = input[i - delay_samples][j][k];\n                } else {\n                    delayed_sample = 0.0f;\n                }\n                output[i][j][k] = gain * (input[i][j][k] + delayed_sample);\n            }\n        }\n    }\n}\n\n// Top function name: simplified_srs_3d_sound_processor\n"
      }
    ],
    "code_length": 751,
    "token_count": 200,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/single_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1029,
    "Worst-caseLatency": 1029.0,
    "BRAM_18K": 0,
    "LUT": 207,
    "DSP": 0,
    "FF": 68,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "single_comparator",
    "ResourceMetric": 4.62153e-05,
    "design_id": "project",
    "algo_name": "single_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "single_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid single_comparator(ap_int<16> input_array[ARRAY_SIZE], ap_int<16> &max_value) {\n    max_value = input_array[0];\n    for (int i = 1; i < ARRAY_SIZE; i++) {\n        if (input_array[i] > max_value) {\n            max_value = input_array[i];\n        }\n    }\n}\n\n// Top function name: single_comparator\n"
      }
    ],
    "code_length": 346,
    "token_count": 98,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/leetcode_hls_algorithms/single_number_problem/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 132,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "single_number_problem",
    "ResourceMetric": 2.97236e-05,
    "design_id": "project",
    "algo_name": "single_number_problem",
    "source_name": "leetcode_hls_algorithms",
    "source_code": [
      {
        "file_name": "single_number_problem.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid single_number_problem(ap_int<32> input_array[ARRAY_SIZE], ap_int<32> &result) {\n    result = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        result ^= input_array[i];\n    }\n}\n\n// Top function name: single_number_problem\n"
      }
    ],
    "code_length": 277,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/single_supply_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "single_supply_comparator",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "single_supply_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "single_supply_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid single_supply_comparator(ap_int<16> input1[SIZE], ap_int<16> input2[SIZE], ap_int<1> output[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = (input1[i] > input2[i]) ? 1 : 0;\n    }\n}\n\n// Top function name: single_supply_comparator\n"
      }
    ],
    "code_length": 292,
    "token_count": 98,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/sipo_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 157,
    "DSP": 0,
    "FF": 27,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sipo_shift_register",
    "ResourceMetric": 3.26959e-05,
    "design_id": "project",
    "algo_name": "sipo_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "sipo_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid sipo_shift_register(ap_uint<1> serial_in, ap_uint<1> parallel_out[SIZE]) {\n    for (int i = SIZE - 1; i > 0; i--) {\n        parallel_out[i] = parallel_out[i - 1];\n    }\n    parallel_out[0] = serial_in;\n}\n\n// Top function name: sipo_shift_register\n"
      }
    ],
    "code_length": 292,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/sipo_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1025,
    "Worst-caseLatency": 1025.0,
    "BRAM_18K": 0,
    "LUT": 11954,
    "DSP": 0,
    "FF": 14,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sipo_shift_register",
    "ResourceMetric": 0.0022936994,
    "design_id": "project",
    "algo_name": "sipo_shift_register",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "sipo_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid sipo_shift_register(ap_uint<1> input, ap_uint<1> output[SIZE]) {\n    #pragma HLS ARRAY_PARTITION variable=output complete dim=1\n    for (int i = SIZE - 1; i > 0; --i) {\n        output[i] = output[i - 1];\n    }\n    output[0] = input;\n}\n\n// Top function name: sipo_shift_register\n"
      }
    ],
    "code_length": 323,
    "token_count": 99,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/siso_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3079,
    "Worst-caseLatency": 3079.0,
    "BRAM_18K": 0,
    "LUT": 285,
    "DSP": 0,
    "FF": 111,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "siso_shift_register",
    "ResourceMetric": 6.52959e-05,
    "design_id": "project",
    "algo_name": "siso_shift_register",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "siso_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid siso_shift_register(ap_uint<1> input[SIZE], ap_uint<1> output[SIZE]) {\n    ap_uint<1> shift_reg[SIZE];\n\n    // Initialize the shift register with zeros\n    for (int i = 0; i < SIZE; i++) {\n        shift_reg[i] = 0;\n    }\n\n    // Perform the shift register operation\n    for (int i = 0; i < SIZE; i++) {\n        // Shift the register\n        for (int j = SIZE - 1; j > 0; j--) {\n            shift_reg[j] = shift_reg[j - 1];\n        }\n        // Insert the new input bit\n        shift_reg[0] = input[i];\n        // Output the last bit of the shift register\n        output[i] = shift_reg[SIZE - 1];\n    }\n}\n\n// Top function name: siso_shift_register\n"
      }
    ],
    "code_length": 692,
    "token_count": 202,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/slam/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048683,
    "Worst-caseLatency": 1048683.0,
    "BRAM_18K": 0,
    "LUT": 2711,
    "DSP": 10,
    "FF": 1025,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "slam",
    "ResourceMetric": 0.000895193,
    "design_id": "project",
    "algo_name": "slam",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "slam.cpp",
        "file_content": "#include <cmath>\n\n#define MAP_SIZE 1024\n#define NUM_LANDMARKS 100\n\nvoid slam(float robot_pose[3], float landmarks[NUM_LANDMARKS][2], float measurements[NUM_LANDMARKS][2], float map[MAP_SIZE][MAP_SIZE]) {\n    int i, j;\n\n    // Initialize the map with zeros\n    for (i = 0; i < MAP_SIZE; i++) {\n        for (j = 0; j < MAP_SIZE; j++) {\n            map[i][j] = 0.0f;\n        }\n    }\n\n    // Update the robot pose based on measurements\n    for (i = 0; i < NUM_LANDMARKS; i++) {\n        float dx = measurements[i][0] - robot_pose[0];\n        float dy = measurements[i][1] - robot_pose[1];\n        float distance = std::sqrt(dx * dx + dy * dy);\n\n        if (distance < 1.0f) {\n            robot_pose[0] += dx * 0.1f;\n            robot_pose[1] += dy * 0.1f;\n        }\n    }\n\n    // Update the map with landmarks\n    for (i = 0; i < NUM_LANDMARKS; i++) {\n        int x = static_cast<int>(landmarks[i][0]);\n        int y = static_cast<int>(landmarks[i][1]);\n\n        if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {\n            map[x][y] = 1.0f;\n        }\n    }\n}\n\n// Top function name: slam\n"
      }
    ],
    "code_length": 1090,
    "token_count": 345,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/sliding_window_protocol/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1040,
    "Worst-caseLatency": 1040.0,
    "BRAM_18K": 0,
    "LUT": 460,
    "DSP": 0,
    "FF": 263,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sliding_window_protocol",
    "ResourceMetric": 0.0001134289,
    "design_id": "project",
    "algo_name": "sliding_window_protocol",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "sliding_window_protocol.cpp",
        "file_content": "#include <iostream>\n\n#define WINDOW_SIZE 8\n#define BUFFER_SIZE 1024\n\nvoid sliding_window_protocol(int input[BUFFER_SIZE], int output[BUFFER_SIZE]) {\n    int window[WINDOW_SIZE];\n    int i, j;\n\n    // Initialize the window\n    for (i = 0; i < WINDOW_SIZE; i++) {\n        window[i] = 0;\n    }\n\n    // Process the input data with the sliding window\n    for (i = 0; i < BUFFER_SIZE; i++) {\n        // Shift the window\n        for (j = WINDOW_SIZE - 1; j > 0; j--) {\n            window[j] = window[j - 1];\n        }\n        // Insert the new element into the window\n        window[0] = input[i];\n\n        // Compute the output as the sum of the window elements\n        int sum = 0;\n        for (j = 0; j < WINDOW_SIZE; j++) {\n            sum += window[j];\n        }\n        output[i] = sum;\n    }\n}\n\n// Top function name: sliding_window_protocol\n"
      }
    ],
    "code_length": 841,
    "token_count": 226,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/sobel_edge_detection/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4199398,
    "Worst-caseLatency": 4199398.0,
    "BRAM_18K": 0,
    "LUT": 1662,
    "DSP": 2,
    "FF": 553,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sobel_edge_detection",
    "ResourceMetric": 0.000427144,
    "design_id": "project",
    "algo_name": "sobel_edge_detection",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "sobel_edge_detection.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid sobel_edge_detection(uint8_t input_image[IMG_HEIGHT][IMG_WIDTH], uint8_t output_image[IMG_HEIGHT][IMG_WIDTH]) {\n    int gx, gy;\n    int sobel_x[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    int sobel_y[3][3] = {\n        {-1, -2, -1},\n        {0, 0, 0},\n        {1, 2, 1}\n    };\n\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            gx = 0;\n            gy = 0;\n            for (int x = -1; x <= 1; x++) {\n                for (int y = -1; y <= 1; y++) {\n                    gx += input_image[i + x][j + y] * sobel_x[x + 1][y + 1];\n                    gy += input_image[i + x][j + y] * sobel_y[x + 1][y + 1];\n                }\n            }\n            int magnitude = sqrt(gx * gx + gy * gy);\n            if (magnitude > 255) magnitude = 255;\n            output_image[i][j] = (uint8_t)magnitude;\n        }\n    }\n}\n// Top function name: sobel_edge_detection\n"
      }
    ],
    "code_length": 1035,
    "token_count": 347,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sobel_edge_detection/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4200420,
    "Worst-caseLatency": 4200420.0,
    "BRAM_18K": 0,
    "LUT": 1662,
    "DSP": 2,
    "FF": 585,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sobel_edge_detection",
    "ResourceMetric": 0.0004302122,
    "design_id": "project",
    "algo_name": "sobel_edge_detection",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sobel_edge_detection.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define IMG_WIDTH 1024\n#define IMG_HEIGHT 1024\n\nvoid sobel_edge_detection(uint8_t input_image[IMG_HEIGHT][IMG_WIDTH], uint8_t output_image[IMG_HEIGHT][IMG_WIDTH]) {\n    int gx, gy;\n    int sobel_x[3][3] = {\n        {-1, 0, 1},\n        {-2, 0, 2},\n        {-1, 0, 1}\n    };\n    int sobel_y[3][3] = {\n        {-1, -2, -1},\n        {0, 0, 0},\n        {1, 2, 1}\n    };\n\n    for (int i = 1; i < IMG_HEIGHT - 1; i++) {\n        for (int j = 1; j < IMG_WIDTH - 1; j++) {\n            gx = 0;\n            gy = 0;\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    gx += input_image[i + k][j + l] * sobel_x[k + 1][l + 1];\n                    gy += input_image[i + k][j + l] * sobel_y[k + 1][l + 1];\n                }\n            }\n            int magnitude = (int) sqrt((float)(gx * gx + gy * gy));\n            if (magnitude > 255) magnitude = 255;\n            output_image[i][j] = (uint8_t) magnitude;\n        }\n    }\n}\n\n// Top function name: sobel_edge_detection\n"
      }
    ],
    "code_length": 1052,
    "token_count": 352,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/softmax_layer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4133,
    "Worst-caseLatency": 4133.0,
    "BRAM_18K": 0,
    "LUT": 1679,
    "DSP": 9,
    "FF": 972,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "softmax_layer",
    "ResourceMetric": 0.000664506,
    "design_id": "project",
    "algo_name": "softmax_layer",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "softmax_layer.cpp",
        "file_content": "#include <cmath>\n#include <hls_math.h>\n\n#define SIZE 1024\n\nvoid softmax_layer(float input[SIZE], float output[SIZE]) {\n    float max_val = input[0];\n    for (int i = 1; i < SIZE; i++) {\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n    }\n\n    float sum_exp = 0.0;\n    for (int i = 0; i < SIZE; i++) {\n        sum_exp += hls::expf(input[i] - max_val);\n    }\n\n    for (int i = 0; i < SIZE; i++) {\n        output[i] = hls::expf(input[i] - max_val) / sum_exp;\n    }\n}\n\n// Top function name: softmax_layer\n"
      }
    ],
    "code_length": 531,
    "token_count": 170,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/sort_radix/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 166289,
    "Worst-caseLatency": 166289.0,
    "BRAM_18K": 0,
    "LUT": 4880,
    "DSP": 0,
    "FF": 2621,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ss_sort",
    "ResourceMetric": 0.0011871203,
    "design_id": "project",
    "algo_name": "sort_radix",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "sort.c",
        "file_content": "/*\nImplementation based on algorithm described in:\nA. Danalis, G. Marin, C. McCurdy, J. S. Meredith, P. C. Roth, K. Spafford, V. Tipparaju, and J. S. Vetter.\nThe scalable heterogeneous computing (shoc) benchmark suite.\nIn Proceedings of the 3rd Workshop on General-Purpose Computation on Graphics Processing Units, 2010\n*/\n\n#include \"sort.h\"\n\nvoid local_scan(int bucket[BUCKETSIZE])\n{\n    int radixID, i, bucket_indx;\n    local_1 : for (radixID=0; radixID<SCAN_RADIX; radixID++) {\n        local_2 : for (i=1; i<SCAN_BLOCK; i++){\n            bucket_indx = radixID*SCAN_BLOCK + i;\n            bucket[bucket_indx] += bucket[bucket_indx-1];\n        }\n    }\n}\n\nvoid sum_scan(int sum[SCAN_RADIX], int bucket[BUCKETSIZE])\n{\n    int radixID, bucket_indx;\n    sum[0] = 0;\n    sum_1 : for (radixID=1; radixID<SCAN_RADIX; radixID++) {\n        bucket_indx = radixID*SCAN_BLOCK - 1;\n        sum[radixID] = sum[radixID-1] + bucket[bucket_indx];\n    }\n}\n\nvoid last_step_scan(int bucket[BUCKETSIZE], int sum[SCAN_RADIX])\n{\n    int radixID, i, bucket_indx;\n    last_1:for (radixID=0; radixID<SCAN_RADIX; radixID++) {\n        last_2:for (i=0; i<SCAN_BLOCK; i++) {\n            bucket_indx = radixID * SCAN_BLOCK + i;\n            bucket[bucket_indx] = bucket[bucket_indx] + sum[radixID];\n         }\n    }\n}\n\nvoid init(int bucket[BUCKETSIZE])\n{\n    int i;\n    init_1 : for (i=0; i<BUCKETSIZE; i++) {\n        bucket[i] = 0;\n    }\n}\n\nvoid hist(int bucket[BUCKETSIZE], int a[SIZE], int exp)\n{\n    int blockID, i, bucket_indx, a_indx;\n    blockID = 0;\n    hist_1 : for (blockID=0; blockID<NUMOFBLOCKS; blockID++) {\n        hist_2 : for(i=0; i<4; i++) {\n            a_indx = blockID * ELEMENTSPERBLOCK + i;\n            bucket_indx = ((a[a_indx] >> exp) & 0x3)*NUMOFBLOCKS + blockID + 1;\n            bucket[bucket_indx]++;\n        }\n    }\n}\n\nvoid update(int b[SIZE], int bucket[BUCKETSIZE], int a[SIZE], int exp)\n{\n    int i, blockID, bucket_indx, a_indx;\n    blockID = 0;\n\n    update_1 : for (blockID = 0; blockID < NUMOFBLOCKS; blockID++) {\n        update_2 : for(i=0; i<4; i++) {\n            bucket_indx = ((a[blockID * ELEMENTSPERBLOCK + i] >> exp) & 0x3)*NUMOFBLOCKS + blockID;\n            a_indx = blockID * ELEMENTSPERBLOCK + i;\n            b[bucket[bucket_indx]] = a[a_indx];\n            bucket[bucket_indx]++;\n        }\n    }\n}\n\nvoid ss_sort(int a[SIZE], int b[SIZE], int bucket[BUCKETSIZE], int sum[SCAN_RADIX]){\n    int exp=0;\n    int valid_buffer=0;\n    #define BUFFER_A 0\n    #define BUFFER_B 1\n\n    sort_1 : for (exp=0; exp<32; exp+=2) {\n        init(bucket);\n        if (valid_buffer == BUFFER_A) {\n            hist(bucket, a, exp);\n        } else {\n            hist(bucket, b, exp);\n        }\n\n        local_scan(bucket);\n        sum_scan(sum, bucket);\n        last_step_scan(bucket, sum);\n\n        if (valid_buffer==BUFFER_A) {\n            update(b, bucket, a, exp);\n            valid_buffer = BUFFER_B;\n        } else {\n            update(a, bucket, b, exp);\n            valid_buffer = BUFFER_A;\n        }\n    }\n    // If trip count is even, buffer A will be valid at the end.\n}\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "sort.h",
        "file_content": "/*\nImplementation based on algorithm described in:\nA. Danalis, G. Marin, C. McCurdy, J. S. Meredith, P. C. Roth, K. Spafford, V. Tipparaju, and J. S. Vetter.\nThe scalable heterogeneous computing (shoc) benchmark suite.\nIn Proceedings of the 3rd Workshop on General-Purpose Computation on Graphics Processing Units, 2010\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"support.h\"\n\n#define TYPE int32_t\n#define TYPE_MAX INT32_MAX\n\n#define SIZE 2048\n#define NUMOFBLOCKS 512\n\n#define ELEMENTSPERBLOCK 4\n#define RADIXSIZE 4\n#define BUCKETSIZE NUMOFBLOCKS*RADIXSIZE\n#define MASK 0x3\n\n#define SCAN_BLOCK 16\n#define SCAN_RADIX BUCKETSIZE/SCAN_BLOCK\n\nvoid ss_sort(int a[SIZE], int b[SIZE], int bucket[BUCKETSIZE], int sum[SCAN_RADIX]);\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  int a[SIZE];\n  int b[SIZE];\n  int bucket[BUCKETSIZE];\n  int sum[SCAN_RADIX];\n};\n"
      }
    ],
    "code_length": 3070,
    "token_count": 929,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/sound_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1036,
    "Worst-caseLatency": 1036.0,
    "BRAM_18K": 0,
    "LUT": 905,
    "DSP": 13,
    "FF": 1042,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sound_processor",
    "ResourceMetric": 0.0006336074,
    "design_id": "project",
    "algo_name": "sound_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "sound_processor.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n\nvoid sound_processor(float input[N], float output[N]) {\n    float gain = 1.5;\n    float threshold = 0.8;\n    float attack = 0.01;\n    float release = 0.1;\n    \n    float envelope = 0.0;\n    \n    for (int i = 0; i < N; i++) {\n        // Apply gain\n        float processed_sample = input[i] * gain;\n\n        // Simple compressor\n        if (processed_sample > threshold) {\n            processed_sample = threshold + (processed_sample - threshold) * attack;\n        } else {\n            processed_sample = processed_sample * release;\n        }\n\n        // Envelope follower\n        if (processed_sample > envelope) {\n            envelope = processed_sample;\n        } else {\n            envelope *= release;\n        }\n\n        // Output the processed sample\n        output[i] = processed_sample;\n    }\n}\n\n// Top function name: sound_processor\n"
      }
    ],
    "code_length": 894,
    "token_count": 207,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rosetta/spam-filter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 18491531,
    "Worst-caseLatency": 18492726.0,
    "BRAM_18K": 10,
    "LUT": 5574,
    "DSP": 8,
    "FF": 880,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "SgdLR",
    "ResourceMetric": 0.0019949447,
    "design_id": "project",
    "algo_name": "spam-filter",
    "source_name": "rosetta",
    "source_code": [
      {
        "file_name": "sgd.cpp",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          typedefs.h                           */\n/*                                                               */\n/*              Constant definitions and typedefs.               */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\n\n\n\n// dataset information\nconst int NUM_FEATURES  = 1024;\nconst int NUM_SAMPLES   = 5000;\nconst int NUM_TRAINING  = 4500;\nconst int NUM_TESTING   = 500;\nconst int STEP_SIZE     = 60000; \nconst int NUM_EPOCHS    = 5;\nconst int DATA_SET_SIZE = NUM_FEATURES * NUM_SAMPLES;\n\n#ifdef OCL\n  #include <string>\n  // target device\n  // change here to map to a different device\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n// datatypes for accelerator\n\n#ifndef SW\n  #ifdef SDSOC\n    // embedded platforms have less off-chip bandwidth\n    #define VFTYPE_WIDTH  64\n    #define VDTYPE_WIDTH  64\n  #else\n    // take advantage of the off-chip bandwidth of ocl platforms\n    #define VFTYPE_WIDTH  512\n    #define VDTYPE_WIDTH  512\n  #endif\n\n  #include \"ap_int.h\"\n  #include \"ap_fixed.h\"\n  // features / parameters\n  #define FTYPE_TWIDTH 32\n  #define FTYPE_IWIDTH 13\n  typedef ap_fixed<FTYPE_TWIDTH,FTYPE_IWIDTH> FeatureType;\n  typedef ap_uint<VFTYPE_WIDTH>               VectorFeatureType;\n  const unsigned int F_VECTOR_SIZE = VFTYPE_WIDTH / FTYPE_TWIDTH;\n  // training data\n  #define DTYPE_TWIDTH 16\n  #define DTYPE_IWIDTH 4\n  typedef ap_fixed<DTYPE_TWIDTH,DTYPE_IWIDTH>  DataType;\n  typedef ap_uint<VDTYPE_WIDTH>                VectorDataType;\n  const unsigned int D_VECTOR_SIZE = VDTYPE_WIDTH / DTYPE_TWIDTH;\n  // label\n  #define LTYPE_WIDTH   8\n  #define VLTYPE_WIDTH  32\n  typedef ap_uint<LTYPE_WIDTH>                 LabelType;\n  typedef ap_uint<VLTYPE_WIDTH>                VectorLabelType;\n  const unsigned int L_VECTOR_SIZE = VLTYPE_WIDTH / LTYPE_WIDTH;\n  \n  // datatypes for the LUT\n  #define LUTOUT_TWIDTH     12\n  #define LUTOUT_IWIDTH     2\n  #define LUTIN_TWIDTH      12\n  #define LUTIN_IWIDTH      4\n  typedef ap_ufixed<32, 20> TmpFixed; \n  typedef ap_uint<LUTIN_TWIDTH> IdxFixed; \n  typedef ap_fixed<LUTIN_TWIDTH, LUTIN_IWIDTH> LutInFixed;\n  typedef ap_fixed<LUTOUT_TWIDTH, LUTOUT_IWIDTH> LutOutFixed;\n#else\n  // software version uses C++ built-in datatypes\n  typedef float FeatureType;\n  typedef float DataType;\n  typedef unsigned char LabelType;\n  // and uses math functions to compute sigmoid values\n  // no need to declare special datatype for sigmoid\n#endif\n\n#define PAR_FACTOR 32\n\n#endif\n\n/*===============================================================*/\n/*                                                               */\n/*                          sgd.cpp                              */\n/*                                                               */\n/*             Hardware function for spam filtering.             */\n/*                                                               */\n/*===============================================================*/\n\n#include \"sgd.h\"\n#include \"lut.h\"\n\n// wrapper for the streamin part\n// prevent incorrect flattening\nvoid read_data(VectorDataType  data[NUM_FEATURES / D_VECTOR_SIZE], \n               DataType        training_instance[NUM_FEATURES])\n{\n  #pragma HLS INLINE\n\n  READ_TRAINING_DATA: for (int i = 0; i < NUM_FEATURES / D_VECTOR_SIZE; i ++ )\n  {\n\n    VectorFeatureType tmp_data = data[i];\n    READ_TRAINING_DATA_INNER: for (int j = 0; j < D_VECTOR_SIZE; j ++ )\n      training_instance[i * D_VECTOR_SIZE + j].range(DTYPE_TWIDTH-1, 0) = tmp_data.range((j+1)*DTYPE_TWIDTH-1, j*DTYPE_TWIDTH);\n  }\n}\n\n// Function to compute the dot product of data (feature) vector and parameter vector\nFeatureType dotProduct(FeatureType param[NUM_FEATURES],\n                       DataType    feature[NUM_FEATURES])\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n  \n\n\n\n  FeatureType result = 0;\n  DOT: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n\n    DOT_INNER: for(int j = 0; j < PAR_FACTOR; j++) \n    {\n      FeatureType term = param[i*PAR_FACTOR+j] * feature[i*PAR_FACTOR+j];\n      result += term;\n    }\n  }\n  return result;\n}\n\n// values of sigmoid function stored in a look-up table\nFeatureType useLUT(FeatureType in) \n{ \n  #pragma HLS INLINE\n  IdxFixed index;\n  if (in < 0)\n  {\n    in = -in;\n    index = (IdxFixed)LUT_SIZE - (IdxFixed)(((TmpFixed)in) << (LUTIN_TWIDTH - LUTIN_IWIDTH));  \n  } \n  else \n    index = ((TmpFixed)in) << (LUTIN_TWIDTH - LUTIN_IWIDTH);  \n  return lut[index];\n}\n\n// Function to compute the probability. The Sigmoid function is implemented using BRAMS \n// to store the value of Sigmoid function for values relevant to this application\nFeatureType Sigmoid(FeatureType exponent) \n{\n  #pragma HLS INLINE\n  if (exponent > 4) \n    return 1.0;\n  else if (exponent < -4) \n    return 0.0;\n  else \n  {\n    LutInFixed inLut = (LutInFixed)exponent;\n    return useLUT(inLut);\n  } \n}\n\n// Compute the gradient of the cost function\nvoid computeGradient(\n    FeatureType grad[NUM_FEATURES],\n    DataType    feature[NUM_FEATURES],\n    FeatureType scale)\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n\n\n  GRAD: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n\n    GRAD_INNER: for (int j = 0; j < PAR_FACTOR; j++)\n      grad[i*PAR_FACTOR+j] = (scale * feature[i*PAR_FACTOR+j]);\n  }\n}\n\n// Update the parameter vector\nvoid updateParameter(\n    FeatureType param[NUM_FEATURES],\n    FeatureType grad[NUM_FEATURES],\n    FeatureType scale)\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n\n\n\n  UPDATE: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n\n    UPDATE_INNER: for (int j = 0; j < PAR_FACTOR; j++)\n      param[i*PAR_FACTOR+j] += scale * grad[i*PAR_FACTOR+j];\n  }\n}\n\n// stream out the data\nvoid streamOut(FeatureType theta_local[NUM_FEATURES], VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE])\n{\n  #pragma HLS INLINE\n  // stream out the result\n  STREAM_OUT: for (int i = 0; i < NUM_FEATURES / F_VECTOR_SIZE; i ++ )\n  {\n\n    VectorFeatureType tmp_theta = 0;\n    STREAM_OUT_INNER: for (int j = 0; j < F_VECTOR_SIZE; j ++ )\n      tmp_theta.range((j+1)*FTYPE_TWIDTH-1, j*FTYPE_TWIDTH) = theta_local[i * F_VECTOR_SIZE + j].range(FTYPE_TWIDTH-1, 0);\n    theta[i] = tmp_theta;\n  }\n\n}\n\n// wrapper, wraps the compute part for dataflow\nvoid compute(FeatureType theta_local[NUM_FEATURES], \n             LabelType training_label,\n             DataType training_instance[NUM_FEATURES])\n{\n  // array for storing gradient\n  FeatureType gradient[NUM_FEATURES];\n\n  // step size\n  FeatureType step = STEP_SIZE;\n\n  // do dot product with the parameter vector\n  FeatureType dot = dotProduct(theta_local, training_instance);\n  // do sigmoid function\n  FeatureType prob = Sigmoid(dot);\n  // compute gradient\n  computeGradient(gradient, training_instance, (prob-training_label));\n  // update the param vector\n  updateParameter(theta_local, gradient, -step);\n}\n\n\n\n// top-level function \nvoid SgdLR( VectorDataType    data[NUM_FEATURES * NUM_TRAINING / D_VECTOR_SIZE],\n            VectorLabelType   label[NUM_TRAINING / L_VECTOR_SIZE],\n            VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE],\n            bool readLabels,\n            bool writeOutput)\n{\n  // intermediate variables \n\n  // local version of the parameters\n  static FeatureType theta_local[NUM_FEATURES];\n  // local buffer of labels\n  static LabelType   label_local[NUM_TRAINING];\n\n  // array for storing one training instance\n  static DataType training_instance[NUM_FEATURES];\n\n  if (readLabels)\n  {\n    // copy in labels\n    LABEL_CP: for (int i = 0; i < NUM_TRAINING / L_VECTOR_SIZE; i ++ )\n    {\n\n      VectorLabelType tmp_label = label[i];\n      LABEL_CP_INNER: for (int j = 0; j < L_VECTOR_SIZE; j ++ )\n        label_local[i * L_VECTOR_SIZE + j].range(LTYPE_WIDTH-1, 0) = tmp_label.range((j+1)*LTYPE_WIDTH-1, j*LTYPE_WIDTH);\n    }\n  }\n\n  // main loop\n  // in each epoch, go through each training instance in sequence\n  TRAINING_INST: for( int training_id = 0; training_id < NUM_TRAINING; training_id ++ )\n  {  \n    #pragma HLS dataflow\n    // get the label\n    LabelType training_label = label_local[training_id];\n    // first reads in the training instance\n    read_data(data + training_id * NUM_FEATURES / D_VECTOR_SIZE, training_instance);\n    // compute part\n    compute(theta_local, training_label, training_instance);\n  }\n\n  if (writeOutput)\n    streamOut(theta_local, theta);\n}\n"
      },
      {
        "file_name": "sgd.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                            sgd.h                              */\n/*                                                               */\n/*          Top-level hardware function declaration              */\n/*                                                               */\n/*===============================================================*/\n\n#include \"typedefs.h\"\n\n// top-level function declaration\n#pragma SDS data mem_attribute(data:NON_CACHEABLE|PHYSICAL_CONTIGUOUS, label:CACHEABLE|PHYSICAL_CONTIGUOUS, theta:CACHEABLE|PHYSICAL_CONTIGUOUS)\n#pragma SDS data data_mover(data:AXIDMA_SG, label:AXIFIFO, theta:AXIDMA_SG)\n#pragma SDS data sys_port(data:AFI, label:AFI, theta:AFI)\n#pragma SDS data zero_copy(theta[0:NUM_FEATURES / F_VECTOR_SIZE])\n#pragma SDS data copy(data[0:NUM_FEATURES * NUM_TRAINING/D_VECTOR_SIZE])\n#pragma SDS data zero_copy(label[0:NUM_TRAINING/L_VECTOR_SIZE])\n#pragma SDS data access_pattern(data:SEQUENTIAL, label:SEQUENTIAL, theta:SEQUENTIAL) \nvoid SgdLR( VectorDataType    data[NUM_FEATURES * NUM_TRAINING / D_VECTOR_SIZE],\n            VectorLabelType   label[NUM_TRAINING / L_VECTOR_SIZE],\n            VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE],\n            bool readLabels,\n            bool writeOutput);\n\n"
      },
      {
        "file_name": "typedefs.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                          typedefs.h                           */\n/*                                                               */\n/*              Constant definitions and typedefs.               */\n/*                                                               */\n/*===============================================================*/\n\n#ifndef __TYPEDEFS_H__\n#define __TYPEDEFS_H__\n\n\n\n// dataset information\nconst int NUM_FEATURES  = 1024;\nconst int NUM_SAMPLES   = 5000;\nconst int NUM_TRAINING  = 4500;\nconst int NUM_TESTING   = 500;\nconst int STEP_SIZE     = 60000; \nconst int NUM_EPOCHS    = 5;\nconst int DATA_SET_SIZE = NUM_FEATURES * NUM_SAMPLES;\n\n#ifdef OCL\n  #include <string>\n  // target device\n  // change here to map to a different device\n  const std::string TARGET_DEVICE = \"xilinx_aws-vu9p-f1-04261818_dynamic_5_0\";\n#endif\n\n// datatypes for accelerator\n\n#ifndef SW\n  #ifdef SDSOC\n    // embedded platforms have less off-chip bandwidth\n    #define VFTYPE_WIDTH  64\n    #define VDTYPE_WIDTH  64\n  #else\n    // take advantage of the off-chip bandwidth of ocl platforms\n    #define VFTYPE_WIDTH  512\n    #define VDTYPE_WIDTH  512\n  #endif\n\n  #include \"ap_int.h\"\n  #include \"ap_fixed.h\"\n  // features / parameters\n  #define FTYPE_TWIDTH 32\n  #define FTYPE_IWIDTH 13\n  typedef ap_fixed<FTYPE_TWIDTH,FTYPE_IWIDTH> FeatureType;\n  typedef ap_uint<VFTYPE_WIDTH>               VectorFeatureType;\n  const unsigned int F_VECTOR_SIZE = VFTYPE_WIDTH / FTYPE_TWIDTH;\n  // training data\n  #define DTYPE_TWIDTH 16\n  #define DTYPE_IWIDTH 4\n  typedef ap_fixed<DTYPE_TWIDTH,DTYPE_IWIDTH>  DataType;\n  typedef ap_uint<VDTYPE_WIDTH>                VectorDataType;\n  const unsigned int D_VECTOR_SIZE = VDTYPE_WIDTH / DTYPE_TWIDTH;\n  // label\n  #define LTYPE_WIDTH   8\n  #define VLTYPE_WIDTH  32\n  typedef ap_uint<LTYPE_WIDTH>                 LabelType;\n  typedef ap_uint<VLTYPE_WIDTH>                VectorLabelType;\n  const unsigned int L_VECTOR_SIZE = VLTYPE_WIDTH / LTYPE_WIDTH;\n  \n  // datatypes for the LUT\n  #define LUTOUT_TWIDTH     12\n  #define LUTOUT_IWIDTH     2\n  #define LUTIN_TWIDTH      12\n  #define LUTIN_IWIDTH      4\n  typedef ap_ufixed<32, 20> TmpFixed; \n  typedef ap_uint<LUTIN_TWIDTH> IdxFixed; \n  typedef ap_fixed<LUTIN_TWIDTH, LUTIN_IWIDTH> LutInFixed;\n  typedef ap_fixed<LUTOUT_TWIDTH, LUTOUT_IWIDTH> LutOutFixed;\n#else\n  // software version uses C++ built-in datatypes\n  typedef float FeatureType;\n  typedef float DataType;\n  typedef unsigned char LabelType;\n  // and uses math functions to compute sigmoid values\n  // no need to declare special datatype for sigmoid\n#endif\n\n#define PAR_FACTOR 32\n\n#endif\n"
      },
      {
        "file_name": "lut.h",
        "file_content": "/*===============================================================*/\n/*                                                               */\n/*                            lut.h                              */\n/*                                                               */\n/*          Stores the look-up table for sigmoid function.       */\n/*                                                               */\n/*===============================================================*/\n\n\nconst int LUT_SIZE = 2048;\nstatic const LutOutFixed lut[LUT_SIZE] = {\n\t0.500000,\n\t0.500977,\n\t0.501953,\n\t0.502930,\n\t0.503906,\n\t0.504883,\n\t0.505859,\n\t0.506836,\n\t0.507812,\n\t0.508789,\n\t0.509766,\n\t0.510742,\n\t0.511719,\n\t0.512695,\n\t0.513672,\n\t0.514648,\n\t0.515625,\n\t0.516602,\n\t0.517578,\n\t0.518555,\n\t0.519531,\n\t0.520508,\n\t0.521484,\n\t0.522461,\n\t0.523438,\n\t0.524414,\n\t0.525391,\n\t0.526367,\n\t0.527344,\n\t0.528320,\n\t0.529297,\n\t0.530273,\n\t0.531250,\n\t0.532227,\n\t0.533203,\n\t0.534180,\n\t0.535156,\n\t0.536133,\n\t0.537109,\n\t0.538086,\n\t0.539062,\n\t0.540039,\n\t0.541016,\n\t0.541992,\n\t0.542969,\n\t0.543945,\n\t0.544922,\n\t0.545898,\n\t0.546875,\n\t0.547852,\n\t0.548828,\n\t0.549805,\n\t0.550781,\n\t0.551758,\n\t0.552734,\n\t0.553711,\n\t0.554688,\n\t0.555664,\n\t0.556641,\n\t0.557617,\n\t0.558594,\n\t0.559570,\n\t0.560547,\n\t0.561523,\n\t0.562500,\n\t0.563477,\n\t0.564453,\n\t0.565430,\n\t0.566406,\n\t0.567383,\n\t0.568359,\n\t0.569336,\n\t0.570312,\n\t0.571289,\n\t0.572266,\n\t0.573242,\n\t0.574219,\n\t0.575195,\n\t0.576172,\n\t0.577148,\n\t0.578125,\n\t0.579102,\n\t0.580078,\n\t0.581055,\n\t0.582031,\n\t0.583008,\n\t0.583984,\n\t0.584961,\n\t0.585938,\n\t0.586914,\n\t0.587891,\n\t0.588867,\n\t0.588867,\n\t0.589844,\n\t0.590820,\n\t0.591797,\n\t0.592773,\n\t0.593750,\n\t0.594727,\n\t0.595703,\n\t0.596680,\n\t0.597656,\n\t0.598633,\n\t0.599609,\n\t0.600586,\n\t0.601562,\n\t0.602539,\n\t0.603516,\n\t0.604492,\n\t0.605469,\n\t0.606445,\n\t0.607422,\n\t0.608398,\n\t0.609375,\n\t0.610352,\n\t0.611328,\n\t0.612305,\n\t0.612305,\n\t0.613281,\n\t0.614258,\n\t0.615234,\n\t0.616211,\n\t0.617188,\n\t0.618164,\n\t0.619141,\n\t0.620117,\n\t0.621094,\n\t0.622070,\n\t0.623047,\n\t0.624023,\n\t0.625000,\n\t0.625977,\n\t0.626953,\n\t0.627930,\n\t0.627930,\n\t0.628906,\n\t0.629883,\n\t0.630859,\n\t0.631836,\n\t0.632812,\n\t0.633789,\n\t0.634766,\n\t0.635742,\n\t0.636719,\n\t0.637695,\n\t0.638672,\n\t0.639648,\n\t0.640625,\n\t0.640625,\n\t0.641602,\n\t0.642578,\n\t0.643555,\n\t0.644531,\n\t0.645508,\n\t0.646484,\n\t0.647461,\n\t0.648438,\n\t0.649414,\n\t0.650391,\n\t0.650391,\n\t0.651367,\n\t0.652344,\n\t0.653320,\n\t0.654297,\n\t0.655273,\n\t0.656250,\n\t0.657227,\n\t0.658203,\n\t0.659180,\n\t0.660156,\n\t0.660156,\n\t0.661133,\n\t0.662109,\n\t0.663086,\n\t0.664062,\n\t0.665039,\n\t0.666016,\n\t0.666992,\n\t0.667969,\n\t0.667969,\n\t0.668945,\n\t0.669922,\n\t0.670898,\n\t0.671875,\n\t0.672852,\n\t0.673828,\n\t0.674805,\n\t0.674805,\n\t0.675781,\n\t0.676758,\n\t0.677734,\n\t0.678711,\n\t0.679688,\n\t0.680664,\n\t0.681641,\n\t0.681641,\n\t0.682617,\n\t0.683594,\n\t0.684570,\n\t0.685547,\n\t0.686523,\n\t0.687500,\n\t0.687500,\n\t0.688477,\n\t0.689453,\n\t0.690430,\n\t0.691406,\n\t0.692383,\n\t0.693359,\n\t0.693359,\n\t0.694336,\n\t0.695312,\n\t0.696289,\n\t0.697266,\n\t0.698242,\n\t0.699219,\n\t0.699219,\n\t0.700195,\n\t0.701172,\n\t0.702148,\n\t0.703125,\n\t0.704102,\n\t0.704102,\n\t0.705078,\n\t0.706055,\n\t0.707031,\n\t0.708008,\n\t0.708984,\n\t0.708984,\n\t0.709961,\n\t0.710938,\n\t0.711914,\n\t0.712891,\n\t0.712891,\n\t0.713867,\n\t0.714844,\n\t0.715820,\n\t0.716797,\n\t0.717773,\n\t0.717773,\n\t0.718750,\n\t0.719727,\n\t0.720703,\n\t0.721680,\n\t0.721680,\n\t0.722656,\n\t0.723633,\n\t0.724609,\n\t0.725586,\n\t0.725586,\n\t0.726562,\n\t0.727539,\n\t0.728516,\n\t0.729492,\n\t0.729492,\n\t0.730469,\n\t0.731445,\n\t0.732422,\n\t0.732422,\n\t0.733398,\n\t0.734375,\n\t0.735352,\n\t0.736328,\n\t0.736328,\n\t0.737305,\n\t0.738281,\n\t0.739258,\n\t0.739258,\n\t0.740234,\n\t0.741211,\n\t0.742188,\n\t0.743164,\n\t0.743164,\n\t0.744141,\n\t0.745117,\n\t0.746094,\n\t0.746094,\n\t0.747070,\n\t0.748047,\n\t0.749023,\n\t0.749023,\n\t0.750000,\n\t0.750977,\n\t0.751953,\n\t0.751953,\n\t0.752930,\n\t0.753906,\n\t0.754883,\n\t0.754883,\n\t0.755859,\n\t0.756836,\n\t0.756836,\n\t0.757812,\n\t0.758789,\n\t0.759766,\n\t0.759766,\n\t0.760742,\n\t0.761719,\n\t0.762695,\n\t0.762695,\n\t0.763672,\n\t0.764648,\n\t0.764648,\n\t0.765625,\n\t0.766602,\n\t0.767578,\n\t0.767578,\n\t0.768555,\n\t0.769531,\n\t0.769531,\n\t0.770508,\n\t0.771484,\n\t0.772461,\n\t0.772461,\n\t0.773438,\n\t0.774414,\n\t0.774414,\n\t0.775391,\n\t0.776367,\n\t0.776367,\n\t0.777344,\n\t0.778320,\n\t0.779297,\n\t0.779297,\n\t0.780273,\n\t0.781250,\n\t0.781250,\n\t0.782227,\n\t0.783203,\n\t0.783203,\n\t0.784180,\n\t0.785156,\n\t0.785156,\n\t0.786133,\n\t0.787109,\n\t0.787109,\n\t0.788086,\n\t0.789062,\n\t0.789062,\n\t0.790039,\n\t0.791016,\n\t0.791016,\n\t0.791992,\n\t0.792969,\n\t0.792969,\n\t0.793945,\n\t0.794922,\n\t0.794922,\n\t0.795898,\n\t0.796875,\n\t0.796875,\n\t0.797852,\n\t0.797852,\n\t0.798828,\n\t0.799805,\n\t0.799805,\n\t0.800781,\n\t0.801758,\n\t0.801758,\n\t0.802734,\n\t0.803711,\n\t0.803711,\n\t0.804688,\n\t0.804688,\n\t0.805664,\n\t0.806641,\n\t0.806641,\n\t0.807617,\n\t0.808594,\n\t0.808594,\n\t0.809570,\n\t0.809570,\n\t0.810547,\n\t0.811523,\n\t0.811523,\n\t0.812500,\n\t0.812500,\n\t0.813477,\n\t0.814453,\n\t0.814453,\n\t0.815430,\n\t0.816406,\n\t0.816406,\n\t0.817383,\n\t0.817383,\n\t0.818359,\n\t0.818359,\n\t0.819336,\n\t0.820312,\n\t0.820312,\n\t0.821289,\n\t0.821289,\n\t0.822266,\n\t0.823242,\n\t0.823242,\n\t0.824219,\n\t0.824219,\n\t0.825195,\n\t0.825195,\n\t0.826172,\n\t0.827148,\n\t0.827148,\n\t0.828125,\n\t0.828125,\n\t0.829102,\n\t0.829102,\n\t0.830078,\n\t0.831055,\n\t0.831055,\n\t0.832031,\n\t0.832031,\n\t0.833008,\n\t0.833008,\n\t0.833984,\n\t0.833984,\n\t0.834961,\n\t0.835938,\n\t0.835938,\n\t0.836914,\n\t0.836914,\n\t0.837891,\n\t0.837891,\n\t0.838867,\n\t0.838867,\n\t0.839844,\n\t0.839844,\n\t0.840820,\n\t0.841797,\n\t0.841797,\n\t0.842773,\n\t0.842773,\n\t0.843750,\n\t0.843750,\n\t0.844727,\n\t0.844727,\n\t0.845703,\n\t0.845703,\n\t0.846680,\n\t0.846680,\n\t0.847656,\n\t0.847656,\n\t0.848633,\n\t0.848633,\n\t0.849609,\n\t0.849609,\n\t0.850586,\n\t0.850586,\n\t0.851562,\n\t0.851562,\n\t0.852539,\n\t0.852539,\n\t0.853516,\n\t0.853516,\n\t0.854492,\n\t0.854492,\n\t0.855469,\n\t0.855469,\n\t0.856445,\n\t0.856445,\n\t0.857422,\n\t0.857422,\n\t0.858398,\n\t0.858398,\n\t0.859375,\n\t0.859375,\n\t0.860352,\n\t0.860352,\n\t0.861328,\n\t0.861328,\n\t0.862305,\n\t0.862305,\n\t0.863281,\n\t0.863281,\n\t0.864258,\n\t0.864258,\n\t0.864258,\n\t0.865234,\n\t0.865234,\n\t0.866211,\n\t0.866211,\n\t0.867188,\n\t0.867188,\n\t0.868164,\n\t0.868164,\n\t0.869141,\n\t0.869141,\n\t0.870117,\n\t0.870117,\n\t0.870117,\n\t0.871094,\n\t0.871094,\n\t0.872070,\n\t0.872070,\n\t0.873047,\n\t0.873047,\n\t0.874023,\n\t0.874023,\n\t0.874023,\n\t0.875000,\n\t0.875000,\n\t0.875977,\n\t0.875977,\n\t0.876953,\n\t0.876953,\n\t0.876953,\n\t0.877930,\n\t0.877930,\n\t0.878906,\n\t0.878906,\n\t0.879883,\n\t0.879883,\n\t0.879883,\n\t0.880859,\n\t0.880859,\n\t0.881836,\n\t0.881836,\n\t0.882812,\n\t0.882812,\n\t0.882812,\n\t0.883789,\n\t0.883789,\n\t0.884766,\n\t0.884766,\n\t0.884766,\n\t0.885742,\n\t0.885742,\n\t0.886719,\n\t0.886719,\n\t0.886719,\n\t0.887695,\n\t0.887695,\n\t0.888672,\n\t0.888672,\n\t0.888672,\n\t0.889648,\n\t0.889648,\n\t0.890625,\n\t0.890625,\n\t0.890625,\n\t0.891602,\n\t0.891602,\n\t0.891602,\n\t0.892578,\n\t0.892578,\n\t0.893555,\n\t0.893555,\n\t0.893555,\n\t0.894531,\n\t0.894531,\n\t0.895508,\n\t0.895508,\n\t0.895508,\n\t0.896484,\n\t0.896484,\n\t0.896484,\n\t0.897461,\n\t0.897461,\n\t0.897461,\n\t0.898438,\n\t0.898438,\n\t0.899414,\n\t0.899414,\n\t0.899414,\n\t0.900391,\n\t0.900391,\n\t0.900391,\n\t0.901367,\n\t0.901367,\n\t0.901367,\n\t0.902344,\n\t0.902344,\n\t0.902344,\n\t0.903320,\n\t0.903320,\n\t0.904297,\n\t0.904297,\n\t0.904297,\n\t0.905273,\n\t0.905273,\n\t0.905273,\n\t0.906250,\n\t0.906250,\n\t0.906250,\n\t0.907227,\n\t0.907227,\n\t0.907227,\n\t0.908203,\n\t0.908203,\n\t0.908203,\n\t0.909180,\n\t0.909180,\n\t0.909180,\n\t0.910156,\n\t0.910156,\n\t0.910156,\n\t0.911133,\n\t0.911133,\n\t0.911133,\n\t0.912109,\n\t0.912109,\n\t0.912109,\n\t0.912109,\n\t0.913086,\n\t0.913086,\n\t0.913086,\n\t0.914062,\n\t0.914062,\n\t0.914062,\n\t0.915039,\n\t0.915039,\n\t0.915039,\n\t0.916016,\n\t0.916016,\n\t0.916016,\n\t0.916992,\n\t0.916992,\n\t0.916992,\n\t0.916992,\n\t0.917969,\n\t0.917969,\n\t0.917969,\n\t0.918945,\n\t0.918945,\n\t0.918945,\n\t0.919922,\n\t0.919922,\n\t0.919922,\n\t0.919922,\n\t0.920898,\n\t0.920898,\n\t0.920898,\n\t0.921875,\n\t0.921875,\n\t0.921875,\n\t0.921875,\n\t0.922852,\n\t0.922852,\n\t0.922852,\n\t0.923828,\n\t0.923828,\n\t0.923828,\n\t0.923828,\n\t0.924805,\n\t0.924805,\n\t0.924805,\n\t0.924805,\n\t0.925781,\n\t0.925781,\n\t0.925781,\n\t0.926758,\n\t0.926758,\n\t0.926758,\n\t0.926758,\n\t0.927734,\n\t0.927734,\n\t0.927734,\n\t0.927734,\n\t0.928711,\n\t0.928711,\n\t0.928711,\n\t0.929688,\n\t0.929688,\n\t0.929688,\n\t0.929688,\n\t0.930664,\n\t0.930664,\n\t0.930664,\n\t0.930664,\n\t0.931641,\n\t0.931641,\n\t0.931641,\n\t0.931641,\n\t0.932617,\n\t0.932617,\n\t0.932617,\n\t0.932617,\n\t0.933594,\n\t0.933594,\n\t0.933594,\n\t0.933594,\n\t0.934570,\n\t0.934570,\n\t0.934570,\n\t0.934570,\n\t0.935547,\n\t0.935547,\n\t0.935547,\n\t0.935547,\n\t0.935547,\n\t0.936523,\n\t0.936523,\n\t0.936523,\n\t0.936523,\n\t0.937500,\n\t0.937500,\n\t0.937500,\n\t0.937500,\n\t0.938477,\n\t0.938477,\n\t0.938477,\n\t0.938477,\n\t0.939453,\n\t0.939453,\n\t0.939453,\n\t0.939453,\n\t0.939453,\n\t0.940430,\n\t0.940430,\n\t0.940430,\n\t0.940430,\n\t0.941406,\n\t0.941406,\n\t0.941406,\n\t0.941406,\n\t0.941406,\n\t0.942383,\n\t0.942383,\n\t0.942383,\n\t0.942383,\n\t0.942383,\n\t0.943359,\n\t0.943359,\n\t0.943359,\n\t0.943359,\n\t0.944336,\n\t0.944336,\n\t0.944336,\n\t0.944336,\n\t0.944336,\n\t0.945312,\n\t0.945312,\n\t0.945312,\n\t0.945312,\n\t0.945312,\n\t0.946289,\n\t0.946289,\n\t0.946289,\n\t0.946289,\n\t0.946289,\n\t0.947266,\n\t0.947266,\n\t0.947266,\n\t0.947266,\n\t0.947266,\n\t0.948242,\n\t0.948242,\n\t0.948242,\n\t0.948242,\n\t0.948242,\n\t0.949219,\n\t0.949219,\n\t0.949219,\n\t0.949219,\n\t0.949219,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.950195,\n\t0.951172,\n\t0.951172,\n\t0.951172,\n\t0.951172,\n\t0.951172,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.952148,\n\t0.953125,\n\t0.953125,\n\t0.953125,\n\t0.953125,\n\t0.953125,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.954102,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.955078,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.956055,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.957031,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958008,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.958984,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.959961,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.960938,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.961914,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.962891,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.963867,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.964844,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.965820,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.966797,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.967773,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.968750,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.969727,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.970703,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.971680,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.972656,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.973633,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.974609,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.975586,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.976562,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.977539,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.978516,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.979492,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.980469,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.981445,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.017578,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.018555,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.019531,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.020508,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.021484,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.022461,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.023438,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.024414,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.025391,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.026367,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.027344,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.028320,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.029297,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.030273,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.031250,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.032227,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.033203,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.034180,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.035156,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.036133,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.037109,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.038086,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.039062,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.040039,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041016,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.041992,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.042969,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.043945,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.044922,\n\t0.045898,\n\t0.045898,\n\t0.045898,\n\t0.045898,\n\t0.045898,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.046875,\n\t0.047852,\n\t0.047852,\n\t0.047852,\n\t0.047852,\n\t0.047852,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.048828,\n\t0.049805,\n\t0.049805,\n\t0.049805,\n\t0.049805,\n\t0.049805,\n\t0.050781,\n\t0.050781,\n\t0.050781,\n\t0.050781,\n\t0.050781,\n\t0.051758,\n\t0.051758,\n\t0.051758,\n\t0.051758,\n\t0.051758,\n\t0.052734,\n\t0.052734,\n\t0.052734,\n\t0.052734,\n\t0.052734,\n\t0.053711,\n\t0.053711,\n\t0.053711,\n\t0.053711,\n\t0.053711,\n\t0.054688,\n\t0.054688,\n\t0.054688,\n\t0.054688,\n\t0.054688,\n\t0.055664,\n\t0.055664,\n\t0.055664,\n\t0.055664,\n\t0.056641,\n\t0.056641,\n\t0.056641,\n\t0.056641,\n\t0.056641,\n\t0.057617,\n\t0.057617,\n\t0.057617,\n\t0.057617,\n\t0.057617,\n\t0.058594,\n\t0.058594,\n\t0.058594,\n\t0.058594,\n\t0.059570,\n\t0.059570,\n\t0.059570,\n\t0.059570,\n\t0.059570,\n\t0.060547,\n\t0.060547,\n\t0.060547,\n\t0.060547,\n\t0.061523,\n\t0.061523,\n\t0.061523,\n\t0.061523,\n\t0.062500,\n\t0.062500,\n\t0.062500,\n\t0.062500,\n\t0.063477,\n\t0.063477,\n\t0.063477,\n\t0.063477,\n\t0.063477,\n\t0.064453,\n\t0.064453,\n\t0.064453,\n\t0.064453,\n\t0.065430,\n\t0.065430,\n\t0.065430,\n\t0.065430,\n\t0.066406,\n\t0.066406,\n\t0.066406,\n\t0.066406,\n\t0.067383,\n\t0.067383,\n\t0.067383,\n\t0.067383,\n\t0.068359,\n\t0.068359,\n\t0.068359,\n\t0.068359,\n\t0.069336,\n\t0.069336,\n\t0.069336,\n\t0.069336,\n\t0.070312,\n\t0.070312,\n\t0.070312,\n\t0.071289,\n\t0.071289,\n\t0.071289,\n\t0.071289,\n\t0.072266,\n\t0.072266,\n\t0.072266,\n\t0.072266,\n\t0.073242,\n\t0.073242,\n\t0.073242,\n\t0.074219,\n\t0.074219,\n\t0.074219,\n\t0.074219,\n\t0.075195,\n\t0.075195,\n\t0.075195,\n\t0.075195,\n\t0.076172,\n\t0.076172,\n\t0.076172,\n\t0.077148,\n\t0.077148,\n\t0.077148,\n\t0.077148,\n\t0.078125,\n\t0.078125,\n\t0.078125,\n\t0.079102,\n\t0.079102,\n\t0.079102,\n\t0.079102,\n\t0.080078,\n\t0.080078,\n\t0.080078,\n\t0.081055,\n\t0.081055,\n\t0.081055,\n\t0.082031,\n\t0.082031,\n\t0.082031,\n\t0.082031,\n\t0.083008,\n\t0.083008,\n\t0.083008,\n\t0.083984,\n\t0.083984,\n\t0.083984,\n\t0.084961,\n\t0.084961,\n\t0.084961,\n\t0.085938,\n\t0.085938,\n\t0.085938,\n\t0.086914,\n\t0.086914,\n\t0.086914,\n\t0.086914,\n\t0.087891,\n\t0.087891,\n\t0.087891,\n\t0.088867,\n\t0.088867,\n\t0.088867,\n\t0.089844,\n\t0.089844,\n\t0.089844,\n\t0.090820,\n\t0.090820,\n\t0.090820,\n\t0.091797,\n\t0.091797,\n\t0.091797,\n\t0.092773,\n\t0.092773,\n\t0.092773,\n\t0.093750,\n\t0.093750,\n\t0.093750,\n\t0.094727,\n\t0.094727,\n\t0.094727,\n\t0.095703,\n\t0.095703,\n\t0.096680,\n\t0.096680,\n\t0.096680,\n\t0.097656,\n\t0.097656,\n\t0.097656,\n\t0.098633,\n\t0.098633,\n\t0.098633,\n\t0.099609,\n\t0.099609,\n\t0.099609,\n\t0.100586,\n\t0.100586,\n\t0.101562,\n\t0.101562,\n\t0.101562,\n\t0.102539,\n\t0.102539,\n\t0.102539,\n\t0.103516,\n\t0.103516,\n\t0.103516,\n\t0.104492,\n\t0.104492,\n\t0.105469,\n\t0.105469,\n\t0.105469,\n\t0.106445,\n\t0.106445,\n\t0.107422,\n\t0.107422,\n\t0.107422,\n\t0.108398,\n\t0.108398,\n\t0.108398,\n\t0.109375,\n\t0.109375,\n\t0.110352,\n\t0.110352,\n\t0.110352,\n\t0.111328,\n\t0.111328,\n\t0.112305,\n\t0.112305,\n\t0.112305,\n\t0.113281,\n\t0.113281,\n\t0.114258,\n\t0.114258,\n\t0.114258,\n\t0.115234,\n\t0.115234,\n\t0.116211,\n\t0.116211,\n\t0.116211,\n\t0.117188,\n\t0.117188,\n\t0.118164,\n\t0.118164,\n\t0.119141,\n\t0.119141,\n\t0.119141,\n\t0.120117,\n\t0.120117,\n\t0.121094,\n\t0.121094,\n\t0.122070,\n\t0.122070,\n\t0.122070,\n\t0.123047,\n\t0.123047,\n\t0.124023,\n\t0.124023,\n\t0.125000,\n\t0.125000,\n\t0.125000,\n\t0.125977,\n\t0.125977,\n\t0.126953,\n\t0.126953,\n\t0.127930,\n\t0.127930,\n\t0.128906,\n\t0.128906,\n\t0.128906,\n\t0.129883,\n\t0.129883,\n\t0.130859,\n\t0.130859,\n\t0.131836,\n\t0.131836,\n\t0.132812,\n\t0.132812,\n\t0.133789,\n\t0.133789,\n\t0.134766,\n\t0.134766,\n\t0.134766,\n\t0.135742,\n\t0.135742,\n\t0.136719,\n\t0.136719,\n\t0.137695,\n\t0.137695,\n\t0.138672,\n\t0.138672,\n\t0.139648,\n\t0.139648,\n\t0.140625,\n\t0.140625,\n\t0.141602,\n\t0.141602,\n\t0.142578,\n\t0.142578,\n\t0.143555,\n\t0.143555,\n\t0.144531,\n\t0.144531,\n\t0.145508,\n\t0.145508,\n\t0.146484,\n\t0.146484,\n\t0.147461,\n\t0.147461,\n\t0.148438,\n\t0.148438,\n\t0.149414,\n\t0.149414,\n\t0.150391,\n\t0.150391,\n\t0.151367,\n\t0.151367,\n\t0.152344,\n\t0.152344,\n\t0.153320,\n\t0.153320,\n\t0.154297,\n\t0.154297,\n\t0.155273,\n\t0.155273,\n\t0.156250,\n\t0.156250,\n\t0.157227,\n\t0.157227,\n\t0.158203,\n\t0.159180,\n\t0.159180,\n\t0.160156,\n\t0.160156,\n\t0.161133,\n\t0.161133,\n\t0.162109,\n\t0.162109,\n\t0.163086,\n\t0.163086,\n\t0.164062,\n\t0.165039,\n\t0.165039,\n\t0.166016,\n\t0.166016,\n\t0.166992,\n\t0.166992,\n\t0.167969,\n\t0.167969,\n\t0.168945,\n\t0.169922,\n\t0.169922,\n\t0.170898,\n\t0.170898,\n\t0.171875,\n\t0.171875,\n\t0.172852,\n\t0.173828,\n\t0.173828,\n\t0.174805,\n\t0.174805,\n\t0.175781,\n\t0.175781,\n\t0.176758,\n\t0.177734,\n\t0.177734,\n\t0.178711,\n\t0.178711,\n\t0.179688,\n\t0.180664,\n\t0.180664,\n\t0.181641,\n\t0.181641,\n\t0.182617,\n\t0.182617,\n\t0.183594,\n\t0.184570,\n\t0.184570,\n\t0.185547,\n\t0.186523,\n\t0.186523,\n\t0.187500,\n\t0.187500,\n\t0.188477,\n\t0.189453,\n\t0.189453,\n\t0.190430,\n\t0.190430,\n\t0.191406,\n\t0.192383,\n\t0.192383,\n\t0.193359,\n\t0.194336,\n\t0.194336,\n\t0.195312,\n\t0.195312,\n\t0.196289,\n\t0.197266,\n\t0.197266,\n\t0.198242,\n\t0.199219,\n\t0.199219,\n\t0.200195,\n\t0.201172,\n\t0.201172,\n\t0.202148,\n\t0.202148,\n\t0.203125,\n\t0.204102,\n\t0.204102,\n\t0.205078,\n\t0.206055,\n\t0.206055,\n\t0.207031,\n\t0.208008,\n\t0.208008,\n\t0.208984,\n\t0.209961,\n\t0.209961,\n\t0.210938,\n\t0.211914,\n\t0.211914,\n\t0.212891,\n\t0.213867,\n\t0.213867,\n\t0.214844,\n\t0.215820,\n\t0.215820,\n\t0.216797,\n\t0.217773,\n\t0.217773,\n\t0.218750,\n\t0.219727,\n\t0.219727,\n\t0.220703,\n\t0.221680,\n\t0.222656,\n\t0.222656,\n\t0.223633,\n\t0.224609,\n\t0.224609,\n\t0.225586,\n\t0.226562,\n\t0.226562,\n\t0.227539,\n\t0.228516,\n\t0.229492,\n\t0.229492,\n\t0.230469,\n\t0.231445,\n\t0.231445,\n\t0.232422,\n\t0.233398,\n\t0.234375,\n\t0.234375,\n\t0.235352,\n\t0.236328,\n\t0.236328,\n\t0.237305,\n\t0.238281,\n\t0.239258,\n\t0.239258,\n\t0.240234,\n\t0.241211,\n\t0.242188,\n\t0.242188,\n\t0.243164,\n\t0.244141,\n\t0.244141,\n\t0.245117,\n\t0.246094,\n\t0.247070,\n\t0.247070,\n\t0.248047,\n\t0.249023,\n\t0.250000,\n\t0.250000,\n\t0.250977,\n\t0.251953,\n\t0.252930,\n\t0.252930,\n\t0.253906,\n\t0.254883,\n\t0.255859,\n\t0.255859,\n\t0.256836,\n\t0.257812,\n\t0.258789,\n\t0.259766,\n\t0.259766,\n\t0.260742,\n\t0.261719,\n\t0.262695,\n\t0.262695,\n\t0.263672,\n\t0.264648,\n\t0.265625,\n\t0.266602,\n\t0.266602,\n\t0.267578,\n\t0.268555,\n\t0.269531,\n\t0.269531,\n\t0.270508,\n\t0.271484,\n\t0.272461,\n\t0.273438,\n\t0.273438,\n\t0.274414,\n\t0.275391,\n\t0.276367,\n\t0.277344,\n\t0.277344,\n\t0.278320,\n\t0.279297,\n\t0.280273,\n\t0.281250,\n\t0.281250,\n\t0.282227,\n\t0.283203,\n\t0.284180,\n\t0.285156,\n\t0.286133,\n\t0.286133,\n\t0.287109,\n\t0.288086,\n\t0.289062,\n\t0.290039,\n\t0.290039,\n\t0.291016,\n\t0.291992,\n\t0.292969,\n\t0.293945,\n\t0.294922,\n\t0.294922,\n\t0.295898,\n\t0.296875,\n\t0.297852,\n\t0.298828,\n\t0.299805,\n\t0.299805,\n\t0.300781,\n\t0.301758,\n\t0.302734,\n\t0.303711,\n\t0.304688,\n\t0.305664,\n\t0.305664,\n\t0.306641,\n\t0.307617,\n\t0.308594,\n\t0.309570,\n\t0.310547,\n\t0.311523,\n\t0.311523,\n\t0.312500,\n\t0.313477,\n\t0.314453,\n\t0.315430,\n\t0.316406,\n\t0.317383,\n\t0.317383,\n\t0.318359,\n\t0.319336,\n\t0.320312,\n\t0.321289,\n\t0.322266,\n\t0.323242,\n\t0.324219,\n\t0.324219,\n\t0.325195,\n\t0.326172,\n\t0.327148,\n\t0.328125,\n\t0.329102,\n\t0.330078,\n\t0.331055,\n\t0.331055,\n\t0.332031,\n\t0.333008,\n\t0.333984,\n\t0.334961,\n\t0.335938,\n\t0.336914,\n\t0.337891,\n\t0.338867,\n\t0.338867,\n\t0.339844,\n\t0.340820,\n\t0.341797,\n\t0.342773,\n\t0.343750,\n\t0.344727,\n\t0.345703,\n\t0.346680,\n\t0.347656,\n\t0.348633,\n\t0.348633,\n\t0.349609,\n\t0.350586,\n\t0.351562,\n\t0.352539,\n\t0.353516,\n\t0.354492,\n\t0.355469,\n\t0.356445,\n\t0.357422,\n\t0.358398,\n\t0.358398,\n\t0.359375,\n\t0.360352,\n\t0.361328,\n\t0.362305,\n\t0.363281,\n\t0.364258,\n\t0.365234,\n\t0.366211,\n\t0.367188,\n\t0.368164,\n\t0.369141,\n\t0.370117,\n\t0.371094,\n\t0.371094,\n\t0.372070,\n\t0.373047,\n\t0.374023,\n\t0.375000,\n\t0.375977,\n\t0.376953,\n\t0.377930,\n\t0.378906,\n\t0.379883,\n\t0.380859,\n\t0.381836,\n\t0.382812,\n\t0.383789,\n\t0.384766,\n\t0.385742,\n\t0.386719,\n\t0.386719,\n\t0.387695,\n\t0.388672,\n\t0.389648,\n\t0.390625,\n\t0.391602,\n\t0.392578,\n\t0.393555,\n\t0.394531,\n\t0.395508,\n\t0.396484,\n\t0.397461,\n\t0.398438,\n\t0.399414,\n\t0.400391,\n\t0.401367,\n\t0.402344,\n\t0.403320,\n\t0.404297,\n\t0.405273,\n\t0.406250,\n\t0.407227,\n\t0.408203,\n\t0.409180,\n\t0.410156,\n\t0.410156,\n\t0.411133,\n\t0.412109,\n\t0.413086,\n\t0.414062,\n\t0.415039,\n\t0.416016,\n\t0.416992,\n\t0.417969,\n\t0.418945,\n\t0.419922,\n\t0.420898,\n\t0.421875,\n\t0.422852,\n\t0.423828,\n\t0.424805,\n\t0.425781,\n\t0.426758,\n\t0.427734,\n\t0.428711,\n\t0.429688,\n\t0.430664,\n\t0.431641,\n\t0.432617,\n\t0.433594,\n\t0.434570,\n\t0.435547,\n\t0.436523,\n\t0.437500,\n\t0.438477,\n\t0.439453,\n\t0.440430,\n\t0.441406,\n\t0.442383,\n\t0.443359,\n\t0.444336,\n\t0.445312,\n\t0.446289,\n\t0.447266,\n\t0.448242,\n\t0.449219,\n\t0.450195,\n\t0.451172,\n\t0.452148,\n\t0.453125,\n\t0.454102,\n\t0.455078,\n\t0.456055,\n\t0.457031,\n\t0.458008,\n\t0.458984,\n\t0.459961,\n\t0.460938,\n\t0.461914,\n\t0.462891,\n\t0.463867,\n\t0.464844,\n\t0.465820,\n\t0.466797,\n\t0.467773,\n\t0.468750,\n\t0.469727,\n\t0.470703,\n\t0.471680,\n\t0.472656,\n\t0.473633,\n\t0.474609,\n\t0.475586,\n\t0.476562,\n\t0.477539,\n\t0.478516,\n\t0.479492,\n\t0.480469,\n\t0.481445,\n\t0.482422,\n\t0.483398,\n\t0.484375,\n\t0.485352,\n\t0.486328,\n\t0.487305,\n\t0.488281,\n\t0.489258,\n\t0.490234,\n\t0.491211,\n\t0.492188,\n\t0.493164,\n\t0.494141,\n\t0.495117,\n\t0.496094,\n\t0.497070,\n\t0.498047,\n\t0.499023\n};\n"
      }
    ],
    "code_length": 8639,
    "token_count": 2208,
    "pragma_number": 15,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sparse_attention/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 102835390,
    "Worst-caseLatency": 102835390.0,
    "BRAM_18K": 2052,
    "LUT": 14116,
    "DSP": 66,
    "FF": 14094,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sparse_attention",
    "ResourceMetric": 0.1331189198,
    "design_id": "project",
    "algo_name": "sparse_attention",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sparse_attention.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n#define D 64\n\nvoid sparse_attention(float query[N][D], float key[N][D], float value[N][D], float output[N][D], float threshold) {\n    float scores[N][N];\n    float max_scores[N];\n    float sum_exp_scores[N];\n\n    // Compute the attention scores\n    for (int i = 0; i < N; i++) {\n        max_scores[i] = -INFINITY;\n        for (int j = 0; j < N; j++) {\n            scores[i][j] = 0;\n            for (int d = 0; d < D; d++) {\n                scores[i][j] += query[i][d] * key[j][d];\n            }\n            if (scores[i][j] > max_scores[i]) {\n                max_scores[i] = scores[i][j];\n            }\n        }\n    }\n\n    // Apply softmax with sparsity\n    for (int i = 0; i < N; i++) {\n        sum_exp_scores[i] = 0;\n        for (int j = 0; j < N; j++) {\n            if (scores[i][j] >= threshold) {\n                scores[i][j] = exp(scores[i][j] - max_scores[i]);\n                sum_exp_scores[i] += scores[i][j];\n            } else {\n                scores[i][j] = 0;\n            }\n        }\n    }\n\n    // Compute the output\n    for (int i = 0; i < N; i++) {\n        for (int d = 0; d < D; d++) {\n            output[i][d] = 0;\n        }\n        for (int j = 0; j < N; j++) {\n            if (scores[i][j] > 0) {\n                for (int d = 0; d < D; d++) {\n                    output[i][d] += scores[i][j] / sum_exp_scores[i] * value[j][d];\n                }\n            }\n        }\n    }\n}\n\n// Top function name: sparse_attention\n"
      }
    ],
    "code_length": 1491,
    "token_count": 444,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/sparse_representations/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 239,
    "DSP": 0,
    "FF": 258,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sparse_representations",
    "ResourceMetric": 7.05695e-05,
    "design_id": "project",
    "algo_name": "sparse_representations",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "sparse_representations.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define SIZE 1024\n\nvoid sparse_representations(float input[SIZE], float output[SIZE], float threshold) {\n    for (int i = 0; i < SIZE; i++) {\n        if (std::abs(input[i]) > threshold) {\n            output[i] = input[i];\n        } else {\n            output[i] = 0.0f;\n        }\n    }\n}\n\n// Top function name: sparse_representations\n"
      }
    ],
    "code_length": 371,
    "token_count": 100,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/speech_recognition_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6295627,
    "Worst-caseLatency": 6295627.0,
    "BRAM_18K": 8,
    "LUT": 10369,
    "DSP": 166,
    "FF": 6555,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "speech_recognition_processor",
    "ResourceMetric": 0.0077117983,
    "design_id": "project",
    "algo_name": "speech_recognition_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "speech_recognition_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid speech_recognition_processor(float input[N], float output[N]) {\n    float mfcc[N];\n    float dct[N];\n    float energy[N];\n    float delta[N];\n    float delta_delta[N];\n\n    // Step 1: MFCC Calculation\n    for (int i = 0; i < N; i++) {\n        mfcc[i] = log(input[i] + 1.0f); // Simplified MFCC calculation\n    }\n\n    // Step 2: Discrete Cosine Transform (DCT)\n    for (int i = 0; i < N; i++) {\n        dct[i] = 0;\n        for (int j = 0; j < N; j++) {\n            dct[i] += mfcc[j] * cos(M_PI * i * (j + 0.5) / N);\n        }\n    }\n\n    // Step 3: Energy Calculation\n    for (int i = 0; i < N; i++) {\n        energy[i] = dct[i] * dct[i];\n    }\n\n    // Step 4: Delta Calculation\n    for (int i = 1; i < N - 1; i++) {\n        delta[i] = (dct[i + 1] - dct[i - 1]) / 2.0f;\n    }\n    delta[0] = delta[1];\n    delta[N - 1] = delta[N - 2];\n\n    // Step 5: Delta-Delta Calculation\n    for (int i = 1; i < N - 1; i++) {\n        delta_delta[i] = (delta[i + 1] - delta[i - 1]) / 2.0f;\n    }\n    delta_delta[0] = delta_delta[1];\n    delta_delta[N - 1] = delta_delta[N - 2];\n\n    // Step 6: Combine Features\n    for (int i = 0; i < N; i++) {\n        output[i] = dct[i] + delta[i] + delta_delta[i];\n    }\n}\n\n// Top function name: speech_recognition_processor\n"
      }
    ],
    "code_length": 1302,
    "token_count": 455,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/spi_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "spi_controller",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "spi_controller",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "spi_controller.cpp",
        "file_content": "#include <stdint.h>\n\n#define DATA_SIZE 1024\n\nvoid spi_controller(uint8_t data_in[DATA_SIZE], uint8_t data_out[DATA_SIZE], uint8_t control[DATA_SIZE]) {\n    uint8_t shift_register = 0;\n    for (int i = 0; i < DATA_SIZE; i++) {\n        // Load data into shift register\n        shift_register = data_in[i];\n        \n        // Simulate SPI transfer\n        for (int bit = 0; bit < 8; bit++) {\n            // Shift out the MSB\n            uint8_t mosi = (shift_register & 0x80) >> 7;\n            shift_register <<= 1;\n            \n            // Simulate receiving data on MISO\n            uint8_t miso = control[i] & (1 << bit) ? 1 : 0;\n            shift_register |= miso;\n        }\n        \n        // Store the received data\n        data_out[i] = shift_register;\n    }\n}\n\n// Top function name: spi_controller\n"
      }
    ],
    "code_length": 808,
    "token_count": 216,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/spi_master_slave_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "spi_master_slave_controller",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "spi_master_slave_controller",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "spi_master_slave_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define DATA_WIDTH 8\n#define ARRAY_SIZE 1024\n\nvoid spi_master_slave_controller(ap_uint<DATA_WIDTH> master_data[ARRAY_SIZE], ap_uint<DATA_WIDTH> slave_data[ARRAY_SIZE], ap_uint<DATA_WIDTH> master_out[ARRAY_SIZE], ap_uint<DATA_WIDTH> slave_out[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        ap_uint<DATA_WIDTH> master_send = master_data[i];\n        ap_uint<DATA_WIDTH> slave_send = slave_data[i];\n        \n        // Simulate SPI data exchange\n        master_out[i] = slave_send;\n        slave_out[i] = master_send;\n    }\n}\n\n// Top function name: spi_master_slave_controller\n"
      }
    ],
    "code_length": 613,
    "token_count": 158,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/split_load_balance/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 18,
    "Worst-caseLatency": 18.0,
    "BRAM_18K": 0,
    "LUT": 442,
    "DSP": 0,
    "FF": 68,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 9.12801e-05,
    "design_id": "project",
    "algo_name": "split_load_balance",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef __SPLIT_LOAD_BALANCE_HH__\n#define __SPLIT_LOAD_BALANCE_HH__\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"ap_int.h\"\n#include \"hls_np_channel.h\"\n#include \"hls_stream.h\"\n\nvoid dut(hls::stream<int>& in1, hls::stream<ap_uint<32>>& out1,\n         hls::stream<ap_uint<32>>& out2, hls::stream<ap_uint<32>>& out3,\n         hls::stream<ap_uint<32>>& out4);\n\n#endif\n\nvoid producer(hls::stream<ap_uint<32>>& out, hls::stream<int>& in) {\n#pragma HLS inline off\n    ap_uint<32> tmp;\n    for (int i = 0; i < 16; i++) {\n        int tmp_d = in.read();\n        out.write(tmp_d);\n    }\n}\n\nvoid consumer1(hls::stream<ap_uint<32>>& in, hls::stream<ap_uint<32>>& out) {\n#pragma HLS inline off\n    for (int i = 0; i < 4; i++) {\n        ap_uint<32> tmp = in.read();\n        out.write(tmp);\n    }\n}\n\nvoid consumer2(hls::stream<ap_uint<32>>& in, hls::stream<ap_uint<32>>& out) {\n#pragma HLS inline off\n    for (int i = 0; i < 4; i++) {\n        ap_uint<32> tmp = in.read();\n        out.write(tmp);\n    }\n}\n\nvoid consumer3(hls::stream<ap_uint<32>>& in, hls::stream<ap_uint<32>>& out) {\n#pragma HLS inline off\n    for (int i = 0; i < 4; i++) {\n        ap_uint<32> tmp = in.read();\n        out.write(tmp);\n    }\n}\n\nvoid consumer4(hls::stream<ap_uint<32>>& in, hls::stream<ap_uint<32>>& out) {\n#pragma HLS inline off\n    for (int i = 0; i < 4; i++) {\n        ap_uint<32> tmp = in.read();\n        out.write(tmp);\n    }\n}\n\nvoid dut(hls::stream<int>& in1, hls::stream<ap_uint<32>>& out1,\n         hls::stream<ap_uint<32>>& out2, hls::stream<ap_uint<32>>& out3,\n         hls::stream<ap_uint<32>>& out4) {\n#pragma HLS dataflow\n\n    hls::split::load_balance<ap_uint<32>, 4, 6> s;\n\n    producer(s.in, in1);\n    consumer1(s.out[0], out1);\n    consumer2(s.out[1], out2);\n    consumer3(s.out[2], out3);\n    consumer4(s.out[3], out4);\n}\n"
      }
    ],
    "code_length": 3154,
    "token_count": 914,
    "pragma_number": 6,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/spmv_crs/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 7411,
    "Worst-caseLatency": 2474941.0,
    "BRAM_18K": 0,
    "LUT": 1133,
    "DSP": 11,
    "FF": 1102,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "spmv",
    "ResourceMetric": 0.0006276749,
    "design_id": "project",
    "algo_name": "spmv_crs",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "spmv.h",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"support.h\"\n\n// These constants valid for the IEEE 494 bus interconnect matrix\n#define NNZ 1666\n#define N 494\n\n#define TYPE double\n\nvoid spmv(TYPE val[NNZ], int32_t cols[NNZ], int32_t rowDelimiters[N + 1],\n          TYPE vec[N], TYPE out[N]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE val[NNZ];\n  int32_t cols[NNZ];\n  int32_t rowDelimiters[N+1];\n  TYPE vec[N];\n  TYPE out[N];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "spmv.c",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include \"spmv.h\"\n\nvoid spmv(TYPE val[NNZ], int32_t cols[NNZ], int32_t rowDelimiters[N+1], TYPE vec[N], TYPE out[N]){\n    int i, j;\n    TYPE sum, Si;\n\n    spmv_1 : for(i = 0; i < N; i++){\n        sum = 0; Si = 0;\n        int tmp_begin = rowDelimiters[i];\n        int tmp_end = rowDelimiters[i+1];\n        spmv_2 : for (j = tmp_begin; j < tmp_end; j++){\n        #pragma HLS loop_tripcount min=1 max=NNZ avg=5\n            Si = val[j] * vec[cols[j]];\n            sum = sum + Si;\n        }\n        out[i] = sum;\n    }\n}\n\n\n"
      }
    ],
    "code_length": 645,
    "token_count": 211,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/spmv_ellpack/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2503,
    "Worst-caseLatency": 2503.0,
    "BRAM_18K": 0,
    "LUT": 2736,
    "DSP": 22,
    "FF": 3335,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "ellpack",
    "ResourceMetric": 0.0014539223,
    "design_id": "project",
    "algo_name": "spmv_ellpack",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "spmv.h",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"support.h\"\n\n// These constants valid for the IEEE 494 bus interconnect matrix\n#define NNZ 1666\n#define N 494\n#define L 10\n\n#define TYPE double\n\nvoid ellpack(TYPE nzval[N*L], int32_t cols[N*L], TYPE vec[N], TYPE out[N]);\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE nzval[N*L];\n  int32_t cols[N*L];\n  TYPE vec[N];\n  TYPE out[N];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "spmv.c",
        "file_content": "/*\nBased on algorithm described here:\nhttp://www.cs.berkeley.edu/~mhoemmen/matrix-seminar/slides/UCB_sparse_tutorial_1.pdf\n*/\n\n#include \"spmv.h\"\n\nvoid ellpack(TYPE nzval[N*L], int32_t cols[N*L], TYPE vec[N], TYPE out[N])\n{\n    int i, j;\n    TYPE Si;\n\n    ellpack_1 : for (i=0; i<N; i++) {\n        TYPE sum = out[i];\n        ellpack_2 : for (j=0; j<L; j++) {\n                Si = nzval[j + i*L] * vec[cols[j + i*L]];\n                sum += Si;\n        }\n        out[i] = sum;\n    }\n}\n"
      }
    ],
    "code_length": 483,
    "token_count": 158,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/spread_spectrum_crystal_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9232,
    "Worst-caseLatency": 9232.0,
    "BRAM_18K": 0,
    "LUT": 7690,
    "DSP": 104,
    "FF": 3241,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "spread_spectrum_crystal_multiplier",
    "ResourceMetric": 0.0046666323,
    "design_id": "project",
    "algo_name": "spread_spectrum_crystal_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "spread_spectrum_crystal_multiplier.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define N 1024\n\nvoid spread_spectrum_crystal_multiplier(float input_signal[N], float output_signal[N], float frequency_multiplier) {\n    float phase = 0.0;\n    float phase_increment = 2 * M_PI * frequency_multiplier / N;\n\n    for (int i = 0; i < N; i++) {\n        output_signal[i] = input_signal[i] * sin(phase);\n        phase += phase_increment;\n        if (phase >= 2 * M_PI) {\n            phase -= 2 * M_PI;\n        }\n    }\n}\n\n// Top function name: spread_spectrum_crystal_multiplier\n"
      }
    ],
    "code_length": 525,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/squeeze_excitation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4136,
    "Worst-caseLatency": 4136.0,
    "BRAM_18K": 0,
    "LUT": 3356,
    "DSP": 34,
    "FF": 1862,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "squeeze_excitation",
    "ResourceMetric": 0.0017640285,
    "design_id": "project",
    "algo_name": "squeeze_excitation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "squeeze_excitation.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid squeeze_excitation(float input[N], float output[N], float scale[N]) {\n    float sum = 0.0;\n    for (int i = 0; i < N; i++) {\n        sum += input[i];\n    }\n\n    float mean = sum / N;\n\n    for (int i = 0; i < N; i++) {\n        scale[i] = 1 / (1 + exp(-mean));\n    }\n\n    for (int i = 0; i < N; i++) {\n        output[i] = input[i] * scale[i];\n    }\n}\n\n// Top function name: squeeze_excitation\n"
      }
    ],
    "code_length": 451,
    "token_count": 145,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/sr_flip_flop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2050,
    "Worst-caseLatency": 2050.0,
    "BRAM_18K": 0,
    "LUT": 316,
    "DSP": 0,
    "FF": 129,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sr_flip_flop",
    "ResourceMetric": 7.29665e-05,
    "design_id": "project",
    "algo_name": "sr_flip_flop",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "sr_flip_flop.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid sr_flip_flop(ap_uint<1> S[SIZE], ap_uint<1> R[SIZE], ap_uint<1> Q[SIZE], ap_uint<1> Qn[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (S[i] == 1 && R[i] == 0) {\n            Q[i] = 1;\n            Qn[i] = 0;\n        } else if (S[i] == 0 && R[i] == 1) {\n            Q[i] = 0;\n            Qn[i] = 1;\n        } else if (S[i] == 0 && R[i] == 0) {\n            // Hold state, Q and Qn remain unchanged\n            if (i > 0) {\n                Q[i] = Q[i-1];\n                Qn[i] = Qn[i-1];\n            } else {\n                Q[i] = 0;\n                Qn[i] = 1;\n            }\n        } else {\n            // Invalid state, set Q and Qn to undefined (0)\n            Q[i] = 0;\n            Qn[i] = 0;\n        }\n    }\n}\n\n// Top function name: sr_flip_flop\n"
      }
    ],
    "code_length": 802,
    "token_count": 280,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/sram_cell/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sram_cell",
    "ResourceMetric": 2.15735e-05,
    "design_id": "project",
    "algo_name": "sram_cell",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "sram_cell.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid sram_cell(uint16_t input_array[ARRAY_SIZE], uint16_t output_array[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Simple operation on SRAM cell\n        output_array[i] = input_array[i] + 1;\n    }\n}\n\n// Top function name: sram_cell\n"
      }
    ],
    "code_length": 303,
    "token_count": 87,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/sram_cell_4bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2057,
    "Worst-caseLatency": 2057.0,
    "BRAM_18K": 1,
    "LUT": 268,
    "DSP": 0,
    "FF": 114,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "sram_cell_4bit",
    "ResourceMetric": 0.0001243275,
    "design_id": "project",
    "algo_name": "sram_cell_4bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "sram_cell_4bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid sram_cell_4bit(uint8_t data_in[ARRAY_SIZE], uint8_t address[ARRAY_SIZE], uint8_t write_enable[ARRAY_SIZE], uint8_t data_out[ARRAY_SIZE]) {\n    uint8_t sram[ARRAY_SIZE] = {0};\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (write_enable[i]) {\n            sram[address[i]] = data_in[i] & 0x0F; // Store only 4 bits\n        } else {\n            data_out[i] = sram[address[i]] & 0x0F; // Read only 4 bits\n        }\n    }\n}\n\n// Top function name: sram_cell_4bit\n"
      }
    ],
    "code_length": 516,
    "token_count": 167,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/srt_divider/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1032,
    "Worst-caseLatency": 1032.0,
    "BRAM_18K": 0,
    "LUT": 6710,
    "DSP": 0,
    "FF": 2677,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "srt_divider",
    "ResourceMetric": 0.0015434194,
    "design_id": "project",
    "algo_name": "srt_divider",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "srt_divider.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid srt_divider(ap_uint<32> dividend[N], ap_uint<32> divisor[N], ap_uint<32> quotient[N], ap_uint<32> remainder[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<32> q = 0;\n        ap_uint<32> r = 0;\n        ap_uint<32> d = dividend[i];\n        ap_uint<32> v = divisor[i];\n\n        for (int j = 31; j >= 0; j--) {\n            r = (r << 1) | ((d >> j) & 1);\n            if (r >= v) {\n                r = r - v;\n                q = q | (1 << j);\n            }\n        }\n        quotient[i] = q;\n        remainder[i] = r;\n    }\n}\n\n// Top function name: srt_divider\n"
      }
    ],
    "code_length": 606,
    "token_count": 202,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/standardization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5159,
    "Worst-caseLatency": 5159.0,
    "BRAM_18K": 0,
    "LUT": 962,
    "DSP": 5,
    "FF": 922,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "standardization",
    "ResourceMetric": 0.0004114009,
    "design_id": "project",
    "algo_name": "standardization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "standardization.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid standardization(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float mean = 0.0;\n    float variance = 0.0;\n    float stddev = 0.0;\n\n    // Calculate mean\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        mean += input[i];\n    }\n    mean /= ARRAY_SIZE;\n\n    // Calculate variance\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        variance += (input[i] - mean) * (input[i] - mean);\n    }\n    variance /= ARRAY_SIZE;\n\n    // Calculate standard deviation\n    stddev = std::sqrt(variance);\n\n    // Standardize the input array\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] - mean) / stddev;\n    }\n}\n\n// Top function name: standardization\n"
      }
    ],
    "code_length": 719,
    "token_count": 204,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/state_space_control/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 8419330,
    "Worst-caseLatency": 8419330.0,
    "BRAM_18K": 0,
    "LUT": 1244,
    "DSP": 5,
    "FF": 720,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "state_space_control",
    "ResourceMetric": 0.0004461103,
    "design_id": "project",
    "algo_name": "state_space_control",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "state_space_control.cpp",
        "file_content": "#include <iostream>\n\n#define N 1024\n\nvoid state_space_control(\n    float A[N][N], \n    float B[N][N], \n    float C[N][N], \n    float D[N][N], \n    float x[N], \n    float u[N], \n    float y[N], \n    float x_next[N]\n) {\n    // Compute y = C * x + D * u\n    for (int i = 0; i < N; i++) {\n        y[i] = 0;\n        for (int j = 0; j < N; j++) {\n            y[i] += C[i][j] * x[j];\n        }\n        for (int j = 0; j < N; j++) {\n            y[i] += D[i][j] * u[j];\n        }\n    }\n\n    // Compute x_next = A * x + B * u\n    for (int i = 0; i < N; i++) {\n        x_next[i] = 0;\n        for (int j = 0; j < N; j++) {\n            x_next[i] += A[i][j] * x[j];\n        }\n        for (int j = 0; j < N; j++) {\n            x_next[i] += B[i][j] * u[j];\n        }\n    }\n}\n\n// Top function name: state_space_control\n"
      }
    ],
    "code_length": 802,
    "token_count": 293,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/static_array_RAM/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3,
    "Worst-caseLatency": 11.0,
    "BRAM_18K": 1,
    "LUT": 319,
    "DSP": 0,
    "FF": 42,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 0.000127204,
    "design_id": "project",
    "algo_name": "static_array_RAM",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <ap_int.h>\n\nint test(int i);\n\nint test(int i) {\n    static ap_int<10> A[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n#pragma HLS BIND_STORAGE variable = A type = RAM_2P impl = BRAM\n    static ap_int<10> B[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n#pragma HLS BIND_STORAGE variable = B type = RAM_2P impl = LUTRAM\n    static ap_int<10> C[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n#pragma HLS BIND_STORAGE variable = C type = RAM_2P impl = URAM\n    A[i] += B[i] + C[i];\n    B[i] += 5;\n    C[i] += 10;\n\n    int result = (A[i] + B[i] + C[i]).to_int();\n    return result;\n}\n"
      }
    ],
    "code_length": 1949,
    "token_count": 564,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/static_array_ROM/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 1,
    "LUT": 31,
    "DSP": 0,
    "FF": 6,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 6.8524e-05,
    "design_id": "project",
    "algo_name": "static_array_ROM",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <ap_int.h>\n\nint test(int i);\n\nint test(int i) {\n    static const ap_int<10> A[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n#pragma HLS BIND_STORAGE variable = A type = ROM_1P impl = BRAM\n    static const ap_int<10> B[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n#pragma HLS BIND_STORAGE variable = B type = ROM_1P impl = LUTRAM\n    return A[i] + B[i];\n}\n"
      }
    ],
    "code_length": 1735,
    "token_count": 464,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/static_array_of_struct_with_array_RAM/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 3,
    "LUT": 236,
    "DSP": 0,
    "FF": 17,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 0.0002328984,
    "design_id": "project",
    "algo_name": "static_array_of_struct_with_array_RAM",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <ap_int.h>\n\ntemplate <int N> struct TestStruct {\n    int A[N];\n    int B[N];\n    int C[N];\n};\n\nint test(int i);\n\nint test(int i) {\n    static TestStruct<10> ts[2] = {{{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n                                    {9, 8, 7, 6, 5, 4, 3, 2, 1, 0},\n                                    {8, 8, 7, 7, 5, 4, 3, 2, 1, 0}},\n                                   {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n                                    {9, 8, 7, 6, 5, 4, 3, 2, 1, 0},\n                                    {9, 9, 8, 6, 5, 4, 3, 2, 1, 0}}};\n\n#pragma HLS BIND_STORAGE variable = ts type = RAM_2P impl = BRAM\n    // #pragma HLS BIND_STORAGE variable=ts type=RAM_2P impl=LUTRAM\n    // URAMs are not supported for global/static arrays\n    // #pragma HLS BIND_STORAGE variable=ts type=RAM_2P impl=URAM\n\n    int ind = i % 2;\n    ts[ind].A[i] += ts[ind].B[i] + ts[ind].C[i];\n    ts[ind].B[i] += 5;\n    ts[ind].C[i] += 10;\n\n    int result = (ts[ind].A[i] + ts[ind].B[i] + ts[ind].C[i]);\n    return result;\n}\n"
      }
    ],
    "code_length": 2396,
    "token_count": 709,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/static_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 165,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "static_shift_register",
    "ResourceMetric": 3.41341e-05,
    "design_id": "project",
    "algo_name": "static_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "static_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid static_shift_register(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE], ap_uint<32> shift_value) {\n    for (int i = 0; i < SIZE; i++) {\n        if (i < shift_value) {\n            output[i] = 0;\n        } else {\n            output[i] = input[i - shift_value];\n        }\n    }\n}\n\n// Top function name: static_shift_register\n"
      }
    ],
    "code_length": 368,
    "token_count": 105,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/static_struct_with_array_RAM/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 1,
    "LUT": 300,
    "DSP": 0,
    "FF": 78,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 0.0001270123,
    "design_id": "project",
    "algo_name": "static_struct_with_array_RAM",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <ap_int.h>\n\ntemplate <int N> struct TestStruct {\n    int A[N];\n    int B[N];\n    int C[N];\n};\n\nint test(int i);\n\nint test(int i) {\n    static TestStruct<10> ts = {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9},\n                                {9, 8, 7, 6, 5, 4, 3, 2, 1, 0},\n                                {9, 8, 7, 6, 5, 4, 3, 2, 1, 0}};\n\n#pragma HLS BIND_STORAGE variable = ts.A type = RAM_2P impl = BRAM\n#pragma HLS BIND_STORAGE variable = ts.B type = RAM_2P impl = LUTRAM\n\n    // URAM on non-Versal devices cannot be initialized\n    // #pragma HLS BIND_STORAGE variable=ts.C type=RAM_2P impl=URAM\n\n    ts.A[i] += ts.B[i] + ts.C[i];\n    ts.B[i] += 5;\n    ts.C[i] += 10;\n\n    return (ts.A[i] + ts.B[i] + ts.C[i]);\n}\n"
      }
    ],
    "code_length": 2098,
    "token_count": 584,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/statistical_significance_testing/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4150,
    "Worst-caseLatency": 4150.0,
    "BRAM_18K": 0,
    "LUT": 1711,
    "DSP": 12,
    "FF": 1577,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "statistical_significance_testing",
    "ResourceMetric": 0.0008117631,
    "design_id": "project",
    "algo_name": "statistical_significance_testing",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "statistical_significance_testing.cpp",
        "file_content": "#include <cmath>\n#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid statistical_significance_testing(float data1[ARRAY_SIZE], float data2[ARRAY_SIZE], float &mean1, float &mean2, float &stddev1, float &stddev2, float &t_statistic) {\n    float sum1 = 0.0f, sum2 = 0.0f;\n    float sum_sq1 = 0.0f, sum_sq2 = 0.0f;\n\n    // Calculate means\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum1 += data1[i];\n        sum2 += data2[i];\n    }\n    mean1 = sum1 / ARRAY_SIZE;\n    mean2 = sum2 / ARRAY_SIZE;\n\n    // Calculate standard deviations\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum_sq1 += (data1[i] - mean1) * (data1[i] - mean1);\n        sum_sq2 += (data2[i] - mean2) * (data2[i] - mean2);\n    }\n    stddev1 = std::sqrt(sum_sq1 / (ARRAY_SIZE - 1));\n    stddev2 = std::sqrt(sum_sq2 / (ARRAY_SIZE - 1));\n\n    // Calculate t-statistic\n    float pooled_stddev = std::sqrt(((stddev1 * stddev1) + (stddev2 * stddev2)) / 2);\n    t_statistic = (mean1 - mean2) / (pooled_stddev * std::sqrt(2.0f / ARRAY_SIZE));\n}\n\n// Top function name: statistical_significance_testing\n"
      }
    ],
    "code_length": 1069,
    "token_count": 353,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/stencil_stencil2d/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 39068,
    "Worst-caseLatency": 39068.0,
    "BRAM_18K": 0,
    "LUT": 928,
    "DSP": 6,
    "FF": 562,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "stencil",
    "ResourceMetric": 0.0003980671,
    "design_id": "project",
    "algo_name": "stencil_stencil2d",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "stencil.c",
        "file_content": "#include \"stencil.h\"\n\nvoid stencil (TYPE orig[row_size * col_size], TYPE sol[row_size * col_size], TYPE filter[f_size]){\n    int r, c, k1, k2;\n    TYPE temp, mul;\n\n    stencil_label1:for (r=0; r<row_size-2; r++) {\n        stencil_label2:for (c=0; c<col_size-2; c++) {\n            temp = (TYPE)0;\n            stencil_label3:for (k1=0;k1<3;k1++){\n                stencil_label4:for (k2=0;k2<3;k2++){\n                    mul = filter[k1*3 + k2] * orig[(r+k1)*col_size + c+k2];\n                    temp += mul;\n                }\n            }\n            sol[(r*col_size) + c] = temp;\n        }\n    }\n}\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "stencil.h",
        "file_content": "#include <stdio.h>\n#include <stdlib.h>\n#include \"support.h\"\n\n//Define input sizes\n#define col_size 64\n#define row_size 128\n#define f_size 9\n\n//Data Bounds\n#define TYPE int32_t\n#define MAX 1000\n#define MIN 1\n\n//Set number of iterations to execute\n#define MAX_ITERATION 1\n\nvoid stencil( TYPE orig[row_size * col_size],\n        TYPE sol[row_size * col_size],\n        TYPE filter[f_size] );\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n    TYPE orig[row_size*col_size];\n    TYPE sol[row_size*col_size];\n    TYPE filter[f_size];\n};\n"
      }
    ],
    "code_length": 599,
    "token_count": 188,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/stencil_stencil3d/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 52819,
    "Worst-caseLatency": 52819.0,
    "BRAM_18K": 0,
    "LUT": 1577,
    "DSP": 3,
    "FF": 490,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "stencil3d",
    "ResourceMetric": 0.0004325073,
    "design_id": "project",
    "algo_name": "stencil_stencil3d",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "stencil.c",
        "file_content": "/*\nImplementation based on algorithm described in:\n\"Stencil computation optimization and auto-tuning on state-of-the-art multicore architectures\"\nK. Datta, M. Murphy, V. Volkov, S. Williams, J. Carter, L. Oliker, D. Patterson, J. Shalf, K. Yelick\nSC 2008\n*/\n\n#include \"stencil.h\"\n\nvoid stencil3d(TYPE C[2], TYPE orig[SIZE], TYPE sol[SIZE]) {\n    int i, j, k;\n    TYPE sum0, sum1, mul0, mul1;\n\n    // Handle boundary conditions by filling with original values\n    height_bound_col : for(j=0; j<col_size; j++) {\n        height_bound_row : for(k=0; k<row_size; k++) {\n            sol[INDX(row_size, col_size, k, j, 0)] = orig[INDX(row_size, col_size, k, j, 0)];\n            sol[INDX(row_size, col_size, k, j, height_size-1)] = orig[INDX(row_size, col_size, k, j, height_size-1)];\n        }\n    }\n    col_bound_height : for(i=1; i<height_size-1; i++) {\n        col_bound_row : for(k=0; k<row_size; k++) {\n            sol[INDX(row_size, col_size, k, 0, i)] = orig[INDX(row_size, col_size, k, 0, i)];\n            sol[INDX(row_size, col_size, k, col_size-1, i)] = orig[INDX(row_size, col_size, k, col_size-1, i)];\n        }\n    }\n    row_bound_height : for(i=1; i<height_size-1; i++) {\n        row_bound_col : for(j=1; j<col_size-1; j++) {\n            sol[INDX(row_size, col_size, 0, j, i)] = orig[INDX(row_size, col_size, 0, j, i)];\n            sol[INDX(row_size, col_size, row_size-1, j, i)] = orig[INDX(row_size, col_size, row_size-1, j, i)];\n        }\n    }\n\n\n    // Stencil computation\n    loop_height : for(i = 1; i < height_size - 1; i++){\n        loop_col : for(j = 1; j < col_size - 1; j++){\n            loop_row : for(k = 1; k < row_size - 1; k++){\n                sum0 = orig[INDX(row_size, col_size, k, j, i)];\n                sum1 = orig[INDX(row_size, col_size, k, j, i + 1)] +\n                       orig[INDX(row_size, col_size, k, j, i - 1)] +\n                       orig[INDX(row_size, col_size, k, j + 1, i)] +\n                       orig[INDX(row_size, col_size, k, j - 1, i)] +\n                       orig[INDX(row_size, col_size, k + 1, j, i)] +\n                       orig[INDX(row_size, col_size, k - 1, j, i)];\n                mul0 = sum0 * C[0];\n                mul1 = sum1 * C[1];\n                sol[INDX(row_size, col_size, k, j, i)] = mul0 + mul1;\n            }\n        }\n    }\n}\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      },
      {
        "file_name": "stencil.h",
        "file_content": "/*\nImplementation based on algorithm described in:\n\"Stencil computation optimization and auto-tuning on state-of-the-art multicore architectures\"\nK. Datta, M. Murphy, V. Volkov, S. Williams, J. Carter, L. Oliker, D. Patterson, J. Shalf, K. Yelick\nSC 2008\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"support.h\"\n\n//Define input sizes\n#define height_size 32\n#define col_size 32\n#define row_size 16\n//Data Bounds\n#define TYPE int32_t\n#define MAX 1000\n#define MIN 1\n//Convenience Macros\n#define SIZE (row_size * col_size * height_size)\n#define INDX(_row_size,_col_size,_i,_j,_k) ((_i)+_row_size*((_j)+_col_size*(_k)))\n\nvoid stencil3d( TYPE C[2], TYPE orig[SIZE], TYPE sol[SIZE] );\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  TYPE C[2];\n  TYPE orig[SIZE];\n  TYPE sol[SIZE];\n};\n"
      }
    ],
    "code_length": 2303,
    "token_count": 754,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/step_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 251,
    "DSP": 0,
    "FF": 110,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "step_counter",
    "ResourceMetric": 5.868e-05,
    "design_id": "project",
    "algo_name": "step_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "step_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid step_counter(ap_int<32> steps[ARRAY_SIZE], ap_int<32> threshold, ap_int<32> &count) {\n    count = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (steps[i] > threshold) {\n            count++;\n        }\n    }\n}\n\n// Top function name: step_counter\n"
      }
    ],
    "code_length": 306,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/stop_and_wait/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "stop_and_wait",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "stop_and_wait",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "stop_and_wait.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid stop_and_wait(uint32_t input[ARRAY_SIZE], uint32_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Simulate sending data\n        uint32_t sent_data = input[i];\n\n        // Simulate waiting for acknowledgment\n        bool ack_received = false;\n        while (!ack_received) {\n            // In a real scenario, this would involve checking some condition\n            // Here we simulate immediate acknowledgment for simplicity\n            ack_received = true;\n        }\n\n        // Simulate receiving data\n        output[i] = sent_data;\n    }\n}\n\n// Top function name: stop_and_wait\n"
      }
    ],
    "code_length": 659,
    "token_count": 148,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/stratified_sampling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1126,
    "Worst-caseLatency": 1126.0,
    "BRAM_18K": 0,
    "LUT": 4535,
    "DSP": 0,
    "FF": 6534,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "stratified_sampling",
    "ResourceMetric": 0.0014961494,
    "design_id": "project",
    "algo_name": "stratified_sampling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "stratified_sampling.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n#define STRATA 10\n\nvoid stratified_sampling(ap_int<32> input[N], ap_int<32> output[STRATA], ap_int<32> strata_size[STRATA]) {\n    ap_int<32> strata_sum[STRATA] = {0};\n    ap_int<32> strata_count[STRATA] = {0};\n\n    for (int i = 0; i < N; i++) {\n        int stratum = (input[i] % STRATA);\n        strata_sum[stratum] += input[i];\n        strata_count[stratum]++;\n    }\n\n    for (int i = 0; i < STRATA; i++) {\n        if (strata_count[i] != 0) {\n            output[i] = strata_sum[i] / strata_count[i];\n        } else {\n            output[i] = 0;\n        }\n        strata_size[i] = strata_count[i];\n    }\n}\n\n// Top function name: stratified_sampling\n"
      }
    ],
    "code_length": 684,
    "token_count": 220,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/stream_better/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3,
    "Worst-caseLatency": 3.0,
    "BRAM_18K": 0,
    "LUT": 143,
    "DSP": 0,
    "FF": 68,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pointer_stream_better",
    "ResourceMetric": 3.39424e-05,
    "design_id": "project",
    "algo_name": "stream_better",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.c",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _POINTER_STREAM_BETTER_H_\n#define _POINTER_STREAM_BETTER_H_\n\n// Missing include: #include <stdio.h>\n\ntypedef int din_t;\ntypedef int dout_t;\n\nvoid pointer_stream_better(volatile dout_t* d_o, volatile din_t* d_i);\n\n#endif\n\nvoid pointer_stream_better(volatile dout_t *d_o, volatile din_t *d_i) {\n  din_t acc = 0;\n\n  acc += *d_i;\n  acc += *d_i;\n  *d_o = acc;\n  acc += *d_i;\n  acc += *d_i;\n  *d_o = acc;\n}\n"
      }
    ],
    "code_length": 1698,
    "token_count": 423,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/struct_ii_issue/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 525,
    "Worst-caseLatency": 525.0,
    "BRAM_18K": 43,
    "LUT": 8948,
    "DSP": 0,
    "FF": 6801,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 0.0050341789,
    "design_id": "project",
    "algo_name": "struct_ii_issue",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <iostream>\n#define NUM 100\n\n// struct alignas(32) A { /* Total size = 256 bits or 32 bytes */\nstruct A { /* Total size = 192 bits (32 x 6) or 24 bytes */\n    int s_1;\n    int s_2;\n    int s_3;\n    int s_4;\n    int s_5;\n    int s_6;\n};\n\n// Top function\nvoid dut(A a_in[NUM], A a_out[NUM], int size);\n\nvoid read(A* a_in, A buf_out[NUM]) {\nREAD:\n    for (int i = 0; i < NUM; i++) {\n        buf_out[i] = a_in[i];\n    }\n}\n\nvoid compute(A buf_in[NUM], A buf_out[NUM], int size) {\nCOMPUTE:\n    for (int j = 0; j < NUM; j++) {\n        buf_out[j].s_1 = buf_in[j].s_1 + size;\n        buf_out[j].s_2 = buf_in[j].s_2;\n        buf_out[j].s_3 = buf_in[j].s_3;\n        buf_out[j].s_4 = buf_in[j].s_4;\n        buf_out[j].s_5 = buf_in[j].s_5;\n        buf_out[j].s_6 = buf_in[j].s_6 % 2;\n    }\n}\n\nvoid write(A buf_in[NUM], A* a_out) {\nWRITE:\n    for (int k = 0; k < NUM; k++) {\n        a_out[k] = buf_in[k];\n    }\n}\n\nvoid dut(A a_in[NUM], A a_out[NUM], int size) {\n#pragma HLS INTERFACE m_axi port = a_in bundle = gmem0\n#pragma HLS INTERFACE m_axi port = a_out bundle = gmem1\n    A buffer_in[NUM];\n    A buffer_out[NUM];\n\n#pragma HLS dataflow\n    read(a_in, buffer_in);\n    compute(buffer_in, buffer_out, size);\n    write(buffer_out, a_out);\n}\n"
      },
      {
        "file_name": "xdut_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of a_in\n//        bit 31~0 - a_in[31:0] (Read/Write)\n// 0x14 : Data signal of a_in\n//        bit 31~0 - a_in[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of a_out\n//        bit 31~0 - a_out[31:0] (Read/Write)\n// 0x20 : Data signal of a_out\n//        bit 31~0 - a_out[63:32] (Read/Write)\n// 0x24 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XDUT_CONTROL_ADDR_A_IN_DATA  0x10\n#define XDUT_CONTROL_BITS_A_IN_DATA  64\n#define XDUT_CONTROL_ADDR_A_OUT_DATA 0x1c\n#define XDUT_CONTROL_BITS_A_OUT_DATA 64\n\n"
      },
      {
        "file_name": "xdut.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xdut.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XDut_CfgInitialize(XDut *InstancePtr, XDut_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XDut_Set_a_in(XDut *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA, (u32)(Data));\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDut_Get_a_in(XDut *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA);\n    Data += (u64)XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_IN_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XDut_Set_a_out(XDut *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA, (u32)(Data));\n    XDut_WriteReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDut_Get_a_out(XDut *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA);\n    Data += (u64)XDut_ReadReg(InstancePtr->Control_BaseAddress, XDUT_CONTROL_ADDR_A_OUT_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xdut_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xdut.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XDut_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XDut_uio_map maps[ MAX_UIO_MAPS ];\n} XDut_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XDut_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XDut_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XDut_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XDut_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XDut_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XDut_Initialize(XDut *InstancePtr, const char* InstanceName) {\n\tXDut_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XDut_Release(XDut *InstancePtr) {\n\tXDut_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xdut.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XDUT_H\n#define XDUT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xdut_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XDut_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XDut;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XDut_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XDut_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XDut_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XDut_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XDut_Initialize(XDut *InstancePtr, UINTPTR BaseAddress);\nXDut_Config* XDut_LookupConfig(UINTPTR BaseAddress);\n#else\nint XDut_Initialize(XDut *InstancePtr, u16 DeviceId);\nXDut_Config* XDut_LookupConfig(u16 DeviceId);\n#endif\nint XDut_CfgInitialize(XDut *InstancePtr, XDut_Config *ConfigPtr);\n#else\nint XDut_Initialize(XDut *InstancePtr, const char* InstanceName);\nint XDut_Release(XDut *InstancePtr);\n#endif\n\n\nvoid XDut_Set_a_in(XDut *InstancePtr, u64 Data);\nu64 XDut_Get_a_in(XDut *InstancePtr);\nvoid XDut_Set_a_out(XDut *InstancePtr, u64 Data);\nu64 XDut_Get_a_out(XDut *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xdut_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xdut.h\"\n\nextern XDut_Config XDut_ConfigTable[];\n\n#ifdef SDT\nXDut_Config *XDut_LookupConfig(UINTPTR BaseAddress) {\n\tXDut_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XDut_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XDut_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XDut_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDut_Initialize(XDut *InstancePtr, UINTPTR BaseAddress) {\n\tXDut_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDut_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDut_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXDut_Config *XDut_LookupConfig(u16 DeviceId) {\n\tXDut_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XDUT_NUM_INSTANCES; Index++) {\n\t\tif (XDut_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XDut_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDut_Initialize(XDut *InstancePtr, u16 DeviceId) {\n\tXDut_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDut_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDut_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 11383,
    "token_count": 3187,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/surface_mount_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 82,
    "DSP": 1,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "surface_mount_multiplier",
    "ResourceMetric": 4.58257e-05,
    "design_id": "project",
    "algo_name": "surface_mount_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "surface_mount_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid surface_mount_multiplier(ap_int<16> A[SIZE], ap_int<16> B[SIZE], ap_int<32> C[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        C[i] = A[i] * B[i];\n    }\n}\n\n// Top function name: surface_mount_multiplier\n"
      }
    ],
    "code_length": 253,
    "token_count": 84,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/surround_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4177938,
    "Worst-caseLatency": 4177938.0,
    "BRAM_18K": 0,
    "LUT": 713,
    "DSP": 0,
    "FF": 268,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "surround_processor",
    "ResourceMetric": 0.0001624248,
    "design_id": "project",
    "algo_name": "surround_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "surround_processor.cpp",
        "file_content": "#include <iostream>\n\n#define SIZE 1024\n\nvoid surround_processor(int input[SIZE][SIZE], int output[SIZE][SIZE]) {\n    for (int i = 1; i < SIZE - 1; i++) {\n        for (int j = 1; j < SIZE - 1; j++) {\n            int sum = 0;\n            sum += input[i-1][j-1];\n            sum += input[i-1][j];\n            sum += input[i-1][j+1];\n            sum += input[i][j-1];\n            sum += input[i][j+1];\n            sum += input[i+1][j-1];\n            sum += input[i+1][j];\n            sum += input[i+1][j+1];\n            output[i][j] = sum / 8;\n        }\n    }\n}\n\n// Top function name: surround_processor\n"
      }
    ],
    "code_length": 600,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/svd/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1089545,
    "Worst-caseLatency": 18332312585.0,
    "BRAM_18K": 4100,
    "LUT": 9069,
    "DSP": 25,
    "FF": 6149,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "svd",
    "ResourceMetric": 0.2572375638,
    "design_id": "project",
    "algo_name": "svd",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "svd.cpp",
        "file_content": "#include <cmath>\n\n#define MATRIX_SIZE 1024\n\nvoid svd(float A[MATRIX_SIZE][MATRIX_SIZE], float U[MATRIX_SIZE][MATRIX_SIZE], float S[MATRIX_SIZE][MATRIX_SIZE], float V[MATRIX_SIZE][MATRIX_SIZE]) {\n    float epsilon = 1e-10;\n    float temp[MATRIX_SIZE][MATRIX_SIZE];\n    float e[MATRIX_SIZE];\n    float work[MATRIX_SIZE];\n    float nrm;\n    int i, j, k, l;\n\n    // Initialize U, S, V\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        for (j = 0; j < MATRIX_SIZE; j++) {\n            U[i][j] = 0.0;\n            S[i][j] = 0.0;\n            V[i][j] = 0.0;\n        }\n    }\n\n    // Copy A to temp\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        for (j = 0; j < MATRIX_SIZE; j++) {\n            temp[i][j] = A[i][j];\n        }\n    }\n\n    // Bidiagonalization\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        e[i] = 0.0;\n        work[i] = 0.0;\n    }\n\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        nrm = 0.0;\n        for (j = i; j < MATRIX_SIZE; j++) {\n            nrm = hypot(nrm, temp[j][i]);\n        }\n        if (nrm > epsilon) {\n            if (temp[i][i] < 0) {\n                nrm = -nrm;\n            }\n            for (j = i; j < MATRIX_SIZE; j++) {\n                temp[j][i] /= nrm;\n            }\n            temp[i][i] += 1.0;\n            for (j = i + 1; j < MATRIX_SIZE; j++) {\n                float s = 0.0;\n                for (k = i; k < MATRIX_SIZE; k++) {\n                    s += temp[k][i] * temp[k][j];\n                }\n                s = -s / temp[i][i];\n                for (k = i; k < MATRIX_SIZE; k++) {\n                    temp[k][j] += s * temp[k][i];\n                }\n            }\n        }\n        for (j = i; j < MATRIX_SIZE; j++) {\n            U[j][i] = temp[j][i];\n        }\n        if (i < MATRIX_SIZE - 1) {\n            nrm = 0.0;\n            for (j = i + 1; j < MATRIX_SIZE; j++) {\n                nrm = hypot(nrm, temp[i][j]);\n            }\n            if (nrm > epsilon) {\n                if (temp[i][i + 1] < 0) {\n                    nrm = -nrm;\n                }\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    temp[i][j] /= nrm;\n                }\n                temp[i][i + 1] += 1.0;\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    e[j] = temp[i][j];\n                }\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    work[j] = 0.0;\n                }\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    for (k = i + 1; k < MATRIX_SIZE; k++) {\n                        work[k] += e[j] * temp[j][k];\n                    }\n                }\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    float s = -e[j] / e[i + 1];\n                    for (k = i + 1; k < MATRIX_SIZE; k++) {\n                        temp[j][k] += s * work[k];\n                    }\n                }\n            }\n            for (j = i + 1; j < MATRIX_SIZE; j++) {\n                V[j][i] = e[j];\n            }\n        }\n    }\n\n    // Diagonalization\n    for (i = MATRIX_SIZE - 1; i >= 0; i--) {\n        if (i < MATRIX_SIZE - 1) {\n            if (e[i] != 0.0) {\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    V[j][i] = temp[i][j] / temp[i][i + 1];\n                }\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    float s = 0.0;\n                    for (k = i + 1; k < MATRIX_SIZE; k++) {\n                        s += temp[i][k] * V[k][j];\n                    }\n                    for (k = i + 1; k < MATRIX_SIZE; k++) {\n                        V[k][j] += s * V[k][i];\n                    }\n                }\n            }\n            for (j = i + 1; j < MATRIX_SIZE; j++) {\n                V[i][j] = 0.0;\n                V[j][i] = 0.0;\n            }\n        }\n        V[i][i] = 1.0;\n    }\n\n    for (i = MATRIX_SIZE - 1; i >= 0; i--) {\n        if (i < MATRIX_SIZE - 1) {\n            if (temp[i][i + 1] != 0.0) {\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    U[j][i] = temp[j][i] / temp[i][i + 1];\n                }\n                for (j = i + 1; j < MATRIX_SIZE; j++) {\n                    float s = 0.0;\n                    for (k = i + 1; k < MATRIX_SIZE; k++) {\n                        s += temp[k][i] * U[k][j];\n                    }\n                    for (k = i + 1; k < MATRIX_SIZE; k++) {\n                        U[k][j] += s * U[k][i];\n                    }\n                }\n            }\n            for (j = i + 1; j < MATRIX_SIZE; j++) {\n                U[i][j] = 0.0;\n                U[j][i] = 0.0;\n            }\n        }\n        U[i][i] = 1.0;\n    }\n\n    for (i = 0; i < MATRIX_SIZE; i++) {\n        S[i][i] = temp[i][i];\n    }\n}\n\n// Top function name: svd\n"
      }
    ],
    "code_length": 4692,
    "token_count": 1431,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/svm/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 98580,
    "Worst-caseLatency": 98580.0,
    "BRAM_18K": 0,
    "LUT": 5487,
    "DSP": 10,
    "FF": 10269,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "svm",
    "ResourceMetric": 0.0023138694,
    "design_id": "project",
    "algo_name": "svm",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "svm.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n#define D 64\n\nvoid svm(float X[N][D], float y[N], float alpha[N], float b, float w[D], float result[N]) {\n    // Initialize weights to zero\n    for (int i = 0; i < D; i++) {\n        w[i] = 0.0;\n    }\n\n    // Compute weights\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < D; j++) {\n            w[j] += alpha[i] * y[i] * X[i][j];\n        }\n    }\n\n    // Compute the result\n    for (int i = 0; i < N; i++) {\n        result[i] = b;\n        for (int j = 0; j < D; j++) {\n            result[i] += w[j] * X[i][j];\n        }\n    }\n}\n\n// Top function name: svm\n"
      }
    ],
    "code_length": 600,
    "token_count": 208,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/svr/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4196386,
    "Worst-caseLatency": 4196386.0,
    "BRAM_18K": 8,
    "LUT": 4575,
    "DSP": 28,
    "FF": 4075,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "svr",
    "ResourceMetric": 0.002539786,
    "design_id": "project",
    "algo_name": "svr",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "svr.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid svr(double X[N], double Y[N], double alpha[N], double b, double C, double epsilon, double kernel[N][N], double output[N]) {\n    double error[N];\n    double f[N];\n    \n    // Initialize error and f\n    for (int i = 0; i < N; i++) {\n        error[i] = 0.0;\n        f[i] = 0.0;\n    }\n\n    // Compute the SVR function\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            f[i] += alpha[j] * kernel[i][j];\n        }\n        f[i] += b;\n        error[i] = Y[i] - f[i];\n    }\n\n    // Update alpha and b\n    for (int i = 0; i < N; i++) {\n        if (error[i] > epsilon) {\n            alpha[i] += C * (error[i] - epsilon);\n        } else if (error[i] < -epsilon) {\n            alpha[i] -= C * (error[i] + epsilon);\n        }\n        b += error[i];\n    }\n\n    // Output the result\n    for (int i = 0; i < N; i++) {\n        output[i] = f[i];\n    }\n}\n\n// Top function name: svr\n"
      }
    ],
    "code_length": 934,
    "token_count": 303,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/swish_activation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1040,
    "Worst-caseLatency": 1040.0,
    "BRAM_18K": 0,
    "LUT": 1134,
    "DSP": 9,
    "FF": 626,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "swish_activation",
    "ResourceMetric": 0.0005268188,
    "design_id": "project",
    "algo_name": "swish_activation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "swish_activation.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid swish_activation(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float x = input[i];\n        output[i] = x / (1.0f + expf(-x));\n    }\n}\n\n// Top function name: swish_activation\n"
      }
    ],
    "code_length": 280,
    "token_count": 82,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/switching_regulator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 215,
    "DSP": 0,
    "FF": 61,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "switching_regulator",
    "ResourceMetric": 4.70783e-05,
    "design_id": "project",
    "algo_name": "switching_regulator",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "switching_regulator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid switching_regulator(ap_int<16> input[ARRAY_SIZE], ap_int<16> output[ARRAY_SIZE], ap_int<16> threshold) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] > threshold) {\n            output[i] = threshold;\n        } else if (input[i] < -threshold) {\n            output[i] = -threshold;\n        } else {\n            output[i] = input[i];\n        }\n    }\n}\n\n// Top function name: switching_regulator\n"
      }
    ],
    "code_length": 462,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/synchronous_training/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 444,
    "DSP": 5,
    "FF": 564,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "synchronous_training",
    "ResourceMetric": 0.0002777408,
    "design_id": "project",
    "algo_name": "synchronous_training",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "synchronous_training.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid synchronous_training(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float weights[ARRAY_SIZE], float bias) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * weights[i] + bias;\n    }\n}\n\n// Top function name: synchronous_training\n"
      }
    ],
    "code_length": 309,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/t_flip_flop/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 90,
    "DSP": 0,
    "FF": 28,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "t_flip_flop",
    "ResourceMetric": 1.99435e-05,
    "design_id": "project",
    "algo_name": "t_flip_flop",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "t_flip_flop.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid t_flip_flop(ap_uint<1> T[SIZE], ap_uint<1> Q[SIZE]) {\n    ap_uint<1> state = 0;\n    for (int i = 0; i < SIZE; i++) {\n        if (T[i] == 1) {\n            state = ~state;\n        }\n        Q[i] = state;\n    }\n}\n\n// Top function name: t_flip_flop\n"
      }
    ],
    "code_length": 290,
    "token_count": 102,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/t_test/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4142,
    "Worst-caseLatency": 4142.0,
    "BRAM_18K": 0,
    "LUT": 1673,
    "DSP": 12,
    "FF": 1537,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "t_test",
    "ResourceMetric": 0.0008006407,
    "design_id": "project",
    "algo_name": "t_test",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "t_test.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid t_test(float data1[N], float data2[N], float &t_statistic, float &p_value) {\n    float mean1 = 0.0f, mean2 = 0.0f;\n    float var1 = 0.0f, var2 = 0.0f;\n    float sum1 = 0.0f, sum2 = 0.0f;\n    float sum_sq1 = 0.0f, sum_sq2 = 0.0f;\n    float diff_mean, pooled_var, sqrt_pooled_var, t_stat;\n\n    // Calculate means\n    for (int i = 0; i < N; i++) {\n        sum1 += data1[i];\n        sum2 += data2[i];\n    }\n    mean1 = sum1 / N;\n    mean2 = sum2 / N;\n\n    // Calculate variances\n    for (int i = 0; i < N; i++) {\n        sum_sq1 += (data1[i] - mean1) * (data1[i] - mean1);\n        sum_sq2 += (data2[i] - mean2) * (data2[i] - mean2);\n    }\n    var1 = sum_sq1 / (N - 1);\n    var2 = sum_sq2 / (N - 1);\n\n    // Calculate t-statistic\n    diff_mean = mean1 - mean2;\n    pooled_var = ((var1 + var2) / 2.0f) / N;\n    sqrt_pooled_var = std::sqrt(pooled_var);\n    t_stat = diff_mean / sqrt_pooled_var;\n\n    // Assign results\n    t_statistic = t_stat;\n    p_value = 0.0f; // Placeholder, actual p-value calculation would require additional steps\n}\n\n// Top function name: t_test\n"
      }
    ],
    "code_length": 1121,
    "token_count": 401,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/target_encoding/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 0,
    "LUT": 336,
    "DSP": 2,
    "FF": 132,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "target_encoding",
    "ResourceMetric": 0.0001324973,
    "design_id": "project",
    "algo_name": "target_encoding",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "target_encoding.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid target_encoding(ap_int<32> input[ARRAY_SIZE], ap_int<32> target[ARRAY_SIZE], ap_int<32> output[ARRAY_SIZE]) {\n    ap_int<32> sum = 0;\n    ap_int<32> count = 0;\n    \n    // Calculate the sum and count of target values\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum += target[i];\n        count++;\n    }\n    \n    // Calculate the mean of target values\n    ap_int<32> mean = sum / count;\n    \n    // Encode the input values based on the mean of target values\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input[i] * mean;\n    }\n}\n\n// Top function name: target_encoding\n"
      }
    ],
    "code_length": 641,
    "token_count": 185,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/tcp_segmentation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6,
    "Worst-caseLatency": 4306421250.0,
    "BRAM_18K": 0,
    "LUT": 964,
    "DSP": 4,
    "FF": 311,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "tcp_segmentation",
    "ResourceMetric": 0.0003254964,
    "design_id": "project",
    "algo_name": "tcp_segmentation",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "tcp_segmentation.cpp",
        "file_content": "#include <cstring>\n\n#define MAX_SEGMENTS 1024\n#define SEGMENT_SIZE 1500\n\nvoid tcp_segmentation(const char input_data[MAX_SEGMENTS * SEGMENT_SIZE], int input_length, char output_data[MAX_SEGMENTS][SEGMENT_SIZE], int segment_lengths[MAX_SEGMENTS], int &num_segments) {\n    int segment_index = 0;\n    int data_index = 0;\n\n    for (int i = 0; i < input_length; i += SEGMENT_SIZE) {\n        int current_segment_size = (input_length - i > SEGMENT_SIZE) ? SEGMENT_SIZE : (input_length - i);\n        segment_lengths[segment_index] = current_segment_size;\n        for (int j = 0; j < current_segment_size; j++) {\n            output_data[segment_index][j] = input_data[data_index++];\n        }\n        segment_index++;\n    }\n    num_segments = segment_index;\n}\n\n// Top function name: tcp_segmentation\n"
      }
    ],
    "code_length": 791,
    "token_count": 198,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/teacher_student_networks/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1035,
    "Worst-caseLatency": 1035.0,
    "BRAM_18K": 0,
    "LUT": 811,
    "DSP": 10,
    "FF": 1165,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "teacher_student_networks",
    "ResourceMetric": 0.0005442633,
    "design_id": "project",
    "algo_name": "teacher_student_networks",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "teacher_student_networks.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid teacher_student_networks(float teacher[LARGE_SCALE], float student[LARGE_SCALE], float output[LARGE_SCALE], float alpha, float beta) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        float teacher_signal = teacher[i];\n        float student_signal = student[i];\n        float error = teacher_signal - student_signal;\n        output[i] = alpha * teacher_signal + beta * error;\n    }\n}\n\n// Top function name: teacher_student_networks\n"
      }
    ],
    "code_length": 484,
    "token_count": 111,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/teletext_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 85,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "teletext_processor",
    "ResourceMetric": 1.86971e-05,
    "design_id": "project",
    "algo_name": "teletext_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "teletext_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid teletext_processor(uint8_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t byte = input[i];\n        uint8_t processed_byte = 0;\n\n        // Example processing: invert bits and shift left by 1\n        processed_byte = ~byte;\n        processed_byte = (processed_byte << 1) | (processed_byte >> 7);\n\n        output[i] = processed_byte;\n    }\n}\n\n// Top function name: teletext_processor\n"
      }
    ],
    "code_length": 493,
    "token_count": 130,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/temperature_based_shutdown/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "temperature_based_shutdown",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "temperature_based_shutdown",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "temperature_based_shutdown.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n#define THRESHOLD 75\n\nvoid temperature_based_shutdown(int temperature_readings[ARRAY_SIZE], int shutdown_flags[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (temperature_readings[i] > THRESHOLD) {\n            shutdown_flags[i] = 1;\n        } else {\n            shutdown_flags[i] = 0;\n        }\n    }\n}\n\n// Top function name: temperature_based_shutdown\n"
      }
    ],
    "code_length": 420,
    "token_count": 106,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/temperature_sensor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "temperature_sensor",
    "ResourceMetric": 2.771e-05,
    "design_id": "project",
    "algo_name": "temperature_sensor",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "temperature_sensor.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid temperature_sensor(int readings[ARRAY_SIZE], int threshold, int results[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (readings[i] > threshold) {\n            results[i] = 1; // Above threshold\n        } else {\n            results[i] = 0; // Below threshold\n        }\n    }\n}\n\n// Top function name: temperature_sensor\n"
      }
    ],
    "code_length": 391,
    "token_count": 99,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/temporal_difference_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 26,
    "Worst-caseLatency": 26.0,
    "BRAM_18K": 0,
    "LUT": 1375,
    "DSP": 11,
    "FF": 1120,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "temporal_difference_learning",
    "ResourceMetric": 0.0006758079,
    "design_id": "project",
    "algo_name": "temporal_difference_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "temporal_difference_learning.cpp",
        "file_content": "#include <cmath>\n\n#define STATE_SIZE 1024\n#define ACTION_SIZE 4\n#define ALPHA 0.1\n#define GAMMA 0.9\n\nvoid temporal_difference_learning(\n    int state,\n    int action,\n    int next_state,\n    double reward,\n    double Q[STATE_SIZE][ACTION_SIZE])\n{\n    double max_next_Q = -INFINITY;\n    for (int a = 0; a < ACTION_SIZE; a++) {\n        if (Q[next_state][a] > max_next_Q) {\n            max_next_Q = Q[next_state][a];\n        }\n    }\n\n    Q[state][action] += ALPHA * (reward + GAMMA * max_next_Q - Q[state][action]);\n}\n\n// Top function name: temporal_difference_learning\n"
      }
    ],
    "code_length": 567,
    "token_count": 156,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/thermal_sensor_calibration/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1031,
    "Worst-caseLatency": 1031.0,
    "BRAM_18K": 0,
    "LUT": 476,
    "DSP": 5,
    "FF": 660,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "thermal_sensor_calibration",
    "ResourceMetric": 0.000293082,
    "design_id": "project",
    "algo_name": "thermal_sensor_calibration",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "thermal_sensor_calibration.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid thermal_sensor_calibration(float raw_data[ARRAY_SIZE], float calibrated_data[ARRAY_SIZE], float offset, float scale) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        calibrated_data[i] = (raw_data[i] + offset) * scale;\n    }\n}\n\n// Top function name: thermal_sensor_calibration\n"
      }
    ],
    "code_length": 349,
    "token_count": 86,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/timer_16bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 109,
    "DSP": 1,
    "FF": 125,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "timer_16bit",
    "ResourceMetric": 6.05916e-05,
    "design_id": "project",
    "algo_name": "timer_16bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "timer_16bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define TIMER_SIZE 1024\n\nvoid timer_16bit(uint16_t start_value, uint16_t increment, uint16_t timer[TIMER_SIZE]) {\n    for (int i = 0; i < TIMER_SIZE; i++) {\n        timer[i] = start_value + i * increment;\n    }\n}\n\n// Top function name: timer_16bit\n"
      }
    ],
    "code_length": 269,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/timer_32bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "timer_32bit",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "timer_32bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "timer_32bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define TIMER_SIZE 1024\n\nvoid timer_32bit(uint32_t input[TIMER_SIZE], uint32_t output[TIMER_SIZE]) {\n    for (int i = 0; i < TIMER_SIZE; i++) {\n        output[i] = input[i] + 1;\n    }\n}\n\n// Top function name: timer_32bit\n"
      }
    ],
    "code_length": 242,
    "token_count": 76,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/timer_8bit/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 64,
    "DSP": 0,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "timer_8bit",
    "ResourceMetric": 1.35194e-05,
    "design_id": "project",
    "algo_name": "timer_8bit",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "timer_8bit.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid timer_8bit(uint8_t input[ARRAY_SIZE], uint8_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        uint8_t count = 0;\n        for (int j = 0; j < 256; j++) {\n            count++;\n        }\n        output[i] = count;\n    }\n}\n\n// Top function name: timer_8bit\n"
      }
    ],
    "code_length": 329,
    "token_count": 102,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/top_k_sampling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3073,
    "Worst-caseLatency": 3073.0,
    "BRAM_18K": 0,
    "LUT": 1194,
    "DSP": 0,
    "FF": 156,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "top_k_sampling",
    "ResourceMetric": 0.0002439249,
    "design_id": "project",
    "algo_name": "top_k_sampling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "top_k_sampling.cpp",
        "file_content": "#include <hls_stream.h>\n#include <ap_int.h>\n\n#define N 1024\n#define K 10\n\nvoid top_k_sampling(ap_int<32> input[N], ap_int<32> output[K]) {\n    ap_int<32> buffer[K];\n    int i, j;\n\n    // Initialize buffer with the first K elements\n    for (i = 0; i < K; i++) {\n        buffer[i] = input[i];\n    }\n\n    // Process the remaining elements\n    for (i = K; i < N; i++) {\n        ap_int<32> min_val = buffer[0];\n        int min_index = 0;\n\n        // Find the minimum value in the buffer\n        for (j = 1; j < K; j++) {\n            if (buffer[j] < min_val) {\n                min_val = buffer[j];\n                min_index = j;\n            }\n        }\n\n        // If the current input is greater than the minimum value in the buffer, replace it\n        if (input[i] > min_val) {\n            buffer[min_index] = input[i];\n        }\n    }\n\n    // Copy the buffer to the output\n    for (i = 0; i < K; i++) {\n        output[i] = buffer[i];\n    }\n}\n\n// Top function name: top_k_sampling\n"
      }
    ],
    "code_length": 977,
    "token_count": 277,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/top_p_sampling/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3098,
    "Worst-caseLatency": 9243.0,
    "BRAM_18K": 0,
    "LUT": 885,
    "DSP": 2,
    "FF": 646,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "top_p_sampling",
    "ResourceMetric": 0.0002870597,
    "design_id": "project",
    "algo_name": "top_p_sampling",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "top_p_sampling.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid top_p_sampling(float logits[ARRAY_SIZE], float cumulative_probs[ARRAY_SIZE], float threshold, int &selected_index) {\n    float sum_probs = 0.0;\n    selected_index = -1;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        sum_probs += logits[i];\n    }\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        cumulative_probs[i] = logits[i] / sum_probs;\n    }\n\n    float cumulative_sum = 0.0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        cumulative_sum += cumulative_probs[i];\n        if (cumulative_sum >= threshold) {\n            selected_index = i;\n            break;\n        }\n    }\n}\n\n// Top function name: top_p_sampling\n"
      }
    ],
    "code_length": 675,
    "token_count": 180,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/total_time_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 139,
    "DSP": 0,
    "FF": 46,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "total_time_counter",
    "ResourceMetric": 3.10659e-05,
    "design_id": "project",
    "algo_name": "total_time_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "total_time_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid total_time_counter(ap_uint<32> input_array[ARRAY_SIZE], ap_uint<32> &total, ap_uint<32> &count) {\n    total = 0;\n    count = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        total += input_array[i];\n        count++;\n    }\n}\n\n// Top function name: total_time_counter\n"
      }
    ],
    "code_length": 322,
    "token_count": 96,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/transformer_decoder_block/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4304576558,
    "Worst-caseLatency": 4304576558.0,
    "BRAM_18K": 10240,
    "LUT": 6906,
    "DSP": 10,
    "FF": 5629,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "transformer_decoder_block",
    "ResourceMetric": 0.6370617242,
    "design_id": "project",
    "algo_name": "transformer_decoder_block",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "transformer_decoder_block.cpp",
        "file_content": "#include <cmath>\n#include <hls_math.h>\n\n#define N 1024 // Large scale size\n#define D_MODEL 512\n#define D_FF 2048\n\nvoid layer_norm(float input[N][D_MODEL], float output[N][D_MODEL], float gamma[D_MODEL], float beta[D_MODEL]) {\n    for (int i = 0; i < N; i++) {\n        float mean = 0.0;\n        float variance = 0.0;\n        for (int j = 0; j < D_MODEL; j++) {\n            mean += input[i][j];\n        }\n        mean /= D_MODEL;\n        for (int j = 0; j < D_MODEL; j++) {\n            variance += (input[i][j] - mean) * (input[i][j] - mean);\n        }\n        variance /= D_MODEL;\n        float stddev = hls::sqrt(variance + 1e-5);\n        for (int j = 0; j < D_MODEL; j++) {\n            output[i][j] = gamma[j] * ((input[i][j] - mean) / stddev) + beta[j];\n        }\n    }\n}\n\nvoid feed_forward(float input[N][D_MODEL], float output[N][D_MODEL], float weights1[D_MODEL][D_FF], float bias1[D_FF], float weights2[D_FF][D_MODEL], float bias2[D_MODEL]) {\n    float intermediate[N][D_FF];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < D_FF; j++) {\n            intermediate[i][j] = bias1[j];\n            for (int k = 0; k < D_MODEL; k++) {\n                intermediate[i][j] += input[i][k] * weights1[k][j];\n            }\n            intermediate[i][j] = hls::max(0.0f, intermediate[i][j]); // ReLU activation\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < D_MODEL; j++) {\n            output[i][j] = bias2[j];\n            for (int k = 0; k < D_FF; k++) {\n                output[i][j] += intermediate[i][k] * weights2[k][j];\n            }\n        }\n    }\n}\n\nvoid add_and_norm(float input1[N][D_MODEL], float input2[N][D_MODEL], float output[N][D_MODEL], float gamma[D_MODEL], float beta[D_MODEL]) {\n    float added[N][D_MODEL];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < D_MODEL; j++) {\n            added[i][j] = input1[i][j] + input2[i][j];\n        }\n    }\n    layer_norm(added, output, gamma, beta);\n}\n\nvoid transformer_decoder_block(float input[N][D_MODEL], float output[N][D_MODEL], float self_attn_out[N][D_MODEL], float enc_dec_attn_out[N][D_MODEL], float gamma1[D_MODEL], float beta1[D_MODEL], float gamma2[D_MODEL], float beta2[D_MODEL], float gamma3[D_MODEL], float beta3[D_MODEL], float weights1[D_MODEL][D_FF], float bias1[D_FF], float weights2[D_FF][D_MODEL], float bias2[D_MODEL]) {\n    float norm1[N][D_MODEL];\n    float norm2[N][D_MODEL];\n    float ff_out[N][D_MODEL];\n\n    add_and_norm(input, self_attn_out, norm1, gamma1, beta1);\n    add_and_norm(norm1, enc_dec_attn_out, norm2, gamma2, beta2);\n    feed_forward(norm2, ff_out, weights1, bias1, weights2, bias2);\n    add_and_norm(norm2, ff_out, output, gamma3, beta3);\n}\n\n// Top function name: transformer_decoder_block\n"
      }
    ],
    "code_length": 2743,
    "token_count": 838,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/transformer_encoder_block/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3221749809,
    "Worst-caseLatency": 3221749809.0,
    "BRAM_18K": 7168,
    "LUT": 3815,
    "DSP": 10,
    "FF": 2838,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "transformer_encoder_block",
    "ResourceMetric": 0.4457251807,
    "design_id": "project",
    "algo_name": "transformer_encoder_block",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "transformer_encoder_block.cpp",
        "file_content": "#include <cmath>\n\n#define INPUT_SIZE 1024\n#define HIDDEN_SIZE 512\n#define OUTPUT_SIZE 512\n\nvoid transformer_encoder_block(\n    float input[INPUT_SIZE][HIDDEN_SIZE],\n    float output[INPUT_SIZE][OUTPUT_SIZE],\n    float weight_q[HIDDEN_SIZE][OUTPUT_SIZE],\n    float weight_k[HIDDEN_SIZE][OUTPUT_SIZE],\n    float weight_v[HIDDEN_SIZE][OUTPUT_SIZE],\n    float weight_o[OUTPUT_SIZE][HIDDEN_SIZE],\n    float bias_q[OUTPUT_SIZE],\n    float bias_k[OUTPUT_SIZE],\n    float bias_v[OUTPUT_SIZE],\n    float bias_o[HIDDEN_SIZE]\n) {\n    float q[INPUT_SIZE][OUTPUT_SIZE];\n    float k[INPUT_SIZE][OUTPUT_SIZE];\n    float v[INPUT_SIZE][OUTPUT_SIZE];\n    float attention_scores[INPUT_SIZE][INPUT_SIZE];\n    float attention_output[INPUT_SIZE][OUTPUT_SIZE];\n    float temp[INPUT_SIZE][HIDDEN_SIZE];\n\n    // Linear transformations for Q, K, V\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            q[i][j] = bias_q[j];\n            k[i][j] = bias_k[j];\n            v[i][j] = bias_v[j];\n            for (int d = 0; d < HIDDEN_SIZE; d++) {\n                q[i][j] += input[i][d] * weight_q[d][j];\n                k[i][j] += input[i][d] * weight_k[d][j];\n                v[i][j] += input[i][d] * weight_v[d][j];\n            }\n        }\n    }\n\n    // Compute attention scores\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < INPUT_SIZE; j++) {\n            attention_scores[i][j] = 0;\n            for (int d = 0; d < OUTPUT_SIZE; d++) {\n                attention_scores[i][j] += q[i][d] * k[j][d];\n            }\n            attention_scores[i][j] /= sqrt(OUTPUT_SIZE);\n        }\n    }\n\n    // Compute attention output\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            attention_output[i][j] = 0;\n            for (int d = 0; d < INPUT_SIZE; d++) {\n                attention_output[i][j] += attention_scores[i][d] * v[d][j];\n            }\n        }\n    }\n\n    // Linear transformation for output\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < HIDDEN_SIZE; j++) {\n            temp[i][j] = bias_o[j];\n            for (int d = 0; d < OUTPUT_SIZE; d++) {\n                temp[i][j] += attention_output[i][d] * weight_o[d][j];\n            }\n        }\n    }\n\n    // Output assignment\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            output[i][j] = temp[i][j];\n        }\n    }\n}\n\n// Top function name: transformer_encoder_block\n"
      }
    ],
    "code_length": 2493,
    "token_count": 712,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/transposed_convolution/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9221,
    "Worst-caseLatency": 9221.0,
    "BRAM_18K": 0,
    "LUT": 710,
    "DSP": 5,
    "FF": 581,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "transposed_convolution",
    "ResourceMetric": 0.0003303802,
    "design_id": "project",
    "algo_name": "transposed_convolution",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "transposed_convolution.cpp",
        "file_content": "#include <iostream>\n\n#define INPUT_SIZE 1024\n#define OUTPUT_SIZE 2048\n#define KERNEL_SIZE 3\n#define STRIDE 2\n\nvoid transposed_convolution(\n    float input[INPUT_SIZE],\n    float kernel[KERNEL_SIZE],\n    float output[OUTPUT_SIZE])\n{\n    int output_index = 0;\n    for (int i = 0; i < INPUT_SIZE; i++) {\n        for (int k = 0; k < KERNEL_SIZE; k++) {\n            output[output_index + k] += input[i] * kernel[k];\n        }\n        output_index += STRIDE;\n    }\n}\n\n// Top function name: transposed_convolution\n"
      }
    ],
    "code_length": 507,
    "token_count": 138,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/triplet_loss/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 290817,
    "Worst-caseLatency": 290817.0,
    "BRAM_18K": 0,
    "LUT": 1361,
    "DSP": 7,
    "FF": 1069,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "triplet_loss",
    "ResourceMetric": 0.0005574176,
    "design_id": "project",
    "algo_name": "triplet_loss",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "triplet_loss.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid triplet_loss(float anchor[N][128], float positive[N][128], float negative[N][128], float margin, float loss[N]) {\n    for (int i = 0; i < N; i++) {\n        float pos_dist = 0.0f;\n        float neg_dist = 0.0f;\n\n        for (int j = 0; j < 128; j++) {\n            float diff_pos = anchor[i][j] - positive[i][j];\n            float diff_neg = anchor[i][j] - negative[i][j];\n            pos_dist += diff_pos * diff_pos;\n            neg_dist += diff_neg * diff_neg;\n        }\n\n        pos_dist = sqrt(pos_dist);\n        neg_dist = sqrt(neg_dist);\n\n        loss[i] = fmax(0.0f, pos_dist - neg_dist + margin);\n    }\n}\n\n// Top function name: triplet_loss\n"
      }
    ],
    "code_length": 686,
    "token_count": 197,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_ip/true_random_number_generator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 88,
    "DSP": 0,
    "FF": 45,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "true_random_number_generator",
    "ResourceMetric": 2.119e-05,
    "design_id": "project",
    "algo_name": "true_random_number_generator",
    "source_name": "rtl_ip",
    "source_code": [
      {
        "file_name": "true_random_number_generator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid true_random_number_generator(ap_uint<32> seed, ap_uint<32> output[ARRAY_SIZE]) {\n    ap_uint<32> lfsr = seed;\n    ap_uint<32> bit;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1;\n        lfsr = (lfsr >> 1) | (bit << 31);\n        output[i] = lfsr;\n    }\n}\n\n// Top function name: true_random_number_generator\n"
      }
    ],
    "code_length": 429,
    "token_count": 157,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/trust_region_method/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 4121,
    "Worst-caseLatency": 4202567.0,
    "BRAM_18K": 0,
    "LUT": 2796,
    "DSP": 11,
    "FF": 1965,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "trust_region_method",
    "ResourceMetric": 0.0010293264,
    "design_id": "project",
    "algo_name": "trust_region_method",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "trust_region_method.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid trust_region_method(double x[N], double g[N], double H[N][N], double delta, double p[N]) {\n    double norm_g = 0.0;\n    for (int i = 0; i < N; i++) {\n        norm_g += g[i] * g[i];\n    }\n    norm_g = std::sqrt(norm_g);\n\n    if (norm_g <= delta) {\n        for (int i = 0; i < N; i++) {\n            p[i] = -g[i];\n        }\n    } else {\n        double norm_p = 0.0;\n        for (int i = 0; i < N; i++) {\n            p[i] = 0.0;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                p[i] += H[i][j] * g[j];\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            norm_p += p[i] * p[i];\n        }\n        norm_p = std::sqrt(norm_p);\n        if (norm_p <= delta) {\n            for (int i = 0; i < N; i++) {\n                p[i] = -p[i];\n            }\n        } else {\n            double factor = delta / norm_p;\n            for (int i = 0; i < N; i++) {\n                p[i] = -factor * p[i];\n            }\n        }\n    }\n}\n\n// Top function name: trust_region_method\n"
      }
    ],
    "code_length": 1092,
    "token_count": 348,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/uart_transmitter_receiver/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 1,
    "LUT": 130,
    "DSP": 0,
    "FF": 30,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "uart_transmitter_receiver",
    "ResourceMetric": 8.98099e-05,
    "design_id": "project",
    "algo_name": "uart_transmitter_receiver",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "uart_transmitter_receiver.cpp",
        "file_content": "#include <stdint.h>\n\n#define BUFFER_SIZE 1024\n\nvoid uart_transmitter_receiver(uint8_t tx_data[BUFFER_SIZE], uint8_t rx_data[BUFFER_SIZE], uint8_t tx_enable, uint8_t rx_enable, uint8_t *tx_done, uint8_t *rx_done) {\n    uint8_t tx_buffer[BUFFER_SIZE];\n    uint8_t rx_buffer[BUFFER_SIZE];\n    \n    // Transmitter\n    if (tx_enable) {\n        for (int i = 0; i < BUFFER_SIZE; i++) {\n            tx_buffer[i] = tx_data[i];\n        }\n        *tx_done = 1;\n    } else {\n        *tx_done = 0;\n    }\n\n    // Receiver\n    if (rx_enable) {\n        for (int i = 0; i < BUFFER_SIZE; i++) {\n            rx_data[i] = rx_buffer[i];\n        }\n        *rx_done = 1;\n    } else {\n        *rx_done = 0;\n    }\n}\n\n// Top function name: uart_transmitter_receiver\n"
      }
    ],
    "code_length": 740,
    "token_count": 219,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/unet_block/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6558703,
    "Worst-caseLatency": 6558703.0,
    "BRAM_18K": 4080,
    "LUT": 2906,
    "DSP": 10,
    "FF": 3153,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "unet_block",
    "ResourceMetric": 0.2541128154,
    "design_id": "project",
    "algo_name": "unet_block",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "unet_block.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define INPUT_SIZE 1024\n#define FILTER_SIZE 3\n#define OUTPUT_SIZE (INPUT_SIZE - FILTER_SIZE + 1)\n\nvoid conv2d(float input[INPUT_SIZE][INPUT_SIZE], float filter[FILTER_SIZE][FILTER_SIZE], float output[OUTPUT_SIZE][OUTPUT_SIZE]) {\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            float sum = 0.0;\n            for (int fi = 0; fi < FILTER_SIZE; fi++) {\n                for (int fj = 0; fj < FILTER_SIZE; fj++) {\n                    sum += input[i + fi][j + fj] * filter[fi][fj];\n                }\n            }\n            output[i][j] = sum;\n        }\n    }\n}\n\nvoid relu(float input[OUTPUT_SIZE][OUTPUT_SIZE], float output[OUTPUT_SIZE][OUTPUT_SIZE]) {\n    for (int i = 0; i < OUTPUT_SIZE; i++) {\n        for (int j = 0; j < OUTPUT_SIZE; j++) {\n            output[i][j] = std::max(0.0f, input[i][j]);\n        }\n    }\n}\n\nvoid maxpool2d(float input[OUTPUT_SIZE][OUTPUT_SIZE], float output[OUTPUT_SIZE / 2][OUTPUT_SIZE / 2]) {\n    for (int i = 0; i < OUTPUT_SIZE; i += 2) {\n        for (int j = 0; j < OUTPUT_SIZE; j += 2) {\n            float max_val = input[i][j];\n            max_val = std::max(max_val, input[i + 1][j]);\n            max_val = std::max(max_val, input[i][j + 1]);\n            max_val = std::max(max_val, input[i + 1][j + 1]);\n            output[i / 2][j / 2] = max_val;\n        }\n    }\n}\n\nvoid unet_block(float input[INPUT_SIZE][INPUT_SIZE], float filter[FILTER_SIZE][FILTER_SIZE], float output[OUTPUT_SIZE / 2][OUTPUT_SIZE / 2]) {\n    float conv_output[OUTPUT_SIZE][OUTPUT_SIZE];\n    float relu_output[OUTPUT_SIZE][OUTPUT_SIZE];\n    conv2d(input, filter, conv_output);\n    relu(conv_output, relu_output);\n    maxpool2d(relu_output, output);\n}\n\n// Top function name: unet_block\n"
      }
    ],
    "code_length": 1784,
    "token_count": 520,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/universal_hexadecimal_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 94,
    "DSP": 0,
    "FF": 17,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "universal_hexadecimal_counter",
    "ResourceMetric": 1.96559e-05,
    "design_id": "project",
    "algo_name": "universal_hexadecimal_counter",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "universal_hexadecimal_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid universal_hexadecimal_counter(ap_uint<4> start_value, ap_uint<4> counter[SIZE]) {\n    ap_uint<4> current_value = start_value;\n    for (int i = 0; i < SIZE; i++) {\n        counter[i] = current_value;\n        current_value++;\n        if (current_value == 16) {\n            current_value = 0;\n        }\n    }\n}\n\n// Top function name: universal_hexadecimal_counter\n"
      }
    ],
    "code_length": 406,
    "token_count": 107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/universal_shift_register/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 293,
    "DSP": 0,
    "FF": 36,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "universal_shift_register",
    "ResourceMetric": 5.96389e-05,
    "design_id": "project",
    "algo_name": "universal_shift_register",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "universal_shift_register.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid universal_shift_register(ap_uint<1> mode, ap_uint<10> shift_amount, ap_uint<32> data_in[SIZE], ap_uint<32> data_out[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        if (mode == 0) { // Logical left shift\n            data_out[i] = data_in[i] << shift_amount;\n        } else if (mode == 1) { // Logical right shift\n            data_out[i] = data_in[i] >> shift_amount;\n        } else if (mode == 2) { // Arithmetic right shift\n            data_out[i] = (ap_int<32>)data_in[i] >> shift_amount;\n        } else { // Rotate right\n            data_out[i] = (data_in[i] >> shift_amount) | (data_in[i] << (32 - shift_amount));\n        }\n    }\n}\n\n// Top function name: universal_shift_register\n"
      }
    ],
    "code_length": 734,
    "token_count": 212,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/unsupervised_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 22030392,
    "Worst-caseLatency": 22040732.0,
    "BRAM_18K": 20,
    "LUT": 2729,
    "DSP": 5,
    "FF": 1968,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "unsupervised_learning",
    "ResourceMetric": 0.0020906218,
    "design_id": "project",
    "algo_name": "unsupervised_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "unsupervised_learning.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid unsupervised_learning(float data[N][N], float centroids[10][N], int labels[N]) {\n    int i, j, k;\n    float min_dist, dist;\n    int min_index;\n\n    // Initialize centroids (for simplicity, using first 10 data points as initial centroids)\n    for (i = 0; i < 10; i++) {\n        for (j = 0; j < N; j++) {\n            centroids[i][j] = data[i][j];\n        }\n    }\n\n    // Main loop for clustering\n    for (i = 0; i < N; i++) {\n        min_dist = 1e30;\n        min_index = -1;\n        for (j = 0; j < 10; j++) {\n            dist = 0;\n            for (k = 0; k < N; k++) {\n                dist += (data[i][k] - centroids[j][k]) * (data[i][k] - centroids[j][k]);\n            }\n            if (dist < min_dist) {\n                min_dist = dist;\n                min_index = j;\n            }\n        }\n        labels[i] = min_index;\n    }\n\n    // Update centroids\n    int count[10] = {0};\n    float sum[10][N] = {0};\n\n    for (i = 0; i < N; i++) {\n        int label = labels[i];\n        count[label]++;\n        for (j = 0; j < N; j++) {\n            sum[label][j] += data[i][j];\n        }\n    }\n\n    for (i = 0; i < 10; i++) {\n        if (count[i] > 0) {\n            for (j = 0; j < N; j++) {\n                centroids[i][j] = sum[i][j] / count[i];\n            }\n        }\n    }\n}\n\n// Top function name: unsupervised_learning\n"
      }
    ],
    "code_length": 1356,
    "token_count": 417,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/unsynchronized_io_maxi/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 9,
    "Worst-caseLatency": 9.0,
    "BRAM_18K": 4,
    "LUT": 1494,
    "DSP": 4,
    "FF": 1134,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "stable_pointer",
    "ResourceMetric": 0.0007540588,
    "design_id": "project",
    "algo_name": "unsynchronized_io_maxi",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include \"ap_axi_sdata.h\"\n#include \"ap_int.h\"\n#include \"hls_stream.h\"\n#define HLS_TASK_ALLOW_NON_STREAM_ARGS\n#include \"hls_print.h\"\n#include \"hls_task.h\"\n\nvoid process_23(hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS INLINE off\n    static int state = 0;\n    static int val;\n\n    in.read(val);\n    val = val * 23;\n    out.write(val);\n}\n\nvoid process_11(hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS INLINE off\n    static int state = 0;\n    static int val;\n\n    in.read(val);\n    val = val * 11;\n    out.write(val);\n}\n\nvoid write_process(hls::stream<int>& in, hls::stream<int>& out, int* mem) {\n    int val;\n    static int addr = 0;\n\n    in.read(val);\n    if (addr >= 32)\n        addr = 0;\n    mem[addr] = val;\n    addr++;\n    val = mem[addr - 1];\n    out.write(val);\n}\n\nextern \"C\" {\n\nvoid stable_pointer(int* mem, hls::stream<int>& in, hls::stream<int>& out) {\n#pragma HLS DATAFLOW\n#pragma HLS INTERFACE mode = m_axi bundle = gmem depth =                       \\\n    256 max_read_burst_length = 16 max_widen_bitwidth =                        \\\n        512 max_write_burst_length = 16 num_read_outstanding =                 \\\n            16 num_write_outstanding = 16 port = mem\n#pragma HLS stable variable = mem\n\n    hls_thread_local hls::stream<int> int_fifo(\"int_fifo\");\n#pragma HLS STREAM depth = 512 type = fifo variable = int_fifo\n    hls_thread_local hls::stream<int> int_fifo2(\"int_fifo2\");\n#pragma HLS STREAM depth = 512 type = fifo variable = int_fifo2\n\n    hls_thread_local hls::task t1(process_23, in, int_fifo);\n    hls_thread_local hls::task t2(process_11, int_fifo, int_fifo2);\n    hls_thread_local hls::task t3(write_process, int_fifo2, out, mem);\n}\n\n} // extern \"C\"\n"
      },
      {
        "file_name": "xstable_pointer_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of mem\n//        bit 31~0 - mem[31:0] (Read/Write)\n// 0x14 : Data signal of mem\n//        bit 31~0 - mem[63:32] (Read/Write)\n// 0x18 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA 0x10\n#define XSTABLE_POINTER_CONTROL_BITS_MEM_DATA 64\n\n"
      },
      {
        "file_name": "xstable_pointer.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XSTABLE_POINTER_H\n#define XSTABLE_POINTER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xstable_pointer_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XStable_pointer_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XStable_pointer;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XStable_pointer_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XStable_pointer_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XStable_pointer_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XStable_pointer_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, UINTPTR BaseAddress);\nXStable_pointer_Config* XStable_pointer_LookupConfig(UINTPTR BaseAddress);\n#else\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, u16 DeviceId);\nXStable_pointer_Config* XStable_pointer_LookupConfig(u16 DeviceId);\n#endif\nint XStable_pointer_CfgInitialize(XStable_pointer *InstancePtr, XStable_pointer_Config *ConfigPtr);\n#else\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, const char* InstanceName);\nint XStable_pointer_Release(XStable_pointer *InstancePtr);\n#endif\n\n\nvoid XStable_pointer_Set_mem(XStable_pointer *InstancePtr, u64 Data);\nu64 XStable_pointer_Get_mem(XStable_pointer *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xstable_pointer.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xstable_pointer.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XStable_pointer_CfgInitialize(XStable_pointer *InstancePtr, XStable_pointer_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XStable_pointer_Set_mem(XStable_pointer *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XStable_pointer_WriteReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA, (u32)(Data));\n    XStable_pointer_WriteReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XStable_pointer_Get_mem(XStable_pointer *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XStable_pointer_ReadReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA);\n    Data += (u64)XStable_pointer_ReadReg(InstancePtr->Control_BaseAddress, XSTABLE_POINTER_CONTROL_ADDR_MEM_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xstable_pointer_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xstable_pointer.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XStable_pointer_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XStable_pointer_uio_map maps[ MAX_UIO_MAPS ];\n} XStable_pointer_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XStable_pointer_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XStable_pointer_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XStable_pointer_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XStable_pointer_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XStable_pointer_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, const char* InstanceName) {\n\tXStable_pointer_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XStable_pointer_Release(XStable_pointer *InstancePtr) {\n\tXStable_pointer_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xstable_pointer_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xstable_pointer.h\"\n\nextern XStable_pointer_Config XStable_pointer_ConfigTable[];\n\n#ifdef SDT\nXStable_pointer_Config *XStable_pointer_LookupConfig(UINTPTR BaseAddress) {\n\tXStable_pointer_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XStable_pointer_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XStable_pointer_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XStable_pointer_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, UINTPTR BaseAddress) {\n\tXStable_pointer_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XStable_pointer_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XStable_pointer_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXStable_pointer_Config *XStable_pointer_LookupConfig(u16 DeviceId) {\n\tXStable_pointer_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XSTABLE_POINTER_NUM_INSTANCES; Index++) {\n\t\tif (XStable_pointer_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XStable_pointer_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XStable_pointer_Initialize(XStable_pointer *InstancePtr, u16 DeviceId) {\n\tXStable_pointer_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XStable_pointer_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XStable_pointer_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 11019,
    "token_count": 2946,
    "pragma_number": 7,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/unsynchronized_io_scalar/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 309,
    "DSP": 0,
    "FF": 142,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "test",
    "ResourceMetric": 7.28706e-05,
    "design_id": "project",
    "algo_name": "unsynchronized_io_scalar",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#pragma once\n\n#include \"hls_task.h\"\n#define N 100\n#include <iostream>\n\nvoid test(hls::stream<int>& in, hls::stream<int>& out, int n);\n\n\nvoid sub_task1(hls::stream<int>& in, hls::stream<int>& out) {\n    int c = in.read();\n    out.write(c + 2);\n}\n\nvoid sub_task2(hls::stream<int>& in, hls::stream<int>& out) {\n    int c = in.read();\n    out.write(c - 1);\n}\n\nvoid task2(hls::stream<int>& in, hls::stream<int>& out, int n) {\n    int c = in.read();\n    out.write(c + 2 + n);\n}\n\nvoid test(hls::stream<int>& in, hls::stream<int>& out, int n) {\n#pragma HLS STABLE variable = n\n    HLS_TASK_STREAM<int> s1;\n    HLS_TASK_STREAM<int> s2;\n    HLS_TASK t(task2, s2, out, n);\n    HLS_TASK t1(sub_task1, in, s1);\n    HLS_TASK t2(sub_task2, s1, s2);\n}\n\n"
      }
    ],
    "code_length": 2123,
    "token_count": 561,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/up_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 123,
    "DSP": 2,
    "FF": 13,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "up_counter",
    "ResourceMetric": 8.02413e-05,
    "design_id": "project",
    "algo_name": "up_counter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "up_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid up_counter(ap_uint<32> start_value, ap_uint<32> increment, ap_uint<32> result[SIZE]) {\n    for (int i = 0; i < SIZE; i++) {\n        result[i] = start_value + i * increment;\n    }\n}\n\n// Top function name: up_counter\n"
      }
    ],
    "code_length": 260,
    "token_count": 79,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/up_down_counter/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 107,
    "DSP": 0,
    "FF": 37,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "up_down_counter",
    "ResourceMetric": 2.40665e-05,
    "design_id": "project",
    "algo_name": "up_down_counter",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "up_down_counter.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid up_down_counter(ap_uint<32> input[SIZE], ap_uint<32> output[SIZE]) {\n    ap_uint<32> counter = 0;\n    for (int i = 0; i < SIZE; i++) {\n        if (input[i] % 2 == 0) {\n            counter++;\n        } else {\n            counter--;\n        }\n        output[i] = counter;\n    }\n}\n\n// Top function name: up_down_counter\n"
      }
    ],
    "code_length": 362,
    "token_count": 107,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_C++_templates/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 103,
    "DSP": 0,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cpp_template",
    "ResourceMetric": 1.97518e-05,
    "design_id": "project",
    "algo_name": "using_C++_templates",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _CPP_TEMPLATE_H_\n#define _CPP_TEMPLATE_H_\n\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\n\n#define FIB_N 5\n\ntypedef int data_t;\n\nvoid cpp_template(data_t a, data_t b, data_t& dout);\n\n#endif\n\n// Tail recursive call\ntemplate <data_t N> struct fibon_s {\n    template <typename T> static T fibon_f(T a, T b) {\n        return fibon_s<N - 1>::fibon_f(b, (a + b));\n    }\n};\n\n// Termination condition\ntemplate <> struct fibon_s<1> {\n    template <typename T> static T fibon_f(T a, T b) { return b; }\n};\n\nvoid cpp_template(data_t a, data_t b, data_t& dout) {\n    dout = fibon_s<FIB_N>::fibon_f(a, b);\n}\n"
      }
    ],
    "code_length": 2041,
    "token_count": 506,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_C++_templates_for_multiple_instances/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 407,
    "DSP": 0,
    "FF": 326,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cpp_template",
    "ResourceMetric": 0.000109306,
    "design_id": "project",
    "algo_name": "using_C++_templates_for_multiple_instances",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _CPP_TEMPLATE_H_\n#define _CPP_TEMPLATE_H_\n\n#include <cstdio>\n\nvoid cpp_template(int inp, int* out);\n\ntemplate <int K> void func_with_static(int inp, int* dout) {\n    // Use inline off pragma to avoid automatic inlining\n#pragma HLS INLINE off\n    static int acc = 0;\n    acc += inp;\n    *dout = acc;\n}\n\n#endif\n\nvoid cpp_template(int inp, int* out) {\n    int out0, out1, out2, out3, out4;\n\n    // Use templated functions to get multiple instances\n    // of the same function.\n    func_with_static<1>(inp, &out0);\n    func_with_static<2>(inp, &out1);\n    func_with_static<3>(inp, &out2);\n    func_with_static<4>(inp, &out3);\n    func_with_static<5>(inp, &out4);\n\n    *out += out0 + out1 + out2 + out3 + out4;\n}\n"
      }
    ],
    "code_length": 2104,
    "token_count": 528,
    "pragma_number": 1,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_arbitrary_precision_arith/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 36,
    "Worst-caseLatency": 36.0,
    "BRAM_18K": 0,
    "LUT": 591,
    "DSP": 1,
    "FF": 717,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cpp_ap_int_arith",
    "ResourceMetric": 0.0002097846,
    "design_id": "project",
    "algo_name": "using_arbitrary_precision_arith",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _CPP_AP_INT_ARITH_H_\n#define _CPP_AP_INT_ARITH_H_\n\n#include \"ap_int.h\"\n// Missing include: #include <stdio.h>\n\n#define N 9\n\n// Old data types\n// typedef char dinA_t;\n// typedef short dinB_t;\n// typedef int dinC_t;\n// typedef long long dinD_t;\n// typedef int dout1_t;\n// typedef unsigned int dout2_t;\n// typedef int32_t dout3_t;\n// typedef int64_t dout4_t;\n\ntypedef ap_int<6> dinA_t;\ntypedef ap_int<12> dinB_t;\ntypedef ap_int<22> dinC_t;\ntypedef ap_int<33> dinD_t;\n\ntypedef ap_int<18> dout1_t;\ntypedef ap_uint<13> dout2_t;\ntypedef ap_int<22> dout3_t;\ntypedef ap_int<6> dout4_t;\n\nvoid cpp_ap_int_arith(dinA_t inA, dinB_t inB, dinC_t inC, dinD_t inD,\n                      dout1_t* out1, dout2_t* out2, dout3_t* out3,\n                      dout4_t* out4);\n\n#endif\n\nvoid cpp_ap_int_arith(dinA_t inA, dinB_t inB, dinC_t inC, dinD_t inD,\n                      dout1_t* out1, dout2_t* out2, dout3_t* out3,\n                      dout4_t* out4) {\n\n    // Basic arithmetic operations\n    *out1 = inA * inB;\n    *out2 = inB + inA;\n    *out3 = inC / inA;\n    *out4 = inD % inA;\n}\n"
      }
    ],
    "code_length": 2464,
    "token_count": 676,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_arbitrary_precision_casting/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 5,
    "DSP": 1,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "arbitrary_precision_casting",
    "ResourceMetric": 2.86627e-05,
    "design_id": "project",
    "algo_name": "using_arbitrary_precision_casting",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _ARBITRARY_PRECISION_CASTING_H_\n#define _ARBITRARY_PRECISION_CASTING_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n\ntypedef ap_int<18> din_t;\ntypedef ap_int<36> dout_t;\n\ndout_t arbitrary_precision_casting(din_t a, din_t b);\n\n#endif\n\ndout_t arbitrary_precision_casting(din_t a, din_t b) {\n\n    return (dout_t)a * (dout_t)b;\n}\n"
      }
    ],
    "code_length": 1760,
    "token_count": 422,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_array_of_streams/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 33,
    "Worst-caseLatency": 33.0,
    "BRAM_18K": 0,
    "LUT": 417,
    "DSP": 0,
    "FF": 182,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "dut",
    "ResourceMetric": 9.74165e-05,
    "design_id": "project",
    "algo_name": "using_array_of_streams",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef __ARRAY_OF_STREAMS_EXAMPLE__\n#define __ARRAY_OF_STREAMS_EXAMPLE__\n\n#include \"hls_stream.h\"\n#include <iostream>\n\n#define M 3\n\nextern int dut(hls::stream<int> s_in[M], hls::stream<int> s_out[M]);\n\n#endif\n\nint dut(hls::stream<int> s_in[M], hls::stream<int> s_out[M]) {\n#pragma HLS INTERFACE axis port = s_in\n#pragma HLS INTERFACE axis port = s_out\n\n    int sum = 0;\n    for (unsigned j = 0; j < M; j++) {\n        for (unsigned i = 0; i < 10; i++) {\n            int val = s_in[j].read();\n            s_out[j].write(val + 2);\n            sum += val;\n        }\n    }\n    return sum;\n}\n"
      }
    ],
    "code_length": 1976,
    "token_count": 489,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_axi_lite/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 142,
    "DSP": 0,
    "FF": 92,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 3.60518e-05,
    "design_id": "project",
    "algo_name": "using_axi_lite",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Missing include: #include <stdio.h>\n\nvoid example(char* a, char* b, char* c) {\n#pragma HLS INTERFACE s_axilite port = a bundle = BUS_A\n#pragma HLS INTERFACE s_axilite port = b bundle = BUS_A\n#pragma HLS INTERFACE s_axilite port = c bundle = BUS_A\n#pragma HLS INTERFACE s_axilite port = return bundle = BUS_A\n\n    *c += *a + *b;\n}\n"
      },
      {
        "file_name": "xexample_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xexample.h\"\n\nextern XExample_Config XExample_ConfigTable[];\n\n#ifdef SDT\nXExample_Config *XExample_LookupConfig(UINTPTR BaseAddress) {\n\tXExample_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XExample_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XExample_ConfigTable[Index].Bus_a_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XExample_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XExample_Initialize(XExample *InstancePtr, UINTPTR BaseAddress) {\n\tXExample_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XExample_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XExample_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXExample_Config *XExample_LookupConfig(u16 DeviceId) {\n\tXExample_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XEXAMPLE_NUM_INSTANCES; Index++) {\n\t\tif (XExample_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XExample_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XExample_Initialize(XExample *InstancePtr, u16 DeviceId) {\n\tXExample_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XExample_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XExample_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      },
      {
        "file_name": "xexample.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XEXAMPLE_H\n#define XEXAMPLE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xexample_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Bus_a_BaseAddress;\n} XExample_Config;\n#endif\n\ntypedef struct {\n    u64 Bus_a_BaseAddress;\n    u32 IsReady;\n} XExample;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XExample_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XExample_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XExample_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XExample_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XExample_Initialize(XExample *InstancePtr, UINTPTR BaseAddress);\nXExample_Config* XExample_LookupConfig(UINTPTR BaseAddress);\n#else\nint XExample_Initialize(XExample *InstancePtr, u16 DeviceId);\nXExample_Config* XExample_LookupConfig(u16 DeviceId);\n#endif\nint XExample_CfgInitialize(XExample *InstancePtr, XExample_Config *ConfigPtr);\n#else\nint XExample_Initialize(XExample *InstancePtr, const char* InstanceName);\nint XExample_Release(XExample *InstancePtr);\n#endif\n\nvoid XExample_Start(XExample *InstancePtr);\nu32 XExample_IsDone(XExample *InstancePtr);\nu32 XExample_IsIdle(XExample *InstancePtr);\nu32 XExample_IsReady(XExample *InstancePtr);\nvoid XExample_EnableAutoRestart(XExample *InstancePtr);\nvoid XExample_DisableAutoRestart(XExample *InstancePtr);\n\nvoid XExample_Set_a(XExample *InstancePtr, u32 Data);\nu32 XExample_Get_a(XExample *InstancePtr);\nvoid XExample_Set_b(XExample *InstancePtr, u32 Data);\nu32 XExample_Get_b(XExample *InstancePtr);\nvoid XExample_Set_c_i(XExample *InstancePtr, u32 Data);\nu32 XExample_Get_c_i(XExample *InstancePtr);\nu32 XExample_Get_c_o(XExample *InstancePtr);\nu32 XExample_Get_c_o_vld(XExample *InstancePtr);\n\nvoid XExample_InterruptGlobalEnable(XExample *InstancePtr);\nvoid XExample_InterruptGlobalDisable(XExample *InstancePtr);\nvoid XExample_InterruptEnable(XExample *InstancePtr, u32 Mask);\nvoid XExample_InterruptDisable(XExample *InstancePtr, u32 Mask);\nvoid XExample_InterruptClear(XExample *InstancePtr, u32 Mask);\nu32 XExample_InterruptGetEnabled(XExample *InstancePtr);\nu32 XExample_InterruptGetStatus(XExample *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xexample_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xexample.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XExample_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XExample_uio_map maps[ MAX_UIO_MAPS ];\n} XExample_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XExample_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XExample_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XExample_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XExample_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XExample_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XExample_Initialize(XExample *InstancePtr, const char* InstanceName) {\n\tXExample_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Bus_a' should be mapped to uioX/map0\n    InstancePtr->Bus_a_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Bus_a_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XExample_Release(XExample *InstancePtr) {\n\tXExample_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Bus_a_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xexample.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xexample.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XExample_CfgInitialize(XExample *InstancePtr, XExample_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Bus_a_BaseAddress = ConfigPtr->Bus_a_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XExample_Start(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL) & 0x80;\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL, Data | 0x01);\n}\n\nu32 XExample_IsDone(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL);\n    return (Data >> 1) & 0x1;\n}\n\nu32 XExample_IsIdle(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL);\n    return (Data >> 2) & 0x1;\n}\n\nu32 XExample_IsReady(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL);\n    // check ap_start to see if the pcore is ready for next input\n    return !(Data & 0x1);\n}\n\nvoid XExample_EnableAutoRestart(XExample *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL, 0x80);\n}\n\nvoid XExample_DisableAutoRestart(XExample *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_AP_CTRL, 0);\n}\n\nvoid XExample_Set_a(XExample *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_A_DATA, Data);\n}\n\nu32 XExample_Get_a(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_A_DATA);\n    return Data;\n}\n\nvoid XExample_Set_b(XExample *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_B_DATA, Data);\n}\n\nu32 XExample_Get_b(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_B_DATA);\n    return Data;\n}\n\nvoid XExample_Set_c_i(XExample *InstancePtr, u32 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_C_I_DATA, Data);\n}\n\nu32 XExample_Get_c_i(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_C_I_DATA);\n    return Data;\n}\n\nu32 XExample_Get_c_o(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_C_O_DATA);\n    return Data;\n}\n\nu32 XExample_Get_c_o_vld(XExample *InstancePtr) {\n    u32 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_C_O_CTRL);\n    return Data & 0x1;\n}\n\nvoid XExample_InterruptGlobalEnable(XExample *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_GIE, 1);\n}\n\nvoid XExample_InterruptGlobalDisable(XExample *InstancePtr) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_GIE, 0);\n}\n\nvoid XExample_InterruptEnable(XExample *InstancePtr, u32 Mask) {\n    u32 Register;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Register =  XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_IER);\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_IER, Register | Mask);\n}\n\nvoid XExample_InterruptDisable(XExample *InstancePtr, u32 Mask) {\n    u32 Register;\n\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Register =  XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_IER);\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_IER, Register & (~Mask));\n}\n\nvoid XExample_InterruptClear(XExample *InstancePtr, u32 Mask) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XExample_WriteReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_ISR, Mask);\n}\n\nu32 XExample_InterruptGetEnabled(XExample *InstancePtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    return XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_IER);\n}\n\nu32 XExample_InterruptGetStatus(XExample *InstancePtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    return XExample_ReadReg(InstancePtr->Bus_a_BaseAddress, XEXAMPLE_BUS_A_ADDR_ISR);\n}\n\n"
      },
      {
        "file_name": "xexample_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// BUS_A\n// 0x00 : Control signals\n//        bit 0  - ap_start (Read/Write/SC)\n//        bit 1  - ap_done (Read/COR)\n//        bit 2  - ap_idle (Read)\n//        bit 3  - ap_ready (Read/COR)\n//        bit 7  - auto_restart (Read/Write)\n//        bit 9  - interrupt (Read)\n//        others - reserved\n// 0x04 : Global Interrupt Enable Register\n//        bit 0  - Global Interrupt Enable (Read/Write)\n//        others - reserved\n// 0x08 : IP Interrupt Enable Register (Read/Write)\n//        bit 0 - enable ap_done interrupt (Read/Write)\n//        others - reserved\n// 0x0c : IP Interrupt Status Register (Read/TOW)\n//        bit 0 - ap_done (Read/TOW)\n//        others - reserved\n// 0x10 : Data signal of a\n//        bit 7~0 - a[7:0] (Read/Write)\n//        others  - reserved\n// 0x14 : reserved\n// 0x18 : Data signal of b\n//        bit 7~0 - b[7:0] (Read/Write)\n//        others  - reserved\n// 0x1c : reserved\n// 0x20 : Data signal of c_i\n//        bit 7~0 - c_i[7:0] (Read/Write)\n//        others  - reserved\n// 0x24 : reserved\n// 0x28 : Data signal of c_o\n//        bit 7~0 - c_o[7:0] (Read)\n//        others  - reserved\n// 0x2c : Control signal of c_o\n//        bit 0  - c_o_ap_vld (Read/COR)\n//        others - reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XEXAMPLE_BUS_A_ADDR_AP_CTRL  0x00\n#define XEXAMPLE_BUS_A_ADDR_GIE      0x04\n#define XEXAMPLE_BUS_A_ADDR_IER      0x08\n#define XEXAMPLE_BUS_A_ADDR_ISR      0x0c\n#define XEXAMPLE_BUS_A_ADDR_A_DATA   0x10\n#define XEXAMPLE_BUS_A_BITS_A_DATA   8\n#define XEXAMPLE_BUS_A_ADDR_B_DATA   0x18\n#define XEXAMPLE_BUS_A_BITS_B_DATA   8\n#define XEXAMPLE_BUS_A_ADDR_C_I_DATA 0x20\n#define XEXAMPLE_BUS_A_BITS_C_I_DATA 8\n#define XEXAMPLE_BUS_A_ADDR_C_O_DATA 0x28\n#define XEXAMPLE_BUS_A_BITS_C_O_DATA 8\n#define XEXAMPLE_BUS_A_ADDR_C_O_CTRL 0x2c\n\n"
      }
    ],
    "code_length": 14592,
    "token_count": 3967,
    "pragma_number": 4,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_axi_stream_no_side_channel_data/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 75,
    "DSP": 0,
    "FF": 2,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 1.45741e-05,
    "design_id": "project",
    "algo_name": "using_axi_stream_no_side_channel_data",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n\n#define DWIDTH 32\n#define type ap_int<DWIDTH>\n\ntypedef hls::axis_data<type, AXIS_DISABLE_ALL> pkt;\n\nvoid example(hls::stream<pkt>& A, hls::stream<pkt>& B) {\n#pragma HLS INTERFACE axis port = A\n#pragma HLS INTERFACE axis port = B\n\n    pkt tmp;\n    pkt t1;\n    A.read(tmp);\n    t1.data = tmp.data + 5;\n    B.write(t1);\n}\n"
      }
    ],
    "code_length": 1758,
    "token_count": 427,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_axi_stream_with_custom_side_channel_data_1/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 75,
    "DSP": 0,
    "FF": 2,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 1.45741e-05,
    "design_id": "project",
    "algo_name": "using_axi_stream_with_custom_side_channel_data_1",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include <iostream>\n\n// Only TDATA and TLAST\ntypedef hls::axis_data<int, AXIS_ENABLE_LAST> packet;\n\n#define SIZE 5\n\nvoid example(hls::stream<packet>& A, hls::stream<packet>& B);\n\nvoid example(hls::stream<packet>& A, hls::stream<packet>& B) {\n#pragma HLS INTERFACE axis port = A\n#pragma HLS INTERFACE axis port = B\n\n    packet tmp = A.read();\n    tmp.data = tmp.data + 5;\n    B.write(tmp);\n}\n"
      }
    ],
    "code_length": 1843,
    "token_count": 444,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_axi_stream_with_custom_side_channel_data_2/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 56,
    "DSP": 0,
    "FF": 2,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 1.09306e-05,
    "design_id": "project",
    "algo_name": "using_axi_stream_with_custom_side_channel_data_2",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include <iostream>\n\ntypedef hls::axis_user<13, (AXIS_ENABLE_USER | AXIS_ENABLE_LAST)> packet;\n\n#define SIZE 5\n\nvoid example(hls::stream<packet>& A, hls::stream<packet>& B);\n\nvoid example(hls::stream<packet>& A, hls::stream<packet>& B) {\n#pragma HLS INTERFACE axis port = A\n#pragma HLS INTERFACE axis port = B\n\n    packet tmp = A.read();\n    tmp.set_user(tmp.get_user() + 5);\n    B.write(tmp);\n}\n"
      }
    ],
    "code_length": 1848,
    "token_count": 445,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_axi_stream_with_side_channel_data/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1,
    "Worst-caseLatency": 1.0,
    "BRAM_18K": 0,
    "LUT": 75,
    "DSP": 0,
    "FF": 2,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 1.45741e-05,
    "design_id": "project",
    "algo_name": "using_axi_stream_with_side_channel_data",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#pragma once\n\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n#include <iostream>\n\ntypedef ap_axis<32, 2, 5, 6> packet;\n\n#define SIZE 5\n\nvoid example(hls::stream<packet>& A, hls::stream<packet>& B);\n\nvoid example(hls::stream<packet>& A, hls::stream<packet>& B) {\n#pragma HLS INTERFACE axis port = A\n#pragma HLS INTERFACE axis port = B\n\n    packet tmp = A.read();\n    tmp.data = tmp.data + 5;\n    B.write(tmp);\n}\n"
      }
    ],
    "code_length": 1802,
    "token_count": 439,
    "pragma_number": 3,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_axis_array_stream_no_side_channel_data/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 53,
    "Worst-caseLatency": 53.0,
    "BRAM_18K": 0,
    "LUT": 131,
    "DSP": 0,
    "FF": 43,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "example",
    "ResourceMetric": 2.92441e-05,
    "design_id": "project",
    "algo_name": "using_axis_array_stream_no_side_channel_data",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvoid example(int A[50], int B[50]) {\n#pragma HLS INTERFACE axis port = A\n#pragma HLS INTERFACE axis port = B\n\n    int i;\n\n    for (i = 0; i < 50; i++) {\n        B[i] = A[i] + 5;\n    }\n}\n"
      }
    ],
    "code_length": 880,
    "token_count": 221,
    "pragma_number": 2,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_double/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 29,
    "Worst-caseLatency": 29.0,
    "BRAM_18K": 0,
    "LUT": 430,
    "DSP": 0,
    "FF": 128,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "pointer_double",
    "ResourceMetric": 9.47318e-05,
    "design_id": "project",
    "algo_name": "using_double",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.c",
        "file_content": "/*\n * Copyright 2022 Xilinx, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _POINTER_DOUBLE_H_\n#define _POINTER_DOUBLE_H_\n\n// Missing include: #include <stdio.h>\n\ntypedef int data_t;\n\ndata_t pointer_double(data_t pos, data_t x, data_t* flag);\n\n#endif\n\ndata_t sub(data_t ptr[10], data_t size, data_t **flagPtr) {\n  data_t x, i;\n\n  x = 0;\n  // Sum x if AND of local index and double-pointer index is true\n  for (i = 0; i < size; ++i)\n    if (**flagPtr & i)\n      x += *(ptr + i);\n  return x;\n}\n\ndata_t pointer_double(data_t pos, data_t x, data_t *flag) {\n  data_t array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n  data_t *ptrFlag;\n  data_t i;\n\n  ptrFlag = flag;\n\n  // Write x into index position pos\n  if (pos >= 0 & pos < 10)\n    *(array + pos) = x;\n\n  // Pass same index (as pos) as pointer to another function\n  return sub(array, 10, &ptrFlag);\n}\n"
      }
    ],
    "code_length": 2066,
    "token_count": 555,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_fifos/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 22,
    "Worst-caseLatency": 55.0,
    "BRAM_18K": 30,
    "LUT": 10068,
    "DSP": 0,
    "FF": 11830,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "diamond",
    "ResourceMetric": 0.0049250966,
    "design_id": "project",
    "algo_name": "using_fifos",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ntypedef unsigned int data_t;\n#include <hls_stream.h>\n#include <hls_vector.h>\n#include <iostream>\n#include <vector>\n\n#define NUM_WORDS 16\n\n// Each vector will be 64 bytes (16 x 4 bytes)\ntypedef hls::vector<uint32_t, NUM_WORDS> vecOf16Words;\n\nextern \"C\" {\n// Top function\nvoid diamond(vecOf16Words* vecIn, vecOf16Words* vecOut, int size);\n}\n\n// Sub functions\n\nvoid load(vecOf16Words* in, hls::stream<vecOf16Words>& out, int vSize);\nvoid compute_A(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out1,\n               hls::stream<vecOf16Words>& out2, int vSize);\nvoid compute_B(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int vSize);\nvoid compute_C(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int vSize);\nvoid compute_D(hls::stream<vecOf16Words>& in1, hls::stream<vecOf16Words>& in2,\n               hls::stream<vecOf16Words>& out, int vSize);\nvoid store(hls::stream<vecOf16Words>& in, vecOf16Words* out, int vSize);\n#define NUM_WORDS 16\nextern \"C\" {\n\nvoid diamond(vecOf16Words* vecIn, vecOf16Words* vecOut, int size) {\n// The depth setting is required for pointer to array in the interface.\n#pragma HLS INTERFACE m_axi port = vecIn depth = 32\n#pragma HLS INTERFACE m_axi port = vecOut depth = 32\n\n    hls::stream<vecOf16Words> c0, c1, c2, c3, c4, c5;\n    assert(size % 16 == 0);\n\n#pragma HLS dataflow\n    load(vecIn, c0, size);\n    compute_A(c0, c1, c2, size);\n    compute_B(c1, c3, size);\n    compute_C(c2, c4, size);\n    compute_D(c3, c4, c5, size);\n    store(c5, vecOut, size);\n}\n}\n\nvoid load(vecOf16Words* in, hls::stream<vecOf16Words>& out, int size) {\nLoop_Ld:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in[i]);\n    }\n}\n\nvoid compute_A(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out1,\n               hls::stream<vecOf16Words>& out2, int size) {\nLoop_A:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        vecOf16Words t = in.read();\n        out1.write(t * 3);\n        out2.write(t * 3);\n    }\n}\n\nvoid compute_B(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int size) {\nLoop_B:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in.read() + 25);\n    }\n}\n\nvoid compute_C(hls::stream<vecOf16Words>& in, hls::stream<vecOf16Words>& out,\n               int size) {\nLoop_C:\n    for (data_t i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in.read() * 2);\n    }\n}\nvoid compute_D(hls::stream<vecOf16Words>& in1, hls::stream<vecOf16Words>& in2,\n               hls::stream<vecOf16Words>& out, int size) {\nLoop_D:\n    for (data_t i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out.write(in1.read() + in2.read());\n    }\n}\n\nvoid store(hls::stream<vecOf16Words>& in, vecOf16Words* out, int size) {\nLoop_St:\n    for (int i = 0; i < size; i++) {\n#pragma HLS performance target_ti = 32\n#pragma HLS LOOP_TRIPCOUNT max = 32\n        out[i] = in.read();\n    }\n}\n"
      },
      {
        "file_name": "xdiamond.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n/***************************** Include Files *********************************/\n#include \"xdiamond.h\"\n\n/************************** Function Implementation *************************/\n#ifndef __linux__\nint XDiamond_CfgInitialize(XDiamond *InstancePtr, XDiamond_Config *ConfigPtr) {\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(ConfigPtr != NULL);\n\n    InstancePtr->Control_BaseAddress = ConfigPtr->Control_BaseAddress;\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n#endif\n\nvoid XDiamond_Set_vecIn(XDiamond *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA, (u32)(Data));\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDiamond_Get_vecIn(XDiamond *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA);\n    Data += (u64)XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECIN_DATA + 4) << 32;\n    return Data;\n}\n\nvoid XDiamond_Set_vecOut(XDiamond *InstancePtr, u64 Data) {\n    Xil_AssertVoid(InstancePtr != NULL);\n    Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA, (u32)(Data));\n    XDiamond_WriteReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA + 4, (u32)(Data >> 32));\n}\n\nu64 XDiamond_Get_vecOut(XDiamond *InstancePtr) {\n    u64 Data;\n\n    Xil_AssertNonvoid(InstancePtr != NULL);\n    Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    Data = XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA);\n    Data += (u64)XDiamond_ReadReg(InstancePtr->Control_BaseAddress, XDIAMOND_CONTROL_ADDR_VECOUT_DATA + 4) << 32;\n    return Data;\n}\n\n"
      },
      {
        "file_name": "xdiamond_hw.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n// control\n// 0x00 : reserved\n// 0x04 : reserved\n// 0x08 : reserved\n// 0x0c : reserved\n// 0x10 : Data signal of vecIn\n//        bit 31~0 - vecIn[31:0] (Read/Write)\n// 0x14 : Data signal of vecIn\n//        bit 31~0 - vecIn[63:32] (Read/Write)\n// 0x18 : reserved\n// 0x1c : Data signal of vecOut\n//        bit 31~0 - vecOut[31:0] (Read/Write)\n// 0x20 : Data signal of vecOut\n//        bit 31~0 - vecOut[63:32] (Read/Write)\n// 0x24 : reserved\n// (SC = Self Clear, COR = Clear on Read, TOW = Toggle on Write, COH = Clear on Handshake)\n\n#define XDIAMOND_CONTROL_ADDR_VECIN_DATA  0x10\n#define XDIAMOND_CONTROL_BITS_VECIN_DATA  64\n#define XDIAMOND_CONTROL_ADDR_VECOUT_DATA 0x1c\n#define XDIAMOND_CONTROL_BITS_VECOUT_DATA 64\n\n"
      },
      {
        "file_name": "xdiamond.h",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef XDIAMOND_H\n#define XDIAMOND_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/***************************** Include Files *********************************/\n#ifndef __linux__\n#include \"xil_types.h\"\n#include \"xil_assert.h\"\n#include \"xstatus.h\"\n#include \"xil_io.h\"\n#else\n#include <stdint.h>\n#include <assert.h>\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <stddef.h>\n#endif\n#include \"xdiamond_hw.h\"\n\n/**************************** Type Definitions ******************************/\n#ifdef __linux__\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\ntypedef uint64_t u64;\n#else\ntypedef struct {\n#ifdef SDT\n    char *Name;\n#else\n    u16 DeviceId;\n#endif\n    u64 Control_BaseAddress;\n} XDiamond_Config;\n#endif\n\ntypedef struct {\n    u64 Control_BaseAddress;\n    u32 IsReady;\n} XDiamond;\n\ntypedef u32 word_type;\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#ifndef __linux__\n#define XDiamond_WriteReg(BaseAddress, RegOffset, Data) \\\n    Xil_Out32((BaseAddress) + (RegOffset), (u32)(Data))\n#define XDiamond_ReadReg(BaseAddress, RegOffset) \\\n    Xil_In32((BaseAddress) + (RegOffset))\n#else\n#define XDiamond_WriteReg(BaseAddress, RegOffset, Data) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset)) = (u32)(Data)\n#define XDiamond_ReadReg(BaseAddress, RegOffset) \\\n    *(volatile u32*)((BaseAddress) + (RegOffset))\n\n#define Xil_AssertVoid(expr)    assert(expr)\n#define Xil_AssertNonvoid(expr) assert(expr)\n\n#define XST_SUCCESS             0\n#define XST_DEVICE_NOT_FOUND    2\n#define XST_OPEN_DEVICE_FAILED  3\n#define XIL_COMPONENT_IS_READY  1\n#endif\n\n/************************** Function Prototypes *****************************/\n#ifndef __linux__\n#ifdef SDT\nint XDiamond_Initialize(XDiamond *InstancePtr, UINTPTR BaseAddress);\nXDiamond_Config* XDiamond_LookupConfig(UINTPTR BaseAddress);\n#else\nint XDiamond_Initialize(XDiamond *InstancePtr, u16 DeviceId);\nXDiamond_Config* XDiamond_LookupConfig(u16 DeviceId);\n#endif\nint XDiamond_CfgInitialize(XDiamond *InstancePtr, XDiamond_Config *ConfigPtr);\n#else\nint XDiamond_Initialize(XDiamond *InstancePtr, const char* InstanceName);\nint XDiamond_Release(XDiamond *InstancePtr);\n#endif\n\n\nvoid XDiamond_Set_vecIn(XDiamond *InstancePtr, u64 Data);\nu64 XDiamond_Get_vecIn(XDiamond *InstancePtr);\nvoid XDiamond_Set_vecOut(XDiamond *InstancePtr, u64 Data);\nu64 XDiamond_Get_vecOut(XDiamond *InstancePtr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"
      },
      {
        "file_name": "xdiamond_linux.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifdef __linux__\n\n/***************************** Include Files *********************************/\n#include \"xdiamond.h\"\n\n/***************** Macros (Inline Functions) Definitions *********************/\n#define MAX_UIO_PATH_SIZE       256\n#define MAX_UIO_NAME_SIZE       64\n#define MAX_UIO_MAPS            5\n#define UIO_INVALID_ADDR        0\n\n/**************************** Type Definitions ******************************/\ntypedef struct {\n    u64 addr;\n    u32 size;\n} XDiamond_uio_map;\n\ntypedef struct {\n    int  uio_fd;\n    int  uio_num;\n    char name[ MAX_UIO_NAME_SIZE ];\n    char version[ MAX_UIO_NAME_SIZE ];\n    XDiamond_uio_map maps[ MAX_UIO_MAPS ];\n} XDiamond_uio_info;\n\n/***************** Variable Definitions **************************************/\nstatic XDiamond_uio_info uio_info;\n\n/************************** Function Implementation *************************/\nstatic int line_from_file(char* filename, char* linebuf) {\n    char* s;\n    int i;\n    FILE* fp = fopen(filename, \"r\");\n    if (!fp) return -1;\n    s = fgets(linebuf, MAX_UIO_NAME_SIZE, fp);\n    fclose(fp);\n    if (!s) return -2;\n    for (i=0; (*s)&&(i<MAX_UIO_NAME_SIZE); i++) {\n        if (*s == '\\n') *s = 0;\n        s++;\n    }\n    return 0;\n}\n\nstatic int uio_info_read_name(XDiamond_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/name\", info->uio_num);\n    return line_from_file(file, info->name);\n}\n\nstatic int uio_info_read_version(XDiamond_uio_info* info) {\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/version\", info->uio_num);\n    return line_from_file(file, info->version);\n}\n\nstatic int uio_info_read_map_addr(XDiamond_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    info->maps[n].addr = UIO_INVALID_ADDR;\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/addr\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].addr);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nstatic int uio_info_read_map_size(XDiamond_uio_info* info, int n) {\n    int ret;\n    char file[ MAX_UIO_PATH_SIZE ];\n    sprintf(file, \"/sys/class/uio/uio%d/maps/map%d/size\", info->uio_num, n);\n    FILE* fp = fopen(file, \"r\");\n    if (!fp) return -1;\n    ret = fscanf(fp, \"0x%x\", &info->maps[n].size);\n    fclose(fp);\n    if (ret < 0) return -2;\n    return 0;\n}\n\nint XDiamond_Initialize(XDiamond *InstancePtr, const char* InstanceName) {\n\tXDiamond_uio_info *InfoPtr = &uio_info;\n\tstruct dirent **namelist;\n    int i, n;\n    char* s;\n    char file[ MAX_UIO_PATH_SIZE ];\n    char name[ MAX_UIO_NAME_SIZE ];\n    int flag = 0;\n\n    assert(InstancePtr != NULL);\n\n    n = scandir(\"/sys/class/uio\", &namelist, 0, alphasort);\n    if (n < 0)  return XST_DEVICE_NOT_FOUND;\n    for (i = 0;  i < n; i++) {\n    \tstrcpy(file, \"/sys/class/uio/\");\n    \tstrcat(file, namelist[i]->d_name);\n    \tstrcat(file, \"/name\");\n        if ((line_from_file(file, name) == 0) && (strcmp(name, InstanceName) == 0)) {\n            flag = 1;\n            s = namelist[i]->d_name;\n            s += 3; // \"uio\"\n            InfoPtr->uio_num = atoi(s);\n            break;\n        }\n    }\n    if (flag == 0)  return XST_DEVICE_NOT_FOUND;\n\n    uio_info_read_name(InfoPtr);\n    uio_info_read_version(InfoPtr);\n    for (n = 0; n < MAX_UIO_MAPS; ++n) {\n        uio_info_read_map_addr(InfoPtr, n);\n        uio_info_read_map_size(InfoPtr, n);\n    }\n\n    sprintf(file, \"/dev/uio%d\", InfoPtr->uio_num);\n    if ((InfoPtr->uio_fd = open(file, O_RDWR)) < 0) {\n        return XST_OPEN_DEVICE_FAILED;\n    }\n\n    // NOTE: slave interface 'Control' should be mapped to uioX/map0\n    InstancePtr->Control_BaseAddress = (u64)mmap(NULL, InfoPtr->maps[0].size, PROT_READ|PROT_WRITE, MAP_SHARED, InfoPtr->uio_fd, 0 * getpagesize());\n    assert(InstancePtr->Control_BaseAddress);\n\n    InstancePtr->IsReady = XIL_COMPONENT_IS_READY;\n\n    return XST_SUCCESS;\n}\n\nint XDiamond_Release(XDiamond *InstancePtr) {\n\tXDiamond_uio_info *InfoPtr = &uio_info;\n\n    assert(InstancePtr != NULL);\n    assert(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);\n\n    munmap((void*)InstancePtr->Control_BaseAddress, InfoPtr->maps[0].size);\n\n    close(InfoPtr->uio_fd);\n\n    return XST_SUCCESS;\n}\n\n#endif\n"
      },
      {
        "file_name": "xdiamond_sinit.c",
        "file_content": "// ==============================================================\n// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2023.2 (64-bit)\n// Tool Version Limit: 2023.10\n// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n// Copyright 2022-2023 Advanced Micro Devices, Inc. All Rights Reserved.\n// \n// ==============================================================\n#ifndef __linux__\n\n#include \"xstatus.h\"\n#ifdef SDT\n#include \"xparameters.h\"\n#endif\n#include \"xdiamond.h\"\n\nextern XDiamond_Config XDiamond_ConfigTable[];\n\n#ifdef SDT\nXDiamond_Config *XDiamond_LookupConfig(UINTPTR BaseAddress) {\n\tXDiamond_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = (u32)0x0; XDiamond_ConfigTable[Index].Name != NULL; Index++) {\n\t\tif (!BaseAddress || XDiamond_ConfigTable[Index].Control_BaseAddress == BaseAddress) {\n\t\t\tConfigPtr = &XDiamond_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDiamond_Initialize(XDiamond *InstancePtr, UINTPTR BaseAddress) {\n\tXDiamond_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDiamond_LookupConfig(BaseAddress);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDiamond_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#else\nXDiamond_Config *XDiamond_LookupConfig(u16 DeviceId) {\n\tXDiamond_Config *ConfigPtr = NULL;\n\n\tint Index;\n\n\tfor (Index = 0; Index < XPAR_XDIAMOND_NUM_INSTANCES; Index++) {\n\t\tif (XDiamond_ConfigTable[Index].DeviceId == DeviceId) {\n\t\t\tConfigPtr = &XDiamond_ConfigTable[Index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ConfigPtr;\n}\n\nint XDiamond_Initialize(XDiamond *InstancePtr, u16 DeviceId) {\n\tXDiamond_Config *ConfigPtr;\n\n\tXil_AssertNonvoid(InstancePtr != NULL);\n\n\tConfigPtr = XDiamond_LookupConfig(DeviceId);\n\tif (ConfigPtr == NULL) {\n\t\tInstancePtr->IsReady = 0;\n\t\treturn (XST_DEVICE_NOT_FOUND);\n\t}\n\n\treturn XDiamond_CfgInitialize(InstancePtr, ConfigPtr);\n}\n#endif\n\n#endif\n\n"
      }
    ],
    "code_length": 13661,
    "token_count": 3788,
    "pragma_number": 15,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_fixed_point/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 0,
    "Worst-caseLatency": 0.0,
    "BRAM_18K": 0,
    "LUT": 4,
    "DSP": 1,
    "FF": 0,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "cpp_ap_fixed",
    "ResourceMetric": 2.8471e-05,
    "design_id": "project",
    "algo_name": "using_fixed_point",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _CPP_AP_FIXED_H_\n#define _CPP_AP_FIXED_H_\n\n#include <cmath>\n#include <cstdlib>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\nusing namespace std;\n#include \"ap_fixed.h\"\n\ntypedef ap_ufixed<10, 8, AP_RND, AP_SAT> din1_t;\ntypedef ap_fixed<6, 3, AP_RND, AP_WRAP> din2_t;\ntypedef ap_fixed<22, 17, AP_TRN, AP_SAT> dint_t;\ntypedef ap_fixed<36, 30> dout_t;\n\ndout_t cpp_ap_fixed(din1_t d_in1, din2_t d_in2);\n\n#endif\n\ndout_t cpp_ap_fixed(din1_t d_in1, din2_t d_in2) {\n\n    static dint_t sum;\n    sum = +d_in1;\n    return sum * d_in2;\n}\n"
      }
    ],
    "code_length": 1933,
    "token_count": 501,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_free_running_pipeline/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 28,
    "Worst-caseLatency": 28.0,
    "BRAM_18K": 0,
    "LUT": 1909,
    "DSP": 3,
    "FF": 549,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "accumulate",
    "ResourceMetric": 0.0005018303,
    "design_id": "project",
    "algo_name": "using_free_running_pipeline",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"ap_axi_sdata.h\"\n#include \"hls_stream.h\"\n// Missing include: #include \"math.h\"\nusing namespace hls;\n\ntypedef double data_t;\n#define SZ 8\n\nvoid free_pipe_mult(data_t A[SZ], hls::stream<data_t>& strm, data_t& out);\n#include <iostream>\n\nint accumulate(data_t A[]) {\n#pragma HLS inline off\n\n    data_t acc = 0.0;\n    for (int i = 0; i < SZ; i++) {\n        std::cout << \"A: \" << A[i] << std::endl;\n        acc += A[i];\n    }\n    return acc;\n}\n\nvoid process(hls::stream<data_t>& strm_in, hls::stream<data_t>& strm_out) {\n#pragma HLS inline off\n\n    for (int i = 0; i < SZ; i++) {\n        data_t tmp;\n        tmp = strm_in.read();\n        strm_out.write(tmp);\n    }\n}\n\nvoid inner(data_t A[SZ], hls::stream<data_t>& stream_in, data_t* out) {\n\n#pragma HLS INTERFACE ap_fifo port = stream_in\n    data_t regA[SZ];\n#pragma HLS ARRAY_PARTITION variable = regA complete\n    for (int i = 0; i < SZ; i++) {\n        data_t tmp;\n        tmp = stream_in.read();\n        regA[i] = A[i] + tmp;\n    }\n\n    *out = accumulate(regA);\n}\n\nvoid free_pipe_mult(data_t A[SZ], hls::stream<data_t>& strm, data_t& out) {\n#pragma HLS DATAFLOW\n#pragma HLS INTERFACE ap_fifo port = strm\n\n    data_t B[SZ];\n\n    for (int i = 0; i < SZ; i++)\n        B[i] = A[i] + i;\n\n    hls::stream<data_t> strm_out;\n    process(strm, strm_out);\n    inner(B, strm_out, &out);\n}\n"
      }
    ],
    "code_length": 2722,
    "token_count": 722,
    "pragma_number": 6,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/using_stream_of_blocks/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 260,
    "Worst-caseLatency": 260.0,
    "BRAM_18K": 0,
    "LUT": 1772,
    "DSP": 0,
    "FF": 205,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "diamond",
    "ResourceMetric": 0.0003594632,
    "design_id": "project",
    "algo_name": "using_stream_of_blocks",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#pragma once\n#include \"hls_stream.h\"\n#include \"hls_streamofblocks.h\"\n\n#define N 100\n#define NUM_BLOCKS 10\ntypedef unsigned char data_t;\ntypedef data_t block_data_t[NUM_BLOCKS];\n\n// Top function\nvoid diamond(hls::stream<data_t>& vecIn, hls::stream<data_t>& vecOut);\n\n// Sub functions\nvoid funcA(hls::stream<data_t>& in, hls::stream_of_blocks<block_data_t>& out1,\n           hls::stream_of_blocks<block_data_t>& out2);\nvoid funcB(hls::stream_of_blocks<block_data_t>& in,\n           hls::stream_of_blocks<block_data_t>& out);\nvoid funcC(hls::stream_of_blocks<block_data_t>& in,\n           hls::stream_of_blocks<block_data_t>& out);\nvoid funcD(hls::stream_of_blocks<block_data_t>& in1,\n           hls::stream_of_blocks<block_data_t>& in2, hls::stream<data_t>& out);\n\nvoid diamond(hls::stream<data_t>& vecIn, hls::stream<data_t>& vecOut) {\n#pragma HLS INTERFACE ap_ctrl_chain port = return\n\n    hls::stream_of_blocks<block_data_t> c1, c2, c3, c4;\n\n#pragma HLS dataflow\n    funcA(vecIn, c1, c2);\n    funcB(c1, c3);\n    funcC(c2, c4);\n    funcD(c3, c4, vecOut);\n}\n\nvoid funcA(hls::stream<data_t>& in, hls::stream_of_blocks<block_data_t>& out1,\n           hls::stream_of_blocks<block_data_t>& out2) {\n#pragma HLS INLINE off\n\nfuncA_Loop0:\n    for (int i = 0; i < N / NUM_BLOCKS; i++) {\n\n        // Obtain write locks for the two output channels\n        hls::write_lock<block_data_t> out1L(out1);\n        hls::write_lock<block_data_t> out2L(out2);\n\n        // Read a block of 10 data items from the stream\n    funcA_Loop1:\n        for (unsigned int j = 0; j < NUM_BLOCKS; j++) {\n            data_t t = in.read() * 3;\n            out1L[j] = t;\n            out2L[j] = t;\n        }\n    }\n}\n\nvoid funcB(hls::stream_of_blocks<block_data_t>& in,\n           hls::stream_of_blocks<block_data_t>& out) {\n#pragma HLS INLINE off\n\nfuncB_Loop0:\n    for (int i = 0; i < N / NUM_BLOCKS; i++) {\n\n        // Obtain a read lock on the input channel\n        // and a write lock for the output channel\n        hls::read_lock<block_data_t> inL(in);\n        hls::write_lock<block_data_t> outL(out);\n    funcB_Loop1:\n        for (unsigned int j = 0; j < NUM_BLOCKS; j++)\n            outL[j] = inL[j] + 25;\n    }\n}\n\nvoid funcC(hls::stream_of_blocks<block_data_t>& in,\n           hls::stream_of_blocks<block_data_t>& out) {\n#pragma HLS INLINE off\n\nLoop0:\n    for (data_t i = 0; i < N / NUM_BLOCKS; i++) {\n\n        // Obtain a read lock on the input channel\n        // and a write lock for the output channel\n        hls::read_lock<block_data_t> inL(in);\n        hls::write_lock<block_data_t> outL(out);\n        for (unsigned int j = 0; j < NUM_BLOCKS; ++j)\n            outL[j] = inL[j] * 2;\n    }\n}\n\nvoid funcD(hls::stream_of_blocks<block_data_t>& in1,\n           hls::stream_of_blocks<block_data_t>& in2, hls::stream<data_t>& out) {\n#pragma HLS INLINE off\n\nLoop0:\n    for (int i = 0; i < N / NUM_BLOCKS; i++) {\n\n        // Obtain two read locks on the input channels\n        hls::read_lock<block_data_t> in1L(in1);\n        hls::read_lock<block_data_t> in2L(in2);\n        for (unsigned int j = 0; j < NUM_BLOCKS; ++j)\n            out.write(in1L[j] + in2L[j] * 2);\n    }\n}\n"
      }
    ],
    "code_length": 4524,
    "token_count": 1280,
    "pragma_number": 7,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/v_measure/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 16,
    "Worst-caseLatency": 33.0,
    "BRAM_18K": 0,
    "LUT": 1574,
    "DSP": 19,
    "FF": 1384,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "v_measure",
    "ResourceMetric": 0.0009609133,
    "design_id": "project",
    "algo_name": "v_measure",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "v_measure.cpp",
        "file_content": "#include <cmath>\n\n#define N 1024\n\nvoid v_measure(int n, double alpha, double beta, double entropy_C, double entropy_K, double mutual_info, double& v_measure) {\n    double homogeneity = 0.0;\n    double completeness = 0.0;\n\n    if (entropy_C != 0) {\n        homogeneity = mutual_info / entropy_C;\n    }\n\n    if (entropy_K != 0) {\n        completeness = mutual_info / entropy_K;\n    }\n\n    if (homogeneity + completeness == 0) {\n        v_measure = 0.0;\n    } else {\n        v_measure = (1 + beta) * (homogeneity * completeness) / (beta * homogeneity + completeness);\n    }\n}\n\n// Top function name: v_measure\n"
      }
    ],
    "code_length": 606,
    "token_count": 163,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/Vitis-HLS-Introductory-Examples-flatten/variable_bound_loops/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2,
    "Worst-caseLatency": 33.0,
    "BRAM_18K": 0,
    "LUT": 107,
    "DSP": 0,
    "FF": 21,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "loop_var",
    "ResourceMetric": 2.25324e-05,
    "design_id": "project",
    "algo_name": "variable_bound_loops",
    "source_name": "Vitis-HLS-Introductory-Examples-flatten",
    "source_code": [
      {
        "file_name": "combined.cpp",
        "file_content": "/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.\n * Copyright 2022-2024 Advanced Micro Devices, Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef _LOOP_VAR_H_\n#define _LOOP_VAR_H_\n\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\n#include \"ap_int.h\"\n#define N 32\n\ntypedef ap_int<8> din_t;\ntypedef ap_int<13> dout_t;\ntypedef ap_uint<5> dsel_t;\n\ndout_t loop_var(din_t A[N], dsel_t width);\n\n#endif\n\ndout_t loop_var(din_t A[N], dsel_t width) {\n\n    dout_t out_accum = 0;\n    dsel_t x;\n\nLOOP_X:\n    for (x = 0; x < width; x++) {\n        out_accum += A[x];\n    }\n\n    return out_accum;\n}\n"
      }
    ],
    "code_length": 1844,
    "token_count": 460,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/variational_inference/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 22770,
    "Worst-caseLatency": 22770.0,
    "BRAM_18K": 6,
    "LUT": 1662,
    "DSP": 16,
    "FF": 1661,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "variational_inference",
    "ResourceMetric": 0.0012932601,
    "design_id": "project",
    "algo_name": "variational_inference",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "variational_inference.cpp",
        "file_content": "#include <cmath>\n#include <iostream>\n\n#define N 1024\n\nvoid variational_inference(float alpha, float beta, float gamma, float delta, float input[N], float output[N]) {\n    float phi[N];\n    float lambda[N];\n    float theta[N];\n\n    // Initialize phi, lambda, and theta\n    for (int i = 0; i < N; i++) {\n        phi[i] = alpha * input[i] + beta;\n        lambda[i] = gamma * input[i] + delta;\n        theta[i] = 0.0f;\n    }\n\n    // Variational Inference Algorithm\n    for (int iter = 0; iter < 10; iter++) {\n        for (int i = 0; i < N; i++) {\n            theta[i] = phi[i] / (lambda[i] + 1.0f);\n        }\n\n        for (int i = 0; i < N; i++) {\n            phi[i] = alpha * input[i] + beta * theta[i];\n            lambda[i] = gamma * input[i] + delta * theta[i];\n        }\n    }\n\n    // Output the result\n    for (int i = 0; i < N; i++) {\n        output[i] = theta[i];\n    }\n}\n\n// Top function name: variational_inference\n"
      }
    ],
    "code_length": 921,
    "token_count": 278,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/vco/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 6165,
    "Worst-caseLatency": 6165.0,
    "BRAM_18K": 0,
    "LUT": 7027,
    "DSP": 104,
    "FF": 3099,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vco",
    "ResourceMetric": 0.0045258769,
    "design_id": "project",
    "algo_name": "vco",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "vco.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define ARRAY_SIZE 1024\n\nvoid vco(float control_voltage[ARRAY_SIZE], float output_signal[ARRAY_SIZE], float frequency, float amplitude) {\n    const float pi = 3.14159265358979323846;\n    float phase = 0.0;\n\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float freq = frequency + control_voltage[i];\n        phase += 2 * pi * freq;\n        if (phase > 2 * pi) {\n            phase -= 2 * pi;\n        }\n        output_signal[i] = amplitude * sin(phase);\n    }\n}\n\n// Top function name: vco\n"
      }
    ],
    "code_length": 527,
    "token_count": 144,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/vcr_vhs_chroma_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 1235,
    "DSP": 0,
    "FF": 188,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vcr_vhs_chroma_signal_processor",
    "ResourceMetric": 0.0002548555,
    "design_id": "project",
    "algo_name": "vcr_vhs_chroma_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "vcr_vhs_chroma_signal_processor.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define SIZE 1024\n\ntypedef ap_fixed<16, 8> fixed_point_t;\n\nvoid vcr_vhs_chroma_signal_processor(fixed_point_t input_signal[SIZE], fixed_point_t output_signal[SIZE]) {\n    fixed_point_t chroma_gain = 1.5;\n    fixed_point_t chroma_offset = 0.1;\n\n    for (int i = 0; i < SIZE; i++) {\n        fixed_point_t processed_signal = input_signal[i] * chroma_gain + chroma_offset;\n        if (processed_signal > 1.0) {\n            processed_signal = 1.0;\n        } else if (processed_signal < -1.0) {\n            processed_signal = -1.0;\n        }\n        output_signal[i] = processed_signal;\n    }\n}\n\n// Top function name: vcr_vhs_chroma_signal_processor\n"
      }
    ],
    "code_length": 667,
    "token_count": 186,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/vector_addition/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 116,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vector_addition",
    "ResourceMetric": 2.46418e-05,
    "design_id": "project",
    "algo_name": "vector_addition",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "vector_addition.cpp",
        "file_content": "#include <ap_int.h>\n\n#define VECTOR_SIZE 1024\n\nvoid vector_addition(ap_int<32> A[VECTOR_SIZE], ap_int<32> B[VECTOR_SIZE], ap_int<32> C[VECTOR_SIZE]) {\n    for (int i = 0; i < VECTOR_SIZE; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n\n// Top function name: vector_addition\n"
      }
    ],
    "code_length": 270,
    "token_count": 89,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/video_controller/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2073602,
    "Worst-caseLatency": 2073602.0,
    "BRAM_18K": 0,
    "LUT": 258,
    "DSP": 0,
    "FF": 67,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_controller",
    "ResourceMetric": 5.58995e-05,
    "design_id": "project",
    "algo_name": "video_controller",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "video_controller.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1920\n#define HEIGHT 1080\n\nvoid video_controller(ap_uint<8> input_frame[HEIGHT][WIDTH], ap_uint<8> output_frame[HEIGHT][WIDTH]) {\n    int i, j;\n    for (i = 0; i < HEIGHT; i++) {\n        for (j = 0; j < WIDTH; j++) {\n            // Example processing: Invert the pixel value\n            output_frame[i][j] = 255 - input_frame[i][j];\n        }\n    }\n}\n\n// Top function name: video_controller\n"
      }
    ],
    "code_length": 425,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/video_display_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 786434,
    "Worst-caseLatency": 786434.0,
    "BRAM_18K": 0,
    "LUT": 240,
    "DSP": 0,
    "FF": 64,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_display_processor",
    "ResourceMetric": 5.216e-05,
    "design_id": "project",
    "algo_name": "video_display_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "video_display_processor.cpp",
        "file_content": "#include <cstdint>\n\n#define WIDTH 1024\n#define HEIGHT 768\n\nvoid video_display_processor(uint8_t input_frame[HEIGHT][WIDTH], uint8_t output_frame[HEIGHT][WIDTH]) {\n    for (int y = 0; y < HEIGHT; y++) {\n        for (int x = 0; x < WIDTH; x++) {\n            // Example processing: Invert colors\n            output_frame[y][x] = 255 - input_frame[y][x];\n        }\n    }\n}\n\n// Top function name: video_display_processor\n"
      }
    ],
    "code_length": 416,
    "token_count": 112,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/video_enhancement_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3138562,
    "Worst-caseLatency": 3138562.0,
    "BRAM_18K": 0,
    "LUT": 463,
    "DSP": 0,
    "FF": 146,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_enhancement_processor",
    "ResourceMetric": 0.000102786,
    "design_id": "project",
    "algo_name": "video_enhancement_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "video_enhancement_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid video_enhancement_processor(ap_uint<8> input[HEIGHT][WIDTH], ap_uint<8> output[HEIGHT][WIDTH]) {\n    ap_uint<8> kernel[3][3] = {{0, -1, 0}, {-1, 5, -1}, {0, -1, 0}};\n    int i, j, ki, kj;\n\n    for (i = 1; i < HEIGHT - 1; i++) {\n        for (j = 1; j < WIDTH - 1; j++) {\n            ap_int<16> pixel_value = 0;\n            for (ki = 0; ki < 3; ki++) {\n                for (kj = 0; kj < 3; kj++) {\n                    pixel_value += input[i + ki - 1][j + kj - 1] * kernel[ki][kj];\n                }\n            }\n            if (pixel_value < 0) pixel_value = 0;\n            if (pixel_value > 255) pixel_value = 255;\n            output[i][j] = (ap_uint<8>)pixel_value;\n        }\n    }\n}\n\n// Top function name: video_enhancement_processor\n"
      }
    ],
    "code_length": 802,
    "token_count": 269,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/video_multiplier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2073602,
    "Worst-caseLatency": 2073602.0,
    "BRAM_18K": 0,
    "LUT": 290,
    "DSP": 0,
    "FF": 67,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_multiplier",
    "ResourceMetric": 6.20359e-05,
    "design_id": "project",
    "algo_name": "video_multiplier",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "video_multiplier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define WIDTH 1920\n#define HEIGHT 1080\n\nvoid video_multiplier(ap_uint<8> input1[HEIGHT][WIDTH], ap_uint<8> input2[HEIGHT][WIDTH], ap_uint<16> output[HEIGHT][WIDTH]) {\n    for (int i = 0; i < HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            output[i][j] = input1[i][j] * input2[i][j];\n        }\n    }\n}\n\n// Top function name: video_multiplier\n"
      }
    ],
    "code_length": 383,
    "token_count": 122,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/video_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1048578,
    "Worst-caseLatency": 1048578.0,
    "BRAM_18K": 0,
    "LUT": 245,
    "DSP": 0,
    "FF": 66,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "video_processor",
    "ResourceMetric": 5.33106e-05,
    "design_id": "project",
    "algo_name": "video_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "video_processor.cpp",
        "file_content": "#include <stdint.h>\n\n#define WIDTH 1024\n#define HEIGHT 1024\n\nvoid video_processor(uint8_t input[HEIGHT][WIDTH], uint8_t output[HEIGHT][WIDTH]) {\n    for (int i = 0; i < HEIGHT; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            uint8_t pixel = input[i][j];\n            // Example processing: simple inversion\n            output[i][j] = 255 - pixel;\n        }\n    }\n}\n\n// Top function name: video_processor\n"
      }
    ],
    "code_length": 416,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/vif_sif_signal_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2070,
    "Worst-caseLatency": 2070.0,
    "BRAM_18K": 3,
    "LUT": 1214,
    "DSP": 4,
    "FF": 552,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "vif_sif_signal_processor",
    "ResourceMetric": 0.0005825571,
    "design_id": "project",
    "algo_name": "vif_sif_signal_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "vif_sif_signal_processor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid vif_sif_signal_processor(ap_int<16> input_signal[ARRAY_SIZE], ap_int<16> output_signal[ARRAY_SIZE]) {\n    ap_int<16> intermediate_signal[ARRAY_SIZE];\n\n    // Step 1: Amplify the input signal\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        intermediate_signal[i] = input_signal[i] * 2;\n    }\n\n    // Step 2: Apply a simple low-pass filter\n    for (int i = 1; i < ARRAY_SIZE - 1; i++) {\n        output_signal[i] = (intermediate_signal[i-1] + intermediate_signal[i] + intermediate_signal[i+1]) / 3;\n    }\n\n    // Handle boundary conditions\n    output_signal[0] = (intermediate_signal[0] + intermediate_signal[1]) / 2;\n    output_signal[ARRAY_SIZE - 1] = (intermediate_signal[ARRAY_SIZE - 2] + intermediate_signal[ARRAY_SIZE - 1]) / 2;\n}\n\n// Top function name: vif_sif_signal_processor\n"
      }
    ],
    "code_length": 836,
    "token_count": 244,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/virtual_memory_management/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1027,
    "Worst-caseLatency": 1027.0,
    "BRAM_18K": 0,
    "LUT": 226,
    "DSP": 0,
    "FF": 51,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "virtual_memory_management",
    "ResourceMetric": 4.82289e-05,
    "design_id": "project",
    "algo_name": "virtual_memory_management",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "virtual_memory_management.cpp",
        "file_content": "#include <iostream>\n\n#define PAGE_SIZE 4096\n#define NUM_PAGES 1024\n#define MEMORY_SIZE (PAGE_SIZE * NUM_PAGES)\n\nvoid virtual_memory_management(int virtual_address[NUM_PAGES], int physical_address[NUM_PAGES], int page_table[NUM_PAGES]) {\n    for (int i = 0; i < NUM_PAGES; i++) {\n        int page_number = virtual_address[i] / PAGE_SIZE;\n        int offset = virtual_address[i] % PAGE_SIZE;\n        physical_address[i] = page_table[page_number] * PAGE_SIZE + offset;\n    }\n}\n\n// Top function name: virtual_memory_management\n"
      }
    ],
    "code_length": 523,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/MachSuite/viterbi/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 294324,
    "Worst-caseLatency": 294324.0,
    "BRAM_18K": 58,
    "LUT": 38796,
    "DSP": 12,
    "FF": 21857,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "viterbi",
    "ResourceMetric": 0.0134640883,
    "design_id": "project",
    "algo_name": "viterbi",
    "source_name": "MachSuite",
    "source_code": [
      {
        "file_name": "viterbi.c",
        "file_content": "#include \"viterbi.h\"\n\nint viterbi( tok_t obs[N_OBS], prob_t init[N_STATES], prob_t transition[N_STATES*N_STATES], prob_t emission[N_STATES*N_TOKENS], state_t path[N_OBS] )\n{\n  prob_t llike[N_OBS][N_STATES];\n  step_t t;\n  state_t prev, curr;\n  prob_t min_p, p;\n  state_t min_s, s;\n  // All probabilities are in -log space. (i.e.: P(x) => -log(P(x)) )\n \n  // Initialize with first observation and initial probabilities\n  L_init: for( s=0; s<N_STATES; s++ ) {\n    llike[0][s] = init[s] + emission[s*N_TOKENS+obs[0]];\n  }\n\n  // Iteratively compute the probabilities over time\n  L_timestep: for( t=1; t<N_OBS; t++ ) {\n    L_curr_state: for( curr=0; curr<N_STATES; curr++ ) {\n      // Compute likelihood HMM is in current state and where it came from.\n      prev = 0;\n      min_p = llike[t-1][prev] +\n              transition[prev*N_STATES+curr] +\n              emission[curr*N_TOKENS+obs[t]];\n      L_prev_state: for( prev=1; prev<N_STATES; prev++ ) {\n        p = llike[t-1][prev] +\n            transition[prev*N_STATES+curr] +\n            emission[curr*N_TOKENS+obs[t]];\n        if( p<min_p ) {\n          min_p = p;\n        }\n      }\n      llike[t][curr] = min_p;\n    }\n  }\n\n  // Identify end state\n  min_s = 0;\n  min_p = llike[N_OBS-1][min_s];\n  L_end: for( s=1; s<N_STATES; s++ ) {\n    p = llike[N_OBS-1][s];\n    if( p<min_p ) {\n      min_p = p;\n      min_s = s;\n    }\n  }\n  path[N_OBS-1] = min_s;\n\n  // Backtrack to recover full path\n  L_backtrack: for( t=N_OBS-2; t>=0; t-- ) {\n    min_s = 0;\n    min_p = llike[t][min_s] + transition[min_s*N_STATES+path[t+1]];\n    L_state: for( s=1; s<N_STATES; s++ ) {\n      p = llike[t][s] + transition[s*N_STATES+path[t+1]];\n      if( p<min_p ) {\n        min_p = p;\n        min_s = s;\n      }\n    }\n    path[t] = min_s;\n  }\n\n  return 0;\n}\n\n"
      },
      {
        "file_name": "viterbi.h",
        "file_content": "/*\nBased on:\nLawrence Rabiner. \"A Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition.\" Proc. IEEE, v77, #2. 1989.\n*/\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <fcntl.h>\n#include \"support.h\"\n\n#define TYPE double\ntypedef uint8_t tok_t;\ntypedef TYPE prob_t;\ntypedef uint8_t state_t;\ntypedef int32_t step_t;\n\n//#define N_STATES 5\n//#define N_OBS 32\n//#define N_TOKENS 9\n#define N_STATES  64\n#define N_OBS     140\n#define N_TOKENS  64\n\nint viterbi( tok_t obs[N_OBS], prob_t init[N_STATES], prob_t transition[N_STATES*N_STATES], prob_t emission[N_STATES*N_TOKENS], state_t path[N_OBS] );\n\n////////////////////////////////////////////////////////////////////////////////\n// Test harness interface code.\n\nstruct bench_args_t {\n  tok_t obs[N_OBS];\n  prob_t init[N_STATES];\n  prob_t transition[N_STATES*N_STATES];\n  prob_t emission[N_STATES*N_TOKENS];\n  state_t path[N_OBS];\n};\n"
      },
      {
        "file_name": "support.h",
        "file_content": "#include <stdlib.h>\n#include <inttypes.h>\n\n///// File and section functions\nchar *readfile(int fd);\nchar *find_section_start(char *s, int n);\n\n///// Array read functions\n#define SECTION_TERMINATED -1\nint parse_string(char *s, char *arr, int n); // n==-1 : %%-terminated\nint parse_uint8_t_array(char *s, uint8_t *arr, int n);\nint parse_uint16_t_array(char *s, uint16_t *arr, int n);\nint parse_uint32_t_array(char *s, uint32_t *arr, int n);\nint parse_uint64_t_array(char *s, uint64_t *arr, int n);\nint parse_int8_t_array(char *s, int8_t *arr, int n);\nint parse_int16_t_array(char *s, int16_t *arr, int n);\nint parse_int32_t_array(char *s, int32_t *arr, int n);\nint parse_int64_t_array(char *s, int64_t *arr, int n);\nint parse_float_array(char *s, float *arr, int n);\nint parse_double_array(char *s, double *arr, int n);\n\n///// Array write functions\nint write_string(int fd, char *arr, int n);\nint write_uint8_t_array(int fd, uint8_t *arr, int n);\nint write_uint16_t_array(int fd, uint16_t *arr, int n);\nint write_uint32_t_array(int fd, uint32_t *arr, int n);\nint write_uint64_t_array(int fd, uint64_t *arr, int n);\nint write_int8_t_array(int fd, int8_t *arr, int n);\nint write_int16_t_array(int fd, int16_t *arr, int n);\nint write_int32_t_array(int fd, int32_t *arr, int n);\nint write_int64_t_array(int fd, int64_t *arr, int n);\nint write_float_array(int fd, float *arr, int n);\nint write_double_array(int fd, double *arr, int n);\n\nint write_section_header(int fd);\n\n///// Per-benchmark files\nvoid run_benchmark( void *vargs );\nvoid input_to_data(int fd, void *vdata);\nvoid data_to_input(int fd, void *vdata);\nvoid output_to_data(int fd, void *vdata);\nvoid data_to_output(int fd, void *vdata);\nint check_data(void *vdata, void *vref);\n\nextern int INPUT_SIZE;\n\n///// TYPE macros\n// Macro trick to automatically expand TYPE into the appropriate function\n// (S)et (T)ype (A)nd (C)oncatenate\n#define __STAC_EXPANDED(f_pfx,t,f_sfx) f_pfx##t##f_sfx\n#define STAC(f_pfx,t,f_sfx) __STAC_EXPANDED(f_pfx,t,f_sfx)\n// Invoke like this:\n//   #define TYPE int32_t\n//   STAC(write_,TYPE,_array)(fd, array, n);\n// where array is of type (TYPE *)\n// This translates to:\n//   write_int32_t_array(fd, array, n);\n\n\n/**** PRNG library. Available at https://github.com/rdadolf/prng. *****/\n#ifndef __PRNG_H__\n#define __PRNG_H__\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <inttypes.h>\n#include <stdint.h>\n\n#define LAG1 (UINT16_C(24))\n#define LAG2 (UINT16_C(55))\n#define RAND_SSIZE ((UINT16_C(1))<<6)\n#define RAND_SMASK (RAND_SSIZE-1)\n#define RAND_EXHAUST_LIMIT LAG2\n// 10x is a heuristic, it just needs to be large enough to remove correlation\n#define RAND_REFILL_COUNT ((LAG2*10)-RAND_EXHAUST_LIMIT)\nstruct prng_rand_t {\n  uint64_t s[RAND_SSIZE]; // Lags\n  uint_fast16_t i; // Location of the current lag\n  uint_fast16_t c; // Exhaustion count\n};\n\n#define PRNG_RAND_MAX UINT64_MAX\n\n\nstatic inline uint64_t prng_rand(struct prng_rand_t *state) {\n  uint_fast16_t i;\n  uint_fast16_t r, new_rands=0;\n\n  if( !state->c ) { // Randomness exhausted, run forward to refill\n    new_rands += RAND_REFILL_COUNT+1;\n    state->c = RAND_EXHAUST_LIMIT-1;\n  } else {\n    new_rands = 1;\n    state->c--;\n  }\n\n  for( r=0; r<new_rands; r++ ) {\n    i = state->i;\n    state->s[i&RAND_SMASK] = state->s[(i+RAND_SSIZE-LAG1)&RAND_SMASK]\n                              + state->s[(i+RAND_SSIZE-LAG2)&RAND_SMASK];\n    state->i++;\n  }\n  return state->s[i&RAND_SMASK];\n}\n\nstatic inline void prng_srand(uint64_t seed, struct prng_rand_t *state) {\n  uint_fast16_t i;\n  // Naive seed\n  state->c = RAND_EXHAUST_LIMIT;\n  state->i = 0;\n\n  state->s[0] = seed;\n  for(i=1; i<RAND_SSIZE; i++) {\n    // Arbitrary magic, mostly to eliminate the effect of low-value seeds.\n    // Probably could be better, but the run-up obviates any real need to.\n    state->s[i] = i*(UINT64_C(2147483647)) + seed;\n  }\n\n  // Run forward 10,000 numbers\n  for(i=0; i<10000; i++) {\n    prng_rand(state);\n  }\n}\n\n// Clean up our macros\n#undef LAG1\n#undef LAG2\n#undef RAND_SSIZE\n#undef RAND_SMASK\n#undef RAND_EXHAUST_LIMIT\n#undef RAND_REFILL_COUNT\n\n// PRNG_RAND_MAX is exported\n\n#endif\n"
      }
    ],
    "code_length": 1777,
    "token_count": 586,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/hls_algorithms/viterbi_decoder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2055,
    "Worst-caseLatency": 2055.0,
    "BRAM_18K": 0,
    "LUT": 249,
    "DSP": 0,
    "FF": 58,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "viterbi_decoder",
    "ResourceMetric": 5.33106e-05,
    "design_id": "project",
    "algo_name": "viterbi_decoder",
    "source_name": "hls_algorithms",
    "source_code": [
      {
        "file_name": "viterbi_decoder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n#define K 2\n\nvoid viterbi_decoder(ap_uint<1> input[N], ap_uint<1> output[N]) {\n    ap_uint<1> state[K] = {0};\n    ap_uint<1> next_state[K];\n    ap_uint<1> path_metric[K] = {0};\n    ap_uint<1> next_path_metric[K];\n    ap_uint<1> decoded_bits[N];\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < K; j++) {\n            next_state[j] = (state[j] << 1) | input[i];\n            next_path_metric[j] = path_metric[j] + (input[i] ^ state[j]);\n        }\n        for (int j = 0; j < K; j++) {\n            state[j] = next_state[j];\n            path_metric[j] = next_path_metric[j];\n        }\n        decoded_bits[i] = state[0];\n    }\n\n    for (int i = 0; i < N; i++) {\n        output[i] = decoded_bits[i];\n    }\n}\n\n// Top function name: viterbi_decoder\n"
      }
    ],
    "code_length": 791,
    "token_count": 257,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/voice/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5159,
    "Worst-caseLatency": 5159.0,
    "BRAM_18K": 0,
    "LUT": 962,
    "DSP": 5,
    "FF": 922,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "voice",
    "ResourceMetric": 0.0004114009,
    "design_id": "project",
    "algo_name": "voice",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "voice.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid voice(float input[N], float output[N]) {\n    float sum = 0.0;\n    float mean = 0.0;\n    float variance = 0.0;\n    float stddev = 0.0;\n\n    // Calculate mean\n    for (int i = 0; i < N; i++) {\n        sum += input[i];\n    }\n    mean = sum / N;\n\n    // Calculate variance\n    sum = 0.0;\n    for (int i = 0; i < N; i++) {\n        sum += (input[i] - mean) * (input[i] - mean);\n    }\n    variance = sum / N;\n\n    // Calculate standard deviation\n    stddev = std::sqrt(variance);\n\n    // Normalize input\n    for (int i = 0; i < N; i++) {\n        output[i] = (input[i] - mean) / stddev;\n    }\n}\n\n// Top function name: voice\n"
      }
    ],
    "code_length": 674,
    "token_count": 214,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_chip/voice_processor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2082,
    "Worst-caseLatency": 2082.0,
    "BRAM_18K": 0,
    "LUT": 1181,
    "DSP": 3,
    "FF": 1118,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "voice_processor",
    "ResourceMetric": 0.0004167825,
    "design_id": "project",
    "algo_name": "voice_processor",
    "source_name": "rtl_chip",
    "source_code": [
      {
        "file_name": "voice_processor.cpp",
        "file_content": "#include <cmath>\n#include <cstdint>\n\n#define N 1024\n\nvoid voice_processor(int16_t input[N], int16_t output[N]) {\n    int16_t max_val = 0;\n    int16_t min_val = 32767;\n    int32_t sum = 0;\n    int32_t sum_squares = 0;\n\n    // Find max, min, sum, and sum of squares\n    for (int i = 0; i < N; i++) {\n        if (input[i] > max_val) {\n            max_val = input[i];\n        }\n        if (input[i] < min_val) {\n            min_val = input[i];\n        }\n        sum += input[i];\n        sum_squares += input[i] * input[i];\n    }\n\n    // Calculate mean and variance\n    int16_t mean = sum / N;\n    int16_t variance = (sum_squares / N) - (mean * mean);\n\n    // Normalize and apply gain\n    for (int i = 0; i < N; i++) {\n        int16_t normalized = (input[i] - mean) / (max_val - min_val);\n        output[i] = normalized * variance;\n    }\n}\n\n// Top function name: voice_processor\n"
      }
    ],
    "code_length": 874,
    "token_count": 261,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/voltage_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 100,
    "DSP": 0,
    "FF": 41,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "voltage_comparator",
    "ResourceMetric": 2.31077e-05,
    "design_id": "project",
    "algo_name": "voltage_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "voltage_comparator.cpp",
        "file_content": "#include <ap_fixed.h>\n\n#define ARRAY_SIZE 1024\n\nvoid voltage_comparator(ap_fixed<16, 8> input_voltage[ARRAY_SIZE], ap_fixed<16, 8> reference_voltage, bool output_result[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_result[i] = (input_voltage[i] > reference_voltage);\n    }\n}\n\n// Top function name: voltage_comparator\n"
      }
    ],
    "code_length": 344,
    "token_count": 94,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/voltage_sensor/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 77,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "voltage_sensor",
    "ResourceMetric": 1.7163e-05,
    "design_id": "project",
    "algo_name": "voltage_sensor",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "voltage_sensor.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid voltage_sensor(ap_int<16> input_voltage[ARRAY_SIZE], ap_int<16> output_voltage[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        // Simple processing: scaling the input voltage by a factor of 2\n        output_voltage[i] = input_voltage[i] * 2;\n    }\n}\n\n// Top function name: voltage_sensor\n"
      }
    ],
    "code_length": 357,
    "token_count": 97,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/voting_classifier/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 81,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "voting_classifier",
    "ResourceMetric": 1.793e-05,
    "design_id": "project",
    "algo_name": "voting_classifier",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "voting_classifier.cpp",
        "file_content": "#include <ap_int.h>\n\n#define NUM_CLASSIFIERS 3\n#define NUM_SAMPLES 1024\n\nvoid voting_classifier(\n    ap_uint<1> classifier1[NUM_SAMPLES],\n    ap_uint<1> classifier2[NUM_SAMPLES],\n    ap_uint<1> classifier3[NUM_SAMPLES],\n    ap_uint<1> output[NUM_SAMPLES])\n{\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        int vote_sum = classifier1[i] + classifier2[i] + classifier3[i];\n        output[i] = (vote_sum >= 2) ? 1 : 0;\n    }\n}\n\n// Top function name: voting_classifier\n"
      }
    ],
    "code_length": 469,
    "token_count": 135,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/wallace_tree_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 217,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "wallace_tree_adder",
    "ResourceMetric": 4.401e-05,
    "design_id": "project",
    "algo_name": "wallace_tree_adder",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "wallace_tree_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid wallace_tree_adder(ap_uint<9> A[N], ap_uint<9> B[N], ap_uint<10> C[N]) {\n    for (int i = 0; i < N; i++) {\n        ap_uint<9> a = A[i];\n        ap_uint<9> b = B[i];\n        ap_uint<10> sum = 0;\n        ap_uint<1> carry = 0;\n\n        for (int j = 0; j < 9; j++) {\n            ap_uint<1> a_bit = a[j];\n            ap_uint<1> b_bit = b[j];\n            ap_uint<1> sum_bit = a_bit ^ b_bit ^ carry;\n            carry = (a_bit & b_bit) | (carry & (a_bit ^ b_bit));\n            sum[j] = sum_bit;\n        }\n        sum[9] = carry;\n        C[i] = sum;\n    }\n}\n\n// Top function name: wallace_tree_adder\n"
      }
    ],
    "code_length": 634,
    "token_count": 221,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/wallace_tree_adder/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3146763,
    "Worst-caseLatency": 3146763.0,
    "BRAM_18K": 4096,
    "LUT": 972,
    "DSP": 0,
    "FF": 182,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "wallace_tree_adder",
    "ResourceMetric": 0.2541721,
    "design_id": "project",
    "algo_name": "wallace_tree_adder",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "wallace_tree_adder.cpp",
        "file_content": "#include <ap_int.h>\n\n#define N 1024\n\nvoid wallace_tree_adder(ap_int<32> A[N], ap_int<32> B[N], ap_int<32> C[N]) {\n    ap_int<32> partial_sums[N][N];\n    ap_int<32> carry[N][N];\n\n    // Initialize partial sums and carry arrays\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            partial_sums[i][j] = 0;\n            carry[i][j] = 0;\n        }\n    }\n\n    // Generate partial sums and carry\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (j == 0) {\n                partial_sums[i][j] = A[i] ^ B[i];\n                carry[i][j] = A[i] & B[i];\n            } else {\n                partial_sums[i][j] = partial_sums[i][j-1] ^ carry[i][j-1];\n                carry[i][j] = partial_sums[i][j-1] & carry[i][j-1];\n            }\n        }\n    }\n\n    // Sum the partial sums and carry to get the final result\n    for (int i = 0; i < N; i++) {\n        C[i] = partial_sums[i][N-1] ^ carry[i][N-1];\n    }\n}\n\n// Top function name: wallace_tree_adder\n"
      }
    ],
    "code_length": 1004,
    "token_count": 339,
    "pragma_number": 0,
    "is_pareto": false
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/warm_restarts/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5242884,
    "Worst-caseLatency": 5242884.0,
    "BRAM_18K": 0,
    "LUT": 596,
    "DSP": 5,
    "FF": 541,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "warm_restarts",
    "ResourceMetric": 0.0003046837,
    "design_id": "project",
    "algo_name": "warm_restarts",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "warm_restarts.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid warm_restarts(float input[ARRAY_SIZE], float output[ARRAY_SIZE], float alpha, float beta) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        float temp = input[i];\n        for (int j = 0; j < ARRAY_SIZE; j++) {\n            temp = alpha * temp + beta;\n        }\n        output[i] = temp;\n    }\n}\n\n// Top function name: warm_restarts\n"
      }
    ],
    "code_length": 385,
    "token_count": 105,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/watchdog_timer/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 148,
    "DSP": 0,
    "FF": 26,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "watchdog_timer",
    "ResourceMetric": 3.08741e-05,
    "design_id": "project",
    "algo_name": "watchdog_timer",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "watchdog_timer.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid watchdog_timer(uint32_t timeout, uint32_t input_array[ARRAY_SIZE], uint32_t output_array[ARRAY_SIZE]) {\n    uint32_t counter = 0;\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (counter >= timeout) {\n            output_array[i] = 0; // Reset output if timeout is reached\n        } else {\n            output_array[i] = input_array[i]; // Copy input to output\n        }\n        counter++;\n    }\n}\n\n// Top function name: watchdog_timer\n"
      }
    ],
    "code_length": 491,
    "token_count": 126,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/wave_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 239,
    "DSP": 0,
    "FF": 193,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "wave_comparator",
    "ResourceMetric": 6.43371e-05,
    "design_id": "project",
    "algo_name": "wave_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "wave_comparator.cpp",
        "file_content": "#include <iostream>\n#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid wave_comparator(float input_wave1[ARRAY_SIZE], float input_wave2[ARRAY_SIZE], float output_wave[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input_wave1[i] > input_wave2[i]) {\n            output_wave[i] = input_wave1[i];\n        } else {\n            output_wave[i] = input_wave2[i];\n        }\n    }\n}\n\n// Top function name: wave_comparator\n"
      }
    ],
    "code_length": 433,
    "token_count": 115,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/weight_pruning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1028,
    "Worst-caseLatency": 1028.0,
    "BRAM_18K": 0,
    "LUT": 295,
    "DSP": 0,
    "FF": 292,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "weight_pruning",
    "ResourceMetric": 8.45683e-05,
    "design_id": "project",
    "algo_name": "weight_pruning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "weight_pruning.cpp",
        "file_content": "#include <iostream>\n\n#define ARRAY_SIZE 1024\n\nvoid weight_pruning(float weights[ARRAY_SIZE], float threshold, float pruned_weights[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (weights[i] < threshold && weights[i] > -threshold) {\n            pruned_weights[i] = 0.0f;\n        } else {\n            pruned_weights[i] = weights[i];\n        }\n    }\n}\n\n// Top function name: weight_pruning\n"
      }
    ],
    "code_length": 409,
    "token_count": 108,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/wifi_module/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 3083,
    "Worst-caseLatency": 3083.0,
    "BRAM_18K": 1,
    "LUT": 362,
    "DSP": 0,
    "FF": 83,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "wifi_module",
    "ResourceMetric": 0.0001393811,
    "design_id": "project",
    "algo_name": "wifi_module",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "wifi_module.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid wifi_module(uint8_t input_data[ARRAY_SIZE], uint8_t output_data[ARRAY_SIZE]) {\n    uint8_t temp_data[ARRAY_SIZE];\n\n    // Step 1: Data Preprocessing\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp_data[i] = input_data[i] ^ 0x5A; // Example preprocessing: XOR with a constant\n    }\n\n    // Step 2: Data Transformation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        temp_data[i] = (temp_data[i] << 1) | (temp_data[i] >> 7); // Example transformation: Rotate left\n    }\n\n    // Step 3: Data Encoding\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output_data[i] = temp_data[i] + 0x33; // Example encoding: Add a constant\n    }\n}\n\n// Top function name: wifi_module\n"
      }
    ],
    "code_length": 728,
    "token_count": 220,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/wilcoxon_signed_rank_test/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1053731,
    "Worst-caseLatency": 1053731.0,
    "BRAM_18K": 12,
    "LUT": 2504,
    "DSP": 3,
    "FF": 1618,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "wilcoxon_signed_rank_test",
    "ResourceMetric": 0.0014624763,
    "design_id": "project",
    "algo_name": "wilcoxon_signed_rank_test",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "wilcoxon_signed_rank_test.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n\nvoid wilcoxon_signed_rank_test(double data1[N], double data2[N], double &W, double &Z)\n{\n    double diff[N];\n    double abs_diff[N];\n    double rank[N];\n    double sum_pos = 0.0;\n    double sum_neg = 0.0;\n\n    // Calculate differences and absolute differences\n    for (int i = 0; i < N; i++) {\n        diff[i] = data2[i] - data1[i];\n        abs_diff[i] = std::abs(diff[i]);\n    }\n\n    // Rank the absolute differences\n    for (int i = 0; i < N; i++) {\n        int r = 1;\n        for (int j = 0; j < N; j++) {\n            if (abs_diff[j] < abs_diff[i]) {\n                r++;\n            }\n        }\n        rank[i] = r;\n    }\n\n    // Calculate the sums of ranks for positive and negative differences\n    for (int i = 0; i < N; i++) {\n        if (diff[i] > 0) {\n            sum_pos += rank[i];\n        } else if (diff[i] < 0) {\n            sum_neg += rank[i];\n        }\n    }\n\n    // Calculate W statistic\n    W = std::min(sum_pos, sum_neg);\n\n    // Calculate Z statistic\n    double mean_W = N * (N + 1) / 4.0;\n    double std_W = std::sqrt(N * (N + 1) * (2 * N + 1) / 24.0);\n    Z = (W - mean_W) / std_W;\n}\n\n// Top function name: wilcoxon_signed_rank_test\n"
      }
    ],
    "code_length": 1210,
    "token_count": 374,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/rtl_module/window_comparator/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 129,
    "DSP": 0,
    "FF": 57,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "window_comparator",
    "ResourceMetric": 3.0203e-05,
    "design_id": "project",
    "algo_name": "window_comparator",
    "source_name": "rtl_module",
    "source_code": [
      {
        "file_name": "window_comparator.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid window_comparator(ap_int<16> input[ARRAY_SIZE], ap_int<16> lower_bound, ap_int<16> upper_bound, bool output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        if (input[i] >= lower_bound && input[i] <= upper_bound) {\n            output[i] = true;\n        } else {\n            output[i] = false;\n        }\n    }\n}\n\n// Top function name: window_comparator\n"
      }
    ],
    "code_length": 420,
    "token_count": 117,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/word_embeddings/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 131088,
    "Worst-caseLatency": 131088.0,
    "BRAM_18K": 0,
    "LUT": 251,
    "DSP": 0,
    "FF": 309,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "word_embeddings",
    "ResourceMetric": 7.77606e-05,
    "design_id": "project",
    "algo_name": "word_embeddings",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "word_embeddings.cpp",
        "file_content": "#include <cmath>\n\n#define VOCAB_SIZE 1024\n#define EMBEDDING_DIM 128\n\nvoid word_embeddings(float input[VOCAB_SIZE][EMBEDDING_DIM], float output[VOCAB_SIZE][EMBEDDING_DIM]) {\n    for (int i = 0; i < VOCAB_SIZE; i++) {\n        for (int j = 0; j < EMBEDDING_DIM; j++) {\n            output[i][j] = input[i][j] / sqrt(EMBEDDING_DIM);\n        }\n    }\n}\n\n// Top function name: word_embeddings\n"
      }
    ],
    "code_length": 385,
    "token_count": 123,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/xgboost/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 53317,
    "Worst-caseLatency": 53317.0,
    "BRAM_18K": 2,
    "LUT": 4997,
    "DSP": 44,
    "FF": 3821,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "xgboost",
    "ResourceMetric": 0.0026675953,
    "design_id": "project",
    "algo_name": "xgboost",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "xgboost.cpp",
        "file_content": "#include <cmath>\n#include <algorithm>\n\n#define N 1024\n#define M 10\n\nvoid xgboost(float data[N][M], float labels[N], float weights[N], float output[N], float trees[M][N], float learning_rate) {\n    float preds[N] = {0};\n\n    for (int t = 0; t < M; t++) {\n        for (int i = 0; i < N; i++) {\n            float pred = 0;\n            for (int j = 0; j < M; j++) {\n                pred += data[i][j] * trees[t][j];\n            }\n            preds[i] += learning_rate * pred;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        output[i] = 1.0 / (1.0 + exp(-preds[i]));\n    }\n}\n\n// Top function name: xgboost\n"
      }
    ],
    "code_length": 612,
    "token_count": 195,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/xnor_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 75,
    "DSP": 0,
    "FF": 1038,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "xnor_gate",
    "ResourceMetric": 0.0001139083,
    "design_id": "project",
    "algo_name": "xnor_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "xnor_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define SIZE 1024\n\nvoid xnor_gate(ap_uint<SIZE> A, ap_uint<SIZE> B, ap_uint<SIZE> &C) {\n    for (int i = 0; i < SIZE; i++) {\n        C[i] = ~(A[i] ^ B[i]);\n    }\n}\n\n// Top function name: xnor_gate\n"
      }
    ],
    "code_length": 218,
    "token_count": 80,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/xor_gate/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1026,
    "Worst-caseLatency": 1026.0,
    "BRAM_18K": 0,
    "LUT": 79,
    "DSP": 0,
    "FF": 25,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "xor_gate",
    "ResourceMetric": 1.75465e-05,
    "design_id": "project",
    "algo_name": "xor_gate",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "xor_gate.cpp",
        "file_content": "#include <ap_int.h>\n\n#define ARRAY_SIZE 1024\n\nvoid xor_gate(ap_uint<1> input1[ARRAY_SIZE], ap_uint<1> input2[ARRAY_SIZE], ap_uint<1> output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = input1[i] ^ input2[i];\n    }\n}\n\n// Top function name: xor_gate\n"
      }
    ],
    "code_length": 281,
    "token_count": 91,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/yeo_johnson_transformation/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 1068,
    "Worst-caseLatency": 1068.0,
    "BRAM_18K": 5,
    "LUT": 14763,
    "DSP": 149,
    "FF": 10181,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "yeo_johnson_transformation",
    "ResourceMetric": 0.0082451045,
    "design_id": "project",
    "algo_name": "yeo_johnson_transformation",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "yeo_johnson_transformation.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid yeo_johnson_transformation(double input[ARRAY_SIZE], double output[ARRAY_SIZE], double lambda) {\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        double x = input[i];\n        if (lambda == 0) {\n            if (x >= 0) {\n                output[i] = log(x + 1);\n            } else {\n                output[i] = -log(-x + 1);\n            }\n        } else if (lambda == 2) {\n            if (x >= 0) {\n                output[i] = (pow(x + 1, lambda) - 1) / lambda;\n            } else {\n                output[i] = -(pow(-x + 1, 2 - lambda) - 1) / (2 - lambda);\n            }\n        } else {\n            if (x >= 0) {\n                output[i] = (pow(x + 1, lambda) - 1) / lambda;\n            } else {\n                output[i] = -(pow(-x + 1, 2 - lambda) - 1) / (2 - lambda);\n            }\n        }\n    }\n}\n\n// Top function name: yeo_johnson_transformation\n"
      }
    ],
    "code_length": 904,
    "token_count": 268,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/z_score_normalization/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 5159,
    "Worst-caseLatency": 5159.0,
    "BRAM_18K": 0,
    "LUT": 962,
    "DSP": 5,
    "FF": 922,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "z_score_normalization",
    "ResourceMetric": 0.0004114009,
    "design_id": "project",
    "algo_name": "z_score_normalization",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "z_score_normalization.cpp",
        "file_content": "#include <cmath>\n\n#define ARRAY_SIZE 1024\n\nvoid z_score_normalization(float input[ARRAY_SIZE], float output[ARRAY_SIZE]) {\n    float mean = 0.0;\n    float stddev = 0.0;\n\n    // Calculate mean\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        mean += input[i];\n    }\n    mean /= ARRAY_SIZE;\n\n    // Calculate standard deviation\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        stddev += (input[i] - mean) * (input[i] - mean);\n    }\n    stddev = std::sqrt(stddev / ARRAY_SIZE);\n\n    // Apply Z-score normalization\n    for (int i = 0; i < ARRAY_SIZE; i++) {\n        output[i] = (input[i] - mean) / stddev;\n    }\n}\n\n// Top function name: z_score_normalization\n"
      }
    ],
    "code_length": 659,
    "token_count": 190,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/operators/zero_crossing_detector/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2051,
    "Worst-caseLatency": 2051.0,
    "BRAM_18K": 0,
    "LUT": 265,
    "DSP": 0,
    "FF": 69,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "zero_crossing_detector",
    "ResourceMetric": 5.74336e-05,
    "design_id": "project",
    "algo_name": "zero_crossing_detector",
    "source_name": "operators",
    "source_code": [
      {
        "file_name": "zero_crossing_detector.cpp",
        "file_content": "#include <stdint.h>\n\n#define ARRAY_SIZE 1024\n\nvoid zero_crossing_detector(int16_t input[ARRAY_SIZE], int8_t output[ARRAY_SIZE]) {\n    for (int i = 0; i < ARRAY_SIZE - 1; i++) {\n        if ((input[i] > 0 && input[i + 1] <= 0) || (input[i] < 0 && input[i + 1] >= 0)) {\n            output[i] = 1;\n        } else {\n            output[i] = 0;\n        }\n    }\n    output[ARRAY_SIZE - 1] = 0; // Last element has no next element to compare\n}\n\n// Top function name: zero_crossing_detector\n"
      }
    ],
    "code_length": 481,
    "token_count": 152,
    "pragma_number": 0,
    "is_pareto": true
  },
  {
    "File Path": "../data/kernels/ai_fpga_hls_algorithms/zero_shot_learning/project/solution1/syn/report/csynth.xml",
    "Part": "xcu280-fsvh2892-2L-e",
    "TargetClockPeriod": 10.0,
    "Best-caseLatency": 2109441,
    "Worst-caseLatency": 2138113.0,
    "BRAM_18K": 5,
    "LUT": 4885,
    "DSP": 32,
    "FF": 2317,
    "Avialable_BRAM_18K": 4032,
    "Avialable_LUT": 1303680,
    "Avialable_DSP": 9024,
    "Avialable_FF": 2607360,
    "is_kernel": true,
    "top_function_name": "zero_shot_learning",
    "ResourceMetric": 0.0023554755,
    "design_id": "project",
    "algo_name": "zero_shot_learning",
    "source_name": "ai_fpga_hls_algorithms",
    "source_code": [
      {
        "file_name": "zero_shot_learning.cpp",
        "file_content": "#include <cmath>\n\n#define LARGE_SCALE 1024\n\nvoid zero_shot_learning(float input_features[LARGE_SCALE], float class_attributes[LARGE_SCALE], float output_scores[LARGE_SCALE]) {\n    for (int i = 0; i < LARGE_SCALE; i++) {\n        output_scores[i] = 0.0f;\n        for (int j = 0; j < LARGE_SCALE; j++) {\n            output_scores[i] += input_features[j] * class_attributes[(i + j) % LARGE_SCALE];\n        }\n        output_scores[i] = std::tanh(output_scores[i]);\n    }\n}\n\n// Top function name: zero_shot_learning\n"
      }
    ],
    "code_length": 510,
    "token_count": 133,
    "pragma_number": 0,
    "is_pareto": true
  }
]